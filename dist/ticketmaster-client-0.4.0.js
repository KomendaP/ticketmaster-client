var TMAPI =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var discovery = __webpack_require__(2);
	var commerce = __webpack_require__(179);

	var API = function(apiKey, accessToken) {
	  return {
	    apiKey: apiKey,
	    accessToken: accessToken,
	    discovery: discovery(apiKey, accessToken),
	    commerce: commerce(apiKey, accessToken)
	  }
	};

	module.exports = function(apiKey, accessToken) {
	  return API(apiKey, accessToken);
	};

	module.exports.discovery = discovery;
	module.exports.commerce = commerce;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var v1 = __webpack_require__(3),
	    v2 = __webpack_require__(170);

	module.exports = function(apiKey, accessToken) {
	  return {
	    v1: v1(apiKey, accessToken),
	    v2: v2(apiKey, accessToken)
	  };
	};

	module.exports.v1 = v1;
	module.exports.v2 = v2;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var attraction = __webpack_require__(4),
	    category   = __webpack_require__(163),
	    event      = __webpack_require__(165),
	    venue      = __webpack_require__(168);

	module.exports = function(apiKey, accessToken) {
	  return {
	    attraction: attraction(apiKey, accessToken),
	    category: category(apiKey, accessToken),
	    event: event(apiKey, accessToken),
	    venue: venue(apiKey, accessToken)
	  };
	};

	module.exports.attraction = attraction;
	module.exports.category = category;
	module.exports.event = event;
	module.exports.venue = venue;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var find = __webpack_require__(5);

	module.exports = function(apiKey, accessToken) {
	  return {
	    find: find(apiKey, accessToken)
	  }
	};

	module.exports.find = find;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(attractionId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v1/attractions/' + attractionId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2014 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:</p>
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.9.30
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};

	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var util = _dereq_("./util.js");

	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};

	Async.prototype._getDomain = function() {};

	if (false) {
	if (util.isNode) {
	    var EventsModule = _dereq_("events");

	    var domainGetter = function() {
	        var domain = process.domain;
	        if (domain === null) return undefined;
	        return domain;
	    };

	    if (EventsModule.usingDomains) {
	        Async.prototype._getDomain = domainGetter;
	    } else {
	        var descriptor =
	            Object.getOwnPropertyDescriptor(EventsModule, "usingDomains");

	        if (descriptor) {
	            if (!descriptor.configurable) {
	                process.on("domainsActivated", function() {
	                    Async.prototype._getDomain = domainGetter;
	                });
	            } else {
	                var usingDomains = false;
	                Object.defineProperty(EventsModule, "usingDomains", {
	                    configurable: false,
	                    enumerable: true,
	                    get: function() {
	                        return usingDomains;
	                    },
	                    set: function(value) {
	                        if (usingDomains || !value) return;
	                        usingDomains = true;
	                        Async.prototype._getDomain = domainGetter;
	                        util.toFastProperties(process);
	                        process.emit("domainsActivated");
	                    }
	                });
	            }
	        }
	    }
	}
	}

	function AsyncInvokeLater(fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    var domain = this._getDomain();
	    if (domain !== undefined) {
	        var fn = domain.bind(promise._settlePromises);
	        this._normalQueue.push(fn, promise, undefined);
	    } else {
	        this._normalQueue._pushOne(promise);
	    }
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    if (schedule.isStatic) {
	        schedule = function(fn) { setTimeout(fn, 0); };
	    }
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}

	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    var domain = this._getDomain();
	    if (domain !== undefined) fn = domain.bind(fn);
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = new Async();
	module.exports.firstLineError = firstLineError;

	},{"./queue.js":28,"./schedule.js":31,"./util.js":38,"events":39}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    this._setBoundTo(thisArg);
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._setBoundTo(thisArg);
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};

	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);

	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function(thisArg) {
	            ret._setBoundTo(thisArg);
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._setBoundTo(thisArg);
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};

	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;

	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};

	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;

	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};

	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};

	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};

	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};

	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);

	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};

	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;

	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};

	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};

	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};

	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};

	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};

	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }

	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }

	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow) {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }

	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }

	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();

	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}

	return CapturedTrace;
	};

	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;

	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}

	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);

	    if (retfilter === errorObj) return retfilter;

	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}

	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundTo;
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);

	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};

	return CatchFilter;
	};

	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};

	function createContext() {
	    if (isDebugging()) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}

	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;

	return createContext;
	};

	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));

	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}

	Promise.prototype._ignoreRejections = function() {
	    this._unsetRejectionIsUnhandled();
	    this._bitField = this._bitField | 16777216;
	};

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 16777216) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};

	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};

	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};

	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};

	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};

	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
	};

	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};

	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}

	return function() {
	    return debugging;
	};
	};

	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;

	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	var returnUndefined = function() {};
	var throwUndefined = function() {
	    throw undefined;
	};

	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};


	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value === undefined) return this.then(returnUndefined);

	    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (reason === undefined) return this.then(throwUndefined);

	    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};

	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};

	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};

	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}

	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};

	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;

	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}

	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo)
	                    : handler();

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }

	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}

	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;

	    var ret = promise._isBound()
	                    ? handler.call(promise._boundTo, value)
	                    : handler(value);

	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}

	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();

	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };

	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};

	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};

	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};

	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }

	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };

	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };

	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};

	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._callback = fn;
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var callback = this._callback;
	        var receiver = this._promise._boundTo;
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }

	    }
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}

	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

	    return map(this, fn, options, null).promise();
	};

	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};


	};

	},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};

	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundTo;
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundTo, reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback = 
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};

	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};

	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);

	};

	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};

	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;

	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};


	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }

	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};

	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};

	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }

	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }

	    var callbackIndex =
	        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);

	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }

	    return ret;
	};

	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};

	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};

	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};

	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};

	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};

	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};

	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};

	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === undefined && this._isBound()) {
	        return this._boundTo;
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};

	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    this._addCallbacks(fulfill, reject, progress, promise, receiver);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver
	) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
	            this._fulfillmentHandler0 = fulfill;
	        if (typeof reject === "function") this._rejectionHandler0 = reject;
	        if (typeof progress === "function") this._progressHandler0 = progress;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function")
	            this[base + 0] = fulfill;
	        if (typeof reject === "function")
	            this[base + 1] = reject;
	        if (typeof progress === "function")
	            this[base + 2] = progress;
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();

	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};

	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};

	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundTo, value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();

	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};

	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};

	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};

	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};

	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;

	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);

	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);


	    this._clearCallbackDataAtIndex(index);

	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }

	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};

	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};

	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};

	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};

	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};

	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};

	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};

	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();

	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }

	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }

	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};

	Promise._makeSelfResolutionError = makeSelfResolutionError;
	_dereq_("./progress.js")(Promise, PromiseArray);
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          

	};

	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._ignoreRejections();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};

	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};


	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};

	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;

	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }

	        promise = null;
	    };
	}


	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}

	PromiseResolver._nodebackForPromise = nodebackForPromise;

	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};

	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};

	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};

	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};

	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};

	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};

	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};

	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};

	module.exports = PromiseResolver;

	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyPropsPattern =
	    /^(?:length|name|arguments|caller|callee|prototype|__isPromisified__)$/;
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !util.isNativeFunctionMethod(value) &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";

	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            util.notEnumerableProp,
	            INTERNAL
	        );
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        obj[promisifiedKey] = promisifier === makeNodePromisified
	                ? makeNodePromisified(key, THIS, key, fn, suffix)
	                : promisifier(fn, function() {
	                    return makeNodePromisified(key, THIS, key, fn, suffix);
	                });
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}

	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};


	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");

	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};

	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};

	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};

	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;

	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};

	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    this._callback = fn;
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._init = function () {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};

	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];

	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;

	    var callback = this._callback;
	    var receiver = this._promise._boundTo;
	    var ret;

	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();

	        if (ret === errorObj) return this._reject(ret.e);

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }

	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }

	    this._resolve(isEach ? preservedValues : this._accum);
	};

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};

	},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	var util = _dereq_("./util");
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof MutationObserver !== "undefined") {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;

	},{"./util":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};

	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};

	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}

	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};

	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};

	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};

	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};

	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};

	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};

	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};

	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};

	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};

	Promise.prototype._value = function() {
	    return this._settledValue;
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};

	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};


	Promise.PromiseInspection = PromiseInspection;
	};

	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function getThen(obj) {
	    return obj.then;
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolveFromThenable(value) {
	        if (!promise) return;
	        if (x === value) {
	            promise._rejectCallback(
	                Promise._makeSelfResolutionError(), false, true);
	        } else {
	            promise._resolveCallback(value);
	        }
	        promise = null;
	    }

	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }

	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};

	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;

	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    if (typeof message !== "string") {
	        message = "operation timed out";
	    }
	    var err = new TimeoutError(message);
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};

	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};

	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}

	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};

	};

	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;

	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }

	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }

	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	        len--;
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = arguments[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = fn.apply(undefined, vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};

	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }

	})();

	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return !isPrimitive(value);
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}


	var wrapsPrimitiveReceiver = (function() {
	    return this !== "string";
	}).call("string");

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    if (es5.isES5) {
	        var oProto = Object.prototype;
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && obj !== oProto) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        return function(obj) {
	            var ret = [];
	            /*jshint forin:false */
	            for (var key in obj) {
	                ret.push(key);
	            }
	            return ret;
	        };
	    }

	})();

	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	            if (((es5.isES5 && keys.length > 1) ||
	                (keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor"))) ||
	                thisAssignmentPattern.test(fn + "")) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            es5.defineProperty(to, key, es5.getDescriptor(from, key));
	        }
	    }
	}

	function isNativeFunctionMethod(fn) {
	    return fn === fn.call ||
	           fn === fn.toString ||
	           fn === fn.bind ||
	           fn === fn.apply;
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]",
	    isNativeFunctionMethod: isNativeFunctionMethod
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;

	},{"./es5.js":14}],39:[function(_dereq_,module,exports){
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	},{}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), (function() { return this; }()), __webpack_require__(8).setImmediate))

/***/ },
/* 7 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	  try {
	    cachedSetTimeout = setTimeout;
	  } catch (e) {
	    cachedSetTimeout = function () {
	      throw new Error('setTimeout is not defined');
	    }
	  }
	  try {
	    cachedClearTimeout = clearTimeout;
	  } catch (e) {
	    cachedClearTimeout = function () {
	      throw new Error('clearTimeout is not defined');
	    }
	  }
	} ())
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = cachedSetTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    cachedClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        cachedSetTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(7).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate, __webpack_require__(8).clearImmediate))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(6);
	var request = __webpack_require__(10);

	var requestAsync = Promise.promisify(request.defaults({
	  headers: {
	    'Accept': 'application/json'
	  },
	  withCredentials: false,
	  timeout: 30000
	}));

	module.exports = requestAsync;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2010-2012 Mikeal Rogers
	//
	//    Licensed under the Apache License, Version 2.0 (the "License");
	//    you may not use this file except in compliance with the License.
	//    You may obtain a copy of the License at
	//
	//        http://www.apache.org/licenses/LICENSE-2.0
	//
	//    Unless required by applicable law or agreed to in writing, software
	//    distributed under the License is distributed on an "AS IS" BASIS,
	//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	//    See the License for the specific language governing permissions and
	//    limitations under the License.

	'use strict'

	var extend                = __webpack_require__(11)
	  , cookies               = __webpack_require__(12)
	  , helpers               = __webpack_require__(31)

	var isFunction            = helpers.isFunction
	  , paramsHaveRequestBody = helpers.paramsHaveRequestBody


	// organize params for patch, post, put, head, del
	function initParams(uri, options, callback) {
	  if (typeof options === 'function') {
	    callback = options
	  }

	  var params = {}
	  if (typeof options === 'object') {
	    extend(params, options, {uri: uri})
	  } else if (typeof uri === 'string') {
	    extend(params, {uri: uri})
	  } else {
	    extend(params, uri)
	  }

	  params.callback = callback
	  return params
	}

	function request (uri, options, callback) {
	  if (typeof uri === 'undefined') {
	    throw new Error('undefined is not a valid uri or options object.')
	  }

	  var params = initParams(uri, options, callback)

	  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
	    throw new Error('HTTP HEAD requests MUST NOT include a request body.')
	  }

	  return new request.Request(params)
	}

	function verbFunc (verb) {
	  var method = verb === 'del' ? 'DELETE' : verb.toUpperCase()
	  return function (uri, options, callback) {
	    var params = initParams(uri, options, callback)
	    params.method = method
	    return request(params, params.callback)
	  }
	}

	// define like this to please codeintel/intellisense IDEs
	request.get = verbFunc('get')
	request.head = verbFunc('head')
	request.post = verbFunc('post')
	request.put = verbFunc('put')
	request.patch = verbFunc('patch')
	request.del = verbFunc('del')

	request.jar = function (store) {
	  return cookies.jar(store)
	}

	request.cookie = function (str) {
	  return cookies.parse(str)
	}

	function wrapRequestMethod (method, options, requester, verb) {

	  return function (uri, opts, callback) {
	    var params = initParams(uri, opts, callback)

	    var target = {}
	    extend(true, target, options, params)

	    if (verb) {
	      target.method = (verb === 'del' ? 'DELETE' : verb.toUpperCase())
	    }

	    if (isFunction(requester)) {
	      method = requester
	    }

	    return method(target, target.callback)
	  }
	}

	request.defaults = function (options, requester) {
	  var self = this

	  if (typeof options === 'function') {
	    requester = options
	    options = {}
	  }

	  var defaults      = wrapRequestMethod(self, options, requester)

	  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del']
	  verbs.forEach(function(verb) {
	    defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)
	  })

	  defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)
	  defaults.jar      = self.jar
	  defaults.defaults = self.defaults
	  return defaults
	}

	request.forever = function (agentOptions, optionsArg) {
	  var options = {}
	  if (optionsArg) {
	    extend(options, optionsArg)
	  }
	  if (agentOptions) {
	    options.agentOptions = agentOptions
	  }

	  options.forever = true
	  return request.defaults(options)
	}

	// Exports

	module.exports = request
	request.Request = __webpack_require__(52)
	request.initParams = initParams

	// Backwards compatibility for request.debug
	Object.defineProperty(request, 'debug', {
	  enumerable : true,
	  get : function() {
	    return request.Request.debug
	  },
	  set : function(debug) {
	    request.Request.debug = debug
	  }
	})


/***/ },
/* 11 */
/***/ function(module, exports) {

	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var undefined;

	var isArray = function isArray(arr) {
		if (typeof Array.isArray === 'function') {
			return Array.isArray(arr);
		}

		return toStr.call(arr) === '[object Array]';
	};

	var isPlainObject = function isPlainObject(obj) {
		'use strict';
		if (!obj || toStr.call(obj) !== '[object Object]') {
			return false;
		}

		var has_own_constructor = hasOwn.call(obj, 'constructor');
		var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		// Not own constructor property must be Object
		if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		var key;
		for (key in obj) {}

		return key === undefined || hasOwn.call(obj, key);
	};

	module.exports = function extend() {
		'use strict';
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0],
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === 'boolean') {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
			target = {};
		}

		for (; i < length; ++i) {
			options = arguments[i];
			// Only deal with non-null/undefined values
			if (options != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};



/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var tough = __webpack_require__(13)

	var Cookie = tough.Cookie
	  , CookieJar = tough.CookieJar


	exports.parse = function(str) {
	  if (str && str.uri) {
	    str = str.uri
	  }
	  if (typeof str !== 'string') {
	    throw new Error('The cookie function only accepts STRING as param')
	  }
	  return Cookie.parse(str)
	}

	// Adapt the sometimes-Async api of tough.CookieJar to our requirements
	function RequestJar(store) {
	  var self = this
	  self._jar = new CookieJar(store)
	}
	RequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {
	  var self = this
	  return self._jar.setCookieSync(cookieOrStr, uri, options || {})
	}
	RequestJar.prototype.getCookieString = function(uri) {
	  var self = this
	  return self._jar.getCookieStringSync(uri)
	}
	RequestJar.prototype.getCookies = function(uri) {
	  var self = this
	  return self._jar.getCookiesSync(uri)
	}

	exports.jar = function(store) {
	  return new RequestJar(store)
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	'use strict';
	var net = __webpack_require__(14);
	var urlParse = __webpack_require__(15).parse;
	var pubsuffix = __webpack_require__(21);
	var Store = __webpack_require__(23).Store;
	var MemoryCookieStore = __webpack_require__(24).MemoryCookieStore;
	var pathMatch = __webpack_require__(26).pathMatch;
	var VERSION = __webpack_require__(30).version;

	var punycode;
	try {
	  punycode = __webpack_require__(22);
	} catch(e) {
	  console.warn("cookie: can't load punycode; won't use punycode for domain normalization");
	}

	var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

	// From RFC6265 S4.1.1
	// note that it excludes \x3B ";"
	var COOKIE_OCTET  = /[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]/;
	var COOKIE_OCTETS = new RegExp('^'+COOKIE_OCTET.source+'+$');

	var CONTROL_CHARS = /[\x00-\x1F]/;

	// Double quotes are part of the value (see: S4.1.1).
	// '\r', '\n' and '\0' should be treated as a terminator in the "relaxed" mode
	// (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60)
	// '=' and ';' are attribute/values separators
	// (see: https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L64)
	var COOKIE_PAIR = /^(([^=;]+))\s*=\s*([^\n\r\0]*)/;

	// Used to parse non-RFC-compliant cookies like '=abc' when given the `loose`
	// option in Cookie.parse:
	var LOOSE_COOKIE_PAIR = /^((?:=)?([^=;]*)\s*=\s*)?([^\n\r\0]*)/;

	// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
	// Note ';' is \x3B
	var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

	// Used for checking whether or not there is a trailing semi-colon
	var TRAILING_SEMICOLON = /;+$/;

	var DAY_OF_MONTH = /^(\d{1,2})[^\d]*$/;
	var TIME = /^(\d{1,2})[^\d]*:(\d{1,2})[^\d]*:(\d{1,2})[^\d]*$/;
	var MONTH = /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;

	var MONTH_TO_NUM = {
	  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
	  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
	};
	var NUM_TO_MONTH = [
	  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
	];
	var NUM_TO_DAY = [
	  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
	];

	var YEAR = /^(\d{2}|\d{4})$/; // 2 to 4 digits

	var MAX_TIME = 2147483647000; // 31-bit max
	var MIN_TIME = 0; // 31-bit min


	// RFC6265 S5.1.1 date parser:
	function parseDate(str) {
	  if (!str) {
	    return;
	  }

	  /* RFC6265 S5.1.1:
	   * 2. Process each date-token sequentially in the order the date-tokens
	   * appear in the cookie-date
	   */
	  var tokens = str.split(DATE_DELIM);
	  if (!tokens) {
	    return;
	  }

	  var hour = null;
	  var minutes = null;
	  var seconds = null;
	  var day = null;
	  var month = null;
	  var year = null;

	  for (var i=0; i<tokens.length; i++) {
	    var token = tokens[i].trim();
	    if (!token.length) {
	      continue;
	    }

	    var result;

	    /* 2.1. If the found-time flag is not set and the token matches the time
	     * production, set the found-time flag and set the hour- value,
	     * minute-value, and second-value to the numbers denoted by the digits in
	     * the date-token, respectively.  Skip the remaining sub-steps and continue
	     * to the next date-token.
	     */
	    if (seconds === null) {
	      result = TIME.exec(token);
	      if (result) {
	        hour = parseInt(result[1], 10);
	        minutes = parseInt(result[2], 10);
	        seconds = parseInt(result[3], 10);
	        /* RFC6265 S5.1.1.5:
	         * [fail if]
	         * *  the hour-value is greater than 23,
	         * *  the minute-value is greater than 59, or
	         * *  the second-value is greater than 59.
	         */
	        if(hour > 23 || minutes > 59 || seconds > 59) {
	          return;
	        }

	        continue;
	      }
	    }

	    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
	     * the day-of-month production, set the found-day-of- month flag and set
	     * the day-of-month-value to the number denoted by the date-token.  Skip
	     * the remaining sub-steps and continue to the next date-token.
	     */
	    if (day === null) {
	      result = DAY_OF_MONTH.exec(token);
	      if (result) {
	        day = parseInt(result, 10);
	        /* RFC6265 S5.1.1.5:
	         * [fail if] the day-of-month-value is less than 1 or greater than 31
	         */
	        if(day < 1 || day > 31) {
	          return;
	        }
	        continue;
	      }
	    }

	    /* 2.3. If the found-month flag is not set and the date-token matches the
	     * month production, set the found-month flag and set the month-value to
	     * the month denoted by the date-token.  Skip the remaining sub-steps and
	     * continue to the next date-token.
	     */
	    if (month === null) {
	      result = MONTH.exec(token);
	      if (result) {
	        month = MONTH_TO_NUM[result[1].toLowerCase()];
	        continue;
	      }
	    }

	    /* 2.4. If the found-year flag is not set and the date-token matches the year
	     * production, set the found-year flag and set the year-value to the number
	     * denoted by the date-token.  Skip the remaining sub-steps and continue to
	     * the next date-token.
	     */
	    if (year === null) {
	      result = YEAR.exec(token);
	      if (result) {
	        year = parseInt(result[0], 10);
	        /* From S5.1.1:
	         * 3.  If the year-value is greater than or equal to 70 and less
	         * than or equal to 99, increment the year-value by 1900.
	         * 4.  If the year-value is greater than or equal to 0 and less
	         * than or equal to 69, increment the year-value by 2000.
	         */
	        if (70 <= year && year <= 99) {
	          year += 1900;
	        } else if (0 <= year && year <= 69) {
	          year += 2000;
	        }

	        if (year < 1601) {
	          return; // 5. ... the year-value is less than 1601
	        }
	      }
	    }
	  }

	  if (seconds === null || day === null || month === null || year === null) {
	    return; // 5. ... at least one of the found-day-of-month, found-month, found-
	            // year, or found-time flags is not set,
	  }

	  return new Date(Date.UTC(year, month, day, hour, minutes, seconds));
	}

	function formatDate(date) {
	  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
	  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
	  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
	  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
	  return NUM_TO_DAY[date.getUTCDay()] + ', ' +
	    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
	    h+':'+m+':'+s+' GMT';
	}

	// S5.1.2 Canonicalized Host Names
	function canonicalDomain(str) {
	  if (str == null) {
	    return null;
	  }
	  str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .

	  // convert to IDN if any non-ASCII characters
	  if (punycode && /[^\u0001-\u007f]/.test(str)) {
	    str = punycode.toASCII(str);
	  }

	  return str.toLowerCase();
	}

	// S5.1.3 Domain Matching
	function domainMatch(str, domStr, canonicalize) {
	  if (str == null || domStr == null) {
	    return null;
	  }
	  if (canonicalize !== false) {
	    str = canonicalDomain(str);
	    domStr = canonicalDomain(domStr);
	  }

	  /*
	   * "The domain string and the string are identical. (Note that both the
	   * domain string and the string will have been canonicalized to lower case at
	   * this point)"
	   */
	  if (str == domStr) {
	    return true;
	  }

	  /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */

	  /* "* The string is a host name (i.e., not an IP address)." */
	  if (net.isIP(str)) {
	    return false;
	  }

	  /* "* The domain string is a suffix of the string" */
	  var idx = str.indexOf(domStr);
	  if (idx <= 0) {
	    return false; // it's a non-match (-1) or prefix (0)
	  }

	  // e.g "a.b.c".indexOf("b.c") === 2
	  // 5 === 3+2
	  if (str.length !== domStr.length + idx) { // it's not a suffix
	    return false;
	  }

	  /* "* The last character of the string that is not included in the domain
	  * string is a %x2E (".") character." */
	  if (str.substr(idx-1,1) !== '.') {
	    return false;
	  }

	  return true;
	}


	// RFC6265 S5.1.4 Paths and Path-Match

	/*
	 * "The user agent MUST use an algorithm equivalent to the following algorithm
	 * to compute the default-path of a cookie:"
	 *
	 * Assumption: the path (and not query part or absolute uri) is passed in.
	 */
	function defaultPath(path) {
	  // "2. If the uri-path is empty or if the first character of the uri-path is not
	  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
	  if (!path || path.substr(0,1) !== "/") {
	    return "/";
	  }

	  // "3. If the uri-path contains no more than one %x2F ("/") character, output
	  // %x2F ("/") and skip the remaining step."
	  if (path === "/") {
	    return path;
	  }

	  var rightSlash = path.lastIndexOf("/");
	  if (rightSlash === 0) {
	    return "/";
	  }

	  // "4. Output the characters of the uri-path from the first character up to,
	  // but not including, the right-most %x2F ("/")."
	  return path.slice(0, rightSlash);
	}


	function parse(str, options) {
	  if (!options || typeof options !== 'object') {
	    options = {};
	  }
	  str = str.trim();

	  // S4.1.1 Trailing semi-colons are not part of the specification.
	  var semiColonCheck = TRAILING_SEMICOLON.exec(str);
	  if (semiColonCheck) {
	    str = str.slice(0, semiColonCheck.index);
	  }

	  // We use a regex to parse the "name-value-pair" part of S5.2
	  var firstSemi = str.indexOf(';'); // S5.2 step 1
	  var pairRe = options.loose ? LOOSE_COOKIE_PAIR : COOKIE_PAIR;
	  var result = pairRe.exec(firstSemi === -1 ? str : str.substr(0,firstSemi));

	  // Rx satisfies the "the name string is empty" and "lacks a %x3D ("=")"
	  // constraints as well as trimming any whitespace.
	  if (!result) {
	    return;
	  }

	  var c = new Cookie();
	  if (result[1]) {
	    c.key = result[2].trim();
	  } else {
	    c.key = '';
	  }
	  c.value = result[3].trim();
	  if (CONTROL_CHARS.test(c.key) || CONTROL_CHARS.test(c.value)) {
	    return;
	  }

	  if (firstSemi === -1) {
	    return c;
	  }

	  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
	  // (including the %x3B (";") in question)." plus later on in the same section
	  // "discard the first ";" and trim".
	  var unparsed = str.slice(firstSemi).replace(/^\s*;\s*/,'').trim();

	  // "If the unparsed-attributes string is empty, skip the rest of these
	  // steps."
	  if (unparsed.length === 0) {
	    return c;
	  }

	  /*
	   * S5.2 says that when looping over the items "[p]rocess the attribute-name
	   * and attribute-value according to the requirements in the following
	   * subsections" for every item.  Plus, for many of the individual attributes
	   * in S5.3 it says to use the "attribute-value of the last attribute in the
	   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
	   * the previous value.
	   */
	  var cookie_avs = unparsed.split(/\s*;\s*/);
	  while (cookie_avs.length) {
	    var av = cookie_avs.shift();
	    var av_sep = av.indexOf('=');
	    var av_key, av_value;

	    if (av_sep === -1) {
	      av_key = av;
	      av_value = null;
	    } else {
	      av_key = av.substr(0,av_sep);
	      av_value = av.substr(av_sep+1);
	    }

	    av_key = av_key.trim().toLowerCase();

	    if (av_value) {
	      av_value = av_value.trim();
	    }

	    switch(av_key) {
	    case 'expires': // S5.2.1
	      if (av_value) {
	        var exp = parseDate(av_value);
	        // "If the attribute-value failed to parse as a cookie date, ignore the
	        // cookie-av."
	        if (exp) {
	          // over and underflow not realistically a concern: V8's getTime() seems to
	          // store something larger than a 32-bit time_t (even with 32-bit node)
	          c.expires = exp;
	        }
	      }
	      break;

	    case 'max-age': // S5.2.2
	      if (av_value) {
	        // "If the first character of the attribute-value is not a DIGIT or a "-"
	        // character ...[or]... If the remainder of attribute-value contains a
	        // non-DIGIT character, ignore the cookie-av."
	        if (/^-?[0-9]+$/.test(av_value)) {
	          var delta = parseInt(av_value, 10);
	          // "If delta-seconds is less than or equal to zero (0), let expiry-time
	          // be the earliest representable date and time."
	          c.setMaxAge(delta);
	        }
	      }
	      break;

	    case 'domain': // S5.2.3
	      // "If the attribute-value is empty, the behavior is undefined.  However,
	      // the user agent SHOULD ignore the cookie-av entirely."
	      if (av_value) {
	        // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
	        // (".") character."
	        var domain = av_value.trim().replace(/^\./, '');
	        if (domain) {
	          // "Convert the cookie-domain to lower case."
	          c.domain = domain.toLowerCase();
	        }
	      }
	      break;

	    case 'path': // S5.2.4
	      /*
	       * "If the attribute-value is empty or if the first character of the
	       * attribute-value is not %x2F ("/"):
	       *   Let cookie-path be the default-path.
	       * Otherwise:
	       *   Let cookie-path be the attribute-value."
	       *
	       * We'll represent the default-path as null since it depends on the
	       * context of the parsing.
	       */
	      c.path = av_value && av_value[0] === "/" ? av_value : null;
	      break;

	    case 'secure': // S5.2.5
	      /*
	       * "If the attribute-name case-insensitively matches the string "Secure",
	       * the user agent MUST append an attribute to the cookie-attribute-list
	       * with an attribute-name of Secure and an empty attribute-value."
	       */
	      c.secure = true;
	      break;

	    case 'httponly': // S5.2.6 -- effectively the same as 'secure'
	      c.httpOnly = true;
	      break;

	    default:
	      c.extensions = c.extensions || [];
	      c.extensions.push(av);
	      break;
	    }
	  }

	  return c;
	}

	// avoid the V8 deoptimization monster!
	function jsonParse(str) {
	  var obj;
	  try {
	    obj = JSON.parse(str);
	  } catch (e) {
	    return e;
	  }
	  return obj;
	}

	function fromJSON(str) {
	  if (!str) {
	    return null;
	  }

	  var obj;
	  if (typeof str === 'string') {
	    obj = jsonParse(str);
	    if (obj instanceof Error) {
	      return null;
	    }
	  } else {
	    // assume it's an Object
	    obj = str;
	  }

	  var c = new Cookie();
	  for (var i=0; i<Cookie.serializableProperties.length; i++) {
	    var prop = Cookie.serializableProperties[i];
	    if (obj[prop] === undefined ||
	        obj[prop] === Cookie.prototype[prop])
	    {
	      continue; // leave as prototype default
	    }

	    if (prop === 'expires' ||
	        prop === 'creation' ||
	        prop === 'lastAccessed')
	    {
	      if (obj[prop] === null) {
	        c[prop] = null;
	      } else {
	        c[prop] = obj[prop] == "Infinity" ?
	          "Infinity" : new Date(obj[prop]);
	      }
	    } else {
	      c[prop] = obj[prop];
	    }
	  }

	  return c;
	}

	/* Section 5.4 part 2:
	 * "*  Cookies with longer paths are listed before cookies with
	 *     shorter paths.
	 *
	 *  *  Among cookies that have equal-length path fields, cookies with
	 *     earlier creation-times are listed before cookies with later
	 *     creation-times."
	 */

	function cookieCompare(a,b) {
	  var cmp = 0;

	  // descending for length: b CMP a
	  var aPathLen = a.path ? a.path.length : 0;
	  var bPathLen = b.path ? b.path.length : 0;
	  cmp = bPathLen - aPathLen;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  // ascending for time: a CMP b
	  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
	  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
	  cmp = aTime - bTime;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  // break ties for the same millisecond (precision of JavaScript's clock)
	  cmp = a.creationIndex - b.creationIndex;

	  return cmp;
	}

	// Gives the permutation of all possible pathMatch()es of a given path. The
	// array is in longest-to-shortest order.  Handy for indexing.
	function permutePath(path) {
	  if (path === '/') {
	    return ['/'];
	  }
	  if (path.lastIndexOf('/') === path.length-1) {
	    path = path.substr(0,path.length-1);
	  }
	  var permutations = [path];
	  while (path.length > 1) {
	    var lindex = path.lastIndexOf('/');
	    if (lindex === 0) {
	      break;
	    }
	    path = path.substr(0,lindex);
	    permutations.push(path);
	  }
	  permutations.push('/');
	  return permutations;
	}

	function getCookieContext(url) {
	  if (url instanceof Object) {
	    return url;
	  }
	  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
	  // Therefore, we will just skip decoding for such URIs.
	  try {
	    url = decodeURI(url);
	  }
	  catch(err) {
	    // Silently swallow error
	  }

	  return urlParse(url);
	}

	function Cookie(options) {
	  options = options || {};

	  Object.keys(options).forEach(function(prop) {
	    if (Cookie.prototype.hasOwnProperty(prop) &&
	        Cookie.prototype[prop] !== options[prop] &&
	        prop.substr(0,1) !== '_')
	    {
	      this[prop] = options[prop];
	    }
	  }, this);

	  this.creation = this.creation || new Date();

	  // used to break creation ties in cookieCompare():
	  Object.defineProperty(this, 'creationIndex', {
	    configurable: false,
	    enumerable: false, // important for assert.deepEqual checks
	    writable: true,
	    value: ++Cookie.cookiesCreated
	  });
	}

	Cookie.cookiesCreated = 0; // incremented each time a cookie is created

	Cookie.parse = parse;
	Cookie.fromJSON = fromJSON;

	Cookie.prototype.key = "";
	Cookie.prototype.value = "";

	// the order in which the RFC has them:
	Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
	Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
	Cookie.prototype.domain = null;
	Cookie.prototype.path = null;
	Cookie.prototype.secure = false;
	Cookie.prototype.httpOnly = false;
	Cookie.prototype.extensions = null;

	// set by the CookieJar:
	Cookie.prototype.hostOnly = null; // boolean when set
	Cookie.prototype.pathIsDefault = null; // boolean when set
	Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
	Cookie.prototype.lastAccessed = null; // Date when set
	Object.defineProperty(Cookie.prototype, 'creationIndex', {
	  configurable: true,
	  enumerable: false,
	  writable: true,
	  value: 0
	});

	Cookie.serializableProperties = Object.keys(Cookie.prototype)
	  .filter(function(prop) {
	    return !(
	      Cookie.prototype[prop] instanceof Function ||
	      prop === 'creationIndex' ||
	      prop.substr(0,1) === '_'
	    );
	  });

	Cookie.prototype.inspect = function inspect() {
	  var now = Date.now();
	  return 'Cookie="'+this.toString() +
	    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
	    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
	    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
	    '"';
	};

	Cookie.prototype.toJSON = function() {
	  var obj = {};

	  var props = Cookie.serializableProperties;
	  for (var i=0; i<props.length; i++) {
	    var prop = props[i];
	    if (this[prop] === Cookie.prototype[prop]) {
	      continue; // leave as prototype default
	    }

	    if (prop === 'expires' ||
	        prop === 'creation' ||
	        prop === 'lastAccessed')
	    {
	      if (this[prop] === null) {
	        obj[prop] = null;
	      } else {
	        obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
	          "Infinity" : this[prop].toISOString();
	      }
	    } else if (prop === 'maxAge') {
	      if (this[prop] !== null) {
	        // again, intentionally not ===
	        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
	          this[prop].toString() : this[prop];
	      }
	    } else {
	      if (this[prop] !== Cookie.prototype[prop]) {
	        obj[prop] = this[prop];
	      }
	    }
	  }

	  return obj;
	};

	Cookie.prototype.clone = function() {
	  return fromJSON(this.toJSON());
	};

	Cookie.prototype.validate = function validate() {
	  if (!COOKIE_OCTETS.test(this.value)) {
	    return false;
	  }
	  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
	    return false;
	  }
	  if (this.maxAge != null && this.maxAge <= 0) {
	    return false; // "Max-Age=" non-zero-digit *DIGIT
	  }
	  if (this.path != null && !PATH_VALUE.test(this.path)) {
	    return false;
	  }

	  var cdomain = this.cdomain();
	  if (cdomain) {
	    if (cdomain.match(/\.$/)) {
	      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
	    }
	    var suffix = pubsuffix.getPublicSuffix(cdomain);
	    if (suffix == null) { // it's a public suffix
	      return false;
	    }
	  }
	  return true;
	};

	Cookie.prototype.setExpires = function setExpires(exp) {
	  if (exp instanceof Date) {
	    this.expires = exp;
	  } else {
	    this.expires = parseDate(exp) || "Infinity";
	  }
	};

	Cookie.prototype.setMaxAge = function setMaxAge(age) {
	  if (age === Infinity || age === -Infinity) {
	    this.maxAge = age.toString(); // so JSON.stringify() works
	  } else {
	    this.maxAge = age;
	  }
	};

	// gives Cookie header format
	Cookie.prototype.cookieString = function cookieString() {
	  var val = this.value;
	  if (val == null) {
	    val = '';
	  }
	  if (this.key === '') {
	    return val;
	  }
	  return this.key+'='+val;
	};

	// gives Set-Cookie header format
	Cookie.prototype.toString = function toString() {
	  var str = this.cookieString();

	  if (this.expires != Infinity) {
	    if (this.expires instanceof Date) {
	      str += '; Expires='+formatDate(this.expires);
	    } else {
	      str += '; Expires='+this.expires;
	    }
	  }

	  if (this.maxAge != null && this.maxAge != Infinity) {
	    str += '; Max-Age='+this.maxAge;
	  }

	  if (this.domain && !this.hostOnly) {
	    str += '; Domain='+this.domain;
	  }
	  if (this.path) {
	    str += '; Path='+this.path;
	  }

	  if (this.secure) {
	    str += '; Secure';
	  }
	  if (this.httpOnly) {
	    str += '; HttpOnly';
	  }
	  if (this.extensions) {
	    this.extensions.forEach(function(ext) {
	      str += '; '+ext;
	    });
	  }

	  return str;
	};

	// TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere)
	// S5.3 says to give the "latest representable date" for which we use Infinity
	// For "expired" we use 0
	Cookie.prototype.TTL = function TTL(now) {
	  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
	   * attribute, the Max-Age attribute has precedence and controls the
	   * expiration date of the cookie.
	   * (Concurs with S5.3 step 3)
	   */
	  if (this.maxAge != null) {
	    return this.maxAge<=0 ? 0 : this.maxAge*1000;
	  }

	  var expires = this.expires;
	  if (expires != Infinity) {
	    if (!(expires instanceof Date)) {
	      expires = parseDate(expires) || Infinity;
	    }

	    if (expires == Infinity) {
	      return Infinity;
	    }

	    return expires.getTime() - (now || Date.now());
	  }

	  return Infinity;
	};

	// expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere)
	Cookie.prototype.expiryTime = function expiryTime(now) {
	  if (this.maxAge != null) {
	    var relativeTo = now || this.creation || new Date();
	    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
	    return relativeTo.getTime() + age;
	  }

	  if (this.expires == Infinity) {
	    return Infinity;
	  }
	  return this.expires.getTime();
	};

	// expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
	// elsewhere), except it returns a Date
	Cookie.prototype.expiryDate = function expiryDate(now) {
	  var millisec = this.expiryTime(now);
	  if (millisec == Infinity) {
	    return new Date(MAX_TIME);
	  } else if (millisec == -Infinity) {
	    return new Date(MIN_TIME);
	  } else {
	    return new Date(millisec);
	  }
	};

	// This replaces the "persistent-flag" parts of S5.3 step 3
	Cookie.prototype.isPersistent = function isPersistent() {
	  return (this.maxAge != null || this.expires != Infinity);
	};

	// Mostly S5.1.2 and S5.2.3:
	Cookie.prototype.cdomain =
	Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
	  if (this.domain == null) {
	    return null;
	  }
	  return canonicalDomain(this.domain);
	};

	function CookieJar(store, options) {
	  if (typeof options === "boolean") {
	    options = {rejectPublicSuffixes: options};
	  } else if (options == null) {
	    options = {};
	  }
	  if (options.rejectPublicSuffixes != null) {
	    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
	  }
	  if (options.looseMode != null) {
	    this.enableLooseMode = options.looseMode;
	  }

	  if (!store) {
	    store = new MemoryCookieStore();
	  }
	  this.store = store;
	}
	CookieJar.prototype.store = null;
	CookieJar.prototype.rejectPublicSuffixes = true;
	CookieJar.prototype.enableLooseMode = false;
	var CAN_BE_SYNC = [];

	CAN_BE_SYNC.push('setCookie');
	CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
	  var err;
	  var context = getCookieContext(url);
	  if (options instanceof Function) {
	    cb = options;
	    options = {};
	  }

	  var host = canonicalDomain(context.hostname);
	  var loose = this.enableLooseMode;
	  if (options.loose != null) {
	    loose = options.loose;
	  }

	  // S5.3 step 1
	  if (!(cookie instanceof Cookie)) {
	    cookie = Cookie.parse(cookie, { loose: loose });
	  }
	  if (!cookie) {
	    err = new Error("Cookie failed to parse");
	    return cb(options.ignoreError ? null : err);
	  }

	  // S5.3 step 2
	  var now = options.now || new Date(); // will assign later to save effort in the face of errors

	  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

	  // S5.3 step 4: NOOP; domain is null by default

	  // S5.3 step 5: public suffixes
	  if (this.rejectPublicSuffixes && cookie.domain) {
	    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
	    if (suffix == null) { // e.g. "com"
	      err = new Error("Cookie has domain set to a public suffix");
	      return cb(options.ignoreError ? null : err);
	    }
	  }

	  // S5.3 step 6:
	  if (cookie.domain) {
	    if (!domainMatch(host, cookie.cdomain(), false)) {
	      err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
	      return cb(options.ignoreError ? null : err);
	    }

	    if (cookie.hostOnly == null) { // don't reset if already set
	      cookie.hostOnly = false;
	    }

	  } else {
	    cookie.hostOnly = true;
	    cookie.domain = host;
	  }

	  //S5.2.4 If the attribute-value is empty or if the first character of the
	  //attribute-value is not %x2F ("/"):
	  //Let cookie-path be the default-path.
	  if (!cookie.path || cookie.path[0] !== '/') {
	    cookie.path = defaultPath(context.pathname);
	    cookie.pathIsDefault = true;
	  }

	  // S5.3 step 8: NOOP; secure attribute
	  // S5.3 step 9: NOOP; httpOnly attribute

	  // S5.3 step 10
	  if (options.http === false && cookie.httpOnly) {
	    err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
	    return cb(options.ignoreError ? null : err);
	  }

	  var store = this.store;

	  if (!store.updateCookie) {
	    store.updateCookie = function(oldCookie, newCookie, cb) {
	      this.putCookie(newCookie, cb);
	    };
	  }

	  function withCookie(err, oldCookie) {
	    if (err) {
	      return cb(err);
	    }

	    var next = function(err) {
	      if (err) {
	        return cb(err);
	      } else {
	        cb(null, cookie);
	      }
	    };

	    if (oldCookie) {
	      // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
	      // domain, and path as the newly created cookie:"
	      if (options.http === false && oldCookie.httpOnly) { // step 11.2
	        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
	        return cb(options.ignoreError ? null : err);
	      }
	      cookie.creation = oldCookie.creation; // step 11.3
	      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
	      cookie.lastAccessed = now;
	      // Step 11.4 (delete cookie) is implied by just setting the new one:
	      store.updateCookie(oldCookie, cookie, next); // step 12

	    } else {
	      cookie.creation = cookie.lastAccessed = now;
	      store.putCookie(cookie, next); // step 12
	    }
	  }

	  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
	};

	// RFC6365 S5.4
	CAN_BE_SYNC.push('getCookies');
	CookieJar.prototype.getCookies = function(url, options, cb) {
	  var context = getCookieContext(url);
	  if (options instanceof Function) {
	    cb = options;
	    options = {};
	  }

	  var host = canonicalDomain(context.hostname);
	  var path = context.pathname || '/';

	  var secure = options.secure;
	  if (secure == null && context.protocol &&
	      (context.protocol == 'https:' || context.protocol == 'wss:'))
	  {
	    secure = true;
	  }

	  var http = options.http;
	  if (http == null) {
	    http = true;
	  }

	  var now = options.now || Date.now();
	  var expireCheck = options.expire !== false;
	  var allPaths = !!options.allPaths;
	  var store = this.store;

	  function matchingCookie(c) {
	    // "Either:
	    //   The cookie's host-only-flag is true and the canonicalized
	    //   request-host is identical to the cookie's domain.
	    // Or:
	    //   The cookie's host-only-flag is false and the canonicalized
	    //   request-host domain-matches the cookie's domain."
	    if (c.hostOnly) {
	      if (c.domain != host) {
	        return false;
	      }
	    } else {
	      if (!domainMatch(host, c.domain, false)) {
	        return false;
	      }
	    }

	    // "The request-uri's path path-matches the cookie's path."
	    if (!allPaths && !pathMatch(path, c.path)) {
	      return false;
	    }

	    // "If the cookie's secure-only-flag is true, then the request-uri's
	    // scheme must denote a "secure" protocol"
	    if (c.secure && !secure) {
	      return false;
	    }

	    // "If the cookie's http-only-flag is true, then exclude the cookie if the
	    // cookie-string is being generated for a "non-HTTP" API"
	    if (c.httpOnly && !http) {
	      return false;
	    }

	    // deferred from S5.3
	    // non-RFC: allow retention of expired cookies by choice
	    if (expireCheck && c.expiryTime() <= now) {
	      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
	      return false;
	    }

	    return true;
	  }

	  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
	    if (err) {
	      return cb(err);
	    }

	    cookies = cookies.filter(matchingCookie);

	    // sorting of S5.4 part 2
	    if (options.sort !== false) {
	      cookies = cookies.sort(cookieCompare);
	    }

	    // S5.4 part 3
	    var now = new Date();
	    cookies.forEach(function(c) {
	      c.lastAccessed = now;
	    });
	    // TODO persist lastAccessed

	    cb(null,cookies);
	  });
	};

	CAN_BE_SYNC.push('getCookieString');
	CookieJar.prototype.getCookieString = function(/*..., cb*/) {
	  var args = Array.prototype.slice.call(arguments,0);
	  var cb = args.pop();
	  var next = function(err,cookies) {
	    if (err) {
	      cb(err);
	    } else {
	      cb(null, cookies
	        .sort(cookieCompare)
	        .map(function(c){
	          return c.cookieString();
	        })
	        .join('; '));
	    }
	  };
	  args.push(next);
	  this.getCookies.apply(this,args);
	};

	CAN_BE_SYNC.push('getSetCookieStrings');
	CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
	  var args = Array.prototype.slice.call(arguments,0);
	  var cb = args.pop();
	  var next = function(err,cookies) {
	    if (err) {
	      cb(err);
	    } else {
	      cb(null, cookies.map(function(c){
	        return c.toString();
	      }));
	    }
	  };
	  args.push(next);
	  this.getCookies.apply(this,args);
	};

	CAN_BE_SYNC.push('serialize');
	CookieJar.prototype.serialize = function(cb) {
	  var type = this.store.constructor.name;
	  if (type === 'Object') {
	    type = null;
	  }

	  // update README.md "Serialization Format" if you change this, please!
	  var serialized = {
	    // The version of tough-cookie that serialized this jar. Generally a good
	    // practice since future versions can make data import decisions based on
	    // known past behavior. When/if this matters, use `semver`.
	    version: 'tough-cookie@'+VERSION,

	    // add the store type, to make humans happy:
	    storeType: type,

	    // CookieJar configuration:
	    rejectPublicSuffixes: !!this.rejectPublicSuffixes,

	    // this gets filled from getAllCookies:
	    cookies: []
	  };

	  if (!(this.store.getAllCookies &&
	        typeof this.store.getAllCookies === 'function'))
	  {
	    return cb(new Error('store does not support getAllCookies and cannot be serialized'));
	  }

	  this.store.getAllCookies(function(err,cookies) {
	    if (err) {
	      return cb(err);
	    }

	    serialized.cookies = cookies.map(function(cookie) {
	      // convert to serialized 'raw' cookies
	      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;

	      // Remove the index so new ones get assigned during deserialization
	      delete cookie.creationIndex;

	      return cookie;
	    });

	    return cb(null, serialized);
	  });
	};

	// well-known name that JSON.stringify calls
	CookieJar.prototype.toJSON = function() {
	  return this.serializeSync();
	};

	// use the class method CookieJar.deserialize instead of calling this directly
	CAN_BE_SYNC.push('_importCookies');
	CookieJar.prototype._importCookies = function(serialized, cb) {
	  var jar = this;
	  var cookies = serialized.cookies;
	  if (!cookies || !Array.isArray(cookies)) {
	    return cb(new Error('serialized jar has no cookies array'));
	  }

	  function putNext(err) {
	    if (err) {
	      return cb(err);
	    }

	    if (!cookies.length) {
	      return cb(err, jar);
	    }

	    var cookie;
	    try {
	      cookie = fromJSON(cookies.shift());
	    } catch (e) {
	      return cb(e);
	    }

	    if (cookie === null) {
	      return putNext(null); // skip this cookie
	    }

	    jar.store.putCookie(cookie, putNext);
	  }

	  putNext();
	};

	CookieJar.deserialize = function(strOrObj, store, cb) {
	  if (arguments.length !== 3) {
	    // store is optional
	    cb = store;
	    store = null;
	  }

	  var serialized;
	  if (typeof strOrObj === 'string') {
	    serialized = jsonParse(strOrObj);
	    if (serialized instanceof Error) {
	      return cb(serialized);
	    }
	  } else {
	    serialized = strOrObj;
	  }

	  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
	  jar._importCookies(serialized, function(err) {
	    if (err) {
	      return cb(err);
	    }
	    cb(null, jar);
	  });
	};

	CookieJar.deserializeSync = function(strOrObj, store) {
	  var serialized = typeof strOrObj === 'string' ?
	    JSON.parse(strOrObj) : strOrObj;
	  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);

	  // catch this mistake early:
	  if (!jar.store.synchronous) {
	    throw new Error('CookieJar store is not synchronous; use async API instead.');
	  }

	  jar._importCookiesSync(serialized);
	  return jar;
	};
	CookieJar.fromJSON = CookieJar.deserializeSync;

	CAN_BE_SYNC.push('clone');
	CookieJar.prototype.clone = function(newStore, cb) {
	  if (arguments.length === 1) {
	    cb = newStore;
	    newStore = null;
	  }

	  this.serialize(function(err,serialized) {
	    if (err) {
	      return cb(err);
	    }
	    CookieJar.deserialize(newStore, serialized, cb);
	  });
	};

	// Use a closure to provide a true imperative API for synchronous stores.
	function syncWrap(method) {
	  return function() {
	    if (!this.store.synchronous) {
	      throw new Error('CookieJar store is not synchronous; use async API instead.');
	    }

	    var args = Array.prototype.slice.call(arguments);
	    var syncErr, syncResult;
	    args.push(function syncCb(err, result) {
	      syncErr = err;
	      syncResult = result;
	    });
	    this[method].apply(this, args);

	    if (syncErr) {
	      throw syncErr;
	    }
	    return syncResult;
	  };
	}

	// wrap all declared CAN_BE_SYNC methods in the sync wrapper
	CAN_BE_SYNC.forEach(function(method) {
	  CookieJar.prototype[method+'Sync'] = syncWrap(method);
	});

	module.exports = {
	  CookieJar: CookieJar,
	  Cookie: Cookie,
	  Store: Store,
	  MemoryCookieStore: MemoryCookieStore,
	  parseDate: parseDate,
	  formatDate: formatDate,
	  parse: parse,
	  fromJSON: fromJSON,
	  domainMatch: domainMatch,
	  defaultPath: defaultPath,
	  pathMatch: pathMatch,
	  getPublicSuffix: pubsuffix.getPublicSuffix,
	  cookieCompare: cookieCompare,
	  permuteDomain: __webpack_require__(25).permuteDomain,
	  permutePath: permutePath,
	  canonicalDomain: canonicalDomain
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(16);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(18);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module), (function() { return this; }())))

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(19);
	exports.encode = exports.stringify = __webpack_require__(20);


/***/ },
/* 19 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 20 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/****************************************************
	 * AUTOMATICALLY GENERATED by generate-pubsuffix.js *
	 *                  DO NOT EDIT!                    *
	 ****************************************************/

	"use strict";

	var punycode = __webpack_require__(22);

	module.exports.getPublicSuffix = function getPublicSuffix(domain) {
	  /*!
	   * Copyright (c) 2015, Salesforce.com, Inc.
	   * All rights reserved.
	   *
	   * Redistribution and use in source and binary forms, with or without
	   * modification, are permitted provided that the following conditions are met:
	   *
	   * 1. Redistributions of source code must retain the above copyright notice,
	   * this list of conditions and the following disclaimer.
	   *
	   * 2. Redistributions in binary form must reproduce the above copyright notice,
	   * this list of conditions and the following disclaimer in the documentation
	   * and/or other materials provided with the distribution.
	   *
	   * 3. Neither the name of Salesforce.com nor the names of its contributors may
	   * be used to endorse or promote products derived from this software without
	   * specific prior written permission.
	   *
	   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	   * POSSIBILITY OF SUCH DAMAGE.
	   */
	  if (!domain) {
	    return null;
	  }
	  if (domain.match(/^\./)) {
	    return null;
	  }
	  var asciiDomain = punycode.toASCII(domain);
	  var converted = false;
	  if (asciiDomain !== domain) {
	    domain = asciiDomain;
	    converted = true;
	  }
	  if (index[domain]) {
	    return null;
	  }

	  domain = domain.toLowerCase();
	  var parts = domain.split('.').reverse();

	  var suffix = '';
	  var suffixLen = 0;
	  for (var i=0; i<parts.length; i++) {
	    var part = parts[i];
	    var starstr = '*'+suffix;
	    var partstr = part+suffix;

	    if (index[starstr]) { // star rule matches
	      suffixLen = i+1;
	      if (index[partstr] === false) { // exception rule matches (NB: false, not undefined)
	        suffixLen--;
	      }
	    } else if (index[partstr]) { // exact match, not exception
	      suffixLen = i+1;
	    }

	    suffix = '.'+partstr;
	  }

	  if (index['*'+suffix]) { // *.domain exists (e.g. *.kyoto.jp for domain='kyoto.jp');
	    return null;
	  }

	  suffixLen = suffixLen || 1;
	  if (parts.length > suffixLen) {
	    var publicSuffix = parts.slice(0,suffixLen+1).reverse().join('.');
	    return converted ? punycode.toUnicode(publicSuffix) : publicSuffix;
	  }

	  return null;
	};

	// The following generated structure is used under the MPL version 2.0
	// See public-suffix.txt for more information

	var index = module.exports.index = Object.freeze(
	{"ac":true,"com.ac":true,"edu.ac":true,"gov.ac":true,"net.ac":true,"mil.ac":true,"org.ac":true,"ad":true,"nom.ad":true,"ae":true,"co.ae":true,"net.ae":true,"org.ae":true,"sch.ae":true,"ac.ae":true,"gov.ae":true,"mil.ae":true,"aero":true,"accident-investigation.aero":true,"accident-prevention.aero":true,"aerobatic.aero":true,"aeroclub.aero":true,"aerodrome.aero":true,"agents.aero":true,"aircraft.aero":true,"airline.aero":true,"airport.aero":true,"air-surveillance.aero":true,"airtraffic.aero":true,"air-traffic-control.aero":true,"ambulance.aero":true,"amusement.aero":true,"association.aero":true,"author.aero":true,"ballooning.aero":true,"broker.aero":true,"caa.aero":true,"cargo.aero":true,"catering.aero":true,"certification.aero":true,"championship.aero":true,"charter.aero":true,"civilaviation.aero":true,"club.aero":true,"conference.aero":true,"consultant.aero":true,"consulting.aero":true,"control.aero":true,"council.aero":true,"crew.aero":true,"design.aero":true,"dgca.aero":true,"educator.aero":true,"emergency.aero":true,"engine.aero":true,"engineer.aero":true,"entertainment.aero":true,"equipment.aero":true,"exchange.aero":true,"express.aero":true,"federation.aero":true,"flight.aero":true,"freight.aero":true,"fuel.aero":true,"gliding.aero":true,"government.aero":true,"groundhandling.aero":true,"group.aero":true,"hanggliding.aero":true,"homebuilt.aero":true,"insurance.aero":true,"journal.aero":true,"journalist.aero":true,"leasing.aero":true,"logistics.aero":true,"magazine.aero":true,"maintenance.aero":true,"marketplace.aero":true,"media.aero":true,"microlight.aero":true,"modelling.aero":true,"navigation.aero":true,"parachuting.aero":true,"paragliding.aero":true,"passenger-association.aero":true,"pilot.aero":true,"press.aero":true,"production.aero":true,"recreation.aero":true,"repbody.aero":true,"res.aero":true,"research.aero":true,"rotorcraft.aero":true,"safety.aero":true,"scientist.aero":true,"services.aero":true,"show.aero":true,"skydiving.aero":true,"software.aero":true,"student.aero":true,"taxi.aero":true,"trader.aero":true,"trading.aero":true,"trainer.aero":true,"union.aero":true,"workinggroup.aero":true,"works.aero":true,"af":true,"gov.af":true,"com.af":true,"org.af":true,"net.af":true,"edu.af":true,"ag":true,"com.ag":true,"org.ag":true,"net.ag":true,"co.ag":true,"nom.ag":true,"ai":true,"off.ai":true,"com.ai":true,"net.ai":true,"org.ai":true,"al":true,"com.al":true,"edu.al":true,"gov.al":true,"mil.al":true,"net.al":true,"org.al":true,"am":true,"an":true,"com.an":true,"net.an":true,"org.an":true,"edu.an":true,"ao":true,"ed.ao":true,"gv.ao":true,"og.ao":true,"co.ao":true,"pb.ao":true,"it.ao":true,"aq":true,"ar":true,"com.ar":true,"edu.ar":true,"gob.ar":true,"gov.ar":true,"int.ar":true,"mil.ar":true,"net.ar":true,"org.ar":true,"tur.ar":true,"arpa":true,"e164.arpa":true,"in-addr.arpa":true,"ip6.arpa":true,"iris.arpa":true,"uri.arpa":true,"urn.arpa":true,"as":true,"gov.as":true,"asia":true,"at":true,"ac.at":true,"co.at":true,"gv.at":true,"or.at":true,"au":true,"com.au":true,"net.au":true,"org.au":true,"edu.au":true,"gov.au":true,"asn.au":true,"id.au":true,"info.au":true,"conf.au":true,"oz.au":true,"act.au":true,"nsw.au":true,"nt.au":true,"qld.au":true,"sa.au":true,"tas.au":true,"vic.au":true,"wa.au":true,"act.edu.au":true,"nsw.edu.au":true,"nt.edu.au":true,"qld.edu.au":true,"sa.edu.au":true,"tas.edu.au":true,"vic.edu.au":true,"wa.edu.au":true,"qld.gov.au":true,"sa.gov.au":true,"tas.gov.au":true,"vic.gov.au":true,"wa.gov.au":true,"aw":true,"com.aw":true,"ax":true,"az":true,"com.az":true,"net.az":true,"int.az":true,"gov.az":true,"org.az":true,"edu.az":true,"info.az":true,"pp.az":true,"mil.az":true,"name.az":true,"pro.az":true,"biz.az":true,"ba":true,"org.ba":true,"net.ba":true,"edu.ba":true,"gov.ba":true,"mil.ba":true,"unsa.ba":true,"unbi.ba":true,"co.ba":true,"com.ba":true,"rs.ba":true,"bb":true,"biz.bb":true,"co.bb":true,"com.bb":true,"edu.bb":true,"gov.bb":true,"info.bb":true,"net.bb":true,"org.bb":true,"store.bb":true,"tv.bb":true,"*.bd":true,"be":true,"ac.be":true,"bf":true,"gov.bf":true,"bg":true,"a.bg":true,"b.bg":true,"c.bg":true,"d.bg":true,"e.bg":true,"f.bg":true,"g.bg":true,"h.bg":true,"i.bg":true,"j.bg":true,"k.bg":true,"l.bg":true,"m.bg":true,"n.bg":true,"o.bg":true,"p.bg":true,"q.bg":true,"r.bg":true,"s.bg":true,"t.bg":true,"u.bg":true,"v.bg":true,"w.bg":true,"x.bg":true,"y.bg":true,"z.bg":true,"0.bg":true,"1.bg":true,"2.bg":true,"3.bg":true,"4.bg":true,"5.bg":true,"6.bg":true,"7.bg":true,"8.bg":true,"9.bg":true,"bh":true,"com.bh":true,"edu.bh":true,"net.bh":true,"org.bh":true,"gov.bh":true,"bi":true,"co.bi":true,"com.bi":true,"edu.bi":true,"or.bi":true,"org.bi":true,"biz":true,"bj":true,"asso.bj":true,"barreau.bj":true,"gouv.bj":true,"bm":true,"com.bm":true,"edu.bm":true,"gov.bm":true,"net.bm":true,"org.bm":true,"*.bn":true,"bo":true,"com.bo":true,"edu.bo":true,"gov.bo":true,"gob.bo":true,"int.bo":true,"org.bo":true,"net.bo":true,"mil.bo":true,"tv.bo":true,"br":true,"adm.br":true,"adv.br":true,"agr.br":true,"am.br":true,"arq.br":true,"art.br":true,"ato.br":true,"b.br":true,"bio.br":true,"blog.br":true,"bmd.br":true,"cim.br":true,"cng.br":true,"cnt.br":true,"com.br":true,"coop.br":true,"ecn.br":true,"eco.br":true,"edu.br":true,"emp.br":true,"eng.br":true,"esp.br":true,"etc.br":true,"eti.br":true,"far.br":true,"flog.br":true,"fm.br":true,"fnd.br":true,"fot.br":true,"fst.br":true,"g12.br":true,"ggf.br":true,"gov.br":true,"imb.br":true,"ind.br":true,"inf.br":true,"jor.br":true,"jus.br":true,"leg.br":true,"lel.br":true,"mat.br":true,"med.br":true,"mil.br":true,"mp.br":true,"mus.br":true,"net.br":true,"*.nom.br":true,"not.br":true,"ntr.br":true,"odo.br":true,"org.br":true,"ppg.br":true,"pro.br":true,"psc.br":true,"psi.br":true,"qsl.br":true,"radio.br":true,"rec.br":true,"slg.br":true,"srv.br":true,"taxi.br":true,"teo.br":true,"tmp.br":true,"trd.br":true,"tur.br":true,"tv.br":true,"vet.br":true,"vlog.br":true,"wiki.br":true,"zlg.br":true,"bs":true,"com.bs":true,"net.bs":true,"org.bs":true,"edu.bs":true,"gov.bs":true,"bt":true,"com.bt":true,"edu.bt":true,"gov.bt":true,"net.bt":true,"org.bt":true,"bv":true,"bw":true,"co.bw":true,"org.bw":true,"by":true,"gov.by":true,"mil.by":true,"com.by":true,"of.by":true,"bz":true,"com.bz":true,"net.bz":true,"org.bz":true,"edu.bz":true,"gov.bz":true,"ca":true,"ab.ca":true,"bc.ca":true,"mb.ca":true,"nb.ca":true,"nf.ca":true,"nl.ca":true,"ns.ca":true,"nt.ca":true,"nu.ca":true,"on.ca":true,"pe.ca":true,"qc.ca":true,"sk.ca":true,"yk.ca":true,"gc.ca":true,"cat":true,"cc":true,"cd":true,"gov.cd":true,"cf":true,"cg":true,"ch":true,"ci":true,"org.ci":true,"or.ci":true,"com.ci":true,"co.ci":true,"edu.ci":true,"ed.ci":true,"ac.ci":true,"net.ci":true,"go.ci":true,"asso.ci":true,"xn--aroport-bya.ci":true,"int.ci":true,"presse.ci":true,"md.ci":true,"gouv.ci":true,"*.ck":true,"www.ck":false,"cl":true,"gov.cl":true,"gob.cl":true,"co.cl":true,"mil.cl":true,"cm":true,"co.cm":true,"com.cm":true,"gov.cm":true,"net.cm":true,"cn":true,"ac.cn":true,"com.cn":true,"edu.cn":true,"gov.cn":true,"net.cn":true,"org.cn":true,"mil.cn":true,"xn--55qx5d.cn":true,"xn--io0a7i.cn":true,"xn--od0alg.cn":true,"ah.cn":true,"bj.cn":true,"cq.cn":true,"fj.cn":true,"gd.cn":true,"gs.cn":true,"gz.cn":true,"gx.cn":true,"ha.cn":true,"hb.cn":true,"he.cn":true,"hi.cn":true,"hl.cn":true,"hn.cn":true,"jl.cn":true,"js.cn":true,"jx.cn":true,"ln.cn":true,"nm.cn":true,"nx.cn":true,"qh.cn":true,"sc.cn":true,"sd.cn":true,"sh.cn":true,"sn.cn":true,"sx.cn":true,"tj.cn":true,"xj.cn":true,"xz.cn":true,"yn.cn":true,"zj.cn":true,"hk.cn":true,"mo.cn":true,"tw.cn":true,"co":true,"arts.co":true,"com.co":true,"edu.co":true,"firm.co":true,"gov.co":true,"info.co":true,"int.co":true,"mil.co":true,"net.co":true,"nom.co":true,"org.co":true,"rec.co":true,"web.co":true,"com":true,"coop":true,"cr":true,"ac.cr":true,"co.cr":true,"ed.cr":true,"fi.cr":true,"go.cr":true,"or.cr":true,"sa.cr":true,"cu":true,"com.cu":true,"edu.cu":true,"org.cu":true,"net.cu":true,"gov.cu":true,"inf.cu":true,"cv":true,"cw":true,"com.cw":true,"edu.cw":true,"net.cw":true,"org.cw":true,"cx":true,"gov.cx":true,"ac.cy":true,"biz.cy":true,"com.cy":true,"ekloges.cy":true,"gov.cy":true,"ltd.cy":true,"name.cy":true,"net.cy":true,"org.cy":true,"parliament.cy":true,"press.cy":true,"pro.cy":true,"tm.cy":true,"cz":true,"de":true,"dj":true,"dk":true,"dm":true,"com.dm":true,"net.dm":true,"org.dm":true,"edu.dm":true,"gov.dm":true,"do":true,"art.do":true,"com.do":true,"edu.do":true,"gob.do":true,"gov.do":true,"mil.do":true,"net.do":true,"org.do":true,"sld.do":true,"web.do":true,"dz":true,"com.dz":true,"org.dz":true,"net.dz":true,"gov.dz":true,"edu.dz":true,"asso.dz":true,"pol.dz":true,"art.dz":true,"ec":true,"com.ec":true,"info.ec":true,"net.ec":true,"fin.ec":true,"k12.ec":true,"med.ec":true,"pro.ec":true,"org.ec":true,"edu.ec":true,"gov.ec":true,"gob.ec":true,"mil.ec":true,"edu":true,"ee":true,"edu.ee":true,"gov.ee":true,"riik.ee":true,"lib.ee":true,"med.ee":true,"com.ee":true,"pri.ee":true,"aip.ee":true,"org.ee":true,"fie.ee":true,"eg":true,"com.eg":true,"edu.eg":true,"eun.eg":true,"gov.eg":true,"mil.eg":true,"name.eg":true,"net.eg":true,"org.eg":true,"sci.eg":true,"*.er":true,"es":true,"com.es":true,"nom.es":true,"org.es":true,"gob.es":true,"edu.es":true,"et":true,"com.et":true,"gov.et":true,"org.et":true,"edu.et":true,"biz.et":true,"name.et":true,"info.et":true,"net.et":true,"eu":true,"fi":true,"aland.fi":true,"*.fj":true,"*.fk":true,"fm":true,"fo":true,"fr":true,"com.fr":true,"asso.fr":true,"nom.fr":true,"prd.fr":true,"presse.fr":true,"tm.fr":true,"aeroport.fr":true,"assedic.fr":true,"avocat.fr":true,"avoues.fr":true,"cci.fr":true,"chambagri.fr":true,"chirurgiens-dentistes.fr":true,"experts-comptables.fr":true,"geometre-expert.fr":true,"gouv.fr":true,"greta.fr":true,"huissier-justice.fr":true,"medecin.fr":true,"notaires.fr":true,"pharmacien.fr":true,"port.fr":true,"veterinaire.fr":true,"ga":true,"gb":true,"gd":true,"ge":true,"com.ge":true,"edu.ge":true,"gov.ge":true,"org.ge":true,"mil.ge":true,"net.ge":true,"pvt.ge":true,"gf":true,"gg":true,"co.gg":true,"net.gg":true,"org.gg":true,"gh":true,"com.gh":true,"edu.gh":true,"gov.gh":true,"org.gh":true,"mil.gh":true,"gi":true,"com.gi":true,"ltd.gi":true,"gov.gi":true,"mod.gi":true,"edu.gi":true,"org.gi":true,"gl":true,"co.gl":true,"com.gl":true,"edu.gl":true,"net.gl":true,"org.gl":true,"gm":true,"gn":true,"ac.gn":true,"com.gn":true,"edu.gn":true,"gov.gn":true,"org.gn":true,"net.gn":true,"gov":true,"gp":true,"com.gp":true,"net.gp":true,"mobi.gp":true,"edu.gp":true,"org.gp":true,"asso.gp":true,"gq":true,"gr":true,"com.gr":true,"edu.gr":true,"net.gr":true,"org.gr":true,"gov.gr":true,"gs":true,"gt":true,"com.gt":true,"edu.gt":true,"gob.gt":true,"ind.gt":true,"mil.gt":true,"net.gt":true,"org.gt":true,"*.gu":true,"gw":true,"gy":true,"co.gy":true,"com.gy":true,"net.gy":true,"hk":true,"com.hk":true,"edu.hk":true,"gov.hk":true,"idv.hk":true,"net.hk":true,"org.hk":true,"xn--55qx5d.hk":true,"xn--wcvs22d.hk":true,"xn--lcvr32d.hk":true,"xn--mxtq1m.hk":true,"xn--gmqw5a.hk":true,"xn--ciqpn.hk":true,"xn--gmq050i.hk":true,"xn--zf0avx.hk":true,"xn--io0a7i.hk":true,"xn--mk0axi.hk":true,"xn--od0alg.hk":true,"xn--od0aq3b.hk":true,"xn--tn0ag.hk":true,"xn--uc0atv.hk":true,"xn--uc0ay4a.hk":true,"hm":true,"hn":true,"com.hn":true,"edu.hn":true,"org.hn":true,"net.hn":true,"mil.hn":true,"gob.hn":true,"hr":true,"iz.hr":true,"from.hr":true,"name.hr":true,"com.hr":true,"ht":true,"com.ht":true,"shop.ht":true,"firm.ht":true,"info.ht":true,"adult.ht":true,"net.ht":true,"pro.ht":true,"org.ht":true,"med.ht":true,"art.ht":true,"coop.ht":true,"pol.ht":true,"asso.ht":true,"edu.ht":true,"rel.ht":true,"gouv.ht":true,"perso.ht":true,"hu":true,"co.hu":true,"info.hu":true,"org.hu":true,"priv.hu":true,"sport.hu":true,"tm.hu":true,"2000.hu":true,"agrar.hu":true,"bolt.hu":true,"casino.hu":true,"city.hu":true,"erotica.hu":true,"erotika.hu":true,"film.hu":true,"forum.hu":true,"games.hu":true,"hotel.hu":true,"ingatlan.hu":true,"jogasz.hu":true,"konyvelo.hu":true,"lakas.hu":true,"media.hu":true,"news.hu":true,"reklam.hu":true,"sex.hu":true,"shop.hu":true,"suli.hu":true,"szex.hu":true,"tozsde.hu":true,"utazas.hu":true,"video.hu":true,"id":true,"ac.id":true,"biz.id":true,"co.id":true,"desa.id":true,"go.id":true,"mil.id":true,"my.id":true,"net.id":true,"or.id":true,"sch.id":true,"web.id":true,"ie":true,"gov.ie":true,"il":true,"ac.il":true,"co.il":true,"gov.il":true,"idf.il":true,"k12.il":true,"muni.il":true,"net.il":true,"org.il":true,"im":true,"ac.im":true,"co.im":true,"com.im":true,"ltd.co.im":true,"net.im":true,"org.im":true,"plc.co.im":true,"tt.im":true,"tv.im":true,"in":true,"co.in":true,"firm.in":true,"net.in":true,"org.in":true,"gen.in":true,"ind.in":true,"nic.in":true,"ac.in":true,"edu.in":true,"res.in":true,"gov.in":true,"mil.in":true,"info":true,"int":true,"eu.int":true,"io":true,"com.io":true,"iq":true,"gov.iq":true,"edu.iq":true,"mil.iq":true,"com.iq":true,"org.iq":true,"net.iq":true,"ir":true,"ac.ir":true,"co.ir":true,"gov.ir":true,"id.ir":true,"net.ir":true,"org.ir":true,"sch.ir":true,"xn--mgba3a4f16a.ir":true,"xn--mgba3a4fra.ir":true,"is":true,"net.is":true,"com.is":true,"edu.is":true,"gov.is":true,"org.is":true,"int.is":true,"it":true,"gov.it":true,"edu.it":true,"abr.it":true,"abruzzo.it":true,"aosta-valley.it":true,"aostavalley.it":true,"bas.it":true,"basilicata.it":true,"cal.it":true,"calabria.it":true,"cam.it":true,"campania.it":true,"emilia-romagna.it":true,"emiliaromagna.it":true,"emr.it":true,"friuli-v-giulia.it":true,"friuli-ve-giulia.it":true,"friuli-vegiulia.it":true,"friuli-venezia-giulia.it":true,"friuli-veneziagiulia.it":true,"friuli-vgiulia.it":true,"friuliv-giulia.it":true,"friulive-giulia.it":true,"friulivegiulia.it":true,"friulivenezia-giulia.it":true,"friuliveneziagiulia.it":true,"friulivgiulia.it":true,"fvg.it":true,"laz.it":true,"lazio.it":true,"lig.it":true,"liguria.it":true,"lom.it":true,"lombardia.it":true,"lombardy.it":true,"lucania.it":true,"mar.it":true,"marche.it":true,"mol.it":true,"molise.it":true,"piedmont.it":true,"piemonte.it":true,"pmn.it":true,"pug.it":true,"puglia.it":true,"sar.it":true,"sardegna.it":true,"sardinia.it":true,"sic.it":true,"sicilia.it":true,"sicily.it":true,"taa.it":true,"tos.it":true,"toscana.it":true,"trentino-a-adige.it":true,"trentino-aadige.it":true,"trentino-alto-adige.it":true,"trentino-altoadige.it":true,"trentino-s-tirol.it":true,"trentino-stirol.it":true,"trentino-sud-tirol.it":true,"trentino-sudtirol.it":true,"trentino-sued-tirol.it":true,"trentino-suedtirol.it":true,"trentinoa-adige.it":true,"trentinoaadige.it":true,"trentinoalto-adige.it":true,"trentinoaltoadige.it":true,"trentinos-tirol.it":true,"trentinostirol.it":true,"trentinosud-tirol.it":true,"trentinosudtirol.it":true,"trentinosued-tirol.it":true,"trentinosuedtirol.it":true,"tuscany.it":true,"umb.it":true,"umbria.it":true,"val-d-aosta.it":true,"val-daosta.it":true,"vald-aosta.it":true,"valdaosta.it":true,"valle-aosta.it":true,"valle-d-aosta.it":true,"valle-daosta.it":true,"valleaosta.it":true,"valled-aosta.it":true,"valledaosta.it":true,"vallee-aoste.it":true,"valleeaoste.it":true,"vao.it":true,"vda.it":true,"ven.it":true,"veneto.it":true,"ag.it":true,"agrigento.it":true,"al.it":true,"alessandria.it":true,"alto-adige.it":true,"altoadige.it":true,"an.it":true,"ancona.it":true,"andria-barletta-trani.it":true,"andria-trani-barletta.it":true,"andriabarlettatrani.it":true,"andriatranibarletta.it":true,"ao.it":true,"aosta.it":true,"aoste.it":true,"ap.it":true,"aq.it":true,"aquila.it":true,"ar.it":true,"arezzo.it":true,"ascoli-piceno.it":true,"ascolipiceno.it":true,"asti.it":true,"at.it":true,"av.it":true,"avellino.it":true,"ba.it":true,"balsan.it":true,"bari.it":true,"barletta-trani-andria.it":true,"barlettatraniandria.it":true,"belluno.it":true,"benevento.it":true,"bergamo.it":true,"bg.it":true,"bi.it":true,"biella.it":true,"bl.it":true,"bn.it":true,"bo.it":true,"bologna.it":true,"bolzano.it":true,"bozen.it":true,"br.it":true,"brescia.it":true,"brindisi.it":true,"bs.it":true,"bt.it":true,"bz.it":true,"ca.it":true,"cagliari.it":true,"caltanissetta.it":true,"campidano-medio.it":true,"campidanomedio.it":true,"campobasso.it":true,"carbonia-iglesias.it":true,"carboniaiglesias.it":true,"carrara-massa.it":true,"carraramassa.it":true,"caserta.it":true,"catania.it":true,"catanzaro.it":true,"cb.it":true,"ce.it":true,"cesena-forli.it":true,"cesenaforli.it":true,"ch.it":true,"chieti.it":true,"ci.it":true,"cl.it":true,"cn.it":true,"co.it":true,"como.it":true,"cosenza.it":true,"cr.it":true,"cremona.it":true,"crotone.it":true,"cs.it":true,"ct.it":true,"cuneo.it":true,"cz.it":true,"dell-ogliastra.it":true,"dellogliastra.it":true,"en.it":true,"enna.it":true,"fc.it":true,"fe.it":true,"fermo.it":true,"ferrara.it":true,"fg.it":true,"fi.it":true,"firenze.it":true,"florence.it":true,"fm.it":true,"foggia.it":true,"forli-cesena.it":true,"forlicesena.it":true,"fr.it":true,"frosinone.it":true,"ge.it":true,"genoa.it":true,"genova.it":true,"go.it":true,"gorizia.it":true,"gr.it":true,"grosseto.it":true,"iglesias-carbonia.it":true,"iglesiascarbonia.it":true,"im.it":true,"imperia.it":true,"is.it":true,"isernia.it":true,"kr.it":true,"la-spezia.it":true,"laquila.it":true,"laspezia.it":true,"latina.it":true,"lc.it":true,"le.it":true,"lecce.it":true,"lecco.it":true,"li.it":true,"livorno.it":true,"lo.it":true,"lodi.it":true,"lt.it":true,"lu.it":true,"lucca.it":true,"macerata.it":true,"mantova.it":true,"massa-carrara.it":true,"massacarrara.it":true,"matera.it":true,"mb.it":true,"mc.it":true,"me.it":true,"medio-campidano.it":true,"mediocampidano.it":true,"messina.it":true,"mi.it":true,"milan.it":true,"milano.it":true,"mn.it":true,"mo.it":true,"modena.it":true,"monza-brianza.it":true,"monza-e-della-brianza.it":true,"monza.it":true,"monzabrianza.it":true,"monzaebrianza.it":true,"monzaedellabrianza.it":true,"ms.it":true,"mt.it":true,"na.it":true,"naples.it":true,"napoli.it":true,"no.it":true,"novara.it":true,"nu.it":true,"nuoro.it":true,"og.it":true,"ogliastra.it":true,"olbia-tempio.it":true,"olbiatempio.it":true,"or.it":true,"oristano.it":true,"ot.it":true,"pa.it":true,"padova.it":true,"padua.it":true,"palermo.it":true,"parma.it":true,"pavia.it":true,"pc.it":true,"pd.it":true,"pe.it":true,"perugia.it":true,"pesaro-urbino.it":true,"pesarourbino.it":true,"pescara.it":true,"pg.it":true,"pi.it":true,"piacenza.it":true,"pisa.it":true,"pistoia.it":true,"pn.it":true,"po.it":true,"pordenone.it":true,"potenza.it":true,"pr.it":true,"prato.it":true,"pt.it":true,"pu.it":true,"pv.it":true,"pz.it":true,"ra.it":true,"ragusa.it":true,"ravenna.it":true,"rc.it":true,"re.it":true,"reggio-calabria.it":true,"reggio-emilia.it":true,"reggiocalabria.it":true,"reggioemilia.it":true,"rg.it":true,"ri.it":true,"rieti.it":true,"rimini.it":true,"rm.it":true,"rn.it":true,"ro.it":true,"roma.it":true,"rome.it":true,"rovigo.it":true,"sa.it":true,"salerno.it":true,"sassari.it":true,"savona.it":true,"si.it":true,"siena.it":true,"siracusa.it":true,"so.it":true,"sondrio.it":true,"sp.it":true,"sr.it":true,"ss.it":true,"suedtirol.it":true,"sv.it":true,"ta.it":true,"taranto.it":true,"te.it":true,"tempio-olbia.it":true,"tempioolbia.it":true,"teramo.it":true,"terni.it":true,"tn.it":true,"to.it":true,"torino.it":true,"tp.it":true,"tr.it":true,"trani-andria-barletta.it":true,"trani-barletta-andria.it":true,"traniandriabarletta.it":true,"tranibarlettaandria.it":true,"trapani.it":true,"trentino.it":true,"trento.it":true,"treviso.it":true,"trieste.it":true,"ts.it":true,"turin.it":true,"tv.it":true,"ud.it":true,"udine.it":true,"urbino-pesaro.it":true,"urbinopesaro.it":true,"va.it":true,"varese.it":true,"vb.it":true,"vc.it":true,"ve.it":true,"venezia.it":true,"venice.it":true,"verbania.it":true,"vercelli.it":true,"verona.it":true,"vi.it":true,"vibo-valentia.it":true,"vibovalentia.it":true,"vicenza.it":true,"viterbo.it":true,"vr.it":true,"vs.it":true,"vt.it":true,"vv.it":true,"je":true,"co.je":true,"net.je":true,"org.je":true,"*.jm":true,"jo":true,"com.jo":true,"org.jo":true,"net.jo":true,"edu.jo":true,"sch.jo":true,"gov.jo":true,"mil.jo":true,"name.jo":true,"jobs":true,"jp":true,"ac.jp":true,"ad.jp":true,"co.jp":true,"ed.jp":true,"go.jp":true,"gr.jp":true,"lg.jp":true,"ne.jp":true,"or.jp":true,"aichi.jp":true,"akita.jp":true,"aomori.jp":true,"chiba.jp":true,"ehime.jp":true,"fukui.jp":true,"fukuoka.jp":true,"fukushima.jp":true,"gifu.jp":true,"gunma.jp":true,"hiroshima.jp":true,"hokkaido.jp":true,"hyogo.jp":true,"ibaraki.jp":true,"ishikawa.jp":true,"iwate.jp":true,"kagawa.jp":true,"kagoshima.jp":true,"kanagawa.jp":true,"kochi.jp":true,"kumamoto.jp":true,"kyoto.jp":true,"mie.jp":true,"miyagi.jp":true,"miyazaki.jp":true,"nagano.jp":true,"nagasaki.jp":true,"nara.jp":true,"niigata.jp":true,"oita.jp":true,"okayama.jp":true,"okinawa.jp":true,"osaka.jp":true,"saga.jp":true,"saitama.jp":true,"shiga.jp":true,"shimane.jp":true,"shizuoka.jp":true,"tochigi.jp":true,"tokushima.jp":true,"tokyo.jp":true,"tottori.jp":true,"toyama.jp":true,"wakayama.jp":true,"yamagata.jp":true,"yamaguchi.jp":true,"yamanashi.jp":true,"xn--4pvxs.jp":true,"xn--vgu402c.jp":true,"xn--c3s14m.jp":true,"xn--f6qx53a.jp":true,"xn--8pvr4u.jp":true,"xn--uist22h.jp":true,"xn--djrs72d6uy.jp":true,"xn--mkru45i.jp":true,"xn--0trq7p7nn.jp":true,"xn--8ltr62k.jp":true,"xn--2m4a15e.jp":true,"xn--efvn9s.jp":true,"xn--32vp30h.jp":true,"xn--4it797k.jp":true,"xn--1lqs71d.jp":true,"xn--5rtp49c.jp":true,"xn--5js045d.jp":true,"xn--ehqz56n.jp":true,"xn--1lqs03n.jp":true,"xn--qqqt11m.jp":true,"xn--kbrq7o.jp":true,"xn--pssu33l.jp":true,"xn--ntsq17g.jp":true,"xn--uisz3g.jp":true,"xn--6btw5a.jp":true,"xn--1ctwo.jp":true,"xn--6orx2r.jp":true,"xn--rht61e.jp":true,"xn--rht27z.jp":true,"xn--djty4k.jp":true,"xn--nit225k.jp":true,"xn--rht3d.jp":true,"xn--klty5x.jp":true,"xn--kltx9a.jp":true,"xn--kltp7d.jp":true,"xn--uuwu58a.jp":true,"xn--zbx025d.jp":true,"xn--ntso0iqx3a.jp":true,"xn--elqq16h.jp":true,"xn--4it168d.jp":true,"xn--klt787d.jp":true,"xn--rny31h.jp":true,"xn--7t0a264c.jp":true,"xn--5rtq34k.jp":true,"xn--k7yn95e.jp":true,"xn--tor131o.jp":true,"xn--d5qv7z876c.jp":true,"*.kawasaki.jp":true,"*.kitakyushu.jp":true,"*.kobe.jp":true,"*.nagoya.jp":true,"*.sapporo.jp":true,"*.sendai.jp":true,"*.yokohama.jp":true,"city.kawasaki.jp":false,"city.kitakyushu.jp":false,"city.kobe.jp":false,"city.nagoya.jp":false,"city.sapporo.jp":false,"city.sendai.jp":false,"city.yokohama.jp":false,"aisai.aichi.jp":true,"ama.aichi.jp":true,"anjo.aichi.jp":true,"asuke.aichi.jp":true,"chiryu.aichi.jp":true,"chita.aichi.jp":true,"fuso.aichi.jp":true,"gamagori.aichi.jp":true,"handa.aichi.jp":true,"hazu.aichi.jp":true,"hekinan.aichi.jp":true,"higashiura.aichi.jp":true,"ichinomiya.aichi.jp":true,"inazawa.aichi.jp":true,"inuyama.aichi.jp":true,"isshiki.aichi.jp":true,"iwakura.aichi.jp":true,"kanie.aichi.jp":true,"kariya.aichi.jp":true,"kasugai.aichi.jp":true,"kira.aichi.jp":true,"kiyosu.aichi.jp":true,"komaki.aichi.jp":true,"konan.aichi.jp":true,"kota.aichi.jp":true,"mihama.aichi.jp":true,"miyoshi.aichi.jp":true,"nishio.aichi.jp":true,"nisshin.aichi.jp":true,"obu.aichi.jp":true,"oguchi.aichi.jp":true,"oharu.aichi.jp":true,"okazaki.aichi.jp":true,"owariasahi.aichi.jp":true,"seto.aichi.jp":true,"shikatsu.aichi.jp":true,"shinshiro.aichi.jp":true,"shitara.aichi.jp":true,"tahara.aichi.jp":true,"takahama.aichi.jp":true,"tobishima.aichi.jp":true,"toei.aichi.jp":true,"togo.aichi.jp":true,"tokai.aichi.jp":true,"tokoname.aichi.jp":true,"toyoake.aichi.jp":true,"toyohashi.aichi.jp":true,"toyokawa.aichi.jp":true,"toyone.aichi.jp":true,"toyota.aichi.jp":true,"tsushima.aichi.jp":true,"yatomi.aichi.jp":true,"akita.akita.jp":true,"daisen.akita.jp":true,"fujisato.akita.jp":true,"gojome.akita.jp":true,"hachirogata.akita.jp":true,"happou.akita.jp":true,"higashinaruse.akita.jp":true,"honjo.akita.jp":true,"honjyo.akita.jp":true,"ikawa.akita.jp":true,"kamikoani.akita.jp":true,"kamioka.akita.jp":true,"katagami.akita.jp":true,"kazuno.akita.jp":true,"kitaakita.akita.jp":true,"kosaka.akita.jp":true,"kyowa.akita.jp":true,"misato.akita.jp":true,"mitane.akita.jp":true,"moriyoshi.akita.jp":true,"nikaho.akita.jp":true,"noshiro.akita.jp":true,"odate.akita.jp":true,"oga.akita.jp":true,"ogata.akita.jp":true,"semboku.akita.jp":true,"yokote.akita.jp":true,"yurihonjo.akita.jp":true,"aomori.aomori.jp":true,"gonohe.aomori.jp":true,"hachinohe.aomori.jp":true,"hashikami.aomori.jp":true,"hiranai.aomori.jp":true,"hirosaki.aomori.jp":true,"itayanagi.aomori.jp":true,"kuroishi.aomori.jp":true,"misawa.aomori.jp":true,"mutsu.aomori.jp":true,"nakadomari.aomori.jp":true,"noheji.aomori.jp":true,"oirase.aomori.jp":true,"owani.aomori.jp":true,"rokunohe.aomori.jp":true,"sannohe.aomori.jp":true,"shichinohe.aomori.jp":true,"shingo.aomori.jp":true,"takko.aomori.jp":true,"towada.aomori.jp":true,"tsugaru.aomori.jp":true,"tsuruta.aomori.jp":true,"abiko.chiba.jp":true,"asahi.chiba.jp":true,"chonan.chiba.jp":true,"chosei.chiba.jp":true,"choshi.chiba.jp":true,"chuo.chiba.jp":true,"funabashi.chiba.jp":true,"futtsu.chiba.jp":true,"hanamigawa.chiba.jp":true,"ichihara.chiba.jp":true,"ichikawa.chiba.jp":true,"ichinomiya.chiba.jp":true,"inzai.chiba.jp":true,"isumi.chiba.jp":true,"kamagaya.chiba.jp":true,"kamogawa.chiba.jp":true,"kashiwa.chiba.jp":true,"katori.chiba.jp":true,"katsuura.chiba.jp":true,"kimitsu.chiba.jp":true,"kisarazu.chiba.jp":true,"kozaki.chiba.jp":true,"kujukuri.chiba.jp":true,"kyonan.chiba.jp":true,"matsudo.chiba.jp":true,"midori.chiba.jp":true,"mihama.chiba.jp":true,"minamiboso.chiba.jp":true,"mobara.chiba.jp":true,"mutsuzawa.chiba.jp":true,"nagara.chiba.jp":true,"nagareyama.chiba.jp":true,"narashino.chiba.jp":true,"narita.chiba.jp":true,"noda.chiba.jp":true,"oamishirasato.chiba.jp":true,"omigawa.chiba.jp":true,"onjuku.chiba.jp":true,"otaki.chiba.jp":true,"sakae.chiba.jp":true,"sakura.chiba.jp":true,"shimofusa.chiba.jp":true,"shirako.chiba.jp":true,"shiroi.chiba.jp":true,"shisui.chiba.jp":true,"sodegaura.chiba.jp":true,"sosa.chiba.jp":true,"tako.chiba.jp":true,"tateyama.chiba.jp":true,"togane.chiba.jp":true,"tohnosho.chiba.jp":true,"tomisato.chiba.jp":true,"urayasu.chiba.jp":true,"yachimata.chiba.jp":true,"yachiyo.chiba.jp":true,"yokaichiba.chiba.jp":true,"yokoshibahikari.chiba.jp":true,"yotsukaido.chiba.jp":true,"ainan.ehime.jp":true,"honai.ehime.jp":true,"ikata.ehime.jp":true,"imabari.ehime.jp":true,"iyo.ehime.jp":true,"kamijima.ehime.jp":true,"kihoku.ehime.jp":true,"kumakogen.ehime.jp":true,"masaki.ehime.jp":true,"matsuno.ehime.jp":true,"matsuyama.ehime.jp":true,"namikata.ehime.jp":true,"niihama.ehime.jp":true,"ozu.ehime.jp":true,"saijo.ehime.jp":true,"seiyo.ehime.jp":true,"shikokuchuo.ehime.jp":true,"tobe.ehime.jp":true,"toon.ehime.jp":true,"uchiko.ehime.jp":true,"uwajima.ehime.jp":true,"yawatahama.ehime.jp":true,"echizen.fukui.jp":true,"eiheiji.fukui.jp":true,"fukui.fukui.jp":true,"ikeda.fukui.jp":true,"katsuyama.fukui.jp":true,"mihama.fukui.jp":true,"minamiechizen.fukui.jp":true,"obama.fukui.jp":true,"ohi.fukui.jp":true,"ono.fukui.jp":true,"sabae.fukui.jp":true,"sakai.fukui.jp":true,"takahama.fukui.jp":true,"tsuruga.fukui.jp":true,"wakasa.fukui.jp":true,"ashiya.fukuoka.jp":true,"buzen.fukuoka.jp":true,"chikugo.fukuoka.jp":true,"chikuho.fukuoka.jp":true,"chikujo.fukuoka.jp":true,"chikushino.fukuoka.jp":true,"chikuzen.fukuoka.jp":true,"chuo.fukuoka.jp":true,"dazaifu.fukuoka.jp":true,"fukuchi.fukuoka.jp":true,"hakata.fukuoka.jp":true,"higashi.fukuoka.jp":true,"hirokawa.fukuoka.jp":true,"hisayama.fukuoka.jp":true,"iizuka.fukuoka.jp":true,"inatsuki.fukuoka.jp":true,"kaho.fukuoka.jp":true,"kasuga.fukuoka.jp":true,"kasuya.fukuoka.jp":true,"kawara.fukuoka.jp":true,"keisen.fukuoka.jp":true,"koga.fukuoka.jp":true,"kurate.fukuoka.jp":true,"kurogi.fukuoka.jp":true,"kurume.fukuoka.jp":true,"minami.fukuoka.jp":true,"miyako.fukuoka.jp":true,"miyama.fukuoka.jp":true,"miyawaka.fukuoka.jp":true,"mizumaki.fukuoka.jp":true,"munakata.fukuoka.jp":true,"nakagawa.fukuoka.jp":true,"nakama.fukuoka.jp":true,"nishi.fukuoka.jp":true,"nogata.fukuoka.jp":true,"ogori.fukuoka.jp":true,"okagaki.fukuoka.jp":true,"okawa.fukuoka.jp":true,"oki.fukuoka.jp":true,"omuta.fukuoka.jp":true,"onga.fukuoka.jp":true,"onojo.fukuoka.jp":true,"oto.fukuoka.jp":true,"saigawa.fukuoka.jp":true,"sasaguri.fukuoka.jp":true,"shingu.fukuoka.jp":true,"shinyoshitomi.fukuoka.jp":true,"shonai.fukuoka.jp":true,"soeda.fukuoka.jp":true,"sue.fukuoka.jp":true,"tachiarai.fukuoka.jp":true,"tagawa.fukuoka.jp":true,"takata.fukuoka.jp":true,"toho.fukuoka.jp":true,"toyotsu.fukuoka.jp":true,"tsuiki.fukuoka.jp":true,"ukiha.fukuoka.jp":true,"umi.fukuoka.jp":true,"usui.fukuoka.jp":true,"yamada.fukuoka.jp":true,"yame.fukuoka.jp":true,"yanagawa.fukuoka.jp":true,"yukuhashi.fukuoka.jp":true,"aizubange.fukushima.jp":true,"aizumisato.fukushima.jp":true,"aizuwakamatsu.fukushima.jp":true,"asakawa.fukushima.jp":true,"bandai.fukushima.jp":true,"date.fukushima.jp":true,"fukushima.fukushima.jp":true,"furudono.fukushima.jp":true,"futaba.fukushima.jp":true,"hanawa.fukushima.jp":true,"higashi.fukushima.jp":true,"hirata.fukushima.jp":true,"hirono.fukushima.jp":true,"iitate.fukushima.jp":true,"inawashiro.fukushima.jp":true,"ishikawa.fukushima.jp":true,"iwaki.fukushima.jp":true,"izumizaki.fukushima.jp":true,"kagamiishi.fukushima.jp":true,"kaneyama.fukushima.jp":true,"kawamata.fukushima.jp":true,"kitakata.fukushima.jp":true,"kitashiobara.fukushima.jp":true,"koori.fukushima.jp":true,"koriyama.fukushima.jp":true,"kunimi.fukushima.jp":true,"miharu.fukushima.jp":true,"mishima.fukushima.jp":true,"namie.fukushima.jp":true,"nango.fukushima.jp":true,"nishiaizu.fukushima.jp":true,"nishigo.fukushima.jp":true,"okuma.fukushima.jp":true,"omotego.fukushima.jp":true,"ono.fukushima.jp":true,"otama.fukushima.jp":true,"samegawa.fukushima.jp":true,"shimogo.fukushima.jp":true,"shirakawa.fukushima.jp":true,"showa.fukushima.jp":true,"soma.fukushima.jp":true,"sukagawa.fukushima.jp":true,"taishin.fukushima.jp":true,"tamakawa.fukushima.jp":true,"tanagura.fukushima.jp":true,"tenei.fukushima.jp":true,"yabuki.fukushima.jp":true,"yamato.fukushima.jp":true,"yamatsuri.fukushima.jp":true,"yanaizu.fukushima.jp":true,"yugawa.fukushima.jp":true,"anpachi.gifu.jp":true,"ena.gifu.jp":true,"gifu.gifu.jp":true,"ginan.gifu.jp":true,"godo.gifu.jp":true,"gujo.gifu.jp":true,"hashima.gifu.jp":true,"hichiso.gifu.jp":true,"hida.gifu.jp":true,"higashishirakawa.gifu.jp":true,"ibigawa.gifu.jp":true,"ikeda.gifu.jp":true,"kakamigahara.gifu.jp":true,"kani.gifu.jp":true,"kasahara.gifu.jp":true,"kasamatsu.gifu.jp":true,"kawaue.gifu.jp":true,"kitagata.gifu.jp":true,"mino.gifu.jp":true,"minokamo.gifu.jp":true,"mitake.gifu.jp":true,"mizunami.gifu.jp":true,"motosu.gifu.jp":true,"nakatsugawa.gifu.jp":true,"ogaki.gifu.jp":true,"sakahogi.gifu.jp":true,"seki.gifu.jp":true,"sekigahara.gifu.jp":true,"shirakawa.gifu.jp":true,"tajimi.gifu.jp":true,"takayama.gifu.jp":true,"tarui.gifu.jp":true,"toki.gifu.jp":true,"tomika.gifu.jp":true,"wanouchi.gifu.jp":true,"yamagata.gifu.jp":true,"yaotsu.gifu.jp":true,"yoro.gifu.jp":true,"annaka.gunma.jp":true,"chiyoda.gunma.jp":true,"fujioka.gunma.jp":true,"higashiagatsuma.gunma.jp":true,"isesaki.gunma.jp":true,"itakura.gunma.jp":true,"kanna.gunma.jp":true,"kanra.gunma.jp":true,"katashina.gunma.jp":true,"kawaba.gunma.jp":true,"kiryu.gunma.jp":true,"kusatsu.gunma.jp":true,"maebashi.gunma.jp":true,"meiwa.gunma.jp":true,"midori.gunma.jp":true,"minakami.gunma.jp":true,"naganohara.gunma.jp":true,"nakanojo.gunma.jp":true,"nanmoku.gunma.jp":true,"numata.gunma.jp":true,"oizumi.gunma.jp":true,"ora.gunma.jp":true,"ota.gunma.jp":true,"shibukawa.gunma.jp":true,"shimonita.gunma.jp":true,"shinto.gunma.jp":true,"showa.gunma.jp":true,"takasaki.gunma.jp":true,"takayama.gunma.jp":true,"tamamura.gunma.jp":true,"tatebayashi.gunma.jp":true,"tomioka.gunma.jp":true,"tsukiyono.gunma.jp":true,"tsumagoi.gunma.jp":true,"ueno.gunma.jp":true,"yoshioka.gunma.jp":true,"asaminami.hiroshima.jp":true,"daiwa.hiroshima.jp":true,"etajima.hiroshima.jp":true,"fuchu.hiroshima.jp":true,"fukuyama.hiroshima.jp":true,"hatsukaichi.hiroshima.jp":true,"higashihiroshima.hiroshima.jp":true,"hongo.hiroshima.jp":true,"jinsekikogen.hiroshima.jp":true,"kaita.hiroshima.jp":true,"kui.hiroshima.jp":true,"kumano.hiroshima.jp":true,"kure.hiroshima.jp":true,"mihara.hiroshima.jp":true,"miyoshi.hiroshima.jp":true,"naka.hiroshima.jp":true,"onomichi.hiroshima.jp":true,"osakikamijima.hiroshima.jp":true,"otake.hiroshima.jp":true,"saka.hiroshima.jp":true,"sera.hiroshima.jp":true,"seranishi.hiroshima.jp":true,"shinichi.hiroshima.jp":true,"shobara.hiroshima.jp":true,"takehara.hiroshima.jp":true,"abashiri.hokkaido.jp":true,"abira.hokkaido.jp":true,"aibetsu.hokkaido.jp":true,"akabira.hokkaido.jp":true,"akkeshi.hokkaido.jp":true,"asahikawa.hokkaido.jp":true,"ashibetsu.hokkaido.jp":true,"ashoro.hokkaido.jp":true,"assabu.hokkaido.jp":true,"atsuma.hokkaido.jp":true,"bibai.hokkaido.jp":true,"biei.hokkaido.jp":true,"bifuka.hokkaido.jp":true,"bihoro.hokkaido.jp":true,"biratori.hokkaido.jp":true,"chippubetsu.hokkaido.jp":true,"chitose.hokkaido.jp":true,"date.hokkaido.jp":true,"ebetsu.hokkaido.jp":true,"embetsu.hokkaido.jp":true,"eniwa.hokkaido.jp":true,"erimo.hokkaido.jp":true,"esan.hokkaido.jp":true,"esashi.hokkaido.jp":true,"fukagawa.hokkaido.jp":true,"fukushima.hokkaido.jp":true,"furano.hokkaido.jp":true,"furubira.hokkaido.jp":true,"haboro.hokkaido.jp":true,"hakodate.hokkaido.jp":true,"hamatonbetsu.hokkaido.jp":true,"hidaka.hokkaido.jp":true,"higashikagura.hokkaido.jp":true,"higashikawa.hokkaido.jp":true,"hiroo.hokkaido.jp":true,"hokuryu.hokkaido.jp":true,"hokuto.hokkaido.jp":true,"honbetsu.hokkaido.jp":true,"horokanai.hokkaido.jp":true,"horonobe.hokkaido.jp":true,"ikeda.hokkaido.jp":true,"imakane.hokkaido.jp":true,"ishikari.hokkaido.jp":true,"iwamizawa.hokkaido.jp":true,"iwanai.hokkaido.jp":true,"kamifurano.hokkaido.jp":true,"kamikawa.hokkaido.jp":true,"kamishihoro.hokkaido.jp":true,"kamisunagawa.hokkaido.jp":true,"kamoenai.hokkaido.jp":true,"kayabe.hokkaido.jp":true,"kembuchi.hokkaido.jp":true,"kikonai.hokkaido.jp":true,"kimobetsu.hokkaido.jp":true,"kitahiroshima.hokkaido.jp":true,"kitami.hokkaido.jp":true,"kiyosato.hokkaido.jp":true,"koshimizu.hokkaido.jp":true,"kunneppu.hokkaido.jp":true,"kuriyama.hokkaido.jp":true,"kuromatsunai.hokkaido.jp":true,"kushiro.hokkaido.jp":true,"kutchan.hokkaido.jp":true,"kyowa.hokkaido.jp":true,"mashike.hokkaido.jp":true,"matsumae.hokkaido.jp":true,"mikasa.hokkaido.jp":true,"minamifurano.hokkaido.jp":true,"mombetsu.hokkaido.jp":true,"moseushi.hokkaido.jp":true,"mukawa.hokkaido.jp":true,"muroran.hokkaido.jp":true,"naie.hokkaido.jp":true,"nakagawa.hokkaido.jp":true,"nakasatsunai.hokkaido.jp":true,"nakatombetsu.hokkaido.jp":true,"nanae.hokkaido.jp":true,"nanporo.hokkaido.jp":true,"nayoro.hokkaido.jp":true,"nemuro.hokkaido.jp":true,"niikappu.hokkaido.jp":true,"niki.hokkaido.jp":true,"nishiokoppe.hokkaido.jp":true,"noboribetsu.hokkaido.jp":true,"numata.hokkaido.jp":true,"obihiro.hokkaido.jp":true,"obira.hokkaido.jp":true,"oketo.hokkaido.jp":true,"okoppe.hokkaido.jp":true,"otaru.hokkaido.jp":true,"otobe.hokkaido.jp":true,"otofuke.hokkaido.jp":true,"otoineppu.hokkaido.jp":true,"oumu.hokkaido.jp":true,"ozora.hokkaido.jp":true,"pippu.hokkaido.jp":true,"rankoshi.hokkaido.jp":true,"rebun.hokkaido.jp":true,"rikubetsu.hokkaido.jp":true,"rishiri.hokkaido.jp":true,"rishirifuji.hokkaido.jp":true,"saroma.hokkaido.jp":true,"sarufutsu.hokkaido.jp":true,"shakotan.hokkaido.jp":true,"shari.hokkaido.jp":true,"shibecha.hokkaido.jp":true,"shibetsu.hokkaido.jp":true,"shikabe.hokkaido.jp":true,"shikaoi.hokkaido.jp":true,"shimamaki.hokkaido.jp":true,"shimizu.hokkaido.jp":true,"shimokawa.hokkaido.jp":true,"shinshinotsu.hokkaido.jp":true,"shintoku.hokkaido.jp":true,"shiranuka.hokkaido.jp":true,"shiraoi.hokkaido.jp":true,"shiriuchi.hokkaido.jp":true,"sobetsu.hokkaido.jp":true,"sunagawa.hokkaido.jp":true,"taiki.hokkaido.jp":true,"takasu.hokkaido.jp":true,"takikawa.hokkaido.jp":true,"takinoue.hokkaido.jp":true,"teshikaga.hokkaido.jp":true,"tobetsu.hokkaido.jp":true,"tohma.hokkaido.jp":true,"tomakomai.hokkaido.jp":true,"tomari.hokkaido.jp":true,"toya.hokkaido.jp":true,"toyako.hokkaido.jp":true,"toyotomi.hokkaido.jp":true,"toyoura.hokkaido.jp":true,"tsubetsu.hokkaido.jp":true,"tsukigata.hokkaido.jp":true,"urakawa.hokkaido.jp":true,"urausu.hokkaido.jp":true,"uryu.hokkaido.jp":true,"utashinai.hokkaido.jp":true,"wakkanai.hokkaido.jp":true,"wassamu.hokkaido.jp":true,"yakumo.hokkaido.jp":true,"yoichi.hokkaido.jp":true,"aioi.hyogo.jp":true,"akashi.hyogo.jp":true,"ako.hyogo.jp":true,"amagasaki.hyogo.jp":true,"aogaki.hyogo.jp":true,"asago.hyogo.jp":true,"ashiya.hyogo.jp":true,"awaji.hyogo.jp":true,"fukusaki.hyogo.jp":true,"goshiki.hyogo.jp":true,"harima.hyogo.jp":true,"himeji.hyogo.jp":true,"ichikawa.hyogo.jp":true,"inagawa.hyogo.jp":true,"itami.hyogo.jp":true,"kakogawa.hyogo.jp":true,"kamigori.hyogo.jp":true,"kamikawa.hyogo.jp":true,"kasai.hyogo.jp":true,"kasuga.hyogo.jp":true,"kawanishi.hyogo.jp":true,"miki.hyogo.jp":true,"minamiawaji.hyogo.jp":true,"nishinomiya.hyogo.jp":true,"nishiwaki.hyogo.jp":true,"ono.hyogo.jp":true,"sanda.hyogo.jp":true,"sannan.hyogo.jp":true,"sasayama.hyogo.jp":true,"sayo.hyogo.jp":true,"shingu.hyogo.jp":true,"shinonsen.hyogo.jp":true,"shiso.hyogo.jp":true,"sumoto.hyogo.jp":true,"taishi.hyogo.jp":true,"taka.hyogo.jp":true,"takarazuka.hyogo.jp":true,"takasago.hyogo.jp":true,"takino.hyogo.jp":true,"tamba.hyogo.jp":true,"tatsuno.hyogo.jp":true,"toyooka.hyogo.jp":true,"yabu.hyogo.jp":true,"yashiro.hyogo.jp":true,"yoka.hyogo.jp":true,"yokawa.hyogo.jp":true,"ami.ibaraki.jp":true,"asahi.ibaraki.jp":true,"bando.ibaraki.jp":true,"chikusei.ibaraki.jp":true,"daigo.ibaraki.jp":true,"fujishiro.ibaraki.jp":true,"hitachi.ibaraki.jp":true,"hitachinaka.ibaraki.jp":true,"hitachiomiya.ibaraki.jp":true,"hitachiota.ibaraki.jp":true,"ibaraki.ibaraki.jp":true,"ina.ibaraki.jp":true,"inashiki.ibaraki.jp":true,"itako.ibaraki.jp":true,"iwama.ibaraki.jp":true,"joso.ibaraki.jp":true,"kamisu.ibaraki.jp":true,"kasama.ibaraki.jp":true,"kashima.ibaraki.jp":true,"kasumigaura.ibaraki.jp":true,"koga.ibaraki.jp":true,"miho.ibaraki.jp":true,"mito.ibaraki.jp":true,"moriya.ibaraki.jp":true,"naka.ibaraki.jp":true,"namegata.ibaraki.jp":true,"oarai.ibaraki.jp":true,"ogawa.ibaraki.jp":true,"omitama.ibaraki.jp":true,"ryugasaki.ibaraki.jp":true,"sakai.ibaraki.jp":true,"sakuragawa.ibaraki.jp":true,"shimodate.ibaraki.jp":true,"shimotsuma.ibaraki.jp":true,"shirosato.ibaraki.jp":true,"sowa.ibaraki.jp":true,"suifu.ibaraki.jp":true,"takahagi.ibaraki.jp":true,"tamatsukuri.ibaraki.jp":true,"tokai.ibaraki.jp":true,"tomobe.ibaraki.jp":true,"tone.ibaraki.jp":true,"toride.ibaraki.jp":true,"tsuchiura.ibaraki.jp":true,"tsukuba.ibaraki.jp":true,"uchihara.ibaraki.jp":true,"ushiku.ibaraki.jp":true,"yachiyo.ibaraki.jp":true,"yamagata.ibaraki.jp":true,"yawara.ibaraki.jp":true,"yuki.ibaraki.jp":true,"anamizu.ishikawa.jp":true,"hakui.ishikawa.jp":true,"hakusan.ishikawa.jp":true,"kaga.ishikawa.jp":true,"kahoku.ishikawa.jp":true,"kanazawa.ishikawa.jp":true,"kawakita.ishikawa.jp":true,"komatsu.ishikawa.jp":true,"nakanoto.ishikawa.jp":true,"nanao.ishikawa.jp":true,"nomi.ishikawa.jp":true,"nonoichi.ishikawa.jp":true,"noto.ishikawa.jp":true,"shika.ishikawa.jp":true,"suzu.ishikawa.jp":true,"tsubata.ishikawa.jp":true,"tsurugi.ishikawa.jp":true,"uchinada.ishikawa.jp":true,"wajima.ishikawa.jp":true,"fudai.iwate.jp":true,"fujisawa.iwate.jp":true,"hanamaki.iwate.jp":true,"hiraizumi.iwate.jp":true,"hirono.iwate.jp":true,"ichinohe.iwate.jp":true,"ichinoseki.iwate.jp":true,"iwaizumi.iwate.jp":true,"iwate.iwate.jp":true,"joboji.iwate.jp":true,"kamaishi.iwate.jp":true,"kanegasaki.iwate.jp":true,"karumai.iwate.jp":true,"kawai.iwate.jp":true,"kitakami.iwate.jp":true,"kuji.iwate.jp":true,"kunohe.iwate.jp":true,"kuzumaki.iwate.jp":true,"miyako.iwate.jp":true,"mizusawa.iwate.jp":true,"morioka.iwate.jp":true,"ninohe.iwate.jp":true,"noda.iwate.jp":true,"ofunato.iwate.jp":true,"oshu.iwate.jp":true,"otsuchi.iwate.jp":true,"rikuzentakata.iwate.jp":true,"shiwa.iwate.jp":true,"shizukuishi.iwate.jp":true,"sumita.iwate.jp":true,"tanohata.iwate.jp":true,"tono.iwate.jp":true,"yahaba.iwate.jp":true,"yamada.iwate.jp":true,"ayagawa.kagawa.jp":true,"higashikagawa.kagawa.jp":true,"kanonji.kagawa.jp":true,"kotohira.kagawa.jp":true,"manno.kagawa.jp":true,"marugame.kagawa.jp":true,"mitoyo.kagawa.jp":true,"naoshima.kagawa.jp":true,"sanuki.kagawa.jp":true,"tadotsu.kagawa.jp":true,"takamatsu.kagawa.jp":true,"tonosho.kagawa.jp":true,"uchinomi.kagawa.jp":true,"utazu.kagawa.jp":true,"zentsuji.kagawa.jp":true,"akune.kagoshima.jp":true,"amami.kagoshima.jp":true,"hioki.kagoshima.jp":true,"isa.kagoshima.jp":true,"isen.kagoshima.jp":true,"izumi.kagoshima.jp":true,"kagoshima.kagoshima.jp":true,"kanoya.kagoshima.jp":true,"kawanabe.kagoshima.jp":true,"kinko.kagoshima.jp":true,"kouyama.kagoshima.jp":true,"makurazaki.kagoshima.jp":true,"matsumoto.kagoshima.jp":true,"minamitane.kagoshima.jp":true,"nakatane.kagoshima.jp":true,"nishinoomote.kagoshima.jp":true,"satsumasendai.kagoshima.jp":true,"soo.kagoshima.jp":true,"tarumizu.kagoshima.jp":true,"yusui.kagoshima.jp":true,"aikawa.kanagawa.jp":true,"atsugi.kanagawa.jp":true,"ayase.kanagawa.jp":true,"chigasaki.kanagawa.jp":true,"ebina.kanagawa.jp":true,"fujisawa.kanagawa.jp":true,"hadano.kanagawa.jp":true,"hakone.kanagawa.jp":true,"hiratsuka.kanagawa.jp":true,"isehara.kanagawa.jp":true,"kaisei.kanagawa.jp":true,"kamakura.kanagawa.jp":true,"kiyokawa.kanagawa.jp":true,"matsuda.kanagawa.jp":true,"minamiashigara.kanagawa.jp":true,"miura.kanagawa.jp":true,"nakai.kanagawa.jp":true,"ninomiya.kanagawa.jp":true,"odawara.kanagawa.jp":true,"oi.kanagawa.jp":true,"oiso.kanagawa.jp":true,"sagamihara.kanagawa.jp":true,"samukawa.kanagawa.jp":true,"tsukui.kanagawa.jp":true,"yamakita.kanagawa.jp":true,"yamato.kanagawa.jp":true,"yokosuka.kanagawa.jp":true,"yugawara.kanagawa.jp":true,"zama.kanagawa.jp":true,"zushi.kanagawa.jp":true,"aki.kochi.jp":true,"geisei.kochi.jp":true,"hidaka.kochi.jp":true,"higashitsuno.kochi.jp":true,"ino.kochi.jp":true,"kagami.kochi.jp":true,"kami.kochi.jp":true,"kitagawa.kochi.jp":true,"kochi.kochi.jp":true,"mihara.kochi.jp":true,"motoyama.kochi.jp":true,"muroto.kochi.jp":true,"nahari.kochi.jp":true,"nakamura.kochi.jp":true,"nankoku.kochi.jp":true,"nishitosa.kochi.jp":true,"niyodogawa.kochi.jp":true,"ochi.kochi.jp":true,"okawa.kochi.jp":true,"otoyo.kochi.jp":true,"otsuki.kochi.jp":true,"sakawa.kochi.jp":true,"sukumo.kochi.jp":true,"susaki.kochi.jp":true,"tosa.kochi.jp":true,"tosashimizu.kochi.jp":true,"toyo.kochi.jp":true,"tsuno.kochi.jp":true,"umaji.kochi.jp":true,"yasuda.kochi.jp":true,"yusuhara.kochi.jp":true,"amakusa.kumamoto.jp":true,"arao.kumamoto.jp":true,"aso.kumamoto.jp":true,"choyo.kumamoto.jp":true,"gyokuto.kumamoto.jp":true,"hitoyoshi.kumamoto.jp":true,"kamiamakusa.kumamoto.jp":true,"kashima.kumamoto.jp":true,"kikuchi.kumamoto.jp":true,"kosa.kumamoto.jp":true,"kumamoto.kumamoto.jp":true,"mashiki.kumamoto.jp":true,"mifune.kumamoto.jp":true,"minamata.kumamoto.jp":true,"minamioguni.kumamoto.jp":true,"nagasu.kumamoto.jp":true,"nishihara.kumamoto.jp":true,"oguni.kumamoto.jp":true,"ozu.kumamoto.jp":true,"sumoto.kumamoto.jp":true,"takamori.kumamoto.jp":true,"uki.kumamoto.jp":true,"uto.kumamoto.jp":true,"yamaga.kumamoto.jp":true,"yamato.kumamoto.jp":true,"yatsushiro.kumamoto.jp":true,"ayabe.kyoto.jp":true,"fukuchiyama.kyoto.jp":true,"higashiyama.kyoto.jp":true,"ide.kyoto.jp":true,"ine.kyoto.jp":true,"joyo.kyoto.jp":true,"kameoka.kyoto.jp":true,"kamo.kyoto.jp":true,"kita.kyoto.jp":true,"kizu.kyoto.jp":true,"kumiyama.kyoto.jp":true,"kyotamba.kyoto.jp":true,"kyotanabe.kyoto.jp":true,"kyotango.kyoto.jp":true,"maizuru.kyoto.jp":true,"minami.kyoto.jp":true,"minamiyamashiro.kyoto.jp":true,"miyazu.kyoto.jp":true,"muko.kyoto.jp":true,"nagaokakyo.kyoto.jp":true,"nakagyo.kyoto.jp":true,"nantan.kyoto.jp":true,"oyamazaki.kyoto.jp":true,"sakyo.kyoto.jp":true,"seika.kyoto.jp":true,"tanabe.kyoto.jp":true,"uji.kyoto.jp":true,"ujitawara.kyoto.jp":true,"wazuka.kyoto.jp":true,"yamashina.kyoto.jp":true,"yawata.kyoto.jp":true,"asahi.mie.jp":true,"inabe.mie.jp":true,"ise.mie.jp":true,"kameyama.mie.jp":true,"kawagoe.mie.jp":true,"kiho.mie.jp":true,"kisosaki.mie.jp":true,"kiwa.mie.jp":true,"komono.mie.jp":true,"kumano.mie.jp":true,"kuwana.mie.jp":true,"matsusaka.mie.jp":true,"meiwa.mie.jp":true,"mihama.mie.jp":true,"minamiise.mie.jp":true,"misugi.mie.jp":true,"miyama.mie.jp":true,"nabari.mie.jp":true,"shima.mie.jp":true,"suzuka.mie.jp":true,"tado.mie.jp":true,"taiki.mie.jp":true,"taki.mie.jp":true,"tamaki.mie.jp":true,"toba.mie.jp":true,"tsu.mie.jp":true,"udono.mie.jp":true,"ureshino.mie.jp":true,"watarai.mie.jp":true,"yokkaichi.mie.jp":true,"furukawa.miyagi.jp":true,"higashimatsushima.miyagi.jp":true,"ishinomaki.miyagi.jp":true,"iwanuma.miyagi.jp":true,"kakuda.miyagi.jp":true,"kami.miyagi.jp":true,"kawasaki.miyagi.jp":true,"kesennuma.miyagi.jp":true,"marumori.miyagi.jp":true,"matsushima.miyagi.jp":true,"minamisanriku.miyagi.jp":true,"misato.miyagi.jp":true,"murata.miyagi.jp":true,"natori.miyagi.jp":true,"ogawara.miyagi.jp":true,"ohira.miyagi.jp":true,"onagawa.miyagi.jp":true,"osaki.miyagi.jp":true,"rifu.miyagi.jp":true,"semine.miyagi.jp":true,"shibata.miyagi.jp":true,"shichikashuku.miyagi.jp":true,"shikama.miyagi.jp":true,"shiogama.miyagi.jp":true,"shiroishi.miyagi.jp":true,"tagajo.miyagi.jp":true,"taiwa.miyagi.jp":true,"tome.miyagi.jp":true,"tomiya.miyagi.jp":true,"wakuya.miyagi.jp":true,"watari.miyagi.jp":true,"yamamoto.miyagi.jp":true,"zao.miyagi.jp":true,"aya.miyazaki.jp":true,"ebino.miyazaki.jp":true,"gokase.miyazaki.jp":true,"hyuga.miyazaki.jp":true,"kadogawa.miyazaki.jp":true,"kawaminami.miyazaki.jp":true,"kijo.miyazaki.jp":true,"kitagawa.miyazaki.jp":true,"kitakata.miyazaki.jp":true,"kitaura.miyazaki.jp":true,"kobayashi.miyazaki.jp":true,"kunitomi.miyazaki.jp":true,"kushima.miyazaki.jp":true,"mimata.miyazaki.jp":true,"miyakonojo.miyazaki.jp":true,"miyazaki.miyazaki.jp":true,"morotsuka.miyazaki.jp":true,"nichinan.miyazaki.jp":true,"nishimera.miyazaki.jp":true,"nobeoka.miyazaki.jp":true,"saito.miyazaki.jp":true,"shiiba.miyazaki.jp":true,"shintomi.miyazaki.jp":true,"takaharu.miyazaki.jp":true,"takanabe.miyazaki.jp":true,"takazaki.miyazaki.jp":true,"tsuno.miyazaki.jp":true,"achi.nagano.jp":true,"agematsu.nagano.jp":true,"anan.nagano.jp":true,"aoki.nagano.jp":true,"asahi.nagano.jp":true,"azumino.nagano.jp":true,"chikuhoku.nagano.jp":true,"chikuma.nagano.jp":true,"chino.nagano.jp":true,"fujimi.nagano.jp":true,"hakuba.nagano.jp":true,"hara.nagano.jp":true,"hiraya.nagano.jp":true,"iida.nagano.jp":true,"iijima.nagano.jp":true,"iiyama.nagano.jp":true,"iizuna.nagano.jp":true,"ikeda.nagano.jp":true,"ikusaka.nagano.jp":true,"ina.nagano.jp":true,"karuizawa.nagano.jp":true,"kawakami.nagano.jp":true,"kiso.nagano.jp":true,"kisofukushima.nagano.jp":true,"kitaaiki.nagano.jp":true,"komagane.nagano.jp":true,"komoro.nagano.jp":true,"matsukawa.nagano.jp":true,"matsumoto.nagano.jp":true,"miasa.nagano.jp":true,"minamiaiki.nagano.jp":true,"minamimaki.nagano.jp":true,"minamiminowa.nagano.jp":true,"minowa.nagano.jp":true,"miyada.nagano.jp":true,"miyota.nagano.jp":true,"mochizuki.nagano.jp":true,"nagano.nagano.jp":true,"nagawa.nagano.jp":true,"nagiso.nagano.jp":true,"nakagawa.nagano.jp":true,"nakano.nagano.jp":true,"nozawaonsen.nagano.jp":true,"obuse.nagano.jp":true,"ogawa.nagano.jp":true,"okaya.nagano.jp":true,"omachi.nagano.jp":true,"omi.nagano.jp":true,"ookuwa.nagano.jp":true,"ooshika.nagano.jp":true,"otaki.nagano.jp":true,"otari.nagano.jp":true,"sakae.nagano.jp":true,"sakaki.nagano.jp":true,"saku.nagano.jp":true,"sakuho.nagano.jp":true,"shimosuwa.nagano.jp":true,"shinanomachi.nagano.jp":true,"shiojiri.nagano.jp":true,"suwa.nagano.jp":true,"suzaka.nagano.jp":true,"takagi.nagano.jp":true,"takamori.nagano.jp":true,"takayama.nagano.jp":true,"tateshina.nagano.jp":true,"tatsuno.nagano.jp":true,"togakushi.nagano.jp":true,"togura.nagano.jp":true,"tomi.nagano.jp":true,"ueda.nagano.jp":true,"wada.nagano.jp":true,"yamagata.nagano.jp":true,"yamanouchi.nagano.jp":true,"yasaka.nagano.jp":true,"yasuoka.nagano.jp":true,"chijiwa.nagasaki.jp":true,"futsu.nagasaki.jp":true,"goto.nagasaki.jp":true,"hasami.nagasaki.jp":true,"hirado.nagasaki.jp":true,"iki.nagasaki.jp":true,"isahaya.nagasaki.jp":true,"kawatana.nagasaki.jp":true,"kuchinotsu.nagasaki.jp":true,"matsuura.nagasaki.jp":true,"nagasaki.nagasaki.jp":true,"obama.nagasaki.jp":true,"omura.nagasaki.jp":true,"oseto.nagasaki.jp":true,"saikai.nagasaki.jp":true,"sasebo.nagasaki.jp":true,"seihi.nagasaki.jp":true,"shimabara.nagasaki.jp":true,"shinkamigoto.nagasaki.jp":true,"togitsu.nagasaki.jp":true,"tsushima.nagasaki.jp":true,"unzen.nagasaki.jp":true,"ando.nara.jp":true,"gose.nara.jp":true,"heguri.nara.jp":true,"higashiyoshino.nara.jp":true,"ikaruga.nara.jp":true,"ikoma.nara.jp":true,"kamikitayama.nara.jp":true,"kanmaki.nara.jp":true,"kashiba.nara.jp":true,"kashihara.nara.jp":true,"katsuragi.nara.jp":true,"kawai.nara.jp":true,"kawakami.nara.jp":true,"kawanishi.nara.jp":true,"koryo.nara.jp":true,"kurotaki.nara.jp":true,"mitsue.nara.jp":true,"miyake.nara.jp":true,"nara.nara.jp":true,"nosegawa.nara.jp":true,"oji.nara.jp":true,"ouda.nara.jp":true,"oyodo.nara.jp":true,"sakurai.nara.jp":true,"sango.nara.jp":true,"shimoichi.nara.jp":true,"shimokitayama.nara.jp":true,"shinjo.nara.jp":true,"soni.nara.jp":true,"takatori.nara.jp":true,"tawaramoto.nara.jp":true,"tenkawa.nara.jp":true,"tenri.nara.jp":true,"uda.nara.jp":true,"yamatokoriyama.nara.jp":true,"yamatotakada.nara.jp":true,"yamazoe.nara.jp":true,"yoshino.nara.jp":true,"aga.niigata.jp":true,"agano.niigata.jp":true,"gosen.niigata.jp":true,"itoigawa.niigata.jp":true,"izumozaki.niigata.jp":true,"joetsu.niigata.jp":true,"kamo.niigata.jp":true,"kariwa.niigata.jp":true,"kashiwazaki.niigata.jp":true,"minamiuonuma.niigata.jp":true,"mitsuke.niigata.jp":true,"muika.niigata.jp":true,"murakami.niigata.jp":true,"myoko.niigata.jp":true,"nagaoka.niigata.jp":true,"niigata.niigata.jp":true,"ojiya.niigata.jp":true,"omi.niigata.jp":true,"sado.niigata.jp":true,"sanjo.niigata.jp":true,"seiro.niigata.jp":true,"seirou.niigata.jp":true,"sekikawa.niigata.jp":true,"shibata.niigata.jp":true,"tagami.niigata.jp":true,"tainai.niigata.jp":true,"tochio.niigata.jp":true,"tokamachi.niigata.jp":true,"tsubame.niigata.jp":true,"tsunan.niigata.jp":true,"uonuma.niigata.jp":true,"yahiko.niigata.jp":true,"yoita.niigata.jp":true,"yuzawa.niigata.jp":true,"beppu.oita.jp":true,"bungoono.oita.jp":true,"bungotakada.oita.jp":true,"hasama.oita.jp":true,"hiji.oita.jp":true,"himeshima.oita.jp":true,"hita.oita.jp":true,"kamitsue.oita.jp":true,"kokonoe.oita.jp":true,"kuju.oita.jp":true,"kunisaki.oita.jp":true,"kusu.oita.jp":true,"oita.oita.jp":true,"saiki.oita.jp":true,"taketa.oita.jp":true,"tsukumi.oita.jp":true,"usa.oita.jp":true,"usuki.oita.jp":true,"yufu.oita.jp":true,"akaiwa.okayama.jp":true,"asakuchi.okayama.jp":true,"bizen.okayama.jp":true,"hayashima.okayama.jp":true,"ibara.okayama.jp":true,"kagamino.okayama.jp":true,"kasaoka.okayama.jp":true,"kibichuo.okayama.jp":true,"kumenan.okayama.jp":true,"kurashiki.okayama.jp":true,"maniwa.okayama.jp":true,"misaki.okayama.jp":true,"nagi.okayama.jp":true,"niimi.okayama.jp":true,"nishiawakura.okayama.jp":true,"okayama.okayama.jp":true,"satosho.okayama.jp":true,"setouchi.okayama.jp":true,"shinjo.okayama.jp":true,"shoo.okayama.jp":true,"soja.okayama.jp":true,"takahashi.okayama.jp":true,"tamano.okayama.jp":true,"tsuyama.okayama.jp":true,"wake.okayama.jp":true,"yakage.okayama.jp":true,"aguni.okinawa.jp":true,"ginowan.okinawa.jp":true,"ginoza.okinawa.jp":true,"gushikami.okinawa.jp":true,"haebaru.okinawa.jp":true,"higashi.okinawa.jp":true,"hirara.okinawa.jp":true,"iheya.okinawa.jp":true,"ishigaki.okinawa.jp":true,"ishikawa.okinawa.jp":true,"itoman.okinawa.jp":true,"izena.okinawa.jp":true,"kadena.okinawa.jp":true,"kin.okinawa.jp":true,"kitadaito.okinawa.jp":true,"kitanakagusuku.okinawa.jp":true,"kumejima.okinawa.jp":true,"kunigami.okinawa.jp":true,"minamidaito.okinawa.jp":true,"motobu.okinawa.jp":true,"nago.okinawa.jp":true,"naha.okinawa.jp":true,"nakagusuku.okinawa.jp":true,"nakijin.okinawa.jp":true,"nanjo.okinawa.jp":true,"nishihara.okinawa.jp":true,"ogimi.okinawa.jp":true,"okinawa.okinawa.jp":true,"onna.okinawa.jp":true,"shimoji.okinawa.jp":true,"taketomi.okinawa.jp":true,"tarama.okinawa.jp":true,"tokashiki.okinawa.jp":true,"tomigusuku.okinawa.jp":true,"tonaki.okinawa.jp":true,"urasoe.okinawa.jp":true,"uruma.okinawa.jp":true,"yaese.okinawa.jp":true,"yomitan.okinawa.jp":true,"yonabaru.okinawa.jp":true,"yonaguni.okinawa.jp":true,"zamami.okinawa.jp":true,"abeno.osaka.jp":true,"chihayaakasaka.osaka.jp":true,"chuo.osaka.jp":true,"daito.osaka.jp":true,"fujiidera.osaka.jp":true,"habikino.osaka.jp":true,"hannan.osaka.jp":true,"higashiosaka.osaka.jp":true,"higashisumiyoshi.osaka.jp":true,"higashiyodogawa.osaka.jp":true,"hirakata.osaka.jp":true,"ibaraki.osaka.jp":true,"ikeda.osaka.jp":true,"izumi.osaka.jp":true,"izumiotsu.osaka.jp":true,"izumisano.osaka.jp":true,"kadoma.osaka.jp":true,"kaizuka.osaka.jp":true,"kanan.osaka.jp":true,"kashiwara.osaka.jp":true,"katano.osaka.jp":true,"kawachinagano.osaka.jp":true,"kishiwada.osaka.jp":true,"kita.osaka.jp":true,"kumatori.osaka.jp":true,"matsubara.osaka.jp":true,"minato.osaka.jp":true,"minoh.osaka.jp":true,"misaki.osaka.jp":true,"moriguchi.osaka.jp":true,"neyagawa.osaka.jp":true,"nishi.osaka.jp":true,"nose.osaka.jp":true,"osakasayama.osaka.jp":true,"sakai.osaka.jp":true,"sayama.osaka.jp":true,"sennan.osaka.jp":true,"settsu.osaka.jp":true,"shijonawate.osaka.jp":true,"shimamoto.osaka.jp":true,"suita.osaka.jp":true,"tadaoka.osaka.jp":true,"taishi.osaka.jp":true,"tajiri.osaka.jp":true,"takaishi.osaka.jp":true,"takatsuki.osaka.jp":true,"tondabayashi.osaka.jp":true,"toyonaka.osaka.jp":true,"toyono.osaka.jp":true,"yao.osaka.jp":true,"ariake.saga.jp":true,"arita.saga.jp":true,"fukudomi.saga.jp":true,"genkai.saga.jp":true,"hamatama.saga.jp":true,"hizen.saga.jp":true,"imari.saga.jp":true,"kamimine.saga.jp":true,"kanzaki.saga.jp":true,"karatsu.saga.jp":true,"kashima.saga.jp":true,"kitagata.saga.jp":true,"kitahata.saga.jp":true,"kiyama.saga.jp":true,"kouhoku.saga.jp":true,"kyuragi.saga.jp":true,"nishiarita.saga.jp":true,"ogi.saga.jp":true,"omachi.saga.jp":true,"ouchi.saga.jp":true,"saga.saga.jp":true,"shiroishi.saga.jp":true,"taku.saga.jp":true,"tara.saga.jp":true,"tosu.saga.jp":true,"yoshinogari.saga.jp":true,"arakawa.saitama.jp":true,"asaka.saitama.jp":true,"chichibu.saitama.jp":true,"fujimi.saitama.jp":true,"fujimino.saitama.jp":true,"fukaya.saitama.jp":true,"hanno.saitama.jp":true,"hanyu.saitama.jp":true,"hasuda.saitama.jp":true,"hatogaya.saitama.jp":true,"hatoyama.saitama.jp":true,"hidaka.saitama.jp":true,"higashichichibu.saitama.jp":true,"higashimatsuyama.saitama.jp":true,"honjo.saitama.jp":true,"ina.saitama.jp":true,"iruma.saitama.jp":true,"iwatsuki.saitama.jp":true,"kamiizumi.saitama.jp":true,"kamikawa.saitama.jp":true,"kamisato.saitama.jp":true,"kasukabe.saitama.jp":true,"kawagoe.saitama.jp":true,"kawaguchi.saitama.jp":true,"kawajima.saitama.jp":true,"kazo.saitama.jp":true,"kitamoto.saitama.jp":true,"koshigaya.saitama.jp":true,"kounosu.saitama.jp":true,"kuki.saitama.jp":true,"kumagaya.saitama.jp":true,"matsubushi.saitama.jp":true,"minano.saitama.jp":true,"misato.saitama.jp":true,"miyashiro.saitama.jp":true,"miyoshi.saitama.jp":true,"moroyama.saitama.jp":true,"nagatoro.saitama.jp":true,"namegawa.saitama.jp":true,"niiza.saitama.jp":true,"ogano.saitama.jp":true,"ogawa.saitama.jp":true,"ogose.saitama.jp":true,"okegawa.saitama.jp":true,"omiya.saitama.jp":true,"otaki.saitama.jp":true,"ranzan.saitama.jp":true,"ryokami.saitama.jp":true,"saitama.saitama.jp":true,"sakado.saitama.jp":true,"satte.saitama.jp":true,"sayama.saitama.jp":true,"shiki.saitama.jp":true,"shiraoka.saitama.jp":true,"soka.saitama.jp":true,"sugito.saitama.jp":true,"toda.saitama.jp":true,"tokigawa.saitama.jp":true,"tokorozawa.saitama.jp":true,"tsurugashima.saitama.jp":true,"urawa.saitama.jp":true,"warabi.saitama.jp":true,"yashio.saitama.jp":true,"yokoze.saitama.jp":true,"yono.saitama.jp":true,"yorii.saitama.jp":true,"yoshida.saitama.jp":true,"yoshikawa.saitama.jp":true,"yoshimi.saitama.jp":true,"aisho.shiga.jp":true,"gamo.shiga.jp":true,"higashiomi.shiga.jp":true,"hikone.shiga.jp":true,"koka.shiga.jp":true,"konan.shiga.jp":true,"kosei.shiga.jp":true,"koto.shiga.jp":true,"kusatsu.shiga.jp":true,"maibara.shiga.jp":true,"moriyama.shiga.jp":true,"nagahama.shiga.jp":true,"nishiazai.shiga.jp":true,"notogawa.shiga.jp":true,"omihachiman.shiga.jp":true,"otsu.shiga.jp":true,"ritto.shiga.jp":true,"ryuoh.shiga.jp":true,"takashima.shiga.jp":true,"takatsuki.shiga.jp":true,"torahime.shiga.jp":true,"toyosato.shiga.jp":true,"yasu.shiga.jp":true,"akagi.shimane.jp":true,"ama.shimane.jp":true,"gotsu.shimane.jp":true,"hamada.shimane.jp":true,"higashiizumo.shimane.jp":true,"hikawa.shimane.jp":true,"hikimi.shimane.jp":true,"izumo.shimane.jp":true,"kakinoki.shimane.jp":true,"masuda.shimane.jp":true,"matsue.shimane.jp":true,"misato.shimane.jp":true,"nishinoshima.shimane.jp":true,"ohda.shimane.jp":true,"okinoshima.shimane.jp":true,"okuizumo.shimane.jp":true,"shimane.shimane.jp":true,"tamayu.shimane.jp":true,"tsuwano.shimane.jp":true,"unnan.shimane.jp":true,"yakumo.shimane.jp":true,"yasugi.shimane.jp":true,"yatsuka.shimane.jp":true,"arai.shizuoka.jp":true,"atami.shizuoka.jp":true,"fuji.shizuoka.jp":true,"fujieda.shizuoka.jp":true,"fujikawa.shizuoka.jp":true,"fujinomiya.shizuoka.jp":true,"fukuroi.shizuoka.jp":true,"gotemba.shizuoka.jp":true,"haibara.shizuoka.jp":true,"hamamatsu.shizuoka.jp":true,"higashiizu.shizuoka.jp":true,"ito.shizuoka.jp":true,"iwata.shizuoka.jp":true,"izu.shizuoka.jp":true,"izunokuni.shizuoka.jp":true,"kakegawa.shizuoka.jp":true,"kannami.shizuoka.jp":true,"kawanehon.shizuoka.jp":true,"kawazu.shizuoka.jp":true,"kikugawa.shizuoka.jp":true,"kosai.shizuoka.jp":true,"makinohara.shizuoka.jp":true,"matsuzaki.shizuoka.jp":true,"minamiizu.shizuoka.jp":true,"mishima.shizuoka.jp":true,"morimachi.shizuoka.jp":true,"nishiizu.shizuoka.jp":true,"numazu.shizuoka.jp":true,"omaezaki.shizuoka.jp":true,"shimada.shizuoka.jp":true,"shimizu.shizuoka.jp":true,"shimoda.shizuoka.jp":true,"shizuoka.shizuoka.jp":true,"susono.shizuoka.jp":true,"yaizu.shizuoka.jp":true,"yoshida.shizuoka.jp":true,"ashikaga.tochigi.jp":true,"bato.tochigi.jp":true,"haga.tochigi.jp":true,"ichikai.tochigi.jp":true,"iwafune.tochigi.jp":true,"kaminokawa.tochigi.jp":true,"kanuma.tochigi.jp":true,"karasuyama.tochigi.jp":true,"kuroiso.tochigi.jp":true,"mashiko.tochigi.jp":true,"mibu.tochigi.jp":true,"moka.tochigi.jp":true,"motegi.tochigi.jp":true,"nasu.tochigi.jp":true,"nasushiobara.tochigi.jp":true,"nikko.tochigi.jp":true,"nishikata.tochigi.jp":true,"nogi.tochigi.jp":true,"ohira.tochigi.jp":true,"ohtawara.tochigi.jp":true,"oyama.tochigi.jp":true,"sakura.tochigi.jp":true,"sano.tochigi.jp":true,"shimotsuke.tochigi.jp":true,"shioya.tochigi.jp":true,"takanezawa.tochigi.jp":true,"tochigi.tochigi.jp":true,"tsuga.tochigi.jp":true,"ujiie.tochigi.jp":true,"utsunomiya.tochigi.jp":true,"yaita.tochigi.jp":true,"aizumi.tokushima.jp":true,"anan.tokushima.jp":true,"ichiba.tokushima.jp":true,"itano.tokushima.jp":true,"kainan.tokushima.jp":true,"komatsushima.tokushima.jp":true,"matsushige.tokushima.jp":true,"mima.tokushima.jp":true,"minami.tokushima.jp":true,"miyoshi.tokushima.jp":true,"mugi.tokushima.jp":true,"nakagawa.tokushima.jp":true,"naruto.tokushima.jp":true,"sanagochi.tokushima.jp":true,"shishikui.tokushima.jp":true,"tokushima.tokushima.jp":true,"wajiki.tokushima.jp":true,"adachi.tokyo.jp":true,"akiruno.tokyo.jp":true,"akishima.tokyo.jp":true,"aogashima.tokyo.jp":true,"arakawa.tokyo.jp":true,"bunkyo.tokyo.jp":true,"chiyoda.tokyo.jp":true,"chofu.tokyo.jp":true,"chuo.tokyo.jp":true,"edogawa.tokyo.jp":true,"fuchu.tokyo.jp":true,"fussa.tokyo.jp":true,"hachijo.tokyo.jp":true,"hachioji.tokyo.jp":true,"hamura.tokyo.jp":true,"higashikurume.tokyo.jp":true,"higashimurayama.tokyo.jp":true,"higashiyamato.tokyo.jp":true,"hino.tokyo.jp":true,"hinode.tokyo.jp":true,"hinohara.tokyo.jp":true,"inagi.tokyo.jp":true,"itabashi.tokyo.jp":true,"katsushika.tokyo.jp":true,"kita.tokyo.jp":true,"kiyose.tokyo.jp":true,"kodaira.tokyo.jp":true,"koganei.tokyo.jp":true,"kokubunji.tokyo.jp":true,"komae.tokyo.jp":true,"koto.tokyo.jp":true,"kouzushima.tokyo.jp":true,"kunitachi.tokyo.jp":true,"machida.tokyo.jp":true,"meguro.tokyo.jp":true,"minato.tokyo.jp":true,"mitaka.tokyo.jp":true,"mizuho.tokyo.jp":true,"musashimurayama.tokyo.jp":true,"musashino.tokyo.jp":true,"nakano.tokyo.jp":true,"nerima.tokyo.jp":true,"ogasawara.tokyo.jp":true,"okutama.tokyo.jp":true,"ome.tokyo.jp":true,"oshima.tokyo.jp":true,"ota.tokyo.jp":true,"setagaya.tokyo.jp":true,"shibuya.tokyo.jp":true,"shinagawa.tokyo.jp":true,"shinjuku.tokyo.jp":true,"suginami.tokyo.jp":true,"sumida.tokyo.jp":true,"tachikawa.tokyo.jp":true,"taito.tokyo.jp":true,"tama.tokyo.jp":true,"toshima.tokyo.jp":true,"chizu.tottori.jp":true,"hino.tottori.jp":true,"kawahara.tottori.jp":true,"koge.tottori.jp":true,"kotoura.tottori.jp":true,"misasa.tottori.jp":true,"nanbu.tottori.jp":true,"nichinan.tottori.jp":true,"sakaiminato.tottori.jp":true,"tottori.tottori.jp":true,"wakasa.tottori.jp":true,"yazu.tottori.jp":true,"yonago.tottori.jp":true,"asahi.toyama.jp":true,"fuchu.toyama.jp":true,"fukumitsu.toyama.jp":true,"funahashi.toyama.jp":true,"himi.toyama.jp":true,"imizu.toyama.jp":true,"inami.toyama.jp":true,"johana.toyama.jp":true,"kamiichi.toyama.jp":true,"kurobe.toyama.jp":true,"nakaniikawa.toyama.jp":true,"namerikawa.toyama.jp":true,"nanto.toyama.jp":true,"nyuzen.toyama.jp":true,"oyabe.toyama.jp":true,"taira.toyama.jp":true,"takaoka.toyama.jp":true,"tateyama.toyama.jp":true,"toga.toyama.jp":true,"tonami.toyama.jp":true,"toyama.toyama.jp":true,"unazuki.toyama.jp":true,"uozu.toyama.jp":true,"yamada.toyama.jp":true,"arida.wakayama.jp":true,"aridagawa.wakayama.jp":true,"gobo.wakayama.jp":true,"hashimoto.wakayama.jp":true,"hidaka.wakayama.jp":true,"hirogawa.wakayama.jp":true,"inami.wakayama.jp":true,"iwade.wakayama.jp":true,"kainan.wakayama.jp":true,"kamitonda.wakayama.jp":true,"katsuragi.wakayama.jp":true,"kimino.wakayama.jp":true,"kinokawa.wakayama.jp":true,"kitayama.wakayama.jp":true,"koya.wakayama.jp":true,"koza.wakayama.jp":true,"kozagawa.wakayama.jp":true,"kudoyama.wakayama.jp":true,"kushimoto.wakayama.jp":true,"mihama.wakayama.jp":true,"misato.wakayama.jp":true,"nachikatsuura.wakayama.jp":true,"shingu.wakayama.jp":true,"shirahama.wakayama.jp":true,"taiji.wakayama.jp":true,"tanabe.wakayama.jp":true,"wakayama.wakayama.jp":true,"yuasa.wakayama.jp":true,"yura.wakayama.jp":true,"asahi.yamagata.jp":true,"funagata.yamagata.jp":true,"higashine.yamagata.jp":true,"iide.yamagata.jp":true,"kahoku.yamagata.jp":true,"kaminoyama.yamagata.jp":true,"kaneyama.yamagata.jp":true,"kawanishi.yamagata.jp":true,"mamurogawa.yamagata.jp":true,"mikawa.yamagata.jp":true,"murayama.yamagata.jp":true,"nagai.yamagata.jp":true,"nakayama.yamagata.jp":true,"nanyo.yamagata.jp":true,"nishikawa.yamagata.jp":true,"obanazawa.yamagata.jp":true,"oe.yamagata.jp":true,"oguni.yamagata.jp":true,"ohkura.yamagata.jp":true,"oishida.yamagata.jp":true,"sagae.yamagata.jp":true,"sakata.yamagata.jp":true,"sakegawa.yamagata.jp":true,"shinjo.yamagata.jp":true,"shirataka.yamagata.jp":true,"shonai.yamagata.jp":true,"takahata.yamagata.jp":true,"tendo.yamagata.jp":true,"tozawa.yamagata.jp":true,"tsuruoka.yamagata.jp":true,"yamagata.yamagata.jp":true,"yamanobe.yamagata.jp":true,"yonezawa.yamagata.jp":true,"yuza.yamagata.jp":true,"abu.yamaguchi.jp":true,"hagi.yamaguchi.jp":true,"hikari.yamaguchi.jp":true,"hofu.yamaguchi.jp":true,"iwakuni.yamaguchi.jp":true,"kudamatsu.yamaguchi.jp":true,"mitou.yamaguchi.jp":true,"nagato.yamaguchi.jp":true,"oshima.yamaguchi.jp":true,"shimonoseki.yamaguchi.jp":true,"shunan.yamaguchi.jp":true,"tabuse.yamaguchi.jp":true,"tokuyama.yamaguchi.jp":true,"toyota.yamaguchi.jp":true,"ube.yamaguchi.jp":true,"yuu.yamaguchi.jp":true,"chuo.yamanashi.jp":true,"doshi.yamanashi.jp":true,"fuefuki.yamanashi.jp":true,"fujikawa.yamanashi.jp":true,"fujikawaguchiko.yamanashi.jp":true,"fujiyoshida.yamanashi.jp":true,"hayakawa.yamanashi.jp":true,"hokuto.yamanashi.jp":true,"ichikawamisato.yamanashi.jp":true,"kai.yamanashi.jp":true,"kofu.yamanashi.jp":true,"koshu.yamanashi.jp":true,"kosuge.yamanashi.jp":true,"minami-alps.yamanashi.jp":true,"minobu.yamanashi.jp":true,"nakamichi.yamanashi.jp":true,"nanbu.yamanashi.jp":true,"narusawa.yamanashi.jp":true,"nirasaki.yamanashi.jp":true,"nishikatsura.yamanashi.jp":true,"oshino.yamanashi.jp":true,"otsuki.yamanashi.jp":true,"showa.yamanashi.jp":true,"tabayama.yamanashi.jp":true,"tsuru.yamanashi.jp":true,"uenohara.yamanashi.jp":true,"yamanakako.yamanashi.jp":true,"yamanashi.yamanashi.jp":true,"*.ke":true,"kg":true,"org.kg":true,"net.kg":true,"com.kg":true,"edu.kg":true,"gov.kg":true,"mil.kg":true,"*.kh":true,"ki":true,"edu.ki":true,"biz.ki":true,"net.ki":true,"org.ki":true,"gov.ki":true,"info.ki":true,"com.ki":true,"km":true,"org.km":true,"nom.km":true,"gov.km":true,"prd.km":true,"tm.km":true,"edu.km":true,"mil.km":true,"ass.km":true,"com.km":true,"coop.km":true,"asso.km":true,"presse.km":true,"medecin.km":true,"notaires.km":true,"pharmaciens.km":true,"veterinaire.km":true,"gouv.km":true,"kn":true,"net.kn":true,"org.kn":true,"edu.kn":true,"gov.kn":true,"kp":true,"com.kp":true,"edu.kp":true,"gov.kp":true,"org.kp":true,"rep.kp":true,"tra.kp":true,"kr":true,"ac.kr":true,"co.kr":true,"es.kr":true,"go.kr":true,"hs.kr":true,"kg.kr":true,"mil.kr":true,"ms.kr":true,"ne.kr":true,"or.kr":true,"pe.kr":true,"re.kr":true,"sc.kr":true,"busan.kr":true,"chungbuk.kr":true,"chungnam.kr":true,"daegu.kr":true,"daejeon.kr":true,"gangwon.kr":true,"gwangju.kr":true,"gyeongbuk.kr":true,"gyeonggi.kr":true,"gyeongnam.kr":true,"incheon.kr":true,"jeju.kr":true,"jeonbuk.kr":true,"jeonnam.kr":true,"seoul.kr":true,"ulsan.kr":true,"*.kw":true,"ky":true,"edu.ky":true,"gov.ky":true,"com.ky":true,"org.ky":true,"net.ky":true,"kz":true,"org.kz":true,"edu.kz":true,"net.kz":true,"gov.kz":true,"mil.kz":true,"com.kz":true,"la":true,"int.la":true,"net.la":true,"info.la":true,"edu.la":true,"gov.la":true,"per.la":true,"com.la":true,"org.la":true,"lb":true,"com.lb":true,"edu.lb":true,"gov.lb":true,"net.lb":true,"org.lb":true,"lc":true,"com.lc":true,"net.lc":true,"co.lc":true,"org.lc":true,"edu.lc":true,"gov.lc":true,"li":true,"lk":true,"gov.lk":true,"sch.lk":true,"net.lk":true,"int.lk":true,"com.lk":true,"org.lk":true,"edu.lk":true,"ngo.lk":true,"soc.lk":true,"web.lk":true,"ltd.lk":true,"assn.lk":true,"grp.lk":true,"hotel.lk":true,"ac.lk":true,"lr":true,"com.lr":true,"edu.lr":true,"gov.lr":true,"org.lr":true,"net.lr":true,"ls":true,"co.ls":true,"org.ls":true,"lt":true,"gov.lt":true,"lu":true,"lv":true,"com.lv":true,"edu.lv":true,"gov.lv":true,"org.lv":true,"mil.lv":true,"id.lv":true,"net.lv":true,"asn.lv":true,"conf.lv":true,"ly":true,"com.ly":true,"net.ly":true,"gov.ly":true,"plc.ly":true,"edu.ly":true,"sch.ly":true,"med.ly":true,"org.ly":true,"id.ly":true,"ma":true,"co.ma":true,"net.ma":true,"gov.ma":true,"org.ma":true,"ac.ma":true,"press.ma":true,"mc":true,"tm.mc":true,"asso.mc":true,"md":true,"me":true,"co.me":true,"net.me":true,"org.me":true,"edu.me":true,"ac.me":true,"gov.me":true,"its.me":true,"priv.me":true,"mg":true,"org.mg":true,"nom.mg":true,"gov.mg":true,"prd.mg":true,"tm.mg":true,"edu.mg":true,"mil.mg":true,"com.mg":true,"co.mg":true,"mh":true,"mil":true,"mk":true,"com.mk":true,"org.mk":true,"net.mk":true,"edu.mk":true,"gov.mk":true,"inf.mk":true,"name.mk":true,"ml":true,"com.ml":true,"edu.ml":true,"gouv.ml":true,"gov.ml":true,"net.ml":true,"org.ml":true,"presse.ml":true,"*.mm":true,"mn":true,"gov.mn":true,"edu.mn":true,"org.mn":true,"mo":true,"com.mo":true,"net.mo":true,"org.mo":true,"edu.mo":true,"gov.mo":true,"mobi":true,"mp":true,"mq":true,"mr":true,"gov.mr":true,"ms":true,"com.ms":true,"edu.ms":true,"gov.ms":true,"net.ms":true,"org.ms":true,"mt":true,"com.mt":true,"edu.mt":true,"net.mt":true,"org.mt":true,"mu":true,"com.mu":true,"net.mu":true,"org.mu":true,"gov.mu":true,"ac.mu":true,"co.mu":true,"or.mu":true,"museum":true,"academy.museum":true,"agriculture.museum":true,"air.museum":true,"airguard.museum":true,"alabama.museum":true,"alaska.museum":true,"amber.museum":true,"ambulance.museum":true,"american.museum":true,"americana.museum":true,"americanantiques.museum":true,"americanart.museum":true,"amsterdam.museum":true,"and.museum":true,"annefrank.museum":true,"anthro.museum":true,"anthropology.museum":true,"antiques.museum":true,"aquarium.museum":true,"arboretum.museum":true,"archaeological.museum":true,"archaeology.museum":true,"architecture.museum":true,"art.museum":true,"artanddesign.museum":true,"artcenter.museum":true,"artdeco.museum":true,"arteducation.museum":true,"artgallery.museum":true,"arts.museum":true,"artsandcrafts.museum":true,"asmatart.museum":true,"assassination.museum":true,"assisi.museum":true,"association.museum":true,"astronomy.museum":true,"atlanta.museum":true,"austin.museum":true,"australia.museum":true,"automotive.museum":true,"aviation.museum":true,"axis.museum":true,"badajoz.museum":true,"baghdad.museum":true,"bahn.museum":true,"bale.museum":true,"baltimore.museum":true,"barcelona.museum":true,"baseball.museum":true,"basel.museum":true,"baths.museum":true,"bauern.museum":true,"beauxarts.museum":true,"beeldengeluid.museum":true,"bellevue.museum":true,"bergbau.museum":true,"berkeley.museum":true,"berlin.museum":true,"bern.museum":true,"bible.museum":true,"bilbao.museum":true,"bill.museum":true,"birdart.museum":true,"birthplace.museum":true,"bonn.museum":true,"boston.museum":true,"botanical.museum":true,"botanicalgarden.museum":true,"botanicgarden.museum":true,"botany.museum":true,"brandywinevalley.museum":true,"brasil.museum":true,"bristol.museum":true,"british.museum":true,"britishcolumbia.museum":true,"broadcast.museum":true,"brunel.museum":true,"brussel.museum":true,"brussels.museum":true,"bruxelles.museum":true,"building.museum":true,"burghof.museum":true,"bus.museum":true,"bushey.museum":true,"cadaques.museum":true,"california.museum":true,"cambridge.museum":true,"can.museum":true,"canada.museum":true,"capebreton.museum":true,"carrier.museum":true,"cartoonart.museum":true,"casadelamoneda.museum":true,"castle.museum":true,"castres.museum":true,"celtic.museum":true,"center.museum":true,"chattanooga.museum":true,"cheltenham.museum":true,"chesapeakebay.museum":true,"chicago.museum":true,"children.museum":true,"childrens.museum":true,"childrensgarden.museum":true,"chiropractic.museum":true,"chocolate.museum":true,"christiansburg.museum":true,"cincinnati.museum":true,"cinema.museum":true,"circus.museum":true,"civilisation.museum":true,"civilization.museum":true,"civilwar.museum":true,"clinton.museum":true,"clock.museum":true,"coal.museum":true,"coastaldefence.museum":true,"cody.museum":true,"coldwar.museum":true,"collection.museum":true,"colonialwilliamsburg.museum":true,"coloradoplateau.museum":true,"columbia.museum":true,"columbus.museum":true,"communication.museum":true,"communications.museum":true,"community.museum":true,"computer.museum":true,"computerhistory.museum":true,"xn--comunicaes-v6a2o.museum":true,"contemporary.museum":true,"contemporaryart.museum":true,"convent.museum":true,"copenhagen.museum":true,"corporation.museum":true,"xn--correios-e-telecomunicaes-ghc29a.museum":true,"corvette.museum":true,"costume.museum":true,"countryestate.museum":true,"county.museum":true,"crafts.museum":true,"cranbrook.museum":true,"creation.museum":true,"cultural.museum":true,"culturalcenter.museum":true,"culture.museum":true,"cyber.museum":true,"cymru.museum":true,"dali.museum":true,"dallas.museum":true,"database.museum":true,"ddr.museum":true,"decorativearts.museum":true,"delaware.museum":true,"delmenhorst.museum":true,"denmark.museum":true,"depot.museum":true,"design.museum":true,"detroit.museum":true,"dinosaur.museum":true,"discovery.museum":true,"dolls.museum":true,"donostia.museum":true,"durham.museum":true,"eastafrica.museum":true,"eastcoast.museum":true,"education.museum":true,"educational.museum":true,"egyptian.museum":true,"eisenbahn.museum":true,"elburg.museum":true,"elvendrell.museum":true,"embroidery.museum":true,"encyclopedic.museum":true,"england.museum":true,"entomology.museum":true,"environment.museum":true,"environmentalconservation.museum":true,"epilepsy.museum":true,"essex.museum":true,"estate.museum":true,"ethnology.museum":true,"exeter.museum":true,"exhibition.museum":true,"family.museum":true,"farm.museum":true,"farmequipment.museum":true,"farmers.museum":true,"farmstead.museum":true,"field.museum":true,"figueres.museum":true,"filatelia.museum":true,"film.museum":true,"fineart.museum":true,"finearts.museum":true,"finland.museum":true,"flanders.museum":true,"florida.museum":true,"force.museum":true,"fortmissoula.museum":true,"fortworth.museum":true,"foundation.museum":true,"francaise.museum":true,"frankfurt.museum":true,"franziskaner.museum":true,"freemasonry.museum":true,"freiburg.museum":true,"fribourg.museum":true,"frog.museum":true,"fundacio.museum":true,"furniture.museum":true,"gallery.museum":true,"garden.museum":true,"gateway.museum":true,"geelvinck.museum":true,"gemological.museum":true,"geology.museum":true,"georgia.museum":true,"giessen.museum":true,"glas.museum":true,"glass.museum":true,"gorge.museum":true,"grandrapids.museum":true,"graz.museum":true,"guernsey.museum":true,"halloffame.museum":true,"hamburg.museum":true,"handson.museum":true,"harvestcelebration.museum":true,"hawaii.museum":true,"health.museum":true,"heimatunduhren.museum":true,"hellas.museum":true,"helsinki.museum":true,"hembygdsforbund.museum":true,"heritage.museum":true,"histoire.museum":true,"historical.museum":true,"historicalsociety.museum":true,"historichouses.museum":true,"historisch.museum":true,"historisches.museum":true,"history.museum":true,"historyofscience.museum":true,"horology.museum":true,"house.museum":true,"humanities.museum":true,"illustration.museum":true,"imageandsound.museum":true,"indian.museum":true,"indiana.museum":true,"indianapolis.museum":true,"indianmarket.museum":true,"intelligence.museum":true,"interactive.museum":true,"iraq.museum":true,"iron.museum":true,"isleofman.museum":true,"jamison.museum":true,"jefferson.museum":true,"jerusalem.museum":true,"jewelry.museum":true,"jewish.museum":true,"jewishart.museum":true,"jfk.museum":true,"journalism.museum":true,"judaica.museum":true,"judygarland.museum":true,"juedisches.museum":true,"juif.museum":true,"karate.museum":true,"karikatur.museum":true,"kids.museum":true,"koebenhavn.museum":true,"koeln.museum":true,"kunst.museum":true,"kunstsammlung.museum":true,"kunstunddesign.museum":true,"labor.museum":true,"labour.museum":true,"lajolla.museum":true,"lancashire.museum":true,"landes.museum":true,"lans.museum":true,"xn--lns-qla.museum":true,"larsson.museum":true,"lewismiller.museum":true,"lincoln.museum":true,"linz.museum":true,"living.museum":true,"livinghistory.museum":true,"localhistory.museum":true,"london.museum":true,"losangeles.museum":true,"louvre.museum":true,"loyalist.museum":true,"lucerne.museum":true,"luxembourg.museum":true,"luzern.museum":true,"mad.museum":true,"madrid.museum":true,"mallorca.museum":true,"manchester.museum":true,"mansion.museum":true,"mansions.museum":true,"manx.museum":true,"marburg.museum":true,"maritime.museum":true,"maritimo.museum":true,"maryland.museum":true,"marylhurst.museum":true,"media.museum":true,"medical.museum":true,"medizinhistorisches.museum":true,"meeres.museum":true,"memorial.museum":true,"mesaverde.museum":true,"michigan.museum":true,"midatlantic.museum":true,"military.museum":true,"mill.museum":true,"miners.museum":true,"mining.museum":true,"minnesota.museum":true,"missile.museum":true,"missoula.museum":true,"modern.museum":true,"moma.museum":true,"money.museum":true,"monmouth.museum":true,"monticello.museum":true,"montreal.museum":true,"moscow.museum":true,"motorcycle.museum":true,"muenchen.museum":true,"muenster.museum":true,"mulhouse.museum":true,"muncie.museum":true,"museet.museum":true,"museumcenter.museum":true,"museumvereniging.museum":true,"music.museum":true,"national.museum":true,"nationalfirearms.museum":true,"nationalheritage.museum":true,"nativeamerican.museum":true,"naturalhistory.museum":true,"naturalhistorymuseum.museum":true,"naturalsciences.museum":true,"nature.museum":true,"naturhistorisches.museum":true,"natuurwetenschappen.museum":true,"naumburg.museum":true,"naval.museum":true,"nebraska.museum":true,"neues.museum":true,"newhampshire.museum":true,"newjersey.museum":true,"newmexico.museum":true,"newport.museum":true,"newspaper.museum":true,"newyork.museum":true,"niepce.museum":true,"norfolk.museum":true,"north.museum":true,"nrw.museum":true,"nuernberg.museum":true,"nuremberg.museum":true,"nyc.museum":true,"nyny.museum":true,"oceanographic.museum":true,"oceanographique.museum":true,"omaha.museum":true,"online.museum":true,"ontario.museum":true,"openair.museum":true,"oregon.museum":true,"oregontrail.museum":true,"otago.museum":true,"oxford.museum":true,"pacific.museum":true,"paderborn.museum":true,"palace.museum":true,"paleo.museum":true,"palmsprings.museum":true,"panama.museum":true,"paris.museum":true,"pasadena.museum":true,"pharmacy.museum":true,"philadelphia.museum":true,"philadelphiaarea.museum":true,"philately.museum":true,"phoenix.museum":true,"photography.museum":true,"pilots.museum":true,"pittsburgh.museum":true,"planetarium.museum":true,"plantation.museum":true,"plants.museum":true,"plaza.museum":true,"portal.museum":true,"portland.museum":true,"portlligat.museum":true,"posts-and-telecommunications.museum":true,"preservation.museum":true,"presidio.museum":true,"press.museum":true,"project.museum":true,"public.museum":true,"pubol.museum":true,"quebec.museum":true,"railroad.museum":true,"railway.museum":true,"research.museum":true,"resistance.museum":true,"riodejaneiro.museum":true,"rochester.museum":true,"rockart.museum":true,"roma.museum":true,"russia.museum":true,"saintlouis.museum":true,"salem.museum":true,"salvadordali.museum":true,"salzburg.museum":true,"sandiego.museum":true,"sanfrancisco.museum":true,"santabarbara.museum":true,"santacruz.museum":true,"santafe.museum":true,"saskatchewan.museum":true,"satx.museum":true,"savannahga.museum":true,"schlesisches.museum":true,"schoenbrunn.museum":true,"schokoladen.museum":true,"school.museum":true,"schweiz.museum":true,"science.museum":true,"scienceandhistory.museum":true,"scienceandindustry.museum":true,"sciencecenter.museum":true,"sciencecenters.museum":true,"science-fiction.museum":true,"sciencehistory.museum":true,"sciences.museum":true,"sciencesnaturelles.museum":true,"scotland.museum":true,"seaport.museum":true,"settlement.museum":true,"settlers.museum":true,"shell.museum":true,"sherbrooke.museum":true,"sibenik.museum":true,"silk.museum":true,"ski.museum":true,"skole.museum":true,"society.museum":true,"sologne.museum":true,"soundandvision.museum":true,"southcarolina.museum":true,"southwest.museum":true,"space.museum":true,"spy.museum":true,"square.museum":true,"stadt.museum":true,"stalbans.museum":true,"starnberg.museum":true,"state.museum":true,"stateofdelaware.museum":true,"station.museum":true,"steam.museum":true,"steiermark.museum":true,"stjohn.museum":true,"stockholm.museum":true,"stpetersburg.museum":true,"stuttgart.museum":true,"suisse.museum":true,"surgeonshall.museum":true,"surrey.museum":true,"svizzera.museum":true,"sweden.museum":true,"sydney.museum":true,"tank.museum":true,"tcm.museum":true,"technology.museum":true,"telekommunikation.museum":true,"television.museum":true,"texas.museum":true,"textile.museum":true,"theater.museum":true,"time.museum":true,"timekeeping.museum":true,"topology.museum":true,"torino.museum":true,"touch.museum":true,"town.museum":true,"transport.museum":true,"tree.museum":true,"trolley.museum":true,"trust.museum":true,"trustee.museum":true,"uhren.museum":true,"ulm.museum":true,"undersea.museum":true,"university.museum":true,"usa.museum":true,"usantiques.museum":true,"usarts.museum":true,"uscountryestate.museum":true,"usculture.museum":true,"usdecorativearts.museum":true,"usgarden.museum":true,"ushistory.museum":true,"ushuaia.museum":true,"uslivinghistory.museum":true,"utah.museum":true,"uvic.museum":true,"valley.museum":true,"vantaa.museum":true,"versailles.museum":true,"viking.museum":true,"village.museum":true,"virginia.museum":true,"virtual.museum":true,"virtuel.museum":true,"vlaanderen.museum":true,"volkenkunde.museum":true,"wales.museum":true,"wallonie.museum":true,"war.museum":true,"washingtondc.museum":true,"watchandclock.museum":true,"watch-and-clock.museum":true,"western.museum":true,"westfalen.museum":true,"whaling.museum":true,"wildlife.museum":true,"williamsburg.museum":true,"windmill.museum":true,"workshop.museum":true,"york.museum":true,"yorkshire.museum":true,"yosemite.museum":true,"youth.museum":true,"zoological.museum":true,"zoology.museum":true,"xn--9dbhblg6di.museum":true,"xn--h1aegh.museum":true,"mv":true,"aero.mv":true,"biz.mv":true,"com.mv":true,"coop.mv":true,"edu.mv":true,"gov.mv":true,"info.mv":true,"int.mv":true,"mil.mv":true,"museum.mv":true,"name.mv":true,"net.mv":true,"org.mv":true,"pro.mv":true,"mw":true,"ac.mw":true,"biz.mw":true,"co.mw":true,"com.mw":true,"coop.mw":true,"edu.mw":true,"gov.mw":true,"int.mw":true,"museum.mw":true,"net.mw":true,"org.mw":true,"mx":true,"com.mx":true,"org.mx":true,"gob.mx":true,"edu.mx":true,"net.mx":true,"my":true,"com.my":true,"net.my":true,"org.my":true,"gov.my":true,"edu.my":true,"mil.my":true,"name.my":true,"*.mz":true,"teledata.mz":false,"na":true,"info.na":true,"pro.na":true,"name.na":true,"school.na":true,"or.na":true,"dr.na":true,"us.na":true,"mx.na":true,"ca.na":true,"in.na":true,"cc.na":true,"tv.na":true,"ws.na":true,"mobi.na":true,"co.na":true,"com.na":true,"org.na":true,"name":true,"nc":true,"asso.nc":true,"ne":true,"net":true,"nf":true,"com.nf":true,"net.nf":true,"per.nf":true,"rec.nf":true,"web.nf":true,"arts.nf":true,"firm.nf":true,"info.nf":true,"other.nf":true,"store.nf":true,"ng":true,"com.ng":true,"edu.ng":true,"name.ng":true,"net.ng":true,"org.ng":true,"sch.ng":true,"gov.ng":true,"mil.ng":true,"mobi.ng":true,"*.ni":true,"nl":true,"bv.nl":true,"no":true,"fhs.no":true,"vgs.no":true,"fylkesbibl.no":true,"folkebibl.no":true,"museum.no":true,"idrett.no":true,"priv.no":true,"mil.no":true,"stat.no":true,"dep.no":true,"kommune.no":true,"herad.no":true,"aa.no":true,"ah.no":true,"bu.no":true,"fm.no":true,"hl.no":true,"hm.no":true,"jan-mayen.no":true,"mr.no":true,"nl.no":true,"nt.no":true,"of.no":true,"ol.no":true,"oslo.no":true,"rl.no":true,"sf.no":true,"st.no":true,"svalbard.no":true,"tm.no":true,"tr.no":true,"va.no":true,"vf.no":true,"gs.aa.no":true,"gs.ah.no":true,"gs.bu.no":true,"gs.fm.no":true,"gs.hl.no":true,"gs.hm.no":true,"gs.jan-mayen.no":true,"gs.mr.no":true,"gs.nl.no":true,"gs.nt.no":true,"gs.of.no":true,"gs.ol.no":true,"gs.oslo.no":true,"gs.rl.no":true,"gs.sf.no":true,"gs.st.no":true,"gs.svalbard.no":true,"gs.tm.no":true,"gs.tr.no":true,"gs.va.no":true,"gs.vf.no":true,"akrehamn.no":true,"xn--krehamn-dxa.no":true,"algard.no":true,"xn--lgrd-poac.no":true,"arna.no":true,"brumunddal.no":true,"bryne.no":true,"bronnoysund.no":true,"xn--brnnysund-m8ac.no":true,"drobak.no":true,"xn--drbak-wua.no":true,"egersund.no":true,"fetsund.no":true,"floro.no":true,"xn--flor-jra.no":true,"fredrikstad.no":true,"hokksund.no":true,"honefoss.no":true,"xn--hnefoss-q1a.no":true,"jessheim.no":true,"jorpeland.no":true,"xn--jrpeland-54a.no":true,"kirkenes.no":true,"kopervik.no":true,"krokstadelva.no":true,"langevag.no":true,"xn--langevg-jxa.no":true,"leirvik.no":true,"mjondalen.no":true,"xn--mjndalen-64a.no":true,"mo-i-rana.no":true,"mosjoen.no":true,"xn--mosjen-eya.no":true,"nesoddtangen.no":true,"orkanger.no":true,"osoyro.no":true,"xn--osyro-wua.no":true,"raholt.no":true,"xn--rholt-mra.no":true,"sandnessjoen.no":true,"xn--sandnessjen-ogb.no":true,"skedsmokorset.no":true,"slattum.no":true,"spjelkavik.no":true,"stathelle.no":true,"stavern.no":true,"stjordalshalsen.no":true,"xn--stjrdalshalsen-sqb.no":true,"tananger.no":true,"tranby.no":true,"vossevangen.no":true,"afjord.no":true,"xn--fjord-lra.no":true,"agdenes.no":true,"al.no":true,"xn--l-1fa.no":true,"alesund.no":true,"xn--lesund-hua.no":true,"alstahaug.no":true,"alta.no":true,"xn--lt-liac.no":true,"alaheadju.no":true,"xn--laheadju-7ya.no":true,"alvdal.no":true,"amli.no":true,"xn--mli-tla.no":true,"amot.no":true,"xn--mot-tla.no":true,"andebu.no":true,"andoy.no":true,"xn--andy-ira.no":true,"andasuolo.no":true,"ardal.no":true,"xn--rdal-poa.no":true,"aremark.no":true,"arendal.no":true,"xn--s-1fa.no":true,"aseral.no":true,"xn--seral-lra.no":true,"asker.no":true,"askim.no":true,"askvoll.no":true,"askoy.no":true,"xn--asky-ira.no":true,"asnes.no":true,"xn--snes-poa.no":true,"audnedaln.no":true,"aukra.no":true,"aure.no":true,"aurland.no":true,"aurskog-holand.no":true,"xn--aurskog-hland-jnb.no":true,"austevoll.no":true,"austrheim.no":true,"averoy.no":true,"xn--avery-yua.no":true,"balestrand.no":true,"ballangen.no":true,"balat.no":true,"xn--blt-elab.no":true,"balsfjord.no":true,"bahccavuotna.no":true,"xn--bhccavuotna-k7a.no":true,"bamble.no":true,"bardu.no":true,"beardu.no":true,"beiarn.no":true,"bajddar.no":true,"xn--bjddar-pta.no":true,"baidar.no":true,"xn--bidr-5nac.no":true,"berg.no":true,"bergen.no":true,"berlevag.no":true,"xn--berlevg-jxa.no":true,"bearalvahki.no":true,"xn--bearalvhki-y4a.no":true,"bindal.no":true,"birkenes.no":true,"bjarkoy.no":true,"xn--bjarky-fya.no":true,"bjerkreim.no":true,"bjugn.no":true,"bodo.no":true,"xn--bod-2na.no":true,"badaddja.no":true,"xn--bdddj-mrabd.no":true,"budejju.no":true,"bokn.no":true,"bremanger.no":true,"bronnoy.no":true,"xn--brnny-wuac.no":true,"bygland.no":true,"bykle.no":true,"barum.no":true,"xn--brum-voa.no":true,"bo.telemark.no":true,"xn--b-5ga.telemark.no":true,"bo.nordland.no":true,"xn--b-5ga.nordland.no":true,"bievat.no":true,"xn--bievt-0qa.no":true,"bomlo.no":true,"xn--bmlo-gra.no":true,"batsfjord.no":true,"xn--btsfjord-9za.no":true,"bahcavuotna.no":true,"xn--bhcavuotna-s4a.no":true,"dovre.no":true,"drammen.no":true,"drangedal.no":true,"dyroy.no":true,"xn--dyry-ira.no":true,"donna.no":true,"xn--dnna-gra.no":true,"eid.no":true,"eidfjord.no":true,"eidsberg.no":true,"eidskog.no":true,"eidsvoll.no":true,"eigersund.no":true,"elverum.no":true,"enebakk.no":true,"engerdal.no":true,"etne.no":true,"etnedal.no":true,"evenes.no":true,"evenassi.no":true,"xn--eveni-0qa01ga.no":true,"evje-og-hornnes.no":true,"farsund.no":true,"fauske.no":true,"fuossko.no":true,"fuoisku.no":true,"fedje.no":true,"fet.no":true,"finnoy.no":true,"xn--finny-yua.no":true,"fitjar.no":true,"fjaler.no":true,"fjell.no":true,"flakstad.no":true,"flatanger.no":true,"flekkefjord.no":true,"flesberg.no":true,"flora.no":true,"fla.no":true,"xn--fl-zia.no":true,"folldal.no":true,"forsand.no":true,"fosnes.no":true,"frei.no":true,"frogn.no":true,"froland.no":true,"frosta.no":true,"frana.no":true,"xn--frna-woa.no":true,"froya.no":true,"xn--frya-hra.no":true,"fusa.no":true,"fyresdal.no":true,"forde.no":true,"xn--frde-gra.no":true,"gamvik.no":true,"gangaviika.no":true,"xn--ggaviika-8ya47h.no":true,"gaular.no":true,"gausdal.no":true,"gildeskal.no":true,"xn--gildeskl-g0a.no":true,"giske.no":true,"gjemnes.no":true,"gjerdrum.no":true,"gjerstad.no":true,"gjesdal.no":true,"gjovik.no":true,"xn--gjvik-wua.no":true,"gloppen.no":true,"gol.no":true,"gran.no":true,"grane.no":true,"granvin.no":true,"gratangen.no":true,"grimstad.no":true,"grong.no":true,"kraanghke.no":true,"xn--kranghke-b0a.no":true,"grue.no":true,"gulen.no":true,"hadsel.no":true,"halden.no":true,"halsa.no":true,"hamar.no":true,"hamaroy.no":true,"habmer.no":true,"xn--hbmer-xqa.no":true,"hapmir.no":true,"xn--hpmir-xqa.no":true,"hammerfest.no":true,"hammarfeasta.no":true,"xn--hmmrfeasta-s4ac.no":true,"haram.no":true,"hareid.no":true,"harstad.no":true,"hasvik.no":true,"aknoluokta.no":true,"xn--koluokta-7ya57h.no":true,"hattfjelldal.no":true,"aarborte.no":true,"haugesund.no":true,"hemne.no":true,"hemnes.no":true,"hemsedal.no":true,"heroy.more-og-romsdal.no":true,"xn--hery-ira.xn--mre-og-romsdal-qqb.no":true,"heroy.nordland.no":true,"xn--hery-ira.nordland.no":true,"hitra.no":true,"hjartdal.no":true,"hjelmeland.no":true,"hobol.no":true,"xn--hobl-ira.no":true,"hof.no":true,"hol.no":true,"hole.no":true,"holmestrand.no":true,"holtalen.no":true,"xn--holtlen-hxa.no":true,"hornindal.no":true,"horten.no":true,"hurdal.no":true,"hurum.no":true,"hvaler.no":true,"hyllestad.no":true,"hagebostad.no":true,"xn--hgebostad-g3a.no":true,"hoyanger.no":true,"xn--hyanger-q1a.no":true,"hoylandet.no":true,"xn--hylandet-54a.no":true,"ha.no":true,"xn--h-2fa.no":true,"ibestad.no":true,"inderoy.no":true,"xn--indery-fya.no":true,"iveland.no":true,"jevnaker.no":true,"jondal.no":true,"jolster.no":true,"xn--jlster-bya.no":true,"karasjok.no":true,"karasjohka.no":true,"xn--krjohka-hwab49j.no":true,"karlsoy.no":true,"galsa.no":true,"xn--gls-elac.no":true,"karmoy.no":true,"xn--karmy-yua.no":true,"kautokeino.no":true,"guovdageaidnu.no":true,"klepp.no":true,"klabu.no":true,"xn--klbu-woa.no":true,"kongsberg.no":true,"kongsvinger.no":true,"kragero.no":true,"xn--krager-gya.no":true,"kristiansand.no":true,"kristiansund.no":true,"krodsherad.no":true,"xn--krdsherad-m8a.no":true,"kvalsund.no":true,"rahkkeravju.no":true,"xn--rhkkervju-01af.no":true,"kvam.no":true,"kvinesdal.no":true,"kvinnherad.no":true,"kviteseid.no":true,"kvitsoy.no":true,"xn--kvitsy-fya.no":true,"kvafjord.no":true,"xn--kvfjord-nxa.no":true,"giehtavuoatna.no":true,"kvanangen.no":true,"xn--kvnangen-k0a.no":true,"navuotna.no":true,"xn--nvuotna-hwa.no":true,"kafjord.no":true,"xn--kfjord-iua.no":true,"gaivuotna.no":true,"xn--givuotna-8ya.no":true,"larvik.no":true,"lavangen.no":true,"lavagis.no":true,"loabat.no":true,"xn--loabt-0qa.no":true,"lebesby.no":true,"davvesiida.no":true,"leikanger.no":true,"leirfjord.no":true,"leka.no":true,"leksvik.no":true,"lenvik.no":true,"leangaviika.no":true,"xn--leagaviika-52b.no":true,"lesja.no":true,"levanger.no":true,"lier.no":true,"lierne.no":true,"lillehammer.no":true,"lillesand.no":true,"lindesnes.no":true,"lindas.no":true,"xn--linds-pra.no":true,"lom.no":true,"loppa.no":true,"lahppi.no":true,"xn--lhppi-xqa.no":true,"lund.no":true,"lunner.no":true,"luroy.no":true,"xn--lury-ira.no":true,"luster.no":true,"lyngdal.no":true,"lyngen.no":true,"ivgu.no":true,"lardal.no":true,"lerdal.no":true,"xn--lrdal-sra.no":true,"lodingen.no":true,"xn--ldingen-q1a.no":true,"lorenskog.no":true,"xn--lrenskog-54a.no":true,"loten.no":true,"xn--lten-gra.no":true,"malvik.no":true,"masoy.no":true,"xn--msy-ula0h.no":true,"muosat.no":true,"xn--muost-0qa.no":true,"mandal.no":true,"marker.no":true,"marnardal.no":true,"masfjorden.no":true,"meland.no":true,"meldal.no":true,"melhus.no":true,"meloy.no":true,"xn--mely-ira.no":true,"meraker.no":true,"xn--merker-kua.no":true,"moareke.no":true,"xn--moreke-jua.no":true,"midsund.no":true,"midtre-gauldal.no":true,"modalen.no":true,"modum.no":true,"molde.no":true,"moskenes.no":true,"moss.no":true,"mosvik.no":true,"malselv.no":true,"xn--mlselv-iua.no":true,"malatvuopmi.no":true,"xn--mlatvuopmi-s4a.no":true,"namdalseid.no":true,"aejrie.no":true,"namsos.no":true,"namsskogan.no":true,"naamesjevuemie.no":true,"xn--nmesjevuemie-tcba.no":true,"laakesvuemie.no":true,"nannestad.no":true,"narvik.no":true,"narviika.no":true,"naustdal.no":true,"nedre-eiker.no":true,"nes.akershus.no":true,"nes.buskerud.no":true,"nesna.no":true,"nesodden.no":true,"nesseby.no":true,"unjarga.no":true,"xn--unjrga-rta.no":true,"nesset.no":true,"nissedal.no":true,"nittedal.no":true,"nord-aurdal.no":true,"nord-fron.no":true,"nord-odal.no":true,"norddal.no":true,"nordkapp.no":true,"davvenjarga.no":true,"xn--davvenjrga-y4a.no":true,"nordre-land.no":true,"nordreisa.no":true,"raisa.no":true,"xn--risa-5na.no":true,"nore-og-uvdal.no":true,"notodden.no":true,"naroy.no":true,"xn--nry-yla5g.no":true,"notteroy.no":true,"xn--nttery-byae.no":true,"odda.no":true,"oksnes.no":true,"xn--ksnes-uua.no":true,"oppdal.no":true,"oppegard.no":true,"xn--oppegrd-ixa.no":true,"orkdal.no":true,"orland.no":true,"xn--rland-uua.no":true,"orskog.no":true,"xn--rskog-uua.no":true,"orsta.no":true,"xn--rsta-fra.no":true,"os.hedmark.no":true,"os.hordaland.no":true,"osen.no":true,"osteroy.no":true,"xn--ostery-fya.no":true,"ostre-toten.no":true,"xn--stre-toten-zcb.no":true,"overhalla.no":true,"ovre-eiker.no":true,"xn--vre-eiker-k8a.no":true,"oyer.no":true,"xn--yer-zna.no":true,"oygarden.no":true,"xn--ygarden-p1a.no":true,"oystre-slidre.no":true,"xn--ystre-slidre-ujb.no":true,"porsanger.no":true,"porsangu.no":true,"xn--porsgu-sta26f.no":true,"porsgrunn.no":true,"radoy.no":true,"xn--rady-ira.no":true,"rakkestad.no":true,"rana.no":true,"ruovat.no":true,"randaberg.no":true,"rauma.no":true,"rendalen.no":true,"rennebu.no":true,"rennesoy.no":true,"xn--rennesy-v1a.no":true,"rindal.no":true,"ringebu.no":true,"ringerike.no":true,"ringsaker.no":true,"rissa.no":true,"risor.no":true,"xn--risr-ira.no":true,"roan.no":true,"rollag.no":true,"rygge.no":true,"ralingen.no":true,"xn--rlingen-mxa.no":true,"rodoy.no":true,"xn--rdy-0nab.no":true,"romskog.no":true,"xn--rmskog-bya.no":true,"roros.no":true,"xn--rros-gra.no":true,"rost.no":true,"xn--rst-0na.no":true,"royken.no":true,"xn--ryken-vua.no":true,"royrvik.no":true,"xn--ryrvik-bya.no":true,"rade.no":true,"xn--rde-ula.no":true,"salangen.no":true,"siellak.no":true,"saltdal.no":true,"salat.no":true,"xn--slt-elab.no":true,"xn--slat-5na.no":true,"samnanger.no":true,"sande.more-og-romsdal.no":true,"sande.xn--mre-og-romsdal-qqb.no":true,"sande.vestfold.no":true,"sandefjord.no":true,"sandnes.no":true,"sandoy.no":true,"xn--sandy-yua.no":true,"sarpsborg.no":true,"sauda.no":true,"sauherad.no":true,"sel.no":true,"selbu.no":true,"selje.no":true,"seljord.no":true,"sigdal.no":true,"siljan.no":true,"sirdal.no":true,"skaun.no":true,"skedsmo.no":true,"ski.no":true,"skien.no":true,"skiptvet.no":true,"skjervoy.no":true,"xn--skjervy-v1a.no":true,"skierva.no":true,"xn--skierv-uta.no":true,"skjak.no":true,"xn--skjk-soa.no":true,"skodje.no":true,"skanland.no":true,"xn--sknland-fxa.no":true,"skanit.no":true,"xn--sknit-yqa.no":true,"smola.no":true,"xn--smla-hra.no":true,"snillfjord.no":true,"snasa.no":true,"xn--snsa-roa.no":true,"snoasa.no":true,"snaase.no":true,"xn--snase-nra.no":true,"sogndal.no":true,"sokndal.no":true,"sola.no":true,"solund.no":true,"songdalen.no":true,"sortland.no":true,"spydeberg.no":true,"stange.no":true,"stavanger.no":true,"steigen.no":true,"steinkjer.no":true,"stjordal.no":true,"xn--stjrdal-s1a.no":true,"stokke.no":true,"stor-elvdal.no":true,"stord.no":true,"stordal.no":true,"storfjord.no":true,"omasvuotna.no":true,"strand.no":true,"stranda.no":true,"stryn.no":true,"sula.no":true,"suldal.no":true,"sund.no":true,"sunndal.no":true,"surnadal.no":true,"sveio.no":true,"svelvik.no":true,"sykkylven.no":true,"sogne.no":true,"xn--sgne-gra.no":true,"somna.no":true,"xn--smna-gra.no":true,"sondre-land.no":true,"xn--sndre-land-0cb.no":true,"sor-aurdal.no":true,"xn--sr-aurdal-l8a.no":true,"sor-fron.no":true,"xn--sr-fron-q1a.no":true,"sor-odal.no":true,"xn--sr-odal-q1a.no":true,"sor-varanger.no":true,"xn--sr-varanger-ggb.no":true,"matta-varjjat.no":true,"xn--mtta-vrjjat-k7af.no":true,"sorfold.no":true,"xn--srfold-bya.no":true,"sorreisa.no":true,"xn--srreisa-q1a.no":true,"sorum.no":true,"xn--srum-gra.no":true,"tana.no":true,"deatnu.no":true,"time.no":true,"tingvoll.no":true,"tinn.no":true,"tjeldsund.no":true,"dielddanuorri.no":true,"tjome.no":true,"xn--tjme-hra.no":true,"tokke.no":true,"tolga.no":true,"torsken.no":true,"tranoy.no":true,"xn--trany-yua.no":true,"tromso.no":true,"xn--troms-zua.no":true,"tromsa.no":true,"romsa.no":true,"trondheim.no":true,"troandin.no":true,"trysil.no":true,"trana.no":true,"xn--trna-woa.no":true,"trogstad.no":true,"xn--trgstad-r1a.no":true,"tvedestrand.no":true,"tydal.no":true,"tynset.no":true,"tysfjord.no":true,"divtasvuodna.no":true,"divttasvuotna.no":true,"tysnes.no":true,"tysvar.no":true,"xn--tysvr-vra.no":true,"tonsberg.no":true,"xn--tnsberg-q1a.no":true,"ullensaker.no":true,"ullensvang.no":true,"ulvik.no":true,"utsira.no":true,"vadso.no":true,"xn--vads-jra.no":true,"cahcesuolo.no":true,"xn--hcesuolo-7ya35b.no":true,"vaksdal.no":true,"valle.no":true,"vang.no":true,"vanylven.no":true,"vardo.no":true,"xn--vard-jra.no":true,"varggat.no":true,"xn--vrggt-xqad.no":true,"vefsn.no":true,"vaapste.no":true,"vega.no":true,"vegarshei.no":true,"xn--vegrshei-c0a.no":true,"vennesla.no":true,"verdal.no":true,"verran.no":true,"vestby.no":true,"vestnes.no":true,"vestre-slidre.no":true,"vestre-toten.no":true,"vestvagoy.no":true,"xn--vestvgy-ixa6o.no":true,"vevelstad.no":true,"vik.no":true,"vikna.no":true,"vindafjord.no":true,"volda.no":true,"voss.no":true,"varoy.no":true,"xn--vry-yla5g.no":true,"vagan.no":true,"xn--vgan-qoa.no":true,"voagat.no":true,"vagsoy.no":true,"xn--vgsy-qoa0j.no":true,"vaga.no":true,"xn--vg-yiab.no":true,"valer.ostfold.no":true,"xn--vler-qoa.xn--stfold-9xa.no":true,"valer.hedmark.no":true,"xn--vler-qoa.hedmark.no":true,"*.np":true,"nr":true,"biz.nr":true,"info.nr":true,"gov.nr":true,"edu.nr":true,"org.nr":true,"net.nr":true,"com.nr":true,"nu":true,"nz":true,"ac.nz":true,"co.nz":true,"cri.nz":true,"geek.nz":true,"gen.nz":true,"govt.nz":true,"health.nz":true,"iwi.nz":true,"kiwi.nz":true,"maori.nz":true,"mil.nz":true,"xn--mori-qsa.nz":true,"net.nz":true,"org.nz":true,"parliament.nz":true,"school.nz":true,"om":true,"co.om":true,"com.om":true,"edu.om":true,"gov.om":true,"med.om":true,"museum.om":true,"net.om":true,"org.om":true,"pro.om":true,"org":true,"pa":true,"ac.pa":true,"gob.pa":true,"com.pa":true,"org.pa":true,"sld.pa":true,"edu.pa":true,"net.pa":true,"ing.pa":true,"abo.pa":true,"med.pa":true,"nom.pa":true,"pe":true,"edu.pe":true,"gob.pe":true,"nom.pe":true,"mil.pe":true,"org.pe":true,"com.pe":true,"net.pe":true,"pf":true,"com.pf":true,"org.pf":true,"edu.pf":true,"*.pg":true,"ph":true,"com.ph":true,"net.ph":true,"org.ph":true,"gov.ph":true,"edu.ph":true,"ngo.ph":true,"mil.ph":true,"i.ph":true,"pk":true,"com.pk":true,"net.pk":true,"edu.pk":true,"org.pk":true,"fam.pk":true,"biz.pk":true,"web.pk":true,"gov.pk":true,"gob.pk":true,"gok.pk":true,"gon.pk":true,"gop.pk":true,"gos.pk":true,"info.pk":true,"pl":true,"com.pl":true,"net.pl":true,"org.pl":true,"aid.pl":true,"agro.pl":true,"atm.pl":true,"auto.pl":true,"biz.pl":true,"edu.pl":true,"gmina.pl":true,"gsm.pl":true,"info.pl":true,"mail.pl":true,"miasta.pl":true,"media.pl":true,"mil.pl":true,"nieruchomosci.pl":true,"nom.pl":true,"pc.pl":true,"powiat.pl":true,"priv.pl":true,"realestate.pl":true,"rel.pl":true,"sex.pl":true,"shop.pl":true,"sklep.pl":true,"sos.pl":true,"szkola.pl":true,"targi.pl":true,"tm.pl":true,"tourism.pl":true,"travel.pl":true,"turystyka.pl":true,"gov.pl":true,"ap.gov.pl":true,"ic.gov.pl":true,"is.gov.pl":true,"us.gov.pl":true,"kmpsp.gov.pl":true,"kppsp.gov.pl":true,"kwpsp.gov.pl":true,"psp.gov.pl":true,"wskr.gov.pl":true,"kwp.gov.pl":true,"mw.gov.pl":true,"ug.gov.pl":true,"um.gov.pl":true,"umig.gov.pl":true,"ugim.gov.pl":true,"upow.gov.pl":true,"uw.gov.pl":true,"starostwo.gov.pl":true,"pa.gov.pl":true,"po.gov.pl":true,"psse.gov.pl":true,"pup.gov.pl":true,"rzgw.gov.pl":true,"sa.gov.pl":true,"so.gov.pl":true,"sr.gov.pl":true,"wsa.gov.pl":true,"sko.gov.pl":true,"uzs.gov.pl":true,"wiih.gov.pl":true,"winb.gov.pl":true,"pinb.gov.pl":true,"wios.gov.pl":true,"witd.gov.pl":true,"wzmiuw.gov.pl":true,"piw.gov.pl":true,"wiw.gov.pl":true,"griw.gov.pl":true,"wif.gov.pl":true,"oum.gov.pl":true,"sdn.gov.pl":true,"zp.gov.pl":true,"uppo.gov.pl":true,"mup.gov.pl":true,"wuoz.gov.pl":true,"konsulat.gov.pl":true,"oirm.gov.pl":true,"augustow.pl":true,"babia-gora.pl":true,"bedzin.pl":true,"beskidy.pl":true,"bialowieza.pl":true,"bialystok.pl":true,"bielawa.pl":true,"bieszczady.pl":true,"boleslawiec.pl":true,"bydgoszcz.pl":true,"bytom.pl":true,"cieszyn.pl":true,"czeladz.pl":true,"czest.pl":true,"dlugoleka.pl":true,"elblag.pl":true,"elk.pl":true,"glogow.pl":true,"gniezno.pl":true,"gorlice.pl":true,"grajewo.pl":true,"ilawa.pl":true,"jaworzno.pl":true,"jelenia-gora.pl":true,"jgora.pl":true,"kalisz.pl":true,"kazimierz-dolny.pl":true,"karpacz.pl":true,"kartuzy.pl":true,"kaszuby.pl":true,"katowice.pl":true,"kepno.pl":true,"ketrzyn.pl":true,"klodzko.pl":true,"kobierzyce.pl":true,"kolobrzeg.pl":true,"konin.pl":true,"konskowola.pl":true,"kutno.pl":true,"lapy.pl":true,"lebork.pl":true,"legnica.pl":true,"lezajsk.pl":true,"limanowa.pl":true,"lomza.pl":true,"lowicz.pl":true,"lubin.pl":true,"lukow.pl":true,"malbork.pl":true,"malopolska.pl":true,"mazowsze.pl":true,"mazury.pl":true,"mielec.pl":true,"mielno.pl":true,"mragowo.pl":true,"naklo.pl":true,"nowaruda.pl":true,"nysa.pl":true,"olawa.pl":true,"olecko.pl":true,"olkusz.pl":true,"olsztyn.pl":true,"opoczno.pl":true,"opole.pl":true,"ostroda.pl":true,"ostroleka.pl":true,"ostrowiec.pl":true,"ostrowwlkp.pl":true,"pila.pl":true,"pisz.pl":true,"podhale.pl":true,"podlasie.pl":true,"polkowice.pl":true,"pomorze.pl":true,"pomorskie.pl":true,"prochowice.pl":true,"pruszkow.pl":true,"przeworsk.pl":true,"pulawy.pl":true,"radom.pl":true,"rawa-maz.pl":true,"rybnik.pl":true,"rzeszow.pl":true,"sanok.pl":true,"sejny.pl":true,"slask.pl":true,"slupsk.pl":true,"sosnowiec.pl":true,"stalowa-wola.pl":true,"skoczow.pl":true,"starachowice.pl":true,"stargard.pl":true,"suwalki.pl":true,"swidnica.pl":true,"swiebodzin.pl":true,"swinoujscie.pl":true,"szczecin.pl":true,"szczytno.pl":true,"tarnobrzeg.pl":true,"tgory.pl":true,"turek.pl":true,"tychy.pl":true,"ustka.pl":true,"walbrzych.pl":true,"warmia.pl":true,"warszawa.pl":true,"waw.pl":true,"wegrow.pl":true,"wielun.pl":true,"wlocl.pl":true,"wloclawek.pl":true,"wodzislaw.pl":true,"wolomin.pl":true,"wroclaw.pl":true,"zachpomor.pl":true,"zagan.pl":true,"zarow.pl":true,"zgora.pl":true,"zgorzelec.pl":true,"pm":true,"pn":true,"gov.pn":true,"co.pn":true,"org.pn":true,"edu.pn":true,"net.pn":true,"post":true,"pr":true,"com.pr":true,"net.pr":true,"org.pr":true,"gov.pr":true,"edu.pr":true,"isla.pr":true,"pro.pr":true,"biz.pr":true,"info.pr":true,"name.pr":true,"est.pr":true,"prof.pr":true,"ac.pr":true,"pro":true,"aca.pro":true,"bar.pro":true,"cpa.pro":true,"jur.pro":true,"law.pro":true,"med.pro":true,"eng.pro":true,"ps":true,"edu.ps":true,"gov.ps":true,"sec.ps":true,"plo.ps":true,"com.ps":true,"org.ps":true,"net.ps":true,"pt":true,"net.pt":true,"gov.pt":true,"org.pt":true,"edu.pt":true,"int.pt":true,"publ.pt":true,"com.pt":true,"nome.pt":true,"pw":true,"co.pw":true,"ne.pw":true,"or.pw":true,"ed.pw":true,"go.pw":true,"belau.pw":true,"py":true,"com.py":true,"coop.py":true,"edu.py":true,"gov.py":true,"mil.py":true,"net.py":true,"org.py":true,"qa":true,"com.qa":true,"edu.qa":true,"gov.qa":true,"mil.qa":true,"name.qa":true,"net.qa":true,"org.qa":true,"sch.qa":true,"re":true,"com.re":true,"asso.re":true,"nom.re":true,"ro":true,"com.ro":true,"org.ro":true,"tm.ro":true,"nt.ro":true,"nom.ro":true,"info.ro":true,"rec.ro":true,"arts.ro":true,"firm.ro":true,"store.ro":true,"www.ro":true,"rs":true,"co.rs":true,"org.rs":true,"edu.rs":true,"ac.rs":true,"gov.rs":true,"in.rs":true,"ru":true,"ac.ru":true,"com.ru":true,"edu.ru":true,"int.ru":true,"net.ru":true,"org.ru":true,"pp.ru":true,"adygeya.ru":true,"altai.ru":true,"amur.ru":true,"arkhangelsk.ru":true,"astrakhan.ru":true,"bashkiria.ru":true,"belgorod.ru":true,"bir.ru":true,"bryansk.ru":true,"buryatia.ru":true,"cbg.ru":true,"chel.ru":true,"chelyabinsk.ru":true,"chita.ru":true,"chukotka.ru":true,"chuvashia.ru":true,"dagestan.ru":true,"dudinka.ru":true,"e-burg.ru":true,"grozny.ru":true,"irkutsk.ru":true,"ivanovo.ru":true,"izhevsk.ru":true,"jar.ru":true,"joshkar-ola.ru":true,"kalmykia.ru":true,"kaluga.ru":true,"kamchatka.ru":true,"karelia.ru":true,"kazan.ru":true,"kchr.ru":true,"kemerovo.ru":true,"khabarovsk.ru":true,"khakassia.ru":true,"khv.ru":true,"kirov.ru":true,"koenig.ru":true,"komi.ru":true,"kostroma.ru":true,"krasnoyarsk.ru":true,"kuban.ru":true,"kurgan.ru":true,"kursk.ru":true,"lipetsk.ru":true,"magadan.ru":true,"mari.ru":true,"mari-el.ru":true,"marine.ru":true,"mordovia.ru":true,"msk.ru":true,"murmansk.ru":true,"nalchik.ru":true,"nnov.ru":true,"nov.ru":true,"novosibirsk.ru":true,"nsk.ru":true,"omsk.ru":true,"orenburg.ru":true,"oryol.ru":true,"palana.ru":true,"penza.ru":true,"perm.ru":true,"ptz.ru":true,"rnd.ru":true,"ryazan.ru":true,"sakhalin.ru":true,"samara.ru":true,"saratov.ru":true,"simbirsk.ru":true,"smolensk.ru":true,"spb.ru":true,"stavropol.ru":true,"stv.ru":true,"surgut.ru":true,"tambov.ru":true,"tatarstan.ru":true,"tom.ru":true,"tomsk.ru":true,"tsaritsyn.ru":true,"tsk.ru":true,"tula.ru":true,"tuva.ru":true,"tver.ru":true,"tyumen.ru":true,"udm.ru":true,"udmurtia.ru":true,"ulan-ude.ru":true,"vladikavkaz.ru":true,"vladimir.ru":true,"vladivostok.ru":true,"volgograd.ru":true,"vologda.ru":true,"voronezh.ru":true,"vrn.ru":true,"vyatka.ru":true,"yakutia.ru":true,"yamal.ru":true,"yaroslavl.ru":true,"yekaterinburg.ru":true,"yuzhno-sakhalinsk.ru":true,"amursk.ru":true,"baikal.ru":true,"cmw.ru":true,"fareast.ru":true,"jamal.ru":true,"kms.ru":true,"k-uralsk.ru":true,"kustanai.ru":true,"kuzbass.ru":true,"magnitka.ru":true,"mytis.ru":true,"nakhodka.ru":true,"nkz.ru":true,"norilsk.ru":true,"oskol.ru":true,"pyatigorsk.ru":true,"rubtsovsk.ru":true,"snz.ru":true,"syzran.ru":true,"vdonsk.ru":true,"zgrad.ru":true,"gov.ru":true,"mil.ru":true,"test.ru":true,"rw":true,"gov.rw":true,"net.rw":true,"edu.rw":true,"ac.rw":true,"com.rw":true,"co.rw":true,"int.rw":true,"mil.rw":true,"gouv.rw":true,"sa":true,"com.sa":true,"net.sa":true,"org.sa":true,"gov.sa":true,"med.sa":true,"pub.sa":true,"edu.sa":true,"sch.sa":true,"sb":true,"com.sb":true,"edu.sb":true,"gov.sb":true,"net.sb":true,"org.sb":true,"sc":true,"com.sc":true,"gov.sc":true,"net.sc":true,"org.sc":true,"edu.sc":true,"sd":true,"com.sd":true,"net.sd":true,"org.sd":true,"edu.sd":true,"med.sd":true,"tv.sd":true,"gov.sd":true,"info.sd":true,"se":true,"a.se":true,"ac.se":true,"b.se":true,"bd.se":true,"brand.se":true,"c.se":true,"d.se":true,"e.se":true,"f.se":true,"fh.se":true,"fhsk.se":true,"fhv.se":true,"g.se":true,"h.se":true,"i.se":true,"k.se":true,"komforb.se":true,"kommunalforbund.se":true,"komvux.se":true,"l.se":true,"lanbib.se":true,"m.se":true,"n.se":true,"naturbruksgymn.se":true,"o.se":true,"org.se":true,"p.se":true,"parti.se":true,"pp.se":true,"press.se":true,"r.se":true,"s.se":true,"t.se":true,"tm.se":true,"u.se":true,"w.se":true,"x.se":true,"y.se":true,"z.se":true,"sg":true,"com.sg":true,"net.sg":true,"org.sg":true,"gov.sg":true,"edu.sg":true,"per.sg":true,"sh":true,"com.sh":true,"net.sh":true,"gov.sh":true,"org.sh":true,"mil.sh":true,"si":true,"sj":true,"sk":true,"sl":true,"com.sl":true,"net.sl":true,"edu.sl":true,"gov.sl":true,"org.sl":true,"sm":true,"sn":true,"art.sn":true,"com.sn":true,"edu.sn":true,"gouv.sn":true,"org.sn":true,"perso.sn":true,"univ.sn":true,"so":true,"com.so":true,"net.so":true,"org.so":true,"sr":true,"st":true,"co.st":true,"com.st":true,"consulado.st":true,"edu.st":true,"embaixada.st":true,"gov.st":true,"mil.st":true,"net.st":true,"org.st":true,"principe.st":true,"saotome.st":true,"store.st":true,"su":true,"adygeya.su":true,"arkhangelsk.su":true,"balashov.su":true,"bashkiria.su":true,"bryansk.su":true,"dagestan.su":true,"grozny.su":true,"ivanovo.su":true,"kalmykia.su":true,"kaluga.su":true,"karelia.su":true,"khakassia.su":true,"krasnodar.su":true,"kurgan.su":true,"lenug.su":true,"mordovia.su":true,"msk.su":true,"murmansk.su":true,"nalchik.su":true,"nov.su":true,"obninsk.su":true,"penza.su":true,"pokrovsk.su":true,"sochi.su":true,"spb.su":true,"togliatti.su":true,"troitsk.su":true,"tula.su":true,"tuva.su":true,"vladikavkaz.su":true,"vladimir.su":true,"vologda.su":true,"sv":true,"com.sv":true,"edu.sv":true,"gob.sv":true,"org.sv":true,"red.sv":true,"sx":true,"gov.sx":true,"sy":true,"edu.sy":true,"gov.sy":true,"net.sy":true,"mil.sy":true,"com.sy":true,"org.sy":true,"sz":true,"co.sz":true,"ac.sz":true,"org.sz":true,"tc":true,"td":true,"tel":true,"tf":true,"tg":true,"th":true,"ac.th":true,"co.th":true,"go.th":true,"in.th":true,"mi.th":true,"net.th":true,"or.th":true,"tj":true,"ac.tj":true,"biz.tj":true,"co.tj":true,"com.tj":true,"edu.tj":true,"go.tj":true,"gov.tj":true,"int.tj":true,"mil.tj":true,"name.tj":true,"net.tj":true,"nic.tj":true,"org.tj":true,"test.tj":true,"web.tj":true,"tk":true,"tl":true,"gov.tl":true,"tm":true,"com.tm":true,"co.tm":true,"org.tm":true,"net.tm":true,"nom.tm":true,"gov.tm":true,"mil.tm":true,"edu.tm":true,"tn":true,"com.tn":true,"ens.tn":true,"fin.tn":true,"gov.tn":true,"ind.tn":true,"intl.tn":true,"nat.tn":true,"net.tn":true,"org.tn":true,"info.tn":true,"perso.tn":true,"tourism.tn":true,"edunet.tn":true,"rnrt.tn":true,"rns.tn":true,"rnu.tn":true,"mincom.tn":true,"agrinet.tn":true,"defense.tn":true,"turen.tn":true,"to":true,"com.to":true,"gov.to":true,"net.to":true,"org.to":true,"edu.to":true,"mil.to":true,"tp":true,"tr":true,"com.tr":true,"info.tr":true,"biz.tr":true,"net.tr":true,"org.tr":true,"web.tr":true,"gen.tr":true,"tv.tr":true,"av.tr":true,"dr.tr":true,"bbs.tr":true,"name.tr":true,"tel.tr":true,"gov.tr":true,"bel.tr":true,"pol.tr":true,"mil.tr":true,"k12.tr":true,"edu.tr":true,"kep.tr":true,"nc.tr":true,"gov.nc.tr":true,"travel":true,"tt":true,"co.tt":true,"com.tt":true,"org.tt":true,"net.tt":true,"biz.tt":true,"info.tt":true,"pro.tt":true,"int.tt":true,"coop.tt":true,"jobs.tt":true,"mobi.tt":true,"travel.tt":true,"museum.tt":true,"aero.tt":true,"name.tt":true,"gov.tt":true,"edu.tt":true,"tv":true,"tw":true,"edu.tw":true,"gov.tw":true,"mil.tw":true,"com.tw":true,"net.tw":true,"org.tw":true,"idv.tw":true,"game.tw":true,"ebiz.tw":true,"club.tw":true,"xn--zf0ao64a.tw":true,"xn--uc0atv.tw":true,"xn--czrw28b.tw":true,"tz":true,"ac.tz":true,"co.tz":true,"go.tz":true,"hotel.tz":true,"info.tz":true,"me.tz":true,"mil.tz":true,"mobi.tz":true,"ne.tz":true,"or.tz":true,"sc.tz":true,"tv.tz":true,"ua":true,"com.ua":true,"edu.ua":true,"gov.ua":true,"in.ua":true,"net.ua":true,"org.ua":true,"cherkassy.ua":true,"cherkasy.ua":true,"chernigov.ua":true,"chernihiv.ua":true,"chernivtsi.ua":true,"chernovtsy.ua":true,"ck.ua":true,"cn.ua":true,"cr.ua":true,"crimea.ua":true,"cv.ua":true,"dn.ua":true,"dnepropetrovsk.ua":true,"dnipropetrovsk.ua":true,"dominic.ua":true,"donetsk.ua":true,"dp.ua":true,"if.ua":true,"ivano-frankivsk.ua":true,"kh.ua":true,"kharkiv.ua":true,"kharkov.ua":true,"kherson.ua":true,"khmelnitskiy.ua":true,"khmelnytskyi.ua":true,"kiev.ua":true,"kirovograd.ua":true,"km.ua":true,"kr.ua":true,"krym.ua":true,"ks.ua":true,"kv.ua":true,"kyiv.ua":true,"lg.ua":true,"lt.ua":true,"lugansk.ua":true,"lutsk.ua":true,"lv.ua":true,"lviv.ua":true,"mk.ua":true,"mykolaiv.ua":true,"nikolaev.ua":true,"od.ua":true,"odesa.ua":true,"odessa.ua":true,"pl.ua":true,"poltava.ua":true,"rivne.ua":true,"rovno.ua":true,"rv.ua":true,"sb.ua":true,"sebastopol.ua":true,"sevastopol.ua":true,"sm.ua":true,"sumy.ua":true,"te.ua":true,"ternopil.ua":true,"uz.ua":true,"uzhgorod.ua":true,"vinnica.ua":true,"vinnytsia.ua":true,"vn.ua":true,"volyn.ua":true,"yalta.ua":true,"zaporizhzhe.ua":true,"zaporizhzhia.ua":true,"zhitomir.ua":true,"zhytomyr.ua":true,"zp.ua":true,"zt.ua":true,"ug":true,"co.ug":true,"or.ug":true,"ac.ug":true,"sc.ug":true,"go.ug":true,"ne.ug":true,"com.ug":true,"org.ug":true,"uk":true,"ac.uk":true,"co.uk":true,"gov.uk":true,"ltd.uk":true,"me.uk":true,"net.uk":true,"nhs.uk":true,"org.uk":true,"plc.uk":true,"police.uk":true,"*.sch.uk":true,"us":true,"dni.us":true,"fed.us":true,"isa.us":true,"kids.us":true,"nsn.us":true,"ak.us":true,"al.us":true,"ar.us":true,"as.us":true,"az.us":true,"ca.us":true,"co.us":true,"ct.us":true,"dc.us":true,"de.us":true,"fl.us":true,"ga.us":true,"gu.us":true,"hi.us":true,"ia.us":true,"id.us":true,"il.us":true,"in.us":true,"ks.us":true,"ky.us":true,"la.us":true,"ma.us":true,"md.us":true,"me.us":true,"mi.us":true,"mn.us":true,"mo.us":true,"ms.us":true,"mt.us":true,"nc.us":true,"nd.us":true,"ne.us":true,"nh.us":true,"nj.us":true,"nm.us":true,"nv.us":true,"ny.us":true,"oh.us":true,"ok.us":true,"or.us":true,"pa.us":true,"pr.us":true,"ri.us":true,"sc.us":true,"sd.us":true,"tn.us":true,"tx.us":true,"ut.us":true,"vi.us":true,"vt.us":true,"va.us":true,"wa.us":true,"wi.us":true,"wv.us":true,"wy.us":true,"k12.ak.us":true,"k12.al.us":true,"k12.ar.us":true,"k12.as.us":true,"k12.az.us":true,"k12.ca.us":true,"k12.co.us":true,"k12.ct.us":true,"k12.dc.us":true,"k12.de.us":true,"k12.fl.us":true,"k12.ga.us":true,"k12.gu.us":true,"k12.ia.us":true,"k12.id.us":true,"k12.il.us":true,"k12.in.us":true,"k12.ks.us":true,"k12.ky.us":true,"k12.la.us":true,"k12.ma.us":true,"k12.md.us":true,"k12.me.us":true,"k12.mi.us":true,"k12.mn.us":true,"k12.mo.us":true,"k12.ms.us":true,"k12.mt.us":true,"k12.nc.us":true,"k12.ne.us":true,"k12.nh.us":true,"k12.nj.us":true,"k12.nm.us":true,"k12.nv.us":true,"k12.ny.us":true,"k12.oh.us":true,"k12.ok.us":true,"k12.or.us":true,"k12.pa.us":true,"k12.pr.us":true,"k12.ri.us":true,"k12.sc.us":true,"k12.tn.us":true,"k12.tx.us":true,"k12.ut.us":true,"k12.vi.us":true,"k12.vt.us":true,"k12.va.us":true,"k12.wa.us":true,"k12.wi.us":true,"k12.wy.us":true,"cc.ak.us":true,"cc.al.us":true,"cc.ar.us":true,"cc.as.us":true,"cc.az.us":true,"cc.ca.us":true,"cc.co.us":true,"cc.ct.us":true,"cc.dc.us":true,"cc.de.us":true,"cc.fl.us":true,"cc.ga.us":true,"cc.gu.us":true,"cc.hi.us":true,"cc.ia.us":true,"cc.id.us":true,"cc.il.us":true,"cc.in.us":true,"cc.ks.us":true,"cc.ky.us":true,"cc.la.us":true,"cc.ma.us":true,"cc.md.us":true,"cc.me.us":true,"cc.mi.us":true,"cc.mn.us":true,"cc.mo.us":true,"cc.ms.us":true,"cc.mt.us":true,"cc.nc.us":true,"cc.nd.us":true,"cc.ne.us":true,"cc.nh.us":true,"cc.nj.us":true,"cc.nm.us":true,"cc.nv.us":true,"cc.ny.us":true,"cc.oh.us":true,"cc.ok.us":true,"cc.or.us":true,"cc.pa.us":true,"cc.pr.us":true,"cc.ri.us":true,"cc.sc.us":true,"cc.sd.us":true,"cc.tn.us":true,"cc.tx.us":true,"cc.ut.us":true,"cc.vi.us":true,"cc.vt.us":true,"cc.va.us":true,"cc.wa.us":true,"cc.wi.us":true,"cc.wv.us":true,"cc.wy.us":true,"lib.ak.us":true,"lib.al.us":true,"lib.ar.us":true,"lib.as.us":true,"lib.az.us":true,"lib.ca.us":true,"lib.co.us":true,"lib.ct.us":true,"lib.dc.us":true,"lib.de.us":true,"lib.fl.us":true,"lib.ga.us":true,"lib.gu.us":true,"lib.hi.us":true,"lib.ia.us":true,"lib.id.us":true,"lib.il.us":true,"lib.in.us":true,"lib.ks.us":true,"lib.ky.us":true,"lib.la.us":true,"lib.ma.us":true,"lib.md.us":true,"lib.me.us":true,"lib.mi.us":true,"lib.mn.us":true,"lib.mo.us":true,"lib.ms.us":true,"lib.mt.us":true,"lib.nc.us":true,"lib.nd.us":true,"lib.ne.us":true,"lib.nh.us":true,"lib.nj.us":true,"lib.nm.us":true,"lib.nv.us":true,"lib.ny.us":true,"lib.oh.us":true,"lib.ok.us":true,"lib.or.us":true,"lib.pa.us":true,"lib.pr.us":true,"lib.ri.us":true,"lib.sc.us":true,"lib.sd.us":true,"lib.tn.us":true,"lib.tx.us":true,"lib.ut.us":true,"lib.vi.us":true,"lib.vt.us":true,"lib.va.us":true,"lib.wa.us":true,"lib.wi.us":true,"lib.wy.us":true,"pvt.k12.ma.us":true,"chtr.k12.ma.us":true,"paroch.k12.ma.us":true,"uy":true,"com.uy":true,"edu.uy":true,"gub.uy":true,"mil.uy":true,"net.uy":true,"org.uy":true,"uz":true,"co.uz":true,"com.uz":true,"net.uz":true,"org.uz":true,"va":true,"vc":true,"com.vc":true,"net.vc":true,"org.vc":true,"gov.vc":true,"mil.vc":true,"edu.vc":true,"ve":true,"arts.ve":true,"co.ve":true,"com.ve":true,"e12.ve":true,"edu.ve":true,"firm.ve":true,"gob.ve":true,"gov.ve":true,"info.ve":true,"int.ve":true,"mil.ve":true,"net.ve":true,"org.ve":true,"rec.ve":true,"store.ve":true,"tec.ve":true,"web.ve":true,"vg":true,"vi":true,"co.vi":true,"com.vi":true,"k12.vi":true,"net.vi":true,"org.vi":true,"vn":true,"com.vn":true,"net.vn":true,"org.vn":true,"edu.vn":true,"gov.vn":true,"int.vn":true,"ac.vn":true,"biz.vn":true,"info.vn":true,"name.vn":true,"pro.vn":true,"health.vn":true,"vu":true,"com.vu":true,"edu.vu":true,"net.vu":true,"org.vu":true,"wf":true,"ws":true,"com.ws":true,"net.ws":true,"org.ws":true,"gov.ws":true,"edu.ws":true,"yt":true,"xn--mgbaam7a8h":true,"xn--y9a3aq":true,"xn--54b7fta0cc":true,"xn--90ais":true,"xn--fiqs8s":true,"xn--fiqz9s":true,"xn--lgbbat1ad8j":true,"xn--wgbh1c":true,"xn--node":true,"xn--qxam":true,"xn--j6w193g":true,"xn--h2brj9c":true,"xn--mgbbh1a71e":true,"xn--fpcrj9c3d":true,"xn--gecrj9c":true,"xn--s9brj9c":true,"xn--45brj9c":true,"xn--xkc2dl3a5ee0h":true,"xn--mgba3a4f16a":true,"xn--mgba3a4fra":true,"xn--mgbtx2b":true,"xn--mgbayh7gpa":true,"xn--3e0b707e":true,"xn--80ao21a":true,"xn--fzc2c9e2c":true,"xn--xkc2al3hye2a":true,"xn--mgbc0a9azcg":true,"xn--d1alf":true,"xn--l1acc":true,"xn--mix891f":true,"xn--mix082f":true,"xn--mgbx4cd0ab":true,"xn--mgb9awbf":true,"xn--mgbai9azgqp6j":true,"xn--mgbai9a5eva00b":true,"xn--ygbi2ammx":true,"xn--90a3ac":true,"xn--o1ac.xn--90a3ac":true,"xn--c1avg.xn--90a3ac":true,"xn--90azh.xn--90a3ac":true,"xn--d1at.xn--90a3ac":true,"xn--o1ach.xn--90a3ac":true,"xn--80au.xn--90a3ac":true,"xn--p1ai":true,"xn--wgbl6a":true,"xn--mgberp4a5d4ar":true,"xn--mgberp4a5d4a87g":true,"xn--mgbqly7c0a67fbc":true,"xn--mgbqly7cvafr":true,"xn--mgbpl2fh":true,"xn--yfro4i67o":true,"xn--clchc0ea0b2g2a9gcd":true,"xn--ogbpf8fl":true,"xn--mgbtf8fl":true,"xn--o3cw4h":true,"xn--pgbs0dh":true,"xn--kpry57d":true,"xn--kprw13d":true,"xn--nnx388a":true,"xn--j1amh":true,"xn--mgb2ddes":true,"xxx":true,"*.ye":true,"ac.za":true,"agrica.za":true,"alt.za":true,"co.za":true,"edu.za":true,"gov.za":true,"grondar.za":true,"law.za":true,"mil.za":true,"net.za":true,"ngo.za":true,"nis.za":true,"nom.za":true,"org.za":true,"school.za":true,"tm.za":true,"web.za":true,"*.zm":true,"*.zw":true,"aaa":true,"aarp":true,"abarth":true,"abb":true,"abbott":true,"abbvie":true,"abc":true,"able":true,"abogado":true,"abudhabi":true,"academy":true,"accenture":true,"accountant":true,"accountants":true,"aco":true,"active":true,"actor":true,"adac":true,"ads":true,"adult":true,"aeg":true,"aetna":true,"afamilycompany":true,"afl":true,"africa":true,"africamagic":true,"agakhan":true,"agency":true,"aig":true,"aigo":true,"airbus":true,"airforce":true,"airtel":true,"akdn":true,"alfaromeo":true,"alibaba":true,"alipay":true,"allfinanz":true,"allstate":true,"ally":true,"alsace":true,"alstom":true,"americanexpress":true,"americanfamily":true,"amex":true,"amfam":true,"amica":true,"amsterdam":true,"analytics":true,"android":true,"anquan":true,"anz":true,"aol":true,"apartments":true,"app":true,"apple":true,"aquarelle":true,"aramco":true,"archi":true,"army":true,"arte":true,"asda":true,"associates":true,"athleta":true,"attorney":true,"auction":true,"audi":true,"audible":true,"audio":true,"auspost":true,"author":true,"auto":true,"autos":true,"avianca":true,"aws":true,"axa":true,"azure":true,"baby":true,"baidu":true,"banamex":true,"bananarepublic":true,"band":true,"bank":true,"bar":true,"barcelona":true,"barclaycard":true,"barclays":true,"barefoot":true,"bargains":true,"basketball":true,"bauhaus":true,"bayern":true,"bbc":true,"bbt":true,"bbva":true,"bcg":true,"bcn":true,"beats":true,"beer":true,"bentley":true,"berlin":true,"best":true,"bestbuy":true,"bet":true,"bharti":true,"bible":true,"bid":true,"bike":true,"bing":true,"bingo":true,"bio":true,"black":true,"blackfriday":true,"blanco":true,"blockbuster":true,"blog":true,"bloomberg":true,"blue":true,"bms":true,"bmw":true,"bnl":true,"bnpparibas":true,"boats":true,"boehringer":true,"bofa":true,"bom":true,"bond":true,"boo":true,"book":true,"booking":true,"boots":true,"bosch":true,"bostik":true,"bot":true,"boutique":true,"bradesco":true,"bridgestone":true,"broadway":true,"broker":true,"brother":true,"brussels":true,"budapest":true,"bugatti":true,"build":true,"builders":true,"business":true,"buy":true,"buzz":true,"bzh":true,"cab":true,"cafe":true,"cal":true,"call":true,"calvinklein":true,"camera":true,"camp":true,"cancerresearch":true,"canon":true,"capetown":true,"capital":true,"capitalone":true,"car":true,"caravan":true,"cards":true,"care":true,"career":true,"careers":true,"cars":true,"cartier":true,"casa":true,"case":true,"caseih":true,"cash":true,"casino":true,"catering":true,"cba":true,"cbn":true,"cbre":true,"cbs":true,"ceb":true,"center":true,"ceo":true,"cern":true,"cfa":true,"cfd":true,"chanel":true,"channel":true,"chase":true,"chat":true,"cheap":true,"chintai":true,"chloe":true,"christmas":true,"chrome":true,"chrysler":true,"church":true,"cipriani":true,"circle":true,"cisco":true,"citadel":true,"citi":true,"citic":true,"city":true,"cityeats":true,"claims":true,"cleaning":true,"click":true,"clinic":true,"clothing":true,"cloud":true,"club":true,"clubmed":true,"coach":true,"codes":true,"coffee":true,"college":true,"cologne":true,"comcast":true,"commbank":true,"community":true,"company":true,"computer":true,"comsec":true,"condos":true,"construction":true,"consulting":true,"contact":true,"contractors":true,"cooking":true,"cookingchannel":true,"cool":true,"corsica":true,"country":true,"coupon":true,"coupons":true,"courses":true,"credit":true,"creditcard":true,"creditunion":true,"cricket":true,"crown":true,"crs":true,"cruises":true,"csc":true,"cuisinella":true,"cymru":true,"cyou":true,"dabur":true,"dad":true,"dance":true,"date":true,"dating":true,"datsun":true,"day":true,"dclk":true,"dds":true,"deal":true,"dealer":true,"deals":true,"degree":true,"delivery":true,"dell":true,"deloitte":true,"delta":true,"democrat":true,"dental":true,"dentist":true,"desi":true,"design":true,"dev":true,"dhl":true,"diamonds":true,"diet":true,"digital":true,"direct":true,"directory":true,"discount":true,"discover":true,"dish":true,"dnp":true,"docs":true,"dodge":true,"dog":true,"doha":true,"domains":true,"doosan":true,"dot":true,"download":true,"drive":true,"dstv":true,"dtv":true,"dubai":true,"duck":true,"dunlop":true,"duns":true,"dupont":true,"durban":true,"dvag":true,"dwg":true,"earth":true,"eat":true,"edeka":true,"education":true,"email":true,"emerck":true,"emerson":true,"energy":true,"engineer":true,"engineering":true,"enterprises":true,"epost":true,"epson":true,"equipment":true,"ericsson":true,"erni":true,"esq":true,"estate":true,"esurance":true,"etisalat":true,"eurovision":true,"eus":true,"events":true,"everbank":true,"exchange":true,"expert":true,"exposed":true,"express":true,"extraspace":true,"fage":true,"fail":true,"fairwinds":true,"faith":true,"family":true,"fan":true,"fans":true,"farm":true,"farmers":true,"fashion":true,"fast":true,"fedex":true,"feedback":true,"ferrari":true,"ferrero":true,"fiat":true,"fidelity":true,"fido":true,"film":true,"final":true,"finance":true,"financial":true,"fire":true,"firestone":true,"firmdale":true,"fish":true,"fishing":true,"fit":true,"fitness":true,"flickr":true,"flights":true,"flir":true,"florist":true,"flowers":true,"flsmidth":true,"fly":true,"foo":true,"foodnetwork":true,"football":true,"ford":true,"forex":true,"forsale":true,"forum":true,"foundation":true,"fox":true,"fresenius":true,"frl":true,"frogans":true,"frontdoor":true,"frontier":true,"ftr":true,"fujitsu":true,"fujixerox":true,"fund":true,"furniture":true,"futbol":true,"fyi":true,"gal":true,"gallery":true,"gallo":true,"gallup":true,"game":true,"games":true,"gap":true,"garden":true,"gbiz":true,"gdn":true,"gea":true,"gent":true,"genting":true,"george":true,"ggee":true,"gift":true,"gifts":true,"gives":true,"giving":true,"glade":true,"glass":true,"gle":true,"global":true,"globo":true,"gmail":true,"gmo":true,"gmx":true,"godaddy":true,"gold":true,"goldpoint":true,"golf":true,"goo":true,"goodhands":true,"goodyear":true,"goog":true,"google":true,"gop":true,"got":true,"gotv":true,"grainger":true,"graphics":true,"gratis":true,"green":true,"gripe":true,"group":true,"guardian":true,"gucci":true,"guge":true,"guide":true,"guitars":true,"guru":true,"hamburg":true,"hangout":true,"haus":true,"hbo":true,"hdfc":true,"hdfcbank":true,"health":true,"healthcare":true,"help":true,"helsinki":true,"here":true,"hermes":true,"hgtv":true,"hiphop":true,"hisamitsu":true,"hitachi":true,"hiv":true,"hkt":true,"hockey":true,"holdings":true,"holiday":true,"homedepot":true,"homegoods":true,"homes":true,"homesense":true,"honda":true,"honeywell":true,"horse":true,"host":true,"hosting":true,"hot":true,"hoteles":true,"hotmail":true,"house":true,"how":true,"hsbc":true,"htc":true,"hughes":true,"hyatt":true,"hyundai":true,"ibm":true,"icbc":true,"ice":true,"icu":true,"ieee":true,"ifm":true,"iinet":true,"ikano":true,"imamat":true,"imdb":true,"immo":true,"immobilien":true,"industries":true,"infiniti":true,"ing":true,"ink":true,"institute":true,"insurance":true,"insure":true,"intel":true,"international":true,"intuit":true,"investments":true,"ipiranga":true,"irish":true,"iselect":true,"ismaili":true,"ist":true,"istanbul":true,"itau":true,"itv":true,"iveco":true,"iwc":true,"jaguar":true,"java":true,"jcb":true,"jcp":true,"jeep":true,"jetzt":true,"jewelry":true,"jio":true,"jlc":true,"jll":true,"jmp":true,"jnj":true,"joburg":true,"jot":true,"joy":true,"jpmorgan":true,"jprs":true,"juegos":true,"juniper":true,"kaufen":true,"kddi":true,"kerryhotels":true,"kerrylogistics":true,"kerryproperties":true,"kfh":true,"kia":true,"kim":true,"kinder":true,"kindle":true,"kitchen":true,"kiwi":true,"koeln":true,"komatsu":true,"kosher":true,"kpmg":true,"kpn":true,"krd":true,"kred":true,"kuokgroup":true,"kyknet":true,"kyoto":true,"lacaixa":true,"ladbrokes":true,"lamborghini":true,"lancaster":true,"lancia":true,"lancome":true,"land":true,"landrover":true,"lanxess":true,"lasalle":true,"lat":true,"latino":true,"latrobe":true,"law":true,"lawyer":true,"lds":true,"lease":true,"leclerc":true,"lefrak":true,"legal":true,"lego":true,"lexus":true,"lgbt":true,"liaison":true,"lidl":true,"life":true,"lifeinsurance":true,"lifestyle":true,"lighting":true,"like":true,"lilly":true,"limited":true,"limo":true,"lincoln":true,"linde":true,"link":true,"lipsy":true,"live":true,"living":true,"lixil":true,"loan":true,"loans":true,"locker":true,"locus":true,"loft":true,"lol":true,"london":true,"lotte":true,"lotto":true,"love":true,"lpl":true,"lplfinancial":true,"ltd":true,"ltda":true,"lundbeck":true,"lupin":true,"luxe":true,"luxury":true,"macys":true,"madrid":true,"maif":true,"maison":true,"makeup":true,"man":true,"management":true,"mango":true,"market":true,"marketing":true,"markets":true,"marriott":true,"marshalls":true,"maserati":true,"mattel":true,"mba":true,"mcd":true,"mcdonalds":true,"mckinsey":true,"med":true,"media":true,"meet":true,"melbourne":true,"meme":true,"memorial":true,"men":true,"menu":true,"meo":true,"metlife":true,"miami":true,"microsoft":true,"mini":true,"mint":true,"mit":true,"mitsubishi":true,"mlb":true,"mls":true,"mma":true,"mnet":true,"mobily":true,"moda":true,"moe":true,"moi":true,"mom":true,"monash":true,"money":true,"monster":true,"montblanc":true,"mopar":true,"mormon":true,"mortgage":true,"moscow":true,"moto":true,"motorcycles":true,"mov":true,"movie":true,"movistar":true,"msd":true,"mtn":true,"mtpc":true,"mtr":true,"multichoice":true,"mutual":true,"mutuelle":true,"mzansimagic":true,"nab":true,"nadex":true,"nagoya":true,"naspers":true,"nationwide":true,"natura":true,"navy":true,"nba":true,"nec":true,"netbank":true,"netflix":true,"network":true,"neustar":true,"new":true,"newholland":true,"news":true,"next":true,"nextdirect":true,"nexus":true,"nfl":true,"ngo":true,"nhk":true,"nico":true,"nike":true,"nikon":true,"ninja":true,"nissan":true,"nokia":true,"northwesternmutual":true,"norton":true,"now":true,"nowruz":true,"nowtv":true,"nra":true,"nrw":true,"ntt":true,"nyc":true,"obi":true,"observer":true,"off":true,"office":true,"okinawa":true,"olayan":true,"olayangroup":true,"oldnavy":true,"ollo":true,"omega":true,"one":true,"ong":true,"onl":true,"online":true,"onyourside":true,"ooo":true,"open":true,"oracle":true,"orange":true,"organic":true,"orientexpress":true,"osaka":true,"otsuka":true,"ott":true,"ovh":true,"page":true,"pamperedchef":true,"panasonic":true,"panerai":true,"paris":true,"pars":true,"partners":true,"parts":true,"party":true,"passagens":true,"pay":true,"payu":true,"pccw":true,"pet":true,"pfizer":true,"pharmacy":true,"philips":true,"photo":true,"photography":true,"photos":true,"physio":true,"piaget":true,"pics":true,"pictet":true,"pictures":true,"pid":true,"pin":true,"ping":true,"pink":true,"pioneer":true,"pizza":true,"place":true,"play":true,"playstation":true,"plumbing":true,"plus":true,"pnc":true,"pohl":true,"poker":true,"politie":true,"porn":true,"pramerica":true,"praxi":true,"press":true,"prime":true,"prod":true,"productions":true,"prof":true,"progressive":true,"promo":true,"properties":true,"property":true,"protection":true,"pru":true,"prudential":true,"pub":true,"qpon":true,"quebec":true,"quest":true,"qvc":true,"racing":true,"raid":true,"read":true,"realestate":true,"realtor":true,"realty":true,"recipes":true,"red":true,"redstone":true,"redumbrella":true,"rehab":true,"reise":true,"reisen":true,"reit":true,"reliance":true,"ren":true,"rent":true,"rentals":true,"repair":true,"report":true,"republican":true,"rest":true,"restaurant":true,"review":true,"reviews":true,"rexroth":true,"rich":true,"richardli":true,"ricoh":true,"rightathome":true,"ril":true,"rio":true,"rip":true,"rocher":true,"rocks":true,"rodeo":true,"rogers":true,"room":true,"rsvp":true,"ruhr":true,"run":true,"rwe":true,"ryukyu":true,"saarland":true,"safe":true,"safety":true,"sakura":true,"sale":true,"salon":true,"samsclub":true,"samsung":true,"sandvik":true,"sandvikcoromant":true,"sanofi":true,"sap":true,"sapo":true,"sarl":true,"sas":true,"save":true,"saxo":true,"sbi":true,"sbs":true,"sca":true,"scb":true,"schaeffler":true,"schmidt":true,"scholarships":true,"school":true,"schule":true,"schwarz":true,"science":true,"scjohnson":true,"scor":true,"scot":true,"seat":true,"secure":true,"security":true,"seek":true,"sener":true,"services":true,"ses":true,"seven":true,"sew":true,"sex":true,"sexy":true,"sfr":true,"shangrila":true,"sharp":true,"shaw":true,"shell":true,"shia":true,"shiksha":true,"shoes":true,"shouji":true,"show":true,"showtime":true,"shriram":true,"silk":true,"sina":true,"singles":true,"site":true,"ski":true,"skin":true,"sky":true,"skype":true,"sling":true,"smart":true,"smile":true,"sncf":true,"soccer":true,"social":true,"softbank":true,"software":true,"sohu":true,"solar":true,"solutions":true,"song":true,"sony":true,"soy":true,"space":true,"spiegel":true,"spot":true,"spreadbetting":true,"srl":true,"srt":true,"stada":true,"staples":true,"star":true,"starhub":true,"statebank":true,"statefarm":true,"statoil":true,"stc":true,"stcgroup":true,"stockholm":true,"storage":true,"store":true,"studio":true,"study":true,"style":true,"sucks":true,"supersport":true,"supplies":true,"supply":true,"support":true,"surf":true,"surgery":true,"suzuki":true,"swatch":true,"swiftcover":true,"swiss":true,"sydney":true,"symantec":true,"systems":true,"tab":true,"taipei":true,"talk":true,"taobao":true,"target":true,"tatamotors":true,"tatar":true,"tattoo":true,"tax":true,"taxi":true,"tci":true,"tdk":true,"team":true,"tech":true,"technology":true,"telecity":true,"telefonica":true,"temasek":true,"tennis":true,"teva":true,"thd":true,"theater":true,"theatre":true,"theguardian":true,"tiaa":true,"tickets":true,"tienda":true,"tiffany":true,"tips":true,"tires":true,"tirol":true,"tjmaxx":true,"tjx":true,"tkmaxx":true,"tmall":true,"today":true,"tokyo":true,"tools":true,"top":true,"toray":true,"toshiba":true,"total":true,"tours":true,"town":true,"toyota":true,"toys":true,"trade":true,"trading":true,"training":true,"travelchannel":true,"travelers":true,"travelersinsurance":true,"trust":true,"trv":true,"tube":true,"tui":true,"tunes":true,"tushu":true,"tvs":true,"ubank":true,"ubs":true,"uconnect":true,"university":true,"uno":true,"uol":true,"ups":true,"vacations":true,"vana":true,"vanguard":true,"vegas":true,"ventures":true,"verisign":true,"versicherung":true,"vet":true,"viajes":true,"video":true,"vig":true,"viking":true,"villas":true,"vin":true,"vip":true,"virgin":true,"visa":true,"vision":true,"vista":true,"vistaprint":true,"viva":true,"vivo":true,"vlaanderen":true,"vodka":true,"volkswagen":true,"vote":true,"voting":true,"voto":true,"voyage":true,"vuelos":true,"wales":true,"walmart":true,"walter":true,"wang":true,"wanggou":true,"warman":true,"watch":true,"watches":true,"weather":true,"weatherchannel":true,"webcam":true,"weber":true,"website":true,"wed":true,"wedding":true,"weibo":true,"weir":true,"whoswho":true,"wien":true,"wiki":true,"williamhill":true,"win":true,"windows":true,"wine":true,"winners":true,"wme":true,"wolterskluwer":true,"woodside":true,"work":true,"works":true,"world":true,"wtc":true,"wtf":true,"xbox":true,"xerox":true,"xfinity":true,"xihuan":true,"xin":true,"xn--11b4c3d":true,"xn--1ck2e1b":true,"xn--1qqw23a":true,"xn--30rr7y":true,"xn--3bst00m":true,"xn--3ds443g":true,"xn--3oq18vl8pn36a":true,"xn--3pxu8k":true,"xn--42c2d9a":true,"xn--45q11c":true,"xn--4gbrim":true,"xn--4gq48lf9j":true,"xn--55qw42g":true,"xn--55qx5d":true,"xn--5su34j936bgsg":true,"xn--5tzm5g":true,"xn--6frz82g":true,"xn--6qq986b3xl":true,"xn--80adxhks":true,"xn--80asehdb":true,"xn--80aswg":true,"xn--8y0a063a":true,"xn--9dbq2a":true,"xn--9et52u":true,"xn--9krt00a":true,"xn--b4w605ferd":true,"xn--bck1b9a5dre4c":true,"xn--c1avg":true,"xn--c2br7g":true,"xn--cck2b3b":true,"xn--cg4bki":true,"xn--czr694b":true,"xn--czrs0t":true,"xn--czru2d":true,"xn--d1acj3b":true,"xn--eckvdtc9d":true,"xn--efvy88h":true,"xn--estv75g":true,"xn--fct429k":true,"xn--fhbei":true,"xn--fiq228c5hs":true,"xn--fiq64b":true,"xn--fjq720a":true,"xn--flw351e":true,"xn--fzys8d69uvgm":true,"xn--g2xx48c":true,"xn--gckr3f0f":true,"xn--hxt814e":true,"xn--i1b6b1a6a2e":true,"xn--imr513n":true,"xn--io0a7i":true,"xn--j1aef":true,"xn--jlq61u9w7b":true,"xn--jvr189m":true,"xn--kcrx77d1x4a":true,"xn--kpu716f":true,"xn--kput3i":true,"xn--mgba3a3ejt":true,"xn--mgba7c0bbn0a":true,"xn--mgbaakc7dvf":true,"xn--mgbab2bd":true,"xn--mgbb9fbpob":true,"xn--mgbca7dzdo":true,"xn--mgbt3dhd":true,"xn--mk1bu44c":true,"xn--mxtq1m":true,"xn--ngbc5azd":true,"xn--ngbe9e0a":true,"xn--nqv7f":true,"xn--nqv7fs00ema":true,"xn--nyqy26a":true,"xn--p1acf":true,"xn--pbt977c":true,"xn--pssy2u":true,"xn--q9jyb4c":true,"xn--qcka1pmc":true,"xn--rhqv96g":true,"xn--rovu88b":true,"xn--ses554g":true,"xn--t60b56a":true,"xn--tckwe":true,"xn--unup4y":true,"xn--vermgensberater-ctb":true,"xn--vermgensberatung-pwb":true,"xn--vhquv":true,"xn--vuq861b":true,"xn--w4r85el8fhu5dnra":true,"xn--w4rs40l":true,"xn--xhq521b":true,"xn--zfr164b":true,"xperia":true,"xyz":true,"yachts":true,"yahoo":true,"yamaxun":true,"yandex":true,"yodobashi":true,"yoga":true,"yokohama":true,"you":true,"youtube":true,"yun":true,"zappos":true,"zara":true,"zero":true,"zip":true,"zippo":true,"zone":true,"zuerich":true,"cloudfront.net":true,"ap-northeast-1.compute.amazonaws.com":true,"ap-southeast-1.compute.amazonaws.com":true,"ap-southeast-2.compute.amazonaws.com":true,"cn-north-1.compute.amazonaws.cn":true,"compute.amazonaws.cn":true,"compute.amazonaws.com":true,"compute-1.amazonaws.com":true,"eu-west-1.compute.amazonaws.com":true,"eu-central-1.compute.amazonaws.com":true,"sa-east-1.compute.amazonaws.com":true,"us-east-1.amazonaws.com":true,"us-gov-west-1.compute.amazonaws.com":true,"us-west-1.compute.amazonaws.com":true,"us-west-2.compute.amazonaws.com":true,"z-1.compute-1.amazonaws.com":true,"z-2.compute-1.amazonaws.com":true,"elasticbeanstalk.com":true,"elb.amazonaws.com":true,"s3.amazonaws.com":true,"s3-ap-northeast-1.amazonaws.com":true,"s3-ap-southeast-1.amazonaws.com":true,"s3-ap-southeast-2.amazonaws.com":true,"s3-external-1.amazonaws.com":true,"s3-external-2.amazonaws.com":true,"s3-fips-us-gov-west-1.amazonaws.com":true,"s3-eu-central-1.amazonaws.com":true,"s3-eu-west-1.amazonaws.com":true,"s3-sa-east-1.amazonaws.com":true,"s3-us-gov-west-1.amazonaws.com":true,"s3-us-west-1.amazonaws.com":true,"s3-us-west-2.amazonaws.com":true,"s3.cn-north-1.amazonaws.com.cn":true,"s3.eu-central-1.amazonaws.com":true,"betainabox.com":true,"ae.org":true,"ar.com":true,"br.com":true,"cn.com":true,"com.de":true,"com.se":true,"de.com":true,"eu.com":true,"gb.com":true,"gb.net":true,"hu.com":true,"hu.net":true,"jp.net":true,"jpn.com":true,"kr.com":true,"mex.com":true,"no.com":true,"qc.com":true,"ru.com":true,"sa.com":true,"se.com":true,"se.net":true,"uk.com":true,"uk.net":true,"us.com":true,"uy.com":true,"za.bz":true,"za.com":true,"africa.com":true,"gr.com":true,"in.net":true,"us.org":true,"co.com":true,"c.la":true,"cloudcontrolled.com":true,"cloudcontrolapp.com":true,"co.ca":true,"c.cdn77.org":true,"cdn77-ssl.net":true,"r.cdn77.net":true,"rsc.cdn77.org":true,"ssl.origin.cdn77-secure.org":true,"co.nl":true,"co.no":true,"*.platform.sh":true,"cupcake.is":true,"dreamhosters.com":true,"duckdns.org":true,"dyndns-at-home.com":true,"dyndns-at-work.com":true,"dyndns-blog.com":true,"dyndns-free.com":true,"dyndns-home.com":true,"dyndns-ip.com":true,"dyndns-mail.com":true,"dyndns-office.com":true,"dyndns-pics.com":true,"dyndns-remote.com":true,"dyndns-server.com":true,"dyndns-web.com":true,"dyndns-wiki.com":true,"dyndns-work.com":true,"dyndns.biz":true,"dyndns.info":true,"dyndns.org":true,"dyndns.tv":true,"at-band-camp.net":true,"ath.cx":true,"barrel-of-knowledge.info":true,"barrell-of-knowledge.info":true,"better-than.tv":true,"blogdns.com":true,"blogdns.net":true,"blogdns.org":true,"blogsite.org":true,"boldlygoingnowhere.org":true,"broke-it.net":true,"buyshouses.net":true,"cechire.com":true,"dnsalias.com":true,"dnsalias.net":true,"dnsalias.org":true,"dnsdojo.com":true,"dnsdojo.net":true,"dnsdojo.org":true,"does-it.net":true,"doesntexist.com":true,"doesntexist.org":true,"dontexist.com":true,"dontexist.net":true,"dontexist.org":true,"doomdns.com":true,"doomdns.org":true,"dvrdns.org":true,"dyn-o-saur.com":true,"dynalias.com":true,"dynalias.net":true,"dynalias.org":true,"dynathome.net":true,"dyndns.ws":true,"endofinternet.net":true,"endofinternet.org":true,"endoftheinternet.org":true,"est-a-la-maison.com":true,"est-a-la-masion.com":true,"est-le-patron.com":true,"est-mon-blogueur.com":true,"for-better.biz":true,"for-more.biz":true,"for-our.info":true,"for-some.biz":true,"for-the.biz":true,"forgot.her.name":true,"forgot.his.name":true,"from-ak.com":true,"from-al.com":true,"from-ar.com":true,"from-az.net":true,"from-ca.com":true,"from-co.net":true,"from-ct.com":true,"from-dc.com":true,"from-de.com":true,"from-fl.com":true,"from-ga.com":true,"from-hi.com":true,"from-ia.com":true,"from-id.com":true,"from-il.com":true,"from-in.com":true,"from-ks.com":true,"from-ky.com":true,"from-la.net":true,"from-ma.com":true,"from-md.com":true,"from-me.org":true,"from-mi.com":true,"from-mn.com":true,"from-mo.com":true,"from-ms.com":true,"from-mt.com":true,"from-nc.com":true,"from-nd.com":true,"from-ne.com":true,"from-nh.com":true,"from-nj.com":true,"from-nm.com":true,"from-nv.com":true,"from-ny.net":true,"from-oh.com":true,"from-ok.com":true,"from-or.com":true,"from-pa.com":true,"from-pr.com":true,"from-ri.com":true,"from-sc.com":true,"from-sd.com":true,"from-tn.com":true,"from-tx.com":true,"from-ut.com":true,"from-va.com":true,"from-vt.com":true,"from-wa.com":true,"from-wi.com":true,"from-wv.com":true,"from-wy.com":true,"ftpaccess.cc":true,"fuettertdasnetz.de":true,"game-host.org":true,"game-server.cc":true,"getmyip.com":true,"gets-it.net":true,"go.dyndns.org":true,"gotdns.com":true,"gotdns.org":true,"groks-the.info":true,"groks-this.info":true,"ham-radio-op.net":true,"here-for-more.info":true,"hobby-site.com":true,"hobby-site.org":true,"home.dyndns.org":true,"homedns.org":true,"homeftp.net":true,"homeftp.org":true,"homeip.net":true,"homelinux.com":true,"homelinux.net":true,"homelinux.org":true,"homeunix.com":true,"homeunix.net":true,"homeunix.org":true,"iamallama.com":true,"in-the-band.net":true,"is-a-anarchist.com":true,"is-a-blogger.com":true,"is-a-bookkeeper.com":true,"is-a-bruinsfan.org":true,"is-a-bulls-fan.com":true,"is-a-candidate.org":true,"is-a-caterer.com":true,"is-a-celticsfan.org":true,"is-a-chef.com":true,"is-a-chef.net":true,"is-a-chef.org":true,"is-a-conservative.com":true,"is-a-cpa.com":true,"is-a-cubicle-slave.com":true,"is-a-democrat.com":true,"is-a-designer.com":true,"is-a-doctor.com":true,"is-a-financialadvisor.com":true,"is-a-geek.com":true,"is-a-geek.net":true,"is-a-geek.org":true,"is-a-green.com":true,"is-a-guru.com":true,"is-a-hard-worker.com":true,"is-a-hunter.com":true,"is-a-knight.org":true,"is-a-landscaper.com":true,"is-a-lawyer.com":true,"is-a-liberal.com":true,"is-a-libertarian.com":true,"is-a-linux-user.org":true,"is-a-llama.com":true,"is-a-musician.com":true,"is-a-nascarfan.com":true,"is-a-nurse.com":true,"is-a-painter.com":true,"is-a-patsfan.org":true,"is-a-personaltrainer.com":true,"is-a-photographer.com":true,"is-a-player.com":true,"is-a-republican.com":true,"is-a-rockstar.com":true,"is-a-socialist.com":true,"is-a-soxfan.org":true,"is-a-student.com":true,"is-a-teacher.com":true,"is-a-techie.com":true,"is-a-therapist.com":true,"is-an-accountant.com":true,"is-an-actor.com":true,"is-an-actress.com":true,"is-an-anarchist.com":true,"is-an-artist.com":true,"is-an-engineer.com":true,"is-an-entertainer.com":true,"is-by.us":true,"is-certified.com":true,"is-found.org":true,"is-gone.com":true,"is-into-anime.com":true,"is-into-cars.com":true,"is-into-cartoons.com":true,"is-into-games.com":true,"is-leet.com":true,"is-lost.org":true,"is-not-certified.com":true,"is-saved.org":true,"is-slick.com":true,"is-uberleet.com":true,"is-very-bad.org":true,"is-very-evil.org":true,"is-very-good.org":true,"is-very-nice.org":true,"is-very-sweet.org":true,"is-with-theband.com":true,"isa-geek.com":true,"isa-geek.net":true,"isa-geek.org":true,"isa-hockeynut.com":true,"issmarterthanyou.com":true,"isteingeek.de":true,"istmein.de":true,"kicks-ass.net":true,"kicks-ass.org":true,"knowsitall.info":true,"land-4-sale.us":true,"lebtimnetz.de":true,"leitungsen.de":true,"likes-pie.com":true,"likescandy.com":true,"merseine.nu":true,"mine.nu":true,"misconfused.org":true,"mypets.ws":true,"myphotos.cc":true,"neat-url.com":true,"office-on-the.net":true,"on-the-web.tv":true,"podzone.net":true,"podzone.org":true,"readmyblog.org":true,"saves-the-whales.com":true,"scrapper-site.net":true,"scrapping.cc":true,"selfip.biz":true,"selfip.com":true,"selfip.info":true,"selfip.net":true,"selfip.org":true,"sells-for-less.com":true,"sells-for-u.com":true,"sells-it.net":true,"sellsyourhome.org":true,"servebbs.com":true,"servebbs.net":true,"servebbs.org":true,"serveftp.net":true,"serveftp.org":true,"servegame.org":true,"shacknet.nu":true,"simple-url.com":true,"space-to-rent.com":true,"stuff-4-sale.org":true,"stuff-4-sale.us":true,"teaches-yoga.com":true,"thruhere.net":true,"traeumtgerade.de":true,"webhop.biz":true,"webhop.info":true,"webhop.net":true,"webhop.org":true,"worse-than.tv":true,"writesthisblog.com":true,"eu.org":true,"al.eu.org":true,"asso.eu.org":true,"at.eu.org":true,"au.eu.org":true,"be.eu.org":true,"bg.eu.org":true,"ca.eu.org":true,"cd.eu.org":true,"ch.eu.org":true,"cn.eu.org":true,"cy.eu.org":true,"cz.eu.org":true,"de.eu.org":true,"dk.eu.org":true,"edu.eu.org":true,"ee.eu.org":true,"es.eu.org":true,"fi.eu.org":true,"fr.eu.org":true,"gr.eu.org":true,"hr.eu.org":true,"hu.eu.org":true,"ie.eu.org":true,"il.eu.org":true,"in.eu.org":true,"int.eu.org":true,"is.eu.org":true,"it.eu.org":true,"jp.eu.org":true,"kr.eu.org":true,"lt.eu.org":true,"lu.eu.org":true,"lv.eu.org":true,"mc.eu.org":true,"me.eu.org":true,"mk.eu.org":true,"mt.eu.org":true,"my.eu.org":true,"net.eu.org":true,"ng.eu.org":true,"nl.eu.org":true,"no.eu.org":true,"nz.eu.org":true,"paris.eu.org":true,"pl.eu.org":true,"pt.eu.org":true,"q-a.eu.org":true,"ro.eu.org":true,"ru.eu.org":true,"se.eu.org":true,"si.eu.org":true,"sk.eu.org":true,"tr.eu.org":true,"uk.eu.org":true,"us.eu.org":true,"a.ssl.fastly.net":true,"b.ssl.fastly.net":true,"global.ssl.fastly.net":true,"a.prod.fastly.net":true,"global.prod.fastly.net":true,"firebaseapp.com":true,"flynnhub.com":true,"service.gov.uk":true,"github.io":true,"githubusercontent.com":true,"ro.com":true,"appspot.com":true,"blogspot.ae":true,"blogspot.al":true,"blogspot.am":true,"blogspot.ba":true,"blogspot.be":true,"blogspot.bg":true,"blogspot.bj":true,"blogspot.ca":true,"blogspot.cf":true,"blogspot.ch":true,"blogspot.cl":true,"blogspot.co.at":true,"blogspot.co.id":true,"blogspot.co.il":true,"blogspot.co.ke":true,"blogspot.co.nz":true,"blogspot.co.uk":true,"blogspot.co.za":true,"blogspot.com":true,"blogspot.com.ar":true,"blogspot.com.au":true,"blogspot.com.br":true,"blogspot.com.by":true,"blogspot.com.co":true,"blogspot.com.cy":true,"blogspot.com.ee":true,"blogspot.com.eg":true,"blogspot.com.es":true,"blogspot.com.mt":true,"blogspot.com.ng":true,"blogspot.com.tr":true,"blogspot.com.uy":true,"blogspot.cv":true,"blogspot.cz":true,"blogspot.de":true,"blogspot.dk":true,"blogspot.fi":true,"blogspot.fr":true,"blogspot.gr":true,"blogspot.hk":true,"blogspot.hr":true,"blogspot.hu":true,"blogspot.ie":true,"blogspot.in":true,"blogspot.is":true,"blogspot.it":true,"blogspot.jp":true,"blogspot.kr":true,"blogspot.li":true,"blogspot.lt":true,"blogspot.lu":true,"blogspot.md":true,"blogspot.mk":true,"blogspot.mr":true,"blogspot.mx":true,"blogspot.my":true,"blogspot.nl":true,"blogspot.no":true,"blogspot.pe":true,"blogspot.pt":true,"blogspot.qa":true,"blogspot.re":true,"blogspot.ro":true,"blogspot.rs":true,"blogspot.ru":true,"blogspot.se":true,"blogspot.sg":true,"blogspot.si":true,"blogspot.sk":true,"blogspot.sn":true,"blogspot.td":true,"blogspot.tw":true,"blogspot.ug":true,"blogspot.vn":true,"codespot.com":true,"googleapis.com":true,"googlecode.com":true,"pagespeedmobilizer.com":true,"withgoogle.com":true,"withyoutube.com":true,"herokuapp.com":true,"herokussl.com":true,"iki.fi":true,"biz.at":true,"info.at":true,"co.pl":true,"azurewebsites.net":true,"azure-mobile.net":true,"cloudapp.net":true,"bmoattachments.org":true,"4u.com":true,"nfshost.com":true,"nyc.mn":true,"nid.io":true,"operaunite.com":true,"outsystemscloud.com":true,"art.pl":true,"gliwice.pl":true,"krakow.pl":true,"poznan.pl":true,"wroc.pl":true,"zakopane.pl":true,"pantheon.io":true,"gotpantheon.com":true,"priv.at":true,"qa2.com":true,"rhcloud.com":true,"sandcats.io":true,"biz.ua":true,"co.ua":true,"pp.ua":true,"sinaapp.com":true,"vipsinaapp.com":true,"1kapp.com":true,"gda.pl":true,"gdansk.pl":true,"gdynia.pl":true,"med.pl":true,"sopot.pl":true,"hk.com":true,"hk.org":true,"ltd.hk":true,"inc.hk":true,"yolasite.com":true,"za.net":true,"za.org":true});

	// END of automatically generated file


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.4.1 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw new RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.4.1',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module), (function() { return this; }())))

/***/ },
/* 23 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	'use strict';
	/*jshint unused:false */

	function Store() {
	}
	exports.Store = Store;

	// Stores may be synchronous, but are still required to use a
	// Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
	// API that converts from synchronous-callbacks to imperative style.
	Store.prototype.synchronous = false;

	Store.prototype.findCookie = function(domain, path, key, cb) {
	  throw new Error('findCookie is not implemented');
	};

	Store.prototype.findCookies = function(domain, path, cb) {
	  throw new Error('findCookies is not implemented');
	};

	Store.prototype.putCookie = function(cookie, cb) {
	  throw new Error('putCookie is not implemented');
	};

	Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
	  // recommended default implementation:
	  // return this.putCookie(newCookie, cb);
	  throw new Error('updateCookie is not implemented');
	};

	Store.prototype.removeCookie = function(domain, path, key, cb) {
	  throw new Error('removeCookie is not implemented');
	};

	Store.prototype.removeCookies = function(domain, path, cb) {
	  throw new Error('removeCookies is not implemented');
	};

	Store.prototype.getAllCookies = function(cb) {
	  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	'use strict';
	var Store = __webpack_require__(23).Store;
	var permuteDomain = __webpack_require__(25).permuteDomain;
	var pathMatch = __webpack_require__(26).pathMatch;
	var util = __webpack_require__(27);

	function MemoryCookieStore() {
	  Store.call(this);
	  this.idx = {};
	}
	util.inherits(MemoryCookieStore, Store);
	exports.MemoryCookieStore = MemoryCookieStore;
	MemoryCookieStore.prototype.idx = null;

	// Since it's just a struct in RAM, this Store is synchronous
	MemoryCookieStore.prototype.synchronous = true;

	// force a default depth:
	MemoryCookieStore.prototype.inspect = function() {
	  return "{ idx: "+util.inspect(this.idx, false, 2)+' }';
	};

	MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
	  if (!this.idx[domain]) {
	    return cb(null,undefined);
	  }
	  if (!this.idx[domain][path]) {
	    return cb(null,undefined);
	  }
	  return cb(null,this.idx[domain][path][key]||null);
	};

	MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
	  var results = [];
	  if (!domain) {
	    return cb(null,[]);
	  }

	  var pathMatcher;
	  if (!path) {
	    // null means "all paths"
	    pathMatcher = function matchAll(domainIndex) {
	      for (var curPath in domainIndex) {
	        var pathIndex = domainIndex[curPath];
	        for (var key in pathIndex) {
	          results.push(pathIndex[key]);
	        }
	      }
	    };

	  } else {
	    pathMatcher = function matchRFC(domainIndex) {
	       //NOTE: we should use path-match algorithm from S5.1.4 here
	       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
	       Object.keys(domainIndex).forEach(function (cookiePath) {
	         if (pathMatch(path, cookiePath)) {
	           var pathIndex = domainIndex[cookiePath];

	           for (var key in pathIndex) {
	             results.push(pathIndex[key]);
	           }
	         }
	       });
	     };
	  }

	  var domains = permuteDomain(domain) || [domain];
	  var idx = this.idx;
	  domains.forEach(function(curDomain) {
	    var domainIndex = idx[curDomain];
	    if (!domainIndex) {
	      return;
	    }
	    pathMatcher(domainIndex);
	  });

	  cb(null,results);
	};

	MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
	  if (!this.idx[cookie.domain]) {
	    this.idx[cookie.domain] = {};
	  }
	  if (!this.idx[cookie.domain][cookie.path]) {
	    this.idx[cookie.domain][cookie.path] = {};
	  }
	  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
	  cb(null);
	};

	MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
	  // updateCookie() may avoid updating cookies that are identical.  For example,
	  // lastAccessed may not be important to some stores and an equality
	  // comparison could exclude that field.
	  this.putCookie(newCookie,cb);
	};

	MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
	  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
	    delete this.idx[domain][path][key];
	  }
	  cb(null);
	};

	MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
	  if (this.idx[domain]) {
	    if (path) {
	      delete this.idx[domain][path];
	    } else {
	      delete this.idx[domain];
	    }
	  }
	  return cb(null);
	};

	MemoryCookieStore.prototype.getAllCookies = function(cb) {
	  var cookies = [];
	  var idx = this.idx;

	  var domains = Object.keys(idx);
	  domains.forEach(function(domain) {
	    var paths = Object.keys(idx[domain]);
	    paths.forEach(function(path) {
	      var keys = Object.keys(idx[domain][path]);
	      keys.forEach(function(key) {
	        if (key !== null) {
	          cookies.push(idx[domain][path][key]);
	        }
	      });
	    });
	  });

	  // Sort by creationIndex so deserializing retains the creation order.
	  // When implementing your own store, this SHOULD retain the order too
	  cookies.sort(function(a,b) {
	    return (a.creationIndex||0) - (b.creationIndex||0);
	  });

	  cb(null, cookies);
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	"use strict";
	var pubsuffix = __webpack_require__(21);

	// Gives the permutation of all possible domainMatch()es of a given domain. The
	// array is in shortest-to-longest order.  Handy for indexing.
	function permuteDomain (domain) {
	  var pubSuf = pubsuffix.getPublicSuffix(domain);
	  if (!pubSuf) {
	    return null;
	  }
	  if (pubSuf == domain) {
	    return [domain];
	  }

	  var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
	  var parts = prefix.split('.').reverse();
	  var cur = pubSuf;
	  var permutations = [cur];
	  while (parts.length) {
	    cur = parts.shift() + '.' + cur;
	    permutations.push(cur);
	  }
	  return permutations;
	}

	exports.permuteDomain = permuteDomain;


/***/ },
/* 26 */
/***/ function(module, exports) {

	/*!
	 * Copyright (c) 2015, Salesforce.com, Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * 1. Redistributions of source code must retain the above copyright notice,
	 * this list of conditions and the following disclaimer.
	 *
	 * 2. Redistributions in binary form must reproduce the above copyright notice,
	 * this list of conditions and the following disclaimer in the documentation
	 * and/or other materials provided with the distribution.
	 *
	 * 3. Neither the name of Salesforce.com nor the names of its contributors may
	 * be used to endorse or promote products derived from this software without
	 * specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
	 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	"use strict";
	/*
	 * "A request-path path-matches a given cookie-path if at least one of the
	 * following conditions holds:"
	 */
	function pathMatch (reqPath, cookiePath) {
	  // "o  The cookie-path and the request-path are identical."
	  if (cookiePath === reqPath) {
	    return true;
	  }

	  var idx = reqPath.indexOf(cookiePath);
	  if (idx === 0) {
	    // "o  The cookie-path is a prefix of the request-path, and the last
	    // character of the cookie-path is %x2F ("/")."
	    if (cookiePath.substr(-1) === "/") {
	      return true;
	    }

	    // " o  The cookie-path is a prefix of the request-path, and the first
	    // character of the request-path that is not included in the cookie- path
	    // is a %x2F ("/") character."
	    if (reqPath.substr(cookiePath.length, 1) === "/") {
	      return true;
	    }
	  }

	  return false;
	}

	exports.pathMatch = pathMatch;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(28);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(29);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)))

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 29 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				"tough-cookie@>=0.12.0",
				"D:\\DAPISDK\\node_modules\\request"
			]
		],
		"_from": "tough-cookie@>=0.12.0",
		"_id": "tough-cookie@2.2.2",
		"_inCache": true,
		"_installable": true,
		"_location": "/tough-cookie",
		"_nodeVersion": "5.1.1",
		"_npmOperationalInternal": {
			"host": "packages-13-west.internal.npmjs.com",
			"tmp": "tmp/tough-cookie-2.2.2.tgz_1457564639182_0.5129188685677946"
		},
		"_npmUser": {
			"email": "jstash@gmail.com",
			"name": "jstash"
		},
		"_npmVersion": "3.3.12",
		"_phantomChildren": {},
		"_requested": {
			"name": "tough-cookie",
			"raw": "tough-cookie@>=0.12.0",
			"rawSpec": ">=0.12.0",
			"scope": null,
			"spec": ">=0.12.0",
			"type": "range"
		},
		"_requiredBy": [
			"/request"
		],
		"_resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.2.2.tgz",
		"_shasum": "c83a1830f4e5ef0b93ef2a3488e724f8de016ac7",
		"_shrinkwrap": null,
		"_spec": "tough-cookie@>=0.12.0",
		"_where": "D:\\DAPISDK\\node_modules\\request",
		"author": {
			"email": "jstashewsky@salesforce.com",
			"name": "Jeremy Stashewsky"
		},
		"bugs": {
			"url": "https://github.com/SalesforceEng/tough-cookie/issues"
		},
		"contributors": [
			{
				"name": "Alexander Savin"
			},
			{
				"name": "Ian Livingstone"
			},
			{
				"name": "Ivan Nikulin"
			},
			{
				"name": "Lalit Kapoor"
			},
			{
				"name": "Sam Thompson"
			},
			{
				"name": "Sebastian Mayr"
			}
		],
		"dependencies": {},
		"description": "RFC6265 Cookies and Cookie Jar for node.js",
		"devDependencies": {
			"async": "^1.4.2",
			"vows": "^0.8.1"
		},
		"directories": {},
		"dist": {
			"shasum": "c83a1830f4e5ef0b93ef2a3488e724f8de016ac7",
			"tarball": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.2.2.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"files": [
			"lib"
		],
		"gitHead": "cc46628c4d7d2e8c372ecba29293ca8a207ec192",
		"homepage": "https://github.com/SalesforceEng/tough-cookie",
		"keywords": [
			"HTTP",
			"cookie",
			"cookies",
			"set-cookie",
			"cookiejar",
			"jar",
			"RFC6265",
			"RFC2965"
		],
		"license": "BSD-3-Clause",
		"main": "./lib/cookie",
		"maintainers": [
			{
				"email": "jeremy@goinstant.com",
				"name": "jstash"
			},
			{
				"email": "services@goinstant.com",
				"name": "goinstant"
			}
		],
		"name": "tough-cookie",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git://github.com/SalesforceEng/tough-cookie.git"
		},
		"scripts": {
			"suffixup": "curl -o public_suffix_list.dat https://publicsuffix.org/list/public_suffix_list.dat && ./generate-pubsuffix.js",
			"test": "vows test/*_test.js"
		},
		"version": "2.2.2"
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, process, Buffer) {'use strict'

	var jsonSafeStringify = __webpack_require__(36)
	  , crypto = __webpack_require__(37)

	function deferMethod() {
	  if (typeof setImmediate === 'undefined') {
	    return process.nextTick
	  }

	  return setImmediate
	}

	function isFunction(value) {
	  return typeof value === 'function'
	}

	function paramsHaveRequestBody(params) {
	  return (
	    params.body ||
	    params.requestBodyStream ||
	    (params.json && typeof params.json !== 'boolean') ||
	    params.multipart
	  )
	}

	function safeStringify (obj) {
	  var ret
	  try {
	    ret = JSON.stringify(obj)
	  } catch (e) {
	    ret = jsonSafeStringify(obj)
	  }
	  return ret
	}

	function md5 (str) {
	  return crypto.createHash('md5').update(str).digest('hex')
	}

	function isReadStream (rs) {
	  return rs.readable && rs.path && rs.mode
	}

	function toBase64 (str) {
	  return (new Buffer(str || '', 'utf8')).toString('base64')
	}

	function copy (obj) {
	  var o = {}
	  Object.keys(obj).forEach(function (i) {
	    o[i] = obj[i]
	  })
	  return o
	}

	exports.isFunction            = isFunction
	exports.paramsHaveRequestBody = paramsHaveRequestBody
	exports.safeStringify         = safeStringify
	exports.md5                   = md5
	exports.isReadStream          = isReadStream
	exports.toBase64              = toBase64
	exports.copy                  = copy
	exports.defer                 = deferMethod()

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8).setImmediate, __webpack_require__(7), __webpack_require__(32).Buffer))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(33)
	var ieee754 = __webpack_require__(34)
	var isArray = __webpack_require__(35)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    this.length = 0
	    this.parent = undefined
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	} else {
	  // pre-set for values that may exist in the future
	  Buffer.prototype.length = undefined
	  Buffer.prototype.parent = undefined
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer, (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 34 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 35 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 36 */
/***/ function(module, exports) {

	exports = module.exports = stringify
	exports.getSerialize = serializer

	function stringify(obj, replacer, spaces, cycleReplacer) {
	  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
	}

	function serializer(replacer, cycleReplacer) {
	  var stack = [], keys = []

	  if (cycleReplacer == null) cycleReplacer = function(key, value) {
	    if (stack[0] === value) return "[Circular ~]"
	    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
	  }

	  return function(key, value) {
	    if (stack.length > 0) {
	      var thisPos = stack.indexOf(this)
	      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
	      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
	      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
	    }
	    else stack.push(value)

	    return replacer == null ? value : replacer.call(this, key, value)
	  }
	}


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(38)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(40)

	exports.createHmac = __webpack_require__(49)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(50)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync


	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(39)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(32).Buffer))

/***/ },
/* 39 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(41)

	var md5 = toConstructor(__webpack_require__(46))
	var rmd160 = toConstructor(__webpack_require__(48))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(32).Buffer
	var Hash   = __webpack_require__(42)(Buffer)

	exports.sha1 = __webpack_require__(43)(Buffer, Hash)
	exports.sha256 = __webpack_require__(44)(Buffer, Hash)
	exports.sha512 = __webpack_require__(45)(Buffer, Hash)


/***/ },
/* 42 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(27).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(27).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(27).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(47);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(40)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(51)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {'use strict'

	var http = __webpack_require__(53)
	  , https = __webpack_require__(72)
	  , url = __webpack_require__(15)
	  , util = __webpack_require__(27)
	  , stream = __webpack_require__(56)
	  , zlib = __webpack_require__(73)
	  , bl = __webpack_require__(93)
	  , hawk = __webpack_require__(94)
	  , aws = __webpack_require__(95)
	  , httpSignature = __webpack_require__(96)
	  , mime = __webpack_require__(111)
	  , stringstream = __webpack_require__(114)
	  , caseless = __webpack_require__(115)
	  , ForeverAgent = __webpack_require__(116)
	  , FormData = __webpack_require__(117)
	  , helpers = __webpack_require__(31)
	  , cookies = __webpack_require__(12)
	  , getProxyFromURI = __webpack_require__(118)
	  , Querystring = __webpack_require__(119).Querystring
	  , Har = __webpack_require__(125).Har
	  , Auth = __webpack_require__(151).Auth
	  , OAuth = __webpack_require__(153).OAuth
	  , Multipart = __webpack_require__(155).Multipart
	  , Redirect = __webpack_require__(159).Redirect
	  , Tunnel = __webpack_require__(160).Tunnel

	var safeStringify = helpers.safeStringify
	  , isReadStream = helpers.isReadStream
	  , toBase64 = helpers.toBase64
	  , defer = helpers.defer
	  , copy = helpers.copy
	  , globalCookieJar = cookies.jar()


	var globalPool = {}

	function filterForNonReserved(reserved, options) {
	  // Filter out properties that are not reserved.
	  // Reserved values are passed in at call site.

	  var object = {}
	  for (var i in options) {
	    var notReserved = (reserved.indexOf(i) === -1)
	    if (notReserved) {
	      object[i] = options[i]
	    }
	  }
	  return object
	}

	function filterOutReservedFunctions(reserved, options) {
	  // Filter out properties that are functions and are reserved.
	  // Reserved values are passed in at call site.

	  var object = {}
	  for (var i in options) {
	    var isReserved = !(reserved.indexOf(i) === -1)
	    var isFunction = (typeof options[i] === 'function')
	    if (!(isReserved && isFunction)) {
	      object[i] = options[i]
	    }
	  }
	  return object

	}

	// Function for properly handling a connection error
	function connectionErrorHandler(error) {
	  var socket = this
	  if (socket.res) {
	    if (socket.res.request) {
	      socket.res.request.emit('error', error)
	    } else {
	      socket.res.emit('error', error)
	    }
	  } else {
	    socket._httpMessage.emit('error', error)
	  }
	}

	// Return a simpler request object to allow serialization
	function requestToJSON() {
	  var self = this
	  return {
	    uri: self.uri,
	    method: self.method,
	    headers: self.headers
	  }
	}

	// Return a simpler response object to allow serialization
	function responseToJSON() {
	  var self = this
	  return {
	    statusCode: self.statusCode,
	    body: self.body,
	    headers: self.headers,
	    request: requestToJSON.call(self.request)
	  }
	}

	function Request (options) {
	  // if given the method property in options, set property explicitMethod to true

	  // extend the Request instance with any non-reserved properties
	  // remove any reserved functions from the options object
	  // set Request instance to be readable and writable
	  // call init

	  var self = this

	  // start with HAR, then override with additional options
	  if (options.har) {
	    self._har = new Har(self)
	    options = self._har.options(options)
	  }

	  stream.Stream.call(self)
	  var reserved = Object.keys(Request.prototype)
	  var nonReserved = filterForNonReserved(reserved, options)

	  stream.Stream.call(self)
	  util._extend(self, nonReserved)
	  options = filterOutReservedFunctions(reserved, options)

	  self.readable = true
	  self.writable = true
	  if (options.method) {
	    self.explicitMethod = true
	  }
	  self._qs = new Querystring(self)
	  self._auth = new Auth(self)
	  self._oauth = new OAuth(self)
	  self._multipart = new Multipart(self)
	  self._redirect = new Redirect(self)
	  self._tunnel = new Tunnel(self)
	  self.init(options)
	}

	util.inherits(Request, stream.Stream)

	// Debugging
	Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG)
	function debug() {
	  if (Request.debug) {
	    console.error('REQUEST %s', util.format.apply(util, arguments))
	  }
	}
	Request.prototype.debug = debug

	Request.prototype.init = function (options) {
	  // init() contains all the code to setup the request object.
	  // the actual outgoing request is not started until start() is called
	  // this function is called from both the constructor and on redirect.
	  var self = this
	  if (!options) {
	    options = {}
	  }
	  self.headers = self.headers ? copy(self.headers) : {}

	  // Delete headers with value undefined since they break
	  // ClientRequest.OutgoingMessage.setHeader in node 0.12
	  for (var headerName in self.headers) {
	    if (typeof self.headers[headerName] === 'undefined') {
	      delete self.headers[headerName]
	    }
	  }

	  caseless.httpify(self, self.headers)

	  if (!self.method) {
	    self.method = options.method || 'GET'
	  }
	  if (!self.localAddress) {
	    self.localAddress = options.localAddress
	  }

	  self._qs.init(options)

	  debug(options)
	  if (!self.pool && self.pool !== false) {
	    self.pool = globalPool
	  }
	  self.dests = self.dests || []
	  self.__isRequestRequest = true

	  // Protect against double callback
	  if (!self._callback && self.callback) {
	    self._callback = self.callback
	    self.callback = function () {
	      if (self._callbackCalled) {
	        return // Print a warning maybe?
	      }
	      self._callbackCalled = true
	      self._callback.apply(self, arguments)
	    }
	    self.on('error', self.callback.bind())
	    self.on('complete', self.callback.bind(self, null))
	  }

	  // People use this property instead all the time, so support it
	  if (!self.uri && self.url) {
	    self.uri = self.url
	    delete self.url
	  }

	  // If there's a baseUrl, then use it as the base URL (i.e. uri must be
	  // specified as a relative path and is appended to baseUrl).
	  if (self.baseUrl) {
	    if (typeof self.baseUrl !== 'string') {
	      return self.emit('error', new Error('options.baseUrl must be a string'))
	    }

	    if (typeof self.uri !== 'string') {
	      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))
	    }

	    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {
	      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))
	    }

	    // Handle all cases to make sure that there's only one slash between
	    // baseUrl and uri.
	    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1
	    var uriStartsWithSlash = self.uri.indexOf('/') === 0

	    if (baseUrlEndsWithSlash && uriStartsWithSlash) {
	      self.uri = self.baseUrl + self.uri.slice(1)
	    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
	      self.uri = self.baseUrl + self.uri
	    } else if (self.uri === '') {
	      self.uri = self.baseUrl
	    } else {
	      self.uri = self.baseUrl + '/' + self.uri
	    }
	    delete self.baseUrl
	  }

	  // A URI is needed by this point, emit error if we haven't been able to get one
	  if (!self.uri) {
	    return self.emit('error', new Error('options.uri is a required argument'))
	  }

	  // If a string URI/URL was given, parse it into a URL object
	  if (typeof self.uri === 'string') {
	    self.uri = url.parse(self.uri)
	  }

	  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
	  if (self.uri.protocol === 'unix:') {
	    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))
	  }

	  // Support Unix Sockets
	  if (self.uri.host === 'unix') {
	    // Get the socket & request paths from the URL
	    var unixParts = self.uri.path.split(':')
	      , host = unixParts[0]
	      , path = unixParts[1]
	    // Apply unix properties to request
	    self.socketPath = host
	    self.uri.pathname = path
	    self.uri.path = path
	    self.uri.host = host
	    self.uri.hostname = host
	    self.uri.isUnix = true
	  }

	  if (self.strictSSL === false) {
	    self.rejectUnauthorized = false
	  }

	  if (!self.uri.pathname) {self.uri.pathname = '/'}

	  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {
	    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar
	    // Detect and reject it as soon as possible
	    var faultyUri = url.format(self.uri)
	    var message = 'Invalid URI "' + faultyUri + '"'
	    if (Object.keys(options).length === 0) {
	      // No option ? This can be the sign of a redirect
	      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)
	      // they should be warned that it can be caused by a redirection (can save some hair)
	      message += '. This can be caused by a crappy redirection.'
	    }
	    // This error was fatal
	    return self.emit('error', new Error(message))
	  }

	  if (!self.hasOwnProperty('proxy')) {
	    self.proxy = getProxyFromURI(self.uri)
	  }

	  self.tunnel = self._tunnel.isEnabled(options)
	  if (self.proxy) {
	    self._tunnel.setup(options)
	  }

	  self._redirect.onRequest(options)

	  self.setHost = false
	  if (!self.hasHeader('host')) {
	    var hostHeaderName = self.originalHostHeaderName || 'host'
	    self.setHeader(hostHeaderName, self.uri.hostname)
	    if (self.uri.port) {
	      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&
	           !(self.uri.port === 443 && self.uri.protocol === 'https:') ) {
	        self.setHeader(hostHeaderName, self.getHeader('host') + (':' + self.uri.port) )
	      }
	    }
	    self.setHost = true
	  }

	  self.jar(self._jar || options.jar)

	  if (!self.uri.port) {
	    if (self.uri.protocol === 'http:') {self.uri.port = 80}
	    else if (self.uri.protocol === 'https:') {self.uri.port = 443}
	  }

	  if (self.proxy && !self.tunnel) {
	    self.port = self.proxy.port
	    self.host = self.proxy.hostname
	  } else {
	    self.port = self.uri.port
	    self.host = self.uri.hostname
	  }

	  if (options.form) {
	    self.form(options.form)
	  }

	  if (options.formData) {
	    var formData = options.formData
	    var requestForm = self.form()
	    var appendFormValue = function (key, value) {
	      if (value.hasOwnProperty('value') && value.hasOwnProperty('options')) {
	        requestForm.append(key, value.value, value.options)
	      } else {
	        requestForm.append(key, value)
	      }
	    }
	    for (var formKey in formData) {
	      if (formData.hasOwnProperty(formKey)) {
	        var formValue = formData[formKey]
	        if (formValue instanceof Array) {
	          for (var j = 0; j < formValue.length; j++) {
	            appendFormValue(formKey, formValue[j])
	          }
	        } else {
	          appendFormValue(formKey, formValue)
	        }
	      }
	    }
	  }

	  if (options.qs) {
	    self.qs(options.qs)
	  }

	  if (self.uri.path) {
	    self.path = self.uri.path
	  } else {
	    self.path = self.uri.pathname + (self.uri.search || '')
	  }

	  if (self.path.length === 0) {
	    self.path = '/'
	  }

	  // Auth must happen last in case signing is dependent on other headers
	  if (options.aws) {
	    self.aws(options.aws)
	  }

	  if (options.hawk) {
	    self.hawk(options.hawk)
	  }

	  if (options.httpSignature) {
	    self.httpSignature(options.httpSignature)
	  }

	  if (options.auth) {
	    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {
	      options.auth.user = options.auth.username
	    }
	    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {
	      options.auth.pass = options.auth.password
	    }

	    self.auth(
	      options.auth.user,
	      options.auth.pass,
	      options.auth.sendImmediately,
	      options.auth.bearer
	    )
	  }

	  if (self.gzip && !self.hasHeader('accept-encoding')) {
	    self.setHeader('accept-encoding', 'gzip')
	  }

	  if (self.uri.auth && !self.hasHeader('authorization')) {
	    var uriAuthPieces = self.uri.auth.split(':').map(function(item) {return self._qs.unescape(item)})
	    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)
	  }

	  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {
	    var proxyAuthPieces = self.proxy.auth.split(':').map(function(item) {return self._qs.unescape(item)})
	    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))
	    self.setHeader('proxy-authorization', authHeader)
	  }

	  if (self.proxy && !self.tunnel) {
	    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)
	  }

	  if (options.json) {
	    self.json(options.json)
	  }
	  if (options.multipart) {
	    self.multipart(options.multipart)
	  }

	  if (options.time) {
	    self.timing = true
	    self.elapsedTime = self.elapsedTime || 0
	  }

	  if (self.body) {
	    var length = 0
	    if (!Buffer.isBuffer(self.body)) {
	      if (Array.isArray(self.body)) {
	        for (var i = 0; i < self.body.length; i++) {
	          length += self.body[i].length
	        }
	      } else {
	        self.body = new Buffer(self.body)
	        length = self.body.length
	      }
	    } else {
	      length = self.body.length
	    }
	    if (length) {
	      if (!self.hasHeader('content-length')) {
	        self.setHeader('content-length', length)
	      }
	    } else {
	      self.emit('error', new Error('Argument error, options.body.'))
	    }
	  }

	  if (options.oauth) {
	    self.oauth(options.oauth)
	  } else if (self._oauth.params && self.hasHeader('authorization')) {
	    self.oauth(self._oauth.params)
	  }

	  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
	    , defaultModules = {'http:':http, 'https:':https}
	    , httpModules = self.httpModules || {}

	  self.httpModule = httpModules[protocol] || defaultModules[protocol]

	  if (!self.httpModule) {
	    return self.emit('error', new Error('Invalid protocol: ' + protocol))
	  }

	  if (options.ca) {
	    self.ca = options.ca
	  }

	  if (!self.agent) {
	    if (options.agentOptions) {
	      self.agentOptions = options.agentOptions
	    }

	    if (options.agentClass) {
	      self.agentClass = options.agentClass
	    } else if (options.forever) {
	      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
	    } else {
	      self.agentClass = self.httpModule.Agent
	    }
	  }

	  if (self.pool === false) {
	    self.agent = false
	  } else {
	    self.agent = self.agent || self.getNewAgent()
	  }

	  self.on('pipe', function (src) {
	    if (self.ntick && self._started) {
	      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))
	    }
	    self.src = src
	    if (isReadStream(src)) {
	      if (!self.hasHeader('content-type')) {
	        self.setHeader('content-type', mime.lookup(src.path))
	      }
	    } else {
	      if (src.headers) {
	        for (var i in src.headers) {
	          if (!self.hasHeader(i)) {
	            self.setHeader(i, src.headers[i])
	          }
	        }
	      }
	      if (self._json && !self.hasHeader('content-type')) {
	        self.setHeader('content-type', 'application/json')
	      }
	      if (src.method && !self.explicitMethod) {
	        self.method = src.method
	      }
	    }

	    // self.on('pipe', function () {
	    //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')
	    // })
	  })

	  defer(function () {
	    if (self._aborted) {
	      return
	    }

	    var end = function () {
	      if (self._form) {
	        if (!self._auth.hasAuth) {
	          self._form.pipe(self)
	        }
	        else if (self._auth.hasAuth && self._auth.sentAuth) {
	          self._form.pipe(self)
	        }
	      }
	      if (self._multipart && self._multipart.chunked) {
	        self._multipart.body.pipe(self)
	      }
	      if (self.body) {
	        if (Array.isArray(self.body)) {
	          self.body.forEach(function (part) {
	            self.write(part)
	          })
	        } else {
	          self.write(self.body)
	        }
	        self.end()
	      } else if (self.requestBodyStream) {
	        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')
	        self.requestBodyStream.pipe(self)
	      } else if (!self.src) {
	        if (self._auth.hasAuth && !self._auth.sentAuth) {
	          self.end()
	          return
	        }
	        if (self.method !== 'GET' && typeof self.method !== 'undefined') {
	          self.setHeader('content-length', 0)
	        }
	        self.end()
	      }
	    }

	    if (self._form && !self.hasHeader('content-length')) {
	      // Before ending the request, we had to compute the length of the whole form, asyncly
	      self.setHeader(self._form.getHeaders())
	      self._form.getLength(function (err, length) {
	        if (!err) {
	          self.setHeader('content-length', length)
	        }
	        end()
	      })
	    } else {
	      end()
	    }

	    self.ntick = true
	  })

	}

	// Must call this when following a redirect from https to http or vice versa
	// Attempts to keep everything as identical as possible, but update the
	// httpModule, Tunneling agent, and/or Forever Agent in use.
	Request.prototype._updateProtocol = function () {
	  var self = this
	  var protocol = self.uri.protocol

	  if (protocol === 'https:' || self.tunnel) {
	    // previously was doing http, now doing https
	    // if it's https, then we might need to tunnel now.
	    if (self.proxy) {
	      if (self._tunnel.setup()) {
	        return
	      }
	    }

	    self.httpModule = https
	    switch (self.agentClass) {
	      case ForeverAgent:
	        self.agentClass = ForeverAgent.SSL
	        break
	      case http.Agent:
	        self.agentClass = https.Agent
	        break
	      default:
	        // nothing we can do.  Just hope for the best.
	        return
	    }

	    // if there's an agent, we need to get a new one.
	    if (self.agent) {
	      self.agent = self.getNewAgent()
	    }

	  } else {
	    // previously was doing https, now doing http
	    self.httpModule = http
	    switch (self.agentClass) {
	      case ForeverAgent.SSL:
	        self.agentClass = ForeverAgent
	        break
	      case https.Agent:
	        self.agentClass = http.Agent
	        break
	      default:
	        // nothing we can do.  just hope for the best
	        return
	    }

	    // if there's an agent, then get a new one.
	    if (self.agent) {
	      self.agent = null
	      self.agent = self.getNewAgent()
	    }
	  }
	}

	Request.prototype.getNewAgent = function () {
	  var self = this
	  var Agent = self.agentClass
	  var options = {}
	  if (self.agentOptions) {
	    for (var i in self.agentOptions) {
	      options[i] = self.agentOptions[i]
	    }
	  }
	  if (self.ca) {
	    options.ca = self.ca
	  }
	  if (self.ciphers) {
	    options.ciphers = self.ciphers
	  }
	  if (self.secureProtocol) {
	    options.secureProtocol = self.secureProtocol
	  }
	  if (self.secureOptions) {
	    options.secureOptions = self.secureOptions
	  }
	  if (typeof self.rejectUnauthorized !== 'undefined') {
	    options.rejectUnauthorized = self.rejectUnauthorized
	  }

	  if (self.cert && self.key) {
	    options.key = self.key
	    options.cert = self.cert
	  }

	  if (self.pfx) {
	    options.pfx = self.pfx
	  }

	  if (self.passphrase) {
	    options.passphrase = self.passphrase
	  }

	  var poolKey = ''

	  // different types of agents are in different pools
	  if (Agent !== self.httpModule.Agent) {
	    poolKey += Agent.name
	  }

	  // ca option is only relevant if proxy or destination are https
	  var proxy = self.proxy
	  if (typeof proxy === 'string') {
	    proxy = url.parse(proxy)
	  }
	  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'

	  if (isHttps) {
	    if (options.ca) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.ca
	    }

	    if (typeof options.rejectUnauthorized !== 'undefined') {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.rejectUnauthorized
	    }

	    if (options.cert) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')
	    }

	    if (options.pfx) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.pfx.toString('ascii')
	    }

	    if (options.ciphers) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.ciphers
	    }

	    if (options.secureProtocol) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.secureProtocol
	    }

	    if (options.secureOptions) {
	      if (poolKey) {
	        poolKey += ':'
	      }
	      poolKey += options.secureOptions
	    }
	  }

	  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {
	    // not doing anything special.  Use the globalAgent
	    return self.httpModule.globalAgent
	  }

	  // we're using a stored agent.  Make sure it's protocol-specific
	  poolKey = self.uri.protocol + poolKey

	  // generate a new agent for this setting if none yet exists
	  if (!self.pool[poolKey]) {
	    self.pool[poolKey] = new Agent(options)
	    // properly set maxSockets on new agents
	    if (self.pool.maxSockets) {
	      self.pool[poolKey].maxSockets = self.pool.maxSockets
	    }
	  }

	  return self.pool[poolKey]
	}

	Request.prototype.start = function () {
	  // start() is called once we are ready to send the outgoing HTTP request.
	  // this is usually called on the first write(), end() or on nextTick()
	  var self = this

	  if (self._aborted) {
	    return
	  }

	  self._started = true
	  self.method = self.method || 'GET'
	  self.href = self.uri.href

	  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {
	    self.setHeader('content-length', self.src.stat.size)
	  }
	  if (self._aws) {
	    self.aws(self._aws, true)
	  }

	  // We have a method named auth, which is completely different from the http.request
	  // auth option.  If we don't remove it, we're gonna have a bad time.
	  var reqOptions = copy(self)
	  delete reqOptions.auth

	  debug('make request', self.uri.href)

	  self.req = self.httpModule.request(reqOptions)

	  if (self.timing) {
	    self.startTime = new Date().getTime()
	  }

	  if (self.timeout && !self.timeoutTimer) {
	    var timeout = self.timeout < 0 ? 0 : self.timeout
	    self.timeoutTimer = setTimeout(function () {
	      self.abort()
	      var e = new Error('ETIMEDOUT')
	      e.code = 'ETIMEDOUT'
	      self.emit('error', e)
	    }, timeout)

	    // Set additional timeout on socket - in case if remote
	    // server freeze after sending headers
	    if (self.req.setTimeout) { // only works on node 0.6+
	      self.req.setTimeout(timeout, function () {
	        if (self.req) {
	          self.req.abort()
	          var e = new Error('ESOCKETTIMEDOUT')
	          e.code = 'ESOCKETTIMEDOUT'
	          self.emit('error', e)
	        }
	      })
	    }
	  }

	  self.req.on('response', self.onRequestResponse.bind(self))
	  self.req.on('error', self.onRequestError.bind(self))
	  self.req.on('drain', function() {
	    self.emit('drain')
	  })
	  self.req.on('socket', function(socket) {
	    self.emit('socket', socket)
	  })

	  self.on('end', function() {
	    if ( self.req.connection ) {
	      self.req.connection.removeListener('error', connectionErrorHandler)
	    }
	  })
	  self.emit('request', self.req)
	}

	Request.prototype.onRequestError = function (error) {
	  var self = this
	  if (self._aborted) {
	    return
	  }
	  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
	      && self.agent.addRequestNoreuse) {
	    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
	    self.start()
	    self.req.end()
	    return
	  }
	  if (self.timeout && self.timeoutTimer) {
	    clearTimeout(self.timeoutTimer)
	    self.timeoutTimer = null
	  }
	  self.emit('error', error)
	}

	Request.prototype.onRequestResponse = function (response) {
	  var self = this
	  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)
	  response.on('end', function() {
	    if (self.timing) {
	      self.elapsedTime += (new Date().getTime() - self.startTime)
	      debug('elapsed time', self.elapsedTime)
	      response.elapsedTime = self.elapsedTime
	    }
	    debug('response end', self.uri.href, response.statusCode, response.headers)
	  })

	  // The check on response.connection is a workaround for browserify.
	  if (response.connection && response.connection.listeners('error').indexOf(connectionErrorHandler) === -1) {
	    response.connection.setMaxListeners(0)
	    response.connection.once('error', connectionErrorHandler)
	  }
	  if (self._aborted) {
	    debug('aborted', self.uri.href)
	    response.resume()
	    return
	  }

	  self.response = response
	  response.request = self
	  response.toJSON = responseToJSON

	  // XXX This is different on 0.10, because SSL is strict by default
	  if (self.httpModule === https &&
	      self.strictSSL && (!response.hasOwnProperty('socket') ||
	      !response.socket.authorized)) {
	    debug('strict ssl error', self.uri.href)
	    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'
	    self.emit('error', new Error('SSL Error: ' + sslErr))
	    return
	  }

	  // Save the original host before any redirect (if it changes, we need to
	  // remove any authorization headers).  Also remember the case of the header
	  // name because lots of broken servers expect Host instead of host and we
	  // want the caller to be able to specify this.
	  self.originalHost = self.getHeader('host')
	  if (!self.originalHostHeaderName) {
	    self.originalHostHeaderName = self.hasHeader('host')
	  }
	  if (self.setHost) {
	    self.removeHeader('host')
	  }
	  if (self.timeout && self.timeoutTimer) {
	    clearTimeout(self.timeoutTimer)
	    self.timeoutTimer = null
	  }

	  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar
	  var addCookie = function (cookie) {
	    //set the cookie if it's domain in the href's domain.
	    try {
	      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
	    } catch (e) {
	      self.emit('error', e)
	    }
	  }

	  response.caseless = caseless(response.headers)

	  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {
	    var headerName = response.caseless.has('set-cookie')
	    if (Array.isArray(response.headers[headerName])) {
	      response.headers[headerName].forEach(addCookie)
	    } else {
	      addCookie(response.headers[headerName])
	    }
	  }

	  if (self._redirect.onResponse(response)) {
	    return // Ignore the rest of the response
	  } else {
	    // Be a good stream and emit end when the response is finished.
	    // Hack to emit end on close because of a core bug that never fires end
	    response.on('close', function () {
	      if (!self._ended) {
	        self.response.emit('end')
	      }
	    })

	    response.on('end', function () {
	      self._ended = true
	    })

	    var responseContent
	    if (self.gzip) {
	      var contentEncoding = response.headers['content-encoding'] || 'identity'
	      contentEncoding = contentEncoding.trim().toLowerCase()

	      if (contentEncoding === 'gzip') {
	        responseContent = zlib.createGunzip()
	        response.pipe(responseContent)
	      } else {
	        // Since previous versions didn't check for Content-Encoding header,
	        // ignore any invalid values to preserve backwards-compatibility
	        if (contentEncoding !== 'identity') {
	          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)
	        }
	        responseContent = response
	      }
	    } else {
	      responseContent = response
	    }

	    if (self.encoding) {
	      if (self.dests.length !== 0) {
	        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')
	      } else if (responseContent.setEncoding) {
	        responseContent.setEncoding(self.encoding)
	      } else {
	        // Should only occur on node pre-v0.9.4 (joyent/node@9b5abe5) with
	        // zlib streams.
	        // If/When support for 0.9.4 is dropped, this should be unnecessary.
	        responseContent = responseContent.pipe(stringstream(self.encoding))
	      }
	    }

	    if (self._paused) {
	      responseContent.pause()
	    }

	    self.responseContent = responseContent

	    self.emit('response', response)

	    self.dests.forEach(function (dest) {
	      self.pipeDest(dest)
	    })

	    responseContent.on('data', function (chunk) {
	      self._destdata = true
	      self.emit('data', chunk)
	    })
	    responseContent.on('end', function (chunk) {
	      self.emit('end', chunk)
	    })
	    responseContent.on('error', function (error) {
	      self.emit('error', error)
	    })
	    responseContent.on('close', function () {self.emit('close')})

	    if (self.callback) {
	      var buffer = bl()
	        , strings = []

	      self.on('data', function (chunk) {
	        if (Buffer.isBuffer(chunk)) {
	          buffer.append(chunk)
	        } else {
	          strings.push(chunk)
	        }
	      })
	      self.on('end', function () {
	        debug('end event', self.uri.href)
	        if (self._aborted) {
	          debug('aborted', self.uri.href)
	          return
	        }

	        if (buffer.length) {
	          debug('has body', self.uri.href, buffer.length)
	          if (self.encoding === null) {
	            // response.body = buffer
	            // can't move to this until https://github.com/rvagg/bl/issues/13
	            response.body = buffer.slice()
	          } else {
	            response.body = buffer.toString(self.encoding)
	          }
	        } else if (strings.length) {
	          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
	          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
	          if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\uFEFF') {
	            strings[0] = strings[0].substring(1)
	          }
	          response.body = strings.join('')
	        }

	        if (self._json) {
	          try {
	            response.body = JSON.parse(response.body, self._jsonReviver)
	          } catch (e) {
	            // empty
	          }
	        }
	        debug('emitting complete', self.uri.href)
	        if (typeof response.body === 'undefined' && !self._json) {
	          response.body = self.encoding === null ? new Buffer(0) : ''
	        }
	        self.emit('complete', response, response.body)
	      })
	    }
	    //if no callback
	    else {
	      self.on('end', function () {
	        if (self._aborted) {
	          debug('aborted', self.uri.href)
	          return
	        }
	        self.emit('complete', response)
	      })
	    }
	  }
	  debug('finish init function', self.uri.href)
	}

	Request.prototype.abort = function () {
	  var self = this
	  self._aborted = true

	  if (self.req) {
	    self.req.abort()
	  }
	  else if (self.response) {
	    self.response.abort()
	  }

	  self.emit('abort')
	}

	Request.prototype.pipeDest = function (dest) {
	  var self = this
	  var response = self.response
	  // Called after the response is received
	  if (dest.headers && !dest.headersSent) {
	    if (response.caseless.has('content-type')) {
	      var ctname = response.caseless.has('content-type')
	      if (dest.setHeader) {
	        dest.setHeader(ctname, response.headers[ctname])
	      }
	      else {
	        dest.headers[ctname] = response.headers[ctname]
	      }
	    }

	    if (response.caseless.has('content-length')) {
	      var clname = response.caseless.has('content-length')
	      if (dest.setHeader) {
	        dest.setHeader(clname, response.headers[clname])
	      } else {
	        dest.headers[clname] = response.headers[clname]
	      }
	    }
	  }
	  if (dest.setHeader && !dest.headersSent) {
	    for (var i in response.headers) {
	      // If the response content is being decoded, the Content-Encoding header
	      // of the response doesn't represent the piped content, so don't pass it.
	      if (!self.gzip || i !== 'content-encoding') {
	        dest.setHeader(i, response.headers[i])
	      }
	    }
	    dest.statusCode = response.statusCode
	  }
	  if (self.pipefilter) {
	    self.pipefilter(response, dest)
	  }
	}

	Request.prototype.qs = function (q, clobber) {
	  var self = this
	  var base
	  if (!clobber && self.uri.query) {
	    base = self._qs.parse(self.uri.query)
	  } else {
	    base = {}
	  }

	  for (var i in q) {
	    base[i] = q[i]
	  }

	  if (self._qs.stringify(base) === '') {
	    return self
	  }

	  var qs = self._qs.stringify(base)

	  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)
	  self.url = self.uri
	  self.path = self.uri.path

	  return self
	}
	Request.prototype.form = function (form) {
	  var self = this
	  if (form) {
	    self.setHeader('content-type', 'application/x-www-form-urlencoded')
	    self.body = (typeof form === 'string')
	      ? self._qs.rfc3986(form.toString('utf8'))
	      : self._qs.stringify(form).toString('utf8')
	    return self
	  }
	  // create form-data object
	  self._form = new FormData()
	  self._form.on('error', function(err) {
	    err.message = 'form-data: ' + err.message
	    self.emit('error', err)
	    self.abort()
	  })
	  return self._form
	}
	Request.prototype.multipart = function (multipart) {
	  var self = this

	  self._multipart.onRequest(multipart)

	  if (!self._multipart.chunked) {
	    self.body = self._multipart.body
	  }

	  return self
	}
	Request.prototype.json = function (val) {
	  var self = this

	  if (!self.hasHeader('accept')) {
	    self.setHeader('accept', 'application/json')
	  }

	  self._json = true
	  if (typeof val === 'boolean') {
	    if (self.body !== undefined) {
	      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
	        self.body = safeStringify(self.body)
	      } else {
	        self.body = self._qs.rfc3986(self.body)
	      }
	      if (!self.hasHeader('content-type')) {
	        self.setHeader('content-type', 'application/json')
	      }
	    }
	  } else {
	    self.body = safeStringify(val)
	    if (!self.hasHeader('content-type')) {
	      self.setHeader('content-type', 'application/json')
	    }
	  }

	  if (typeof self.jsonReviver === 'function') {
	    self._jsonReviver = self.jsonReviver
	  }

	  return self
	}
	Request.prototype.getHeader = function (name, headers) {
	  var self = this
	  var result, re, match
	  if (!headers) {
	    headers = self.headers
	  }
	  Object.keys(headers).forEach(function (key) {
	    if (key.length !== name.length) {
	      return
	    }
	    re = new RegExp(name, 'i')
	    match = key.match(re)
	    if (match) {
	      result = headers[key]
	    }
	  })
	  return result
	}

	Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
	  var self = this

	  self._auth.onRequest(user, pass, sendImmediately, bearer)

	  return self
	}
	Request.prototype.aws = function (opts, now) {
	  var self = this

	  if (!now) {
	    self._aws = opts
	    return self
	  }
	  var date = new Date()
	  self.setHeader('date', date.toUTCString())
	  var auth =
	    { key: opts.key
	    , secret: opts.secret
	    , verb: self.method.toUpperCase()
	    , date: date
	    , contentType: self.getHeader('content-type') || ''
	    , md5: self.getHeader('content-md5') || ''
	    , amazonHeaders: aws.canonicalizeHeaders(self.headers)
	    }
	  var path = self.uri.path
	  if (opts.bucket && path) {
	    auth.resource = '/' + opts.bucket + path
	  } else if (opts.bucket && !path) {
	    auth.resource = '/' + opts.bucket
	  } else if (!opts.bucket && path) {
	    auth.resource = path
	  } else if (!opts.bucket && !path) {
	    auth.resource = '/'
	  }
	  auth.resource = aws.canonicalizeResource(auth.resource)
	  self.setHeader('authorization', aws.authorization(auth))

	  return self
	}
	Request.prototype.httpSignature = function (opts) {
	  var self = this
	  httpSignature.signRequest({
	    getHeader: function(header) {
	      return self.getHeader(header, self.headers)
	    },
	    setHeader: function(header, value) {
	      self.setHeader(header, value)
	    },
	    method: self.method,
	    path: self.path
	  }, opts)
	  debug('httpSignature authorization', self.getHeader('authorization'))

	  return self
	}
	Request.prototype.hawk = function (opts) {
	  var self = this
	  self.setHeader('Authorization', hawk.client.header(self.uri, self.method, opts).field)
	}
	Request.prototype.oauth = function (_oauth) {
	  var self = this

	  self._oauth.onRequest(_oauth)

	  return self
	}

	Request.prototype.jar = function (jar) {
	  var self = this
	  var cookies

	  if (self._redirect.redirectsFollowed === 0) {
	    self.originalCookieHeader = self.getHeader('cookie')
	  }

	  if (!jar) {
	    // disable cookies
	    cookies = false
	    self._disableCookies = true
	  } else {
	    var targetCookieJar = (jar && jar.getCookieString) ? jar : globalCookieJar
	    var urihref = self.uri.href
	    //fetch cookie in the Specified host
	    if (targetCookieJar) {
	      cookies = targetCookieJar.getCookieString(urihref)
	    }
	  }

	  //if need cookie and cookie is not empty
	  if (cookies && cookies.length) {
	    if (self.originalCookieHeader) {
	      // Don't overwrite existing Cookie header
	      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)
	    } else {
	      self.setHeader('cookie', cookies)
	    }
	  }
	  self._jar = jar
	  return self
	}


	// Stream API
	Request.prototype.pipe = function (dest, opts) {
	  var self = this

	  if (self.response) {
	    if (self._destdata) {
	      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))
	    } else if (self._ended) {
	      self.emit('error', new Error('You cannot pipe after the response has been ended.'))
	    } else {
	      stream.Stream.prototype.pipe.call(self, dest, opts)
	      self.pipeDest(dest)
	      return dest
	    }
	  } else {
	    self.dests.push(dest)
	    stream.Stream.prototype.pipe.call(self, dest, opts)
	    return dest
	  }
	}
	Request.prototype.write = function () {
	  var self = this
	  if (!self._started) {
	    self.start()
	  }
	  return self.req.write.apply(self.req, arguments)
	}
	Request.prototype.end = function (chunk) {
	  var self = this
	  if (chunk) {
	    self.write(chunk)
	  }
	  if (!self._started) {
	    self.start()
	  }
	  self.req.end()
	}
	Request.prototype.pause = function () {
	  var self = this
	  if (!self.responseContent) {
	    self._paused = true
	  } else {
	    self.responseContent.pause.apply(self.responseContent, arguments)
	  }
	}
	Request.prototype.resume = function () {
	  var self = this
	  if (!self.responseContent) {
	    self._paused = false
	  } else {
	    self.responseContent.resume.apply(self.responseContent, arguments)
	  }
	}
	Request.prototype.destroy = function () {
	  var self = this
	  if (!self._ended) {
	    self.end()
	  } else if (self.response) {
	    self.response.destroy()
	  }
	}

	Request.defaultProxyHeaderWhiteList =
	  Tunnel.defaultProxyHeaderWhiteList.slice()

	Request.defaultProxyHeaderExclusiveList =
	  Tunnel.defaultProxyHeaderExclusiveList.slice()

	// Exports

	Request.prototype.toJSON = requestToJSON
	module.exports = Request

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(32).Buffer))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var http = module.exports;
	var EventEmitter = __webpack_require__(54).EventEmitter;
	var Request = __webpack_require__(55);
	var url = __webpack_require__(15)

	http.request = function (params, cb) {
	    if (typeof params === 'string') {
	        params = url.parse(params)
	    }
	    if (!params) params = {};
	    if (!params.host && !params.port) {
	        params.port = parseInt(window.location.port, 10);
	    }
	    if (!params.host && params.hostname) {
	        params.host = params.hostname;
	    }

	    if (!params.protocol) {
	        if (params.scheme) {
	            params.protocol = params.scheme + ':';
	        } else {
	            params.protocol = window.location.protocol;
	        }
	    }

	    if (!params.host) {
	        params.host = window.location.hostname || window.location.host;
	    }
	    if (/:/.test(params.host)) {
	        if (!params.port) {
	            params.port = params.host.split(':')[1];
	        }
	        params.host = params.host.split(':')[0];
	    }
	    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
	    
	    var req = new Request(new xhrHttp, params);
	    if (cb) req.on('response', cb);
	    return req;
	};

	http.get = function (params, cb) {
	    params.method = 'GET';
	    var req = http.request(params, cb);
	    req.end();
	    return req;
	};

	http.Agent = function () {};
	http.Agent.defaultMaxSockets = 4;

	var xhrHttp = (function () {
	    if (typeof window === 'undefined') {
	        throw new Error('no window object present');
	    }
	    else if (window.XMLHttpRequest) {
	        return window.XMLHttpRequest;
	    }
	    else if (window.ActiveXObject) {
	        var axs = [
	            'Msxml2.XMLHTTP.6.0',
	            'Msxml2.XMLHTTP.3.0',
	            'Microsoft.XMLHTTP'
	        ];
	        for (var i = 0; i < axs.length; i++) {
	            try {
	                var ax = new(window.ActiveXObject)(axs[i]);
	                return function () {
	                    if (ax) {
	                        var ax_ = ax;
	                        ax = null;
	                        return ax_;
	                    }
	                    else {
	                        return new(window.ActiveXObject)(axs[i]);
	                    }
	                };
	            }
	            catch (e) {}
	        }
	        throw new Error('ajax not supported in this browser')
	    }
	    else {
	        throw new Error('ajax not supported in this browser');
	    }
	})();

	http.STATUS_CODES = {
	    100 : 'Continue',
	    101 : 'Switching Protocols',
	    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
	    200 : 'OK',
	    201 : 'Created',
	    202 : 'Accepted',
	    203 : 'Non-Authoritative Information',
	    204 : 'No Content',
	    205 : 'Reset Content',
	    206 : 'Partial Content',
	    207 : 'Multi-Status',               // RFC 4918
	    300 : 'Multiple Choices',
	    301 : 'Moved Permanently',
	    302 : 'Moved Temporarily',
	    303 : 'See Other',
	    304 : 'Not Modified',
	    305 : 'Use Proxy',
	    307 : 'Temporary Redirect',
	    400 : 'Bad Request',
	    401 : 'Unauthorized',
	    402 : 'Payment Required',
	    403 : 'Forbidden',
	    404 : 'Not Found',
	    405 : 'Method Not Allowed',
	    406 : 'Not Acceptable',
	    407 : 'Proxy Authentication Required',
	    408 : 'Request Time-out',
	    409 : 'Conflict',
	    410 : 'Gone',
	    411 : 'Length Required',
	    412 : 'Precondition Failed',
	    413 : 'Request Entity Too Large',
	    414 : 'Request-URI Too Large',
	    415 : 'Unsupported Media Type',
	    416 : 'Requested Range Not Satisfiable',
	    417 : 'Expectation Failed',
	    418 : 'I\'m a teapot',              // RFC 2324
	    422 : 'Unprocessable Entity',       // RFC 4918
	    423 : 'Locked',                     // RFC 4918
	    424 : 'Failed Dependency',          // RFC 4918
	    425 : 'Unordered Collection',       // RFC 4918
	    426 : 'Upgrade Required',           // RFC 2817
	    428 : 'Precondition Required',      // RFC 6585
	    429 : 'Too Many Requests',          // RFC 6585
	    431 : 'Request Header Fields Too Large',// RFC 6585
	    500 : 'Internal Server Error',
	    501 : 'Not Implemented',
	    502 : 'Bad Gateway',
	    503 : 'Service Unavailable',
	    504 : 'Gateway Time-out',
	    505 : 'HTTP Version Not Supported',
	    506 : 'Variant Also Negotiates',    // RFC 2295
	    507 : 'Insufficient Storage',       // RFC 4918
	    509 : 'Bandwidth Limit Exceeded',
	    510 : 'Not Extended',               // RFC 2774
	    511 : 'Network Authentication Required' // RFC 6585
	};

/***/ },
/* 54 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(56);
	var Response = __webpack_require__(70);
	var Base64 = __webpack_require__(71);
	var inherits = __webpack_require__(29);

	var Request = module.exports = function (xhr, params) {
	    var self = this;
	    self.writable = true;
	    self.xhr = xhr;
	    self.body = [];
	    
	    self.uri = (params.protocol || 'http:') + '//'
	        + params.host
	        + (params.port ? ':' + params.port : '')
	        + (params.path || '/')
	    ;
	    
	    if (typeof params.withCredentials === 'undefined') {
	        params.withCredentials = true;
	    }

	    try { xhr.withCredentials = params.withCredentials }
	    catch (e) {}
	    
	    if (params.responseType) try { xhr.responseType = params.responseType }
	    catch (e) {}
	    
	    xhr.open(
	        params.method || 'GET',
	        self.uri,
	        true
	    );

	    xhr.onerror = function(event) {
	        self.emit('error', new Error('Network error'));
	    };

	    self._headers = {};
	    
	    if (params.headers) {
	        var keys = objectKeys(params.headers);
	        for (var i = 0; i < keys.length; i++) {
	            var key = keys[i];
	            if (!self.isSafeRequestHeader(key)) continue;
	            var value = params.headers[key];
	            self.setHeader(key, value);
	        }
	    }
	    
	    if (params.auth) {
	        //basic auth
	        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
	    }

	    var res = new Response;
	    res.on('close', function () {
	        self.emit('close');
	    });
	    
	    res.on('ready', function () {
	        self.emit('response', res);
	    });

	    res.on('error', function (err) {
	        self.emit('error', err);
	    });
	    
	    xhr.onreadystatechange = function () {
	        // Fix for IE9 bug
	        // SCRIPT575: Could not complete the operation due to error c00c023f
	        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
	        if (xhr.__aborted) return;
	        res.handle(xhr);
	    };
	};

	inherits(Request, Stream);

	Request.prototype.setHeader = function (key, value) {
	    this._headers[key.toLowerCase()] = value
	};

	Request.prototype.getHeader = function (key) {
	    return this._headers[key.toLowerCase()]
	};

	Request.prototype.removeHeader = function (key) {
	    delete this._headers[key.toLowerCase()]
	};

	Request.prototype.write = function (s) {
	    this.body.push(s);
	};

	Request.prototype.destroy = function (s) {
	    this.xhr.__aborted = true;
	    this.xhr.abort();
	    this.emit('close');
	};

	Request.prototype.end = function (s) {
	    if (s !== undefined) this.body.push(s);

	    var keys = objectKeys(this._headers);
	    for (var i = 0; i < keys.length; i++) {
	        var key = keys[i];
	        var value = this._headers[key];
	        if (isArray(value)) {
	            for (var j = 0; j < value.length; j++) {
	                this.xhr.setRequestHeader(key, value[j]);
	            }
	        }
	        else this.xhr.setRequestHeader(key, value)
	    }

	    if (this.body.length === 0) {
	        this.xhr.send('');
	    }
	    else if (typeof this.body[0] === 'string') {
	        this.xhr.send(this.body.join(''));
	    }
	    else if (isArray(this.body[0])) {
	        var body = [];
	        for (var i = 0; i < this.body.length; i++) {
	            body.push.apply(body, this.body[i]);
	        }
	        this.xhr.send(body);
	    }
	    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
	        var len = 0;
	        for (var i = 0; i < this.body.length; i++) {
	            len += this.body[i].length;
	        }
	        var body = new(this.body[0].constructor)(len);
	        var k = 0;
	        
	        for (var i = 0; i < this.body.length; i++) {
	            var b = this.body[i];
	            for (var j = 0; j < b.length; j++) {
	                body[k++] = b[j];
	            }
	        }
	        this.xhr.send(body);
	    }
	    else if (isXHR2Compatible(this.body[0])) {
	        this.xhr.send(this.body[0]);
	    }
	    else {
	        var body = '';
	        for (var i = 0; i < this.body.length; i++) {
	            body += this.body[i].toString();
	        }
	        this.xhr.send(body);
	    }
	};

	// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
	Request.unsafeHeaders = [
	    "accept-charset",
	    "accept-encoding",
	    "access-control-request-headers",
	    "access-control-request-method",
	    "connection",
	    "content-length",
	    "cookie",
	    "cookie2",
	    "content-transfer-encoding",
	    "date",
	    "expect",
	    "host",
	    "keep-alive",
	    "origin",
	    "referer",
	    "te",
	    "trailer",
	    "transfer-encoding",
	    "upgrade",
	    "user-agent",
	    "via"
	];

	Request.prototype.isSafeRequestHeader = function (headerName) {
	    if (!headerName) return false;
	    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
	};

	var objectKeys = Object.keys || function (obj) {
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    return keys;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};

	var indexOf = function (xs, x) {
	    if (xs.indexOf) return xs.indexOf(x);
	    for (var i = 0; i < xs.length; i++) {
	        if (xs[i] === x) return i;
	    }
	    return -1;
	};

	var isXHR2Compatible = function (obj) {
	    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
	    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
	    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
	};


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(54).EventEmitter;
	var inherits = __webpack_require__(29);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(57);
	Stream.Writable = __webpack_require__(66);
	Stream.Duplex = __webpack_require__(67);
	Stream.Transform = __webpack_require__(68);
	Stream.PassThrough = __webpack_require__(69);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(56); // hack to fix a circular dependency issue when used with browserify
	exports = module.exports = __webpack_require__(58);
	exports.Stream = Stream;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(62);
	exports.Duplex = __webpack_require__(63);
	exports.Transform = __webpack_require__(64);
	exports.PassThrough = __webpack_require__(65);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(56);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(59);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(32).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(54).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(56);

	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(61).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }

	      if (state.needReadable)
	        emitReadable(stream);

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(61).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;

	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }

	    if (state.length === 0)
	      endReadable(this);

	    return ret;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;

	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;

	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}

	function emitReadable_(stream) {
	  stream.emit('readable');
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }

	  function onend() {
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);

	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}

	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;

	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }

	  while (state.pipesCount && null !== (chunk = src.read())) {

	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);

	    src.emit('data', chunk);

	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }

	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;

	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }

	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}

	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};

	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};

	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;

	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }

	  var paused = startPaused || false;
	  var readable = false;

	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;

	  stream.on('readable', function() {
	    readable = true;

	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);

	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });

	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };

	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };

	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(32).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(32).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	var Stream = __webpack_require__(56);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(63);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);

	  return ret;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;

	    doWrite(stream, state, len, chunk, encoding, cb);

	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }

	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	var Readable = __webpack_require__(58);
	var Writable = __webpack_require__(62);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(63);

	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  var ts = this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(64);

	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(62)


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(63)


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(64)


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(65)


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(56);
	var util = __webpack_require__(27);

	var Response = module.exports = function (res) {
	    this.offset = 0;
	    this.readable = true;
	};

	util.inherits(Response, Stream);

	var capable = {
	    streaming : true,
	    status2 : true
	};

	function parseHeaders (res) {
	    var lines = res.getAllResponseHeaders().split(/\r?\n/);
	    var headers = {};
	    for (var i = 0; i < lines.length; i++) {
	        var line = lines[i];
	        if (line === '') continue;
	        
	        var m = line.match(/^([^:]+):\s*(.*)/);
	        if (m) {
	            var key = m[1].toLowerCase(), value = m[2];
	            
	            if (headers[key] !== undefined) {
	            
	                if (isArray(headers[key])) {
	                    headers[key].push(value);
	                }
	                else {
	                    headers[key] = [ headers[key], value ];
	                }
	            }
	            else {
	                headers[key] = value;
	            }
	        }
	        else {
	            headers[line] = true;
	        }
	    }
	    return headers;
	}

	Response.prototype.getResponse = function (xhr) {
	    var respType = String(xhr.responseType).toLowerCase();
	    if (respType === 'blob') return xhr.responseBlob || xhr.response;
	    if (respType === 'arraybuffer') return xhr.response;
	    return xhr.responseText;
	}

	Response.prototype.getHeader = function (key) {
	    return this.headers[key.toLowerCase()];
	};

	Response.prototype.handle = function (res) {
	    if (res.readyState === 2 && capable.status2) {
	        try {
	            this.statusCode = res.status;
	            this.headers = parseHeaders(res);
	        }
	        catch (err) {
	            capable.status2 = false;
	        }
	        
	        if (capable.status2) {
	            this.emit('ready');
	        }
	    }
	    else if (capable.streaming && res.readyState === 3) {
	        try {
	            if (!this.statusCode) {
	                this.statusCode = res.status;
	                this.headers = parseHeaders(res);
	                this.emit('ready');
	            }
	        }
	        catch (err) {}
	        
	        try {
	            this._emitData(res);
	        }
	        catch (err) {
	            capable.streaming = false;
	        }
	    }
	    else if (res.readyState === 4) {
	        if (!this.statusCode) {
	            this.statusCode = res.status;
	            this.emit('ready');
	        }
	        this._emitData(res);
	        
	        if (res.error) {
	            this.emit('error', this.getResponse(res));
	        }
	        else this.emit('end');
	        
	        this.emit('close');
	    }
	};

	Response.prototype._emitData = function (res) {
	    var respBody = this.getResponse(res);
	    if (respBody.toString().match(/ArrayBuffer/)) {
	        this.emit('data', new Uint8Array(respBody, this.offset));
	        this.offset = respBody.byteLength;
	        return;
	    }
	    if (respBody.length > this.offset) {
	        this.emit('data', respBody.slice(this.offset));
	        this.offset = respBody.length;
	    }
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	;(function () {

	  var object =  true ? exports : this; // #8: web workers
	  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	  function InvalidCharacterError(message) {
	    this.message = message;
	  }
	  InvalidCharacterError.prototype = new Error;
	  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	  // encoder
	  // [https://gist.github.com/999166] by [https://github.com/nignag]
	  object.btoa || (
	  object.btoa = function (input) {
	    for (
	      // initialize result and counter
	      var block, charCode, idx = 0, map = chars, output = '';
	      // if the next input index does not exist:
	      //   change the mapping table to "="
	      //   check if d has no fractional digits
	      input.charAt(idx | 0) || (map = '=', idx % 1);
	      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	    ) {
	      charCode = input.charCodeAt(idx += 3/4);
	      if (charCode > 0xFF) {
	        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	      }
	      block = block << 8 | charCode;
	    }
	    return output;
	  });

	  // decoder
	  // [https://gist.github.com/1020396] by [https://github.com/atk]
	  object.atob || (
	  object.atob = function (input) {
	    input = input.replace(/=+$/, '');
	    if (input.length % 4 == 1) {
	      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
	    }
	    for (
	      // initialize result and counters
	      var bc = 0, bs, buffer, idx = 0, output = '';
	      // get next character
	      buffer = input.charAt(idx++);
	      // character found in table? initialize bit storage and add its ascii value;
	      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
	        // and if not first of each 4 characters,
	        // convert the first 8 bits to one ascii character
	        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
	    ) {
	      // try to find character in table (0-63, not found => -1)
	      buffer = chars.indexOf(buffer);
	    }
	    return output;
	  });

	}());


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var http = __webpack_require__(53);

	var https = module.exports;

	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};

	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    return http.request.call(this, params, cb);
	}


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Transform = __webpack_require__(74);

	var binding = __webpack_require__(80);
	var util = __webpack_require__(27);
	var assert = __webpack_require__(92).ok;

	// zlib doesn't provide these, so kludge them in following the same
	// const naming scheme zlib uses.
	binding.Z_MIN_WINDOWBITS = 8;
	binding.Z_MAX_WINDOWBITS = 15;
	binding.Z_DEFAULT_WINDOWBITS = 15;

	// fewer than 64 bytes per chunk is stupid.
	// technically it could work with as few as 8, but even 64 bytes
	// is absurdly low.  Usually a MB or more is best.
	binding.Z_MIN_CHUNK = 64;
	binding.Z_MAX_CHUNK = Infinity;
	binding.Z_DEFAULT_CHUNK = (16 * 1024);

	binding.Z_MIN_MEMLEVEL = 1;
	binding.Z_MAX_MEMLEVEL = 9;
	binding.Z_DEFAULT_MEMLEVEL = 8;

	binding.Z_MIN_LEVEL = -1;
	binding.Z_MAX_LEVEL = 9;
	binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

	// expose all the zlib constants
	Object.keys(binding).forEach(function(k) {
	  if (k.match(/^Z/)) exports[k] = binding[k];
	});

	// translation table for return codes.
	exports.codes = {
	  Z_OK: binding.Z_OK,
	  Z_STREAM_END: binding.Z_STREAM_END,
	  Z_NEED_DICT: binding.Z_NEED_DICT,
	  Z_ERRNO: binding.Z_ERRNO,
	  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
	  Z_DATA_ERROR: binding.Z_DATA_ERROR,
	  Z_MEM_ERROR: binding.Z_MEM_ERROR,
	  Z_BUF_ERROR: binding.Z_BUF_ERROR,
	  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
	};

	Object.keys(exports.codes).forEach(function(k) {
	  exports.codes[exports.codes[k]] = k;
	});

	exports.Deflate = Deflate;
	exports.Inflate = Inflate;
	exports.Gzip = Gzip;
	exports.Gunzip = Gunzip;
	exports.DeflateRaw = DeflateRaw;
	exports.InflateRaw = InflateRaw;
	exports.Unzip = Unzip;

	exports.createDeflate = function(o) {
	  return new Deflate(o);
	};

	exports.createInflate = function(o) {
	  return new Inflate(o);
	};

	exports.createDeflateRaw = function(o) {
	  return new DeflateRaw(o);
	};

	exports.createInflateRaw = function(o) {
	  return new InflateRaw(o);
	};

	exports.createGzip = function(o) {
	  return new Gzip(o);
	};

	exports.createGunzip = function(o) {
	  return new Gunzip(o);
	};

	exports.createUnzip = function(o) {
	  return new Unzip(o);
	};


	// Convenience methods.
	// compress/decompress a string or buffer in one step.
	exports.deflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Deflate(opts), buffer, callback);
	};

	exports.deflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Deflate(opts), buffer);
	};

	exports.gzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gzip(opts), buffer, callback);
	};

	exports.gzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gzip(opts), buffer);
	};

	exports.deflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
	};

	exports.deflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new DeflateRaw(opts), buffer);
	};

	exports.unzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Unzip(opts), buffer, callback);
	};

	exports.unzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Unzip(opts), buffer);
	};

	exports.inflate = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Inflate(opts), buffer, callback);
	};

	exports.inflateSync = function(buffer, opts) {
	  return zlibBufferSync(new Inflate(opts), buffer);
	};

	exports.gunzip = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new Gunzip(opts), buffer, callback);
	};

	exports.gunzipSync = function(buffer, opts) {
	  return zlibBufferSync(new Gunzip(opts), buffer);
	};

	exports.inflateRaw = function(buffer, opts, callback) {
	  if (typeof opts === 'function') {
	    callback = opts;
	    opts = {};
	  }
	  return zlibBuffer(new InflateRaw(opts), buffer, callback);
	};

	exports.inflateRawSync = function(buffer, opts) {
	  return zlibBufferSync(new InflateRaw(opts), buffer);
	};

	function zlibBuffer(engine, buffer, callback) {
	  var buffers = [];
	  var nread = 0;

	  engine.on('error', onError);
	  engine.on('end', onEnd);

	  engine.end(buffer);
	  flow();

	  function flow() {
	    var chunk;
	    while (null !== (chunk = engine.read())) {
	      buffers.push(chunk);
	      nread += chunk.length;
	    }
	    engine.once('readable', flow);
	  }

	  function onError(err) {
	    engine.removeListener('end', onEnd);
	    engine.removeListener('readable', flow);
	    callback(err);
	  }

	  function onEnd() {
	    var buf = Buffer.concat(buffers, nread);
	    buffers = [];
	    callback(null, buf);
	    engine.close();
	  }
	}

	function zlibBufferSync(engine, buffer) {
	  if (typeof buffer === 'string')
	    buffer = new Buffer(buffer);
	  if (!Buffer.isBuffer(buffer))
	    throw new TypeError('Not a string or buffer');

	  var flushFlag = binding.Z_FINISH;

	  return engine._processChunk(buffer, flushFlag);
	}

	// generic zlib
	// minimal 2-byte header
	function Deflate(opts) {
	  if (!(this instanceof Deflate)) return new Deflate(opts);
	  Zlib.call(this, opts, binding.DEFLATE);
	}

	function Inflate(opts) {
	  if (!(this instanceof Inflate)) return new Inflate(opts);
	  Zlib.call(this, opts, binding.INFLATE);
	}



	// gzip - bigger header, same deflate compression
	function Gzip(opts) {
	  if (!(this instanceof Gzip)) return new Gzip(opts);
	  Zlib.call(this, opts, binding.GZIP);
	}

	function Gunzip(opts) {
	  if (!(this instanceof Gunzip)) return new Gunzip(opts);
	  Zlib.call(this, opts, binding.GUNZIP);
	}



	// raw - no header
	function DeflateRaw(opts) {
	  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
	  Zlib.call(this, opts, binding.DEFLATERAW);
	}

	function InflateRaw(opts) {
	  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
	  Zlib.call(this, opts, binding.INFLATERAW);
	}


	// auto-detect header.
	function Unzip(opts) {
	  if (!(this instanceof Unzip)) return new Unzip(opts);
	  Zlib.call(this, opts, binding.UNZIP);
	}


	// the Zlib class they all inherit from
	// This thing manages the queue of requests, and returns
	// true or false if there is anything in the queue when
	// you call the .write() method.

	function Zlib(opts, mode) {
	  this._opts = opts = opts || {};
	  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

	  Transform.call(this, opts);

	  if (opts.flush) {
	    if (opts.flush !== binding.Z_NO_FLUSH &&
	        opts.flush !== binding.Z_PARTIAL_FLUSH &&
	        opts.flush !== binding.Z_SYNC_FLUSH &&
	        opts.flush !== binding.Z_FULL_FLUSH &&
	        opts.flush !== binding.Z_FINISH &&
	        opts.flush !== binding.Z_BLOCK) {
	      throw new Error('Invalid flush flag: ' + opts.flush);
	    }
	  }
	  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

	  if (opts.chunkSize) {
	    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
	        opts.chunkSize > exports.Z_MAX_CHUNK) {
	      throw new Error('Invalid chunk size: ' + opts.chunkSize);
	    }
	  }

	  if (opts.windowBits) {
	    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
	        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
	      throw new Error('Invalid windowBits: ' + opts.windowBits);
	    }
	  }

	  if (opts.level) {
	    if (opts.level < exports.Z_MIN_LEVEL ||
	        opts.level > exports.Z_MAX_LEVEL) {
	      throw new Error('Invalid compression level: ' + opts.level);
	    }
	  }

	  if (opts.memLevel) {
	    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
	        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
	      throw new Error('Invalid memLevel: ' + opts.memLevel);
	    }
	  }

	  if (opts.strategy) {
	    if (opts.strategy != exports.Z_FILTERED &&
	        opts.strategy != exports.Z_HUFFMAN_ONLY &&
	        opts.strategy != exports.Z_RLE &&
	        opts.strategy != exports.Z_FIXED &&
	        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
	      throw new Error('Invalid strategy: ' + opts.strategy);
	    }
	  }

	  if (opts.dictionary) {
	    if (!Buffer.isBuffer(opts.dictionary)) {
	      throw new Error('Invalid dictionary: it should be a Buffer instance');
	    }
	  }

	  this._binding = new binding.Zlib(mode);

	  var self = this;
	  this._hadError = false;
	  this._binding.onerror = function(message, errno) {
	    // there is no way to cleanly recover.
	    // continuing only obscures problems.
	    self._binding = null;
	    self._hadError = true;

	    var error = new Error(message);
	    error.errno = errno;
	    error.code = exports.codes[errno];
	    self.emit('error', error);
	  };

	  var level = exports.Z_DEFAULT_COMPRESSION;
	  if (typeof opts.level === 'number') level = opts.level;

	  var strategy = exports.Z_DEFAULT_STRATEGY;
	  if (typeof opts.strategy === 'number') strategy = opts.strategy;

	  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
	                     level,
	                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
	                     strategy,
	                     opts.dictionary);

	  this._buffer = new Buffer(this._chunkSize);
	  this._offset = 0;
	  this._closed = false;
	  this._level = level;
	  this._strategy = strategy;

	  this.once('end', this.close);
	}

	util.inherits(Zlib, Transform);

	Zlib.prototype.params = function(level, strategy, callback) {
	  if (level < exports.Z_MIN_LEVEL ||
	      level > exports.Z_MAX_LEVEL) {
	    throw new RangeError('Invalid compression level: ' + level);
	  }
	  if (strategy != exports.Z_FILTERED &&
	      strategy != exports.Z_HUFFMAN_ONLY &&
	      strategy != exports.Z_RLE &&
	      strategy != exports.Z_FIXED &&
	      strategy != exports.Z_DEFAULT_STRATEGY) {
	    throw new TypeError('Invalid strategy: ' + strategy);
	  }

	  if (this._level !== level || this._strategy !== strategy) {
	    var self = this;
	    this.flush(binding.Z_SYNC_FLUSH, function() {
	      self._binding.params(level, strategy);
	      if (!self._hadError) {
	        self._level = level;
	        self._strategy = strategy;
	        if (callback) callback();
	      }
	    });
	  } else {
	    process.nextTick(callback);
	  }
	};

	Zlib.prototype.reset = function() {
	  return this._binding.reset();
	};

	// This is the _flush function called by the transform class,
	// internally, when the last chunk has been written.
	Zlib.prototype._flush = function(callback) {
	  this._transform(new Buffer(0), '', callback);
	};

	Zlib.prototype.flush = function(kind, callback) {
	  var ws = this._writableState;

	  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
	    callback = kind;
	    kind = binding.Z_FULL_FLUSH;
	  }

	  if (ws.ended) {
	    if (callback)
	      process.nextTick(callback);
	  } else if (ws.ending) {
	    if (callback)
	      this.once('end', callback);
	  } else if (ws.needDrain) {
	    var self = this;
	    this.once('drain', function() {
	      self.flush(callback);
	    });
	  } else {
	    this._flushFlag = kind;
	    this.write(new Buffer(0), '', callback);
	  }
	};

	Zlib.prototype.close = function(callback) {
	  if (callback)
	    process.nextTick(callback);

	  if (this._closed)
	    return;

	  this._closed = true;

	  this._binding.close();

	  var self = this;
	  process.nextTick(function() {
	    self.emit('close');
	  });
	};

	Zlib.prototype._transform = function(chunk, encoding, cb) {
	  var flushFlag;
	  var ws = this._writableState;
	  var ending = ws.ending || ws.ended;
	  var last = ending && (!chunk || ws.length === chunk.length);

	  if (!chunk === null && !Buffer.isBuffer(chunk))
	    return cb(new Error('invalid input'));

	  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
	  // If it's explicitly flushing at some other time, then we use
	  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
	  // goodness.
	  if (last)
	    flushFlag = binding.Z_FINISH;
	  else {
	    flushFlag = this._flushFlag;
	    // once we've flushed the last of the queue, stop flushing and
	    // go back to the normal behavior.
	    if (chunk.length >= ws.length) {
	      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
	    }
	  }

	  var self = this;
	  this._processChunk(chunk, flushFlag, cb);
	};

	Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
	  var availInBefore = chunk && chunk.length;
	  var availOutBefore = this._chunkSize - this._offset;
	  var inOff = 0;

	  var self = this;

	  var async = typeof cb === 'function';

	  if (!async) {
	    var buffers = [];
	    var nread = 0;

	    var error;
	    this.on('error', function(er) {
	      error = er;
	    });

	    do {
	      var res = this._binding.writeSync(flushFlag,
	                                        chunk, // in
	                                        inOff, // in_off
	                                        availInBefore, // in_len
	                                        this._buffer, // out
	                                        this._offset, //out_off
	                                        availOutBefore); // out_len
	    } while (!this._hadError && callback(res[0], res[1]));

	    if (this._hadError) {
	      throw error;
	    }

	    var buf = Buffer.concat(buffers, nread);
	    this.close();

	    return buf;
	  }

	  var req = this._binding.write(flushFlag,
	                                chunk, // in
	                                inOff, // in_off
	                                availInBefore, // in_len
	                                this._buffer, // out
	                                this._offset, //out_off
	                                availOutBefore); // out_len

	  req.buffer = chunk;
	  req.callback = callback;

	  function callback(availInAfter, availOutAfter) {
	    if (self._hadError)
	      return;

	    var have = availOutBefore - availOutAfter;
	    assert(have >= 0, 'have should not go down');

	    if (have > 0) {
	      var out = self._buffer.slice(self._offset, self._offset + have);
	      self._offset += have;
	      // serve some output to the consumer.
	      if (async) {
	        self.push(out);
	      } else {
	        buffers.push(out);
	        nread += out.length;
	      }
	    }

	    // exhausted the output buffer, or used all the input create a new one.
	    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
	      availOutBefore = self._chunkSize;
	      self._offset = 0;
	      self._buffer = new Buffer(self._chunkSize);
	    }

	    if (availOutAfter === 0) {
	      // Not actually done.  Need to reprocess.
	      // Also, update the availInBefore to the availInAfter value,
	      // so that if we have to hit it a third (fourth, etc.) time,
	      // it'll have the correct byte counts.
	      inOff += (availInBefore - availInAfter);
	      availInBefore = availInAfter;

	      if (!async)
	        return true;

	      var newReq = self._binding.write(flushFlag,
	                                       chunk,
	                                       inOff,
	                                       availInBefore,
	                                       self._buffer,
	                                       self._offset,
	                                       self._chunkSize);
	      newReq.callback = callback; // this same function
	      newReq.buffer = chunk;
	      return;
	    }

	    if (!async)
	      return false;

	    // finished with the chunk.
	    cb();
	  }
	};

	util.inherits(Deflate, Zlib);
	util.inherits(Inflate, Zlib);
	util.inherits(Gzip, Zlib);
	util.inherits(Gunzip, Zlib);
	util.inherits(DeflateRaw, Zlib);
	util.inherits(InflateRaw, Zlib);
	util.inherits(Unzip, Zlib);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer, __webpack_require__(7)))

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(75)


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(76);

	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	var Readable = __webpack_require__(77);
	var Writable = __webpack_require__(79);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(59);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(32).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(54).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(56);

	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(78);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(76);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(61).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(76);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(61).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 78 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(32).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(60);
	util.inherits = __webpack_require__(29);
	/*</replacement>*/

	var Stream = __webpack_require__(56);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(76);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(76);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {var msg = __webpack_require__(81);
	var zstream = __webpack_require__(82);
	var zlib_deflate = __webpack_require__(83);
	var zlib_inflate = __webpack_require__(88);
	var constants = __webpack_require__(91);

	for (var key in constants) {
	  exports[key] = constants[key];
	}

	// zlib modes
	exports.NONE = 0;
	exports.DEFLATE = 1;
	exports.INFLATE = 2;
	exports.GZIP = 3;
	exports.GUNZIP = 4;
	exports.DEFLATERAW = 5;
	exports.INFLATERAW = 6;
	exports.UNZIP = 7;

	/**
	 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
	 */
	function Zlib(mode) {
	  if (mode < exports.DEFLATE || mode > exports.UNZIP)
	    throw new TypeError("Bad argument");
	    
	  this.mode = mode;
	  this.init_done = false;
	  this.write_in_progress = false;
	  this.pending_close = false;
	  this.windowBits = 0;
	  this.level = 0;
	  this.memLevel = 0;
	  this.strategy = 0;
	  this.dictionary = null;
	}

	Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
	  this.windowBits = windowBits;
	  this.level = level;
	  this.memLevel = memLevel;
	  this.strategy = strategy;
	  // dictionary not supported.
	  
	  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
	    this.windowBits += 16;
	    
	  if (this.mode === exports.UNZIP)
	    this.windowBits += 32;
	    
	  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
	    this.windowBits = -this.windowBits;
	    
	  this.strm = new zstream();
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateInit2(
	        this.strm,
	        this.level,
	        exports.Z_DEFLATED,
	        this.windowBits,
	        this.memLevel,
	        this.strategy
	      );
	      break;
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	    case exports.UNZIP:
	      var status  = zlib_inflate.inflateInit2(
	        this.strm,
	        this.windowBits
	      );
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	    return;
	  }
	  
	  this.write_in_progress = false;
	  this.init_done = true;
	};

	Zlib.prototype.params = function() {
	  throw new Error("deflateParams Not supported");
	};

	Zlib.prototype._writeCheck = function() {
	  if (!this.init_done)
	    throw new Error("write before init");
	    
	  if (this.mode === exports.NONE)
	    throw new Error("already finalized");
	    
	  if (this.write_in_progress)
	    throw new Error("write already in progress");
	    
	  if (this.pending_close)
	    throw new Error("close is pending");
	};

	Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
	  this._writeCheck();
	  this.write_in_progress = true;
	  
	  var self = this;
	  process.nextTick(function() {
	    self.write_in_progress = false;
	    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
	    self.callback(res[0], res[1]);
	    
	    if (self.pending_close)
	      self.close();
	  });
	  
	  return this;
	};

	// set method for Node buffers, used by pako
	function bufferSet(data, offset) {
	  for (var i = 0; i < data.length; i++) {
	    this[offset + i] = data[i];
	  }
	}

	Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this._writeCheck();
	  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
	};

	Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
	  this.write_in_progress = true;
	  
	  if (flush !== exports.Z_NO_FLUSH &&
	      flush !== exports.Z_PARTIAL_FLUSH &&
	      flush !== exports.Z_SYNC_FLUSH &&
	      flush !== exports.Z_FULL_FLUSH &&
	      flush !== exports.Z_FINISH &&
	      flush !== exports.Z_BLOCK) {
	    throw new Error("Invalid flush value");
	  }
	  
	  if (input == null) {
	    input = new Buffer(0);
	    in_len = 0;
	    in_off = 0;
	  }
	  
	  if (out._set)
	    out.set = out._set;
	  else
	    out.set = bufferSet;
	  
	  var strm = this.strm;
	  strm.avail_in = in_len;
	  strm.input = input;
	  strm.next_in = in_off;
	  strm.avail_out = out_len;
	  strm.output = out;
	  strm.next_out = out_off;
	  
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.GZIP:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflate(strm, flush);
	      break;
	    case exports.UNZIP:
	    case exports.INFLATE:
	    case exports.GUNZIP:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflate(strm, flush);
	      break;
	    default:
	      throw new Error("Unknown mode " + this.mode);
	  }
	  
	  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
	    this._error(status);
	  }
	  
	  this.write_in_progress = false;
	  return [strm.avail_in, strm.avail_out];
	};

	Zlib.prototype.close = function() {
	  if (this.write_in_progress) {
	    this.pending_close = true;
	    return;
	  }
	  
	  this.pending_close = false;
	  
	  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
	    zlib_deflate.deflateEnd(this.strm);
	  } else {
	    zlib_inflate.inflateEnd(this.strm);
	  }
	  
	  this.mode = exports.NONE;
	};

	Zlib.prototype.reset = function() {
	  switch (this.mode) {
	    case exports.DEFLATE:
	    case exports.DEFLATERAW:
	      var status = zlib_deflate.deflateReset(this.strm);
	      break;
	    case exports.INFLATE:
	    case exports.INFLATERAW:
	      var status = zlib_inflate.inflateReset(this.strm);
	      break;
	  }
	  
	  if (status !== exports.Z_OK) {
	    this._error(status);
	  }
	};

	Zlib.prototype._error = function(status) {
	  this.onerror(msg[status] + ': ' + this.strm.msg, status);
	  
	  this.write_in_progress = false;
	  if (this.pending_close)
	    this.close();
	};

	exports.Zlib = Zlib;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(32).Buffer))

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  '2':    'need dictionary',     /* Z_NEED_DICT       2  */
	  '1':    'stream end',          /* Z_STREAM_END      1  */
	  '0':    '',                    /* Z_OK              0  */
	  '-1':   'file error',          /* Z_ERRNO         (-1) */
	  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
	  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
	  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
	  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
	  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
	};


/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';


	function ZStream() {
	  /* next input byte */
	  this.input = null; // JS specific, because we have no pointers
	  this.next_in = 0;
	  /* number of bytes available at input */
	  this.avail_in = 0;
	  /* total number of input bytes read so far */
	  this.total_in = 0;
	  /* next output byte should be put there */
	  this.output = null; // JS specific, because we have no pointers
	  this.next_out = 0;
	  /* remaining free space at output */
	  this.avail_out = 0;
	  /* total number of bytes output so far */
	  this.total_out = 0;
	  /* last error message, NULL if no error */
	  this.msg = ''/*Z_NULL*/;
	  /* not visible by applications */
	  this.state = null;
	  /* best guess about the data type: binary or text */
	  this.data_type = 2/*Z_UNKNOWN*/;
	  /* adler32 value of the uncompressed data */
	  this.adler = 0;
	}

	module.exports = ZStream;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var utils   = __webpack_require__(84);
	var trees   = __webpack_require__(85);
	var adler32 = __webpack_require__(86);
	var crc32   = __webpack_require__(87);
	var msg   = __webpack_require__(81);

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	var Z_NO_FLUSH      = 0;
	var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	//var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	//var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	//var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;


	/* compression levels */
	//var Z_NO_COMPRESSION      = 0;
	//var Z_BEST_SPEED          = 1;
	//var Z_BEST_COMPRESSION    = 9;
	var Z_DEFAULT_COMPRESSION = -1;


	var Z_FILTERED            = 1;
	var Z_HUFFMAN_ONLY        = 2;
	var Z_RLE                 = 3;
	var Z_FIXED               = 4;
	var Z_DEFAULT_STRATEGY    = 0;

	/* Possible values of the data_type field (though see inflate()) */
	//var Z_BINARY              = 0;
	//var Z_TEXT                = 1;
	//var Z_ASCII               = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;


	/* The deflate compression method */
	var Z_DEFLATED  = 8;

	/*============================================================================*/


	var MAX_MEM_LEVEL = 9;
	/* Maximum value for memLevel in deflateInit2 */
	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_MEM_LEVEL = 8;


	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */
	var LITERALS      = 256;
	/* number of literal bytes 0..255 */
	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */
	var D_CODES       = 30;
	/* number of distance codes */
	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */
	var HEAP_SIZE     = 2*L_CODES + 1;
	/* maximum heap size */
	var MAX_BITS  = 15;
	/* All codes must not exceed MAX_BITS bits */

	var MIN_MATCH = 3;
	var MAX_MATCH = 258;
	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

	var PRESET_DICT = 0x20;

	var INIT_STATE = 42;
	var EXTRA_STATE = 69;
	var NAME_STATE = 73;
	var COMMENT_STATE = 91;
	var HCRC_STATE = 103;
	var BUSY_STATE = 113;
	var FINISH_STATE = 666;

	var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
	var BS_BLOCK_DONE     = 2; /* block flush performed */
	var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
	var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

	var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

	function err(strm, errorCode) {
	  strm.msg = msg[errorCode];
	  return errorCode;
	}

	function rank(f) {
	  return ((f) << 1) - ((f) > 4 ? 9 : 0);
	}

	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


	/* =========================================================================
	 * Flush as much pending output as possible. All deflate() output goes
	 * through this function so some applications may wish to modify it
	 * to avoid allocating a large strm->output buffer and copying into it.
	 * (See also read_buf()).
	 */
	function flush_pending(strm) {
	  var s = strm.state;

	  //_tr_flush_bits(s);
	  var len = s.pending;
	  if (len > strm.avail_out) {
	    len = strm.avail_out;
	  }
	  if (len === 0) { return; }

	  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
	  strm.next_out += len;
	  s.pending_out += len;
	  strm.total_out += len;
	  strm.avail_out -= len;
	  s.pending -= len;
	  if (s.pending === 0) {
	    s.pending_out = 0;
	  }
	}


	function flush_block_only (s, last) {
	  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
	  s.block_start = s.strstart;
	  flush_pending(s.strm);
	}


	function put_byte(s, b) {
	  s.pending_buf[s.pending++] = b;
	}


	/* =========================================================================
	 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
	 * IN assertion: the stream state is correct and there is enough room in
	 * pending_buf.
	 */
	function putShortMSB(s, b) {
	//  put_byte(s, (Byte)(b >> 8));
	//  put_byte(s, (Byte)(b & 0xff));
	  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
	  s.pending_buf[s.pending++] = b & 0xff;
	}


	/* ===========================================================================
	 * Read a new buffer from the current input stream, update the adler32
	 * and total number of bytes read.  All deflate() input goes through
	 * this function so some applications may wish to modify it to avoid
	 * allocating a large strm->input buffer and copying from it.
	 * (See also flush_pending()).
	 */
	function read_buf(strm, buf, start, size) {
	  var len = strm.avail_in;

	  if (len > size) { len = size; }
	  if (len === 0) { return 0; }

	  strm.avail_in -= len;

	  utils.arraySet(buf, strm.input, strm.next_in, len, start);
	  if (strm.state.wrap === 1) {
	    strm.adler = adler32(strm.adler, buf, len, start);
	  }

	  else if (strm.state.wrap === 2) {
	    strm.adler = crc32(strm.adler, buf, len, start);
	  }

	  strm.next_in += len;
	  strm.total_in += len;

	  return len;
	}


	/* ===========================================================================
	 * Set match_start to the longest match starting at the given string and
	 * return its length. Matches shorter or equal to prev_length are discarded,
	 * in which case the result is equal to prev_length and match_start is
	 * garbage.
	 * IN assertions: cur_match is the head of the hash chain for the current
	 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
	 * OUT assertion: the match length is not greater than s->lookahead.
	 */
	function longest_match(s, cur_match) {
	  var chain_length = s.max_chain_length;      /* max hash chain length */
	  var scan = s.strstart; /* current string */
	  var match;                       /* matched string */
	  var len;                           /* length of current match */
	  var best_len = s.prev_length;              /* best match length so far */
	  var nice_match = s.nice_match;             /* stop if match long enough */
	  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
	      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

	  var _win = s.window; // shortcut

	  var wmask = s.w_mask;
	  var prev  = s.prev;

	  /* Stop when cur_match becomes <= limit. To simplify the code,
	   * we prevent matches with the string of window index 0.
	   */

	  var strend = s.strstart + MAX_MATCH;
	  var scan_end1  = _win[scan + best_len - 1];
	  var scan_end   = _win[scan + best_len];

	  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
	   * It is easy to get rid of this optimization if necessary.
	   */
	  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

	  /* Do not waste too much time if we already have a good match: */
	  if (s.prev_length >= s.good_match) {
	    chain_length >>= 2;
	  }
	  /* Do not look for matches beyond the end of the input. This is necessary
	   * to make deflate deterministic.
	   */
	  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

	  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

	  do {
	    // Assert(cur_match < s->strstart, "no future");
	    match = cur_match;

	    /* Skip to next match if the match length cannot increase
	     * or if the match length is less than 2.  Note that the checks below
	     * for insufficient lookahead only occur occasionally for performance
	     * reasons.  Therefore uninitialized memory will be accessed, and
	     * conditional jumps will be made that depend on those values.
	     * However the length of the match is limited to the lookahead, so
	     * the output of deflate is not affected by the uninitialized values.
	     */

	    if (_win[match + best_len]     !== scan_end  ||
	        _win[match + best_len - 1] !== scan_end1 ||
	        _win[match]                !== _win[scan] ||
	        _win[++match]              !== _win[scan + 1]) {
	      continue;
	    }

	    /* The check at best_len-1 can be removed because it will be made
	     * again later. (This heuristic is not always a win.)
	     * It is not necessary to compare scan[2] and match[2] since they
	     * are always equal when the other bytes match, given that
	     * the hash keys are equal and that HASH_BITS >= 8.
	     */
	    scan += 2;
	    match++;
	    // Assert(*scan == *match, "match[2]?");

	    /* We check for insufficient lookahead only every 8th comparison;
	     * the 256th check will be made at strstart+258.
	     */
	    do {
	      /*jshint noempty:false*/
	    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
	             scan < strend);

	    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

	    len = MAX_MATCH - (strend - scan);
	    scan = strend - MAX_MATCH;

	    if (len > best_len) {
	      s.match_start = cur_match;
	      best_len = len;
	      if (len >= nice_match) {
	        break;
	      }
	      scan_end1  = _win[scan + best_len - 1];
	      scan_end   = _win[scan + best_len];
	    }
	  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

	  if (best_len <= s.lookahead) {
	    return best_len;
	  }
	  return s.lookahead;
	}


	/* ===========================================================================
	 * Fill the window when the lookahead becomes insufficient.
	 * Updates strstart and lookahead.
	 *
	 * IN assertion: lookahead < MIN_LOOKAHEAD
	 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	 *    At least one byte has been read, or avail_in == 0; reads are
	 *    performed for at least two bytes (required for the zip translate_eol
	 *    option -- not supported here).
	 */
	function fill_window(s) {
	  var _w_size = s.w_size;
	  var p, n, m, more, str;

	  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

	  do {
	    more = s.window_size - s.lookahead - s.strstart;

	    // JS ints have 32 bit, block below not needed
	    /* Deal with !@#$% 64K limit: */
	    //if (sizeof(int) <= 2) {
	    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
	    //        more = wsize;
	    //
	    //  } else if (more == (unsigned)(-1)) {
	    //        /* Very unlikely, but possible on 16 bit machine if
	    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
	    //         */
	    //        more--;
	    //    }
	    //}


	    /* If the window is almost full and there is insufficient lookahead,
	     * move the upper half to the lower one to make room in the upper half.
	     */
	    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

	      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
	      s.match_start -= _w_size;
	      s.strstart -= _w_size;
	      /* we now have strstart >= MAX_DIST */
	      s.block_start -= _w_size;

	      /* Slide the hash table (could be avoided with 32 bit values
	       at the expense of memory usage). We slide even when level == 0
	       to keep the hash table consistent if we switch back to level > 0
	       later. (Using level 0 permanently is not an optimal usage of
	       zlib, so we don't care about this pathological case.)
	       */

	      n = s.hash_size;
	      p = n;
	      do {
	        m = s.head[--p];
	        s.head[p] = (m >= _w_size ? m - _w_size : 0);
	      } while (--n);

	      n = _w_size;
	      p = n;
	      do {
	        m = s.prev[--p];
	        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
	        /* If n is not on any hash chain, prev[n] is garbage but
	         * its value will never be used.
	         */
	      } while (--n);

	      more += _w_size;
	    }
	    if (s.strm.avail_in === 0) {
	      break;
	    }

	    /* If there was no sliding:
	     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	     *    more == window_size - lookahead - strstart
	     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	     * => more >= window_size - 2*WSIZE + 2
	     * In the BIG_MEM or MMAP case (not yet supported),
	     *   window_size == input_size + MIN_LOOKAHEAD  &&
	     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	     * Otherwise, window_size == 2*WSIZE so more >= 2.
	     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
	     */
	    //Assert(more >= 2, "more < 2");
	    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
	    s.lookahead += n;

	    /* Initialize the hash value now that we have some input: */
	    if (s.lookahead + s.insert >= MIN_MATCH) {
	      str = s.strstart - s.insert;
	      s.ins_h = s.window[str];

	      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
	//#if MIN_MATCH != 3
	//        Call update_hash() MIN_MATCH-3 more times
	//#endif
	      while (s.insert) {
	        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;

	        s.prev[str & s.w_mask] = s.head[s.ins_h];
	        s.head[s.ins_h] = str;
	        str++;
	        s.insert--;
	        if (s.lookahead + s.insert < MIN_MATCH) {
	          break;
	        }
	      }
	    }
	    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
	     * but this is not important since only literal bytes will be emitted.
	     */

	  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

	  /* If the WIN_INIT bytes after the end of the current data have never been
	   * written, then zero those bytes in order to avoid memory check reports of
	   * the use of uninitialized (or uninitialised as Julian writes) bytes by
	   * the longest match routines.  Update the high water mark for the next
	   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
	   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
	   */
	//  if (s.high_water < s.window_size) {
	//    var curr = s.strstart + s.lookahead;
	//    var init = 0;
	//
	//    if (s.high_water < curr) {
	//      /* Previous high water mark below current data -- zero WIN_INIT
	//       * bytes or up to end of window, whichever is less.
	//       */
	//      init = s.window_size - curr;
	//      if (init > WIN_INIT)
	//        init = WIN_INIT;
	//      zmemzero(s->window + curr, (unsigned)init);
	//      s->high_water = curr + init;
	//    }
	//    else if (s->high_water < (ulg)curr + WIN_INIT) {
	//      /* High water mark at or above current data, but below current data
	//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
	//       * to end of window, whichever is less.
	//       */
	//      init = (ulg)curr + WIN_INIT - s->high_water;
	//      if (init > s->window_size - s->high_water)
	//        init = s->window_size - s->high_water;
	//      zmemzero(s->window + s->high_water, (unsigned)init);
	//      s->high_water += init;
	//    }
	//  }
	//
	//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
	//    "not enough room for search");
	}

	/* ===========================================================================
	 * Copy without compression as much as possible from the input stream, return
	 * the current block state.
	 * This function does not insert new strings in the dictionary since
	 * uncompressible data is probably not useful. This function is used
	 * only for the level=0 compression option.
	 * NOTE: this function should be optimized to avoid extra copying from
	 * window to pending_buf.
	 */
	function deflate_stored(s, flush) {
	  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
	   * to pending_buf_size, and each stored block has a 5 byte header:
	   */
	  var max_block_size = 0xffff;

	  if (max_block_size > s.pending_buf_size - 5) {
	    max_block_size = s.pending_buf_size - 5;
	  }

	  /* Copy as much as possible from input to output: */
	  for (;;) {
	    /* Fill the window as much as possible: */
	    if (s.lookahead <= 1) {

	      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
	      //  s->block_start >= (long)s->w_size, "slide too late");
	//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
	//        s.block_start >= s.w_size)) {
	//        throw  new Error("slide too late");
	//      }

	      fill_window(s);
	      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }

	      if (s.lookahead === 0) {
	        break;
	      }
	      /* flush the current block */
	    }
	    //Assert(s->block_start >= 0L, "block gone");
	//    if (s.block_start < 0) throw new Error("block gone");

	    s.strstart += s.lookahead;
	    s.lookahead = 0;

	    /* Emit a stored block if pending_buf will be full: */
	    var max_start = s.block_start + max_block_size;

	    if (s.strstart === 0 || s.strstart >= max_start) {
	      /* strstart == 0 is possible when wraparound on 16-bit machine */
	      s.lookahead = s.strstart - max_start;
	      s.strstart = max_start;
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/


	    }
	    /* Flush if we may have to slide, otherwise block_start may become
	     * negative and the data will be gone:
	     */
	    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }

	  s.insert = 0;

	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }

	  if (s.strstart > s.block_start) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_NEED_MORE;
	}

	/* ===========================================================================
	 * Compress as much as possible from the input stream, return the current
	 * block state.
	 * This function does not perform lazy evaluation of matches and inserts
	 * new strings in the dictionary only for unmatched strings or for short
	 * matches. It is used only for the fast compression options.
	 */
	function deflate_fast(s, flush) {
	  var hash_head;        /* head of the hash chain */
	  var bflush;           /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) {
	        break; /* flush the current block */
	      }
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     * At this point we have always match_length < MIN_MATCH
	     */
	    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */
	    }
	    if (s.match_length >= MIN_MATCH) {
	      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

	      /*** _tr_tally_dist(s, s.strstart - s.match_start,
	                     s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;

	      /* Insert new strings in the hash table only if the match length
	       * is not too large. This saves time but degrades compression.
	       */
	      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
	        s.match_length--; /* string at strstart already in table */
	        do {
	          s.strstart++;
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
	           * always MIN_MATCH bytes ahead.
	           */
	        } while (--s.match_length !== 0);
	        s.strstart++;
	      } else
	      {
	        s.strstart += s.match_length;
	        s.match_length = 0;
	        s.ins_h = s.window[s.strstart];
	        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
	        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

	//#if MIN_MATCH != 3
	//                Call UPDATE_HASH() MIN_MATCH-3 more times
	//#endif
	        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
	         * matter since it will be recomputed at next deflate call.
	         */
	      }
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s.window[s.strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * Same as above, but achieves better compression. We use a lazy
	 * evaluation for matches: a match is finally adopted only if there is
	 * no better match at the next window position.
	 */
	function deflate_slow(s, flush) {
	  var hash_head;          /* head of hash chain */
	  var bflush;              /* set if current block must be flushed */

	  var max_insert;

	  /* Process the input block. */
	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the next match, plus MIN_MATCH bytes to insert the
	     * string following the next match.
	     */
	    if (s.lookahead < MIN_LOOKAHEAD) {
	      fill_window(s);
	      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* Insert the string window[strstart .. strstart+2] in the
	     * dictionary, and set hash_head to the head of the hash chain:
	     */
	    hash_head = 0/*NIL*/;
	    if (s.lookahead >= MIN_MATCH) {
	      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	      s.head[s.ins_h] = s.strstart;
	      /***/
	    }

	    /* Find the longest match, discarding those <= prev_length.
	     */
	    s.prev_length = s.match_length;
	    s.prev_match = s.match_start;
	    s.match_length = MIN_MATCH-1;

	    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
	        s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
	      /* To simplify the code, we prevent matches with the string
	       * of window index 0 (in particular we have to avoid a match
	       * of the string with itself at the start of the input file).
	       */
	      s.match_length = longest_match(s, hash_head);
	      /* longest_match() sets match_start */

	      if (s.match_length <= 5 &&
	         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

	        /* If prev_match is also MIN_MATCH, match_start is garbage
	         * but we will ignore the current match anyway.
	         */
	        s.match_length = MIN_MATCH-1;
	      }
	    }
	    /* If there was a match at the previous step and the current
	     * match is not better, output the previous match:
	     */
	    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
	      max_insert = s.strstart + s.lookahead - MIN_MATCH;
	      /* Do not insert strings in hash table beyond this. */

	      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

	      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
	                     s.prev_length - MIN_MATCH, bflush);***/
	      bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);
	      /* Insert in hash table all strings up to the end of the match.
	       * strstart-1 and strstart are already inserted. If there is not
	       * enough lookahead, the last two strings are not inserted in
	       * the hash table.
	       */
	      s.lookahead -= s.prev_length-1;
	      s.prev_length -= 2;
	      do {
	        if (++s.strstart <= max_insert) {
	          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
	          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
	          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
	          s.head[s.ins_h] = s.strstart;
	          /***/
	        }
	      } while (--s.prev_length !== 0);
	      s.match_available = 0;
	      s.match_length = MIN_MATCH-1;
	      s.strstart++;

	      if (bflush) {
	        /*** FLUSH_BLOCK(s, 0); ***/
	        flush_block_only(s, false);
	        if (s.strm.avail_out === 0) {
	          return BS_NEED_MORE;
	        }
	        /***/
	      }

	    } else if (s.match_available) {
	      /* If there was no match at the previous position, output a
	       * single literal. If there was a match but the current match
	       * is longer, truncate the previous match to a single literal.
	       */
	      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);

	      if (bflush) {
	        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
	        flush_block_only(s, false);
	        /***/
	      }
	      s.strstart++;
	      s.lookahead--;
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	    } else {
	      /* There is no previous match to compare with, wait for
	       * the next step to decide.
	       */
	      s.match_available = 1;
	      s.strstart++;
	      s.lookahead--;
	    }
	  }
	  //Assert (flush != Z_NO_FLUSH, "no flush?");
	  if (s.match_available) {
	    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);

	    s.match_available = 0;
	  }
	  s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }

	  return BS_BLOCK_DONE;
	}


	/* ===========================================================================
	 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
	 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
	 * deflate switches away from Z_RLE.)
	 */
	function deflate_rle(s, flush) {
	  var bflush;            /* set if current block must be flushed */
	  var prev;              /* byte at distance one to match */
	  var scan, strend;      /* scan goes up to strend for length of run */

	  var _win = s.window;

	  for (;;) {
	    /* Make sure that we always have enough lookahead, except
	     * at the end of the input file. We need MAX_MATCH bytes
	     * for the longest run, plus one for the unrolled loop.
	     */
	    if (s.lookahead <= MAX_MATCH) {
	      fill_window(s);
	      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
	        return BS_NEED_MORE;
	      }
	      if (s.lookahead === 0) { break; } /* flush the current block */
	    }

	    /* See how many times the previous byte repeats */
	    s.match_length = 0;
	    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
	      scan = s.strstart - 1;
	      prev = _win[scan];
	      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
	        strend = s.strstart + MAX_MATCH;
	        do {
	          /*jshint noempty:false*/
	        } while (prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 prev === _win[++scan] && prev === _win[++scan] &&
	                 scan < strend);
	        s.match_length = MAX_MATCH - (strend - scan);
	        if (s.match_length > s.lookahead) {
	          s.match_length = s.lookahead;
	        }
	      }
	      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
	    }

	    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
	    if (s.match_length >= MIN_MATCH) {
	      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

	      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
	      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

	      s.lookahead -= s.match_length;
	      s.strstart += s.match_length;
	      s.match_length = 0;
	    } else {
	      /* No match, output a literal byte */
	      //Tracevv((stderr,"%c", s->window[s->strstart]));
	      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

	      s.lookahead--;
	      s.strstart++;
	    }
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* ===========================================================================
	 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
	 * (It will be regenerated if this run of deflate switches away from Huffman.)
	 */
	function deflate_huff(s, flush) {
	  var bflush;             /* set if current block must be flushed */

	  for (;;) {
	    /* Make sure that we have a literal to write. */
	    if (s.lookahead === 0) {
	      fill_window(s);
	      if (s.lookahead === 0) {
	        if (flush === Z_NO_FLUSH) {
	          return BS_NEED_MORE;
	        }
	        break;      /* flush the current block */
	      }
	    }

	    /* Output a literal byte */
	    s.match_length = 0;
	    //Tracevv((stderr,"%c", s->window[s->strstart]));
	    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
	    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
	    s.lookahead--;
	    s.strstart++;
	    if (bflush) {
	      /*** FLUSH_BLOCK(s, 0); ***/
	      flush_block_only(s, false);
	      if (s.strm.avail_out === 0) {
	        return BS_NEED_MORE;
	      }
	      /***/
	    }
	  }
	  s.insert = 0;
	  if (flush === Z_FINISH) {
	    /*** FLUSH_BLOCK(s, 1); ***/
	    flush_block_only(s, true);
	    if (s.strm.avail_out === 0) {
	      return BS_FINISH_STARTED;
	    }
	    /***/
	    return BS_FINISH_DONE;
	  }
	  if (s.last_lit) {
	    /*** FLUSH_BLOCK(s, 0); ***/
	    flush_block_only(s, false);
	    if (s.strm.avail_out === 0) {
	      return BS_NEED_MORE;
	    }
	    /***/
	  }
	  return BS_BLOCK_DONE;
	}

	/* Values for max_lazy_match, good_match and max_chain_length, depending on
	 * the desired pack level (0..9). The values given below have been tuned to
	 * exclude worst case performance for pathological files. Better values may be
	 * found for specific files.
	 */
	var Config = function (good_length, max_lazy, nice_length, max_chain, func) {
	  this.good_length = good_length;
	  this.max_lazy = max_lazy;
	  this.nice_length = nice_length;
	  this.max_chain = max_chain;
	  this.func = func;
	};

	var configuration_table;

	configuration_table = [
	  /*      good lazy nice chain */
	  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
	  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
	  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
	  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

	  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
	  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
	  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
	  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
	  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
	  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
	];


	/* ===========================================================================
	 * Initialize the "longest match" routines for a new zlib stream
	 */
	function lm_init(s) {
	  s.window_size = 2 * s.w_size;

	  /*** CLEAR_HASH(s); ***/
	  zero(s.head); // Fill with NIL (= 0);

	  /* Set the default configuration parameters:
	   */
	  s.max_lazy_match = configuration_table[s.level].max_lazy;
	  s.good_match = configuration_table[s.level].good_length;
	  s.nice_match = configuration_table[s.level].nice_length;
	  s.max_chain_length = configuration_table[s.level].max_chain;

	  s.strstart = 0;
	  s.block_start = 0;
	  s.lookahead = 0;
	  s.insert = 0;
	  s.match_length = s.prev_length = MIN_MATCH - 1;
	  s.match_available = 0;
	  s.ins_h = 0;
	}


	function DeflateState() {
	  this.strm = null;            /* pointer back to this zlib stream */
	  this.status = 0;            /* as the name implies */
	  this.pending_buf = null;      /* output still pending */
	  this.pending_buf_size = 0;  /* size of pending_buf */
	  this.pending_out = 0;       /* next pending byte to output to the stream */
	  this.pending = 0;           /* nb of bytes in the pending buffer */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.gzhead = null;         /* gzip header information to write */
	  this.gzindex = 0;           /* where in extra, name, or comment */
	  this.method = Z_DEFLATED; /* can only be DEFLATED */
	  this.last_flush = -1;   /* value of flush param for previous deflate call */

	  this.w_size = 0;  /* LZ77 window size (32K by default) */
	  this.w_bits = 0;  /* log2(w_size)  (8..16) */
	  this.w_mask = 0;  /* w_size - 1 */

	  this.window = null;
	  /* Sliding window. Input bytes are read into the second half of the window,
	   * and move to the first half later to keep a dictionary of at least wSize
	   * bytes. With this organization, matches are limited to a distance of
	   * wSize-MAX_MATCH bytes, but this ensures that IO is always
	   * performed with a length multiple of the block size.
	   */

	  this.window_size = 0;
	  /* Actual size of window: 2*wSize, except when the user input buffer
	   * is directly used as sliding window.
	   */

	  this.prev = null;
	  /* Link to older string with same hash index. To limit the size of this
	   * array to 64K, this link is maintained only for the last 32K strings.
	   * An index in this array is thus a window index modulo 32K.
	   */

	  this.head = null;   /* Heads of the hash chains or NIL. */

	  this.ins_h = 0;       /* hash index of string to be inserted */
	  this.hash_size = 0;   /* number of elements in hash table */
	  this.hash_bits = 0;   /* log2(hash_size) */
	  this.hash_mask = 0;   /* hash_size-1 */

	  this.hash_shift = 0;
	  /* Number of bits by which ins_h must be shifted at each input
	   * step. It must be such that after MIN_MATCH steps, the oldest
	   * byte no longer takes part in the hash key, that is:
	   *   hash_shift * MIN_MATCH >= hash_bits
	   */

	  this.block_start = 0;
	  /* Window position at the beginning of the current output block. Gets
	   * negative when the window is moved backwards.
	   */

	  this.match_length = 0;      /* length of best match */
	  this.prev_match = 0;        /* previous match */
	  this.match_available = 0;   /* set if previous match exists */
	  this.strstart = 0;          /* start of string to insert */
	  this.match_start = 0;       /* start of matching string */
	  this.lookahead = 0;         /* number of valid bytes ahead in window */

	  this.prev_length = 0;
	  /* Length of the best match at previous step. Matches not greater than this
	   * are discarded. This is used in the lazy match evaluation.
	   */

	  this.max_chain_length = 0;
	  /* To speed up deflation, hash chains are never searched beyond this
	   * length.  A higher limit improves compression ratio but degrades the
	   * speed.
	   */

	  this.max_lazy_match = 0;
	  /* Attempt to find a better match only when the current match is strictly
	   * smaller than this value. This mechanism is used only for compression
	   * levels >= 4.
	   */
	  // That's alias to max_lazy_match, don't use directly
	  //this.max_insert_length = 0;
	  /* Insert new strings in the hash table only if the match length is not
	   * greater than this length. This saves time but degrades compression.
	   * max_insert_length is used only for compression levels <= 3.
	   */

	  this.level = 0;     /* compression level (1..9) */
	  this.strategy = 0;  /* favor or force Huffman coding*/

	  this.good_match = 0;
	  /* Use a faster search when the previous match is longer than this */

	  this.nice_match = 0; /* Stop searching when current match exceeds this */

	              /* used by trees.c: */

	  /* Didn't use ct_data typedef below to suppress compiler warning */

	  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
	  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
	  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

	  // Use flat array of DOUBLE size, with interleaved fata,
	  // because JS does not support effective
	  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
	  this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);
	  this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);
	  zero(this.dyn_ltree);
	  zero(this.dyn_dtree);
	  zero(this.bl_tree);

	  this.l_desc   = null;         /* desc. for literal tree */
	  this.d_desc   = null;         /* desc. for distance tree */
	  this.bl_desc  = null;         /* desc. for bit length tree */

	  //ush bl_count[MAX_BITS+1];
	  this.bl_count = new utils.Buf16(MAX_BITS+1);
	  /* number of codes at each bit length for an optimal tree */

	  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
	  this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */
	  zero(this.heap);

	  this.heap_len = 0;               /* number of elements in the heap */
	  this.heap_max = 0;               /* element of largest frequency */
	  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	   * The same heap array is used to build all trees.
	   */

	  this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];
	  zero(this.depth);
	  /* Depth of each subtree used as tie breaker for trees of equal frequency
	   */

	  this.l_buf = 0;          /* buffer index for literals or lengths */

	  this.lit_bufsize = 0;
	  /* Size of match buffer for literals/lengths.  There are 4 reasons for
	   * limiting lit_bufsize to 64K:
	   *   - frequencies can be kept in 16 bit counters
	   *   - if compression is not successful for the first block, all input
	   *     data is still in the window so we can still emit a stored block even
	   *     when input comes from standard input.  (This can also be done for
	   *     all blocks if lit_bufsize is not greater than 32K.)
	   *   - if compression is not successful for a file smaller than 64K, we can
	   *     even emit a stored file instead of a stored block (saving 5 bytes).
	   *     This is applicable only for zip (not gzip or zlib).
	   *   - creating new Huffman trees less frequently may not provide fast
	   *     adaptation to changes in the input data statistics. (Take for
	   *     example a binary file with poorly compressible code followed by
	   *     a highly compressible string table.) Smaller buffer sizes give
	   *     fast adaptation but have of course the overhead of transmitting
	   *     trees more frequently.
	   *   - I can't count above 4
	   */

	  this.last_lit = 0;      /* running index in l_buf */

	  this.d_buf = 0;
	  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
	   * the same number of elements. To use different lengths, an extra flag
	   * array would be necessary.
	   */

	  this.opt_len = 0;       /* bit length of current block with optimal trees */
	  this.static_len = 0;    /* bit length of current block with static trees */
	  this.matches = 0;       /* number of string matches in current block */
	  this.insert = 0;        /* bytes at end of window left to insert */


	  this.bi_buf = 0;
	  /* Output buffer. bits are inserted starting at the bottom (least
	   * significant bits).
	   */
	  this.bi_valid = 0;
	  /* Number of valid bits in bi_buf.  All bits above the last valid bit
	   * are always zero.
	   */

	  // Used for window memory init. We safely ignore it for JS. That makes
	  // sense only for pointers and memory check tools.
	  //this.high_water = 0;
	  /* High water mark offset in window for initialized bytes -- bytes above
	   * this are set to zero in order to avoid memory check warnings when
	   * longest match routines access bytes past the input.  This is then
	   * updated to the new high water mark.
	   */
	}


	function deflateResetKeep(strm) {
	  var s;

	  if (!strm || !strm.state) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.total_in = strm.total_out = 0;
	  strm.data_type = Z_UNKNOWN;

	  s = strm.state;
	  s.pending = 0;
	  s.pending_out = 0;

	  if (s.wrap < 0) {
	    s.wrap = -s.wrap;
	    /* was made negative by deflate(..., Z_FINISH); */
	  }
	  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
	  strm.adler = (s.wrap === 2) ?
	    0  // crc32(0, Z_NULL, 0)
	  :
	    1; // adler32(0, Z_NULL, 0)
	  s.last_flush = Z_NO_FLUSH;
	  trees._tr_init(s);
	  return Z_OK;
	}


	function deflateReset(strm) {
	  var ret = deflateResetKeep(strm);
	  if (ret === Z_OK) {
	    lm_init(strm.state);
	  }
	  return ret;
	}


	function deflateSetHeader(strm, head) {
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
	  strm.state.gzhead = head;
	  return Z_OK;
	}


	function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
	  if (!strm) { // === Z_NULL
	    return Z_STREAM_ERROR;
	  }
	  var wrap = 1;

	  if (level === Z_DEFAULT_COMPRESSION) {
	    level = 6;
	  }

	  if (windowBits < 0) { /* suppress zlib wrapper */
	    wrap = 0;
	    windowBits = -windowBits;
	  }

	  else if (windowBits > 15) {
	    wrap = 2;           /* write gzip wrapper instead */
	    windowBits -= 16;
	  }


	  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
	    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	    strategy < 0 || strategy > Z_FIXED) {
	    return err(strm, Z_STREAM_ERROR);
	  }


	  if (windowBits === 8) {
	    windowBits = 9;
	  }
	  /* until 256-byte window bug fixed */

	  var s = new DeflateState();

	  strm.state = s;
	  s.strm = strm;

	  s.wrap = wrap;
	  s.gzhead = null;
	  s.w_bits = windowBits;
	  s.w_size = 1 << s.w_bits;
	  s.w_mask = s.w_size - 1;

	  s.hash_bits = memLevel + 7;
	  s.hash_size = 1 << s.hash_bits;
	  s.hash_mask = s.hash_size - 1;
	  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

	  s.window = new utils.Buf8(s.w_size * 2);
	  s.head = new utils.Buf16(s.hash_size);
	  s.prev = new utils.Buf16(s.w_size);

	  // Don't need mem init magic for JS.
	  //s.high_water = 0;  /* nothing written to s->window yet */

	  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

	  s.pending_buf_size = s.lit_bufsize * 4;
	  s.pending_buf = new utils.Buf8(s.pending_buf_size);

	  s.d_buf = s.lit_bufsize >> 1;
	  s.l_buf = (1 + 2) * s.lit_bufsize;

	  s.level = level;
	  s.strategy = strategy;
	  s.method = method;

	  return deflateReset(strm);
	}

	function deflateInit(strm, level) {
	  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
	}


	function deflate(strm, flush) {
	  var old_flush, s;
	  var beg, val; // for gzip header write only

	  if (!strm || !strm.state ||
	    flush > Z_BLOCK || flush < 0) {
	    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
	  }

	  s = strm.state;

	  if (!strm.output ||
	      (!strm.input && strm.avail_in !== 0) ||
	      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
	    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
	  }

	  s.strm = strm; /* just in case */
	  old_flush = s.last_flush;
	  s.last_flush = flush;

	  /* Write the header */
	  if (s.status === INIT_STATE) {

	    if (s.wrap === 2) { // GZIP header
	      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
	      put_byte(s, 31);
	      put_byte(s, 139);
	      put_byte(s, 8);
	      if (!s.gzhead) { // s->gzhead == Z_NULL
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, 0);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, OS_CODE);
	        s.status = BUSY_STATE;
	      }
	      else {
	        put_byte(s, (s.gzhead.text ? 1 : 0) +
	                    (s.gzhead.hcrc ? 2 : 0) +
	                    (!s.gzhead.extra ? 0 : 4) +
	                    (!s.gzhead.name ? 0 : 8) +
	                    (!s.gzhead.comment ? 0 : 16)
	                );
	        put_byte(s, s.gzhead.time & 0xff);
	        put_byte(s, (s.gzhead.time >> 8) & 0xff);
	        put_byte(s, (s.gzhead.time >> 16) & 0xff);
	        put_byte(s, (s.gzhead.time >> 24) & 0xff);
	        put_byte(s, s.level === 9 ? 2 :
	                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
	                     4 : 0));
	        put_byte(s, s.gzhead.os & 0xff);
	        if (s.gzhead.extra && s.gzhead.extra.length) {
	          put_byte(s, s.gzhead.extra.length & 0xff);
	          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
	        }
	        if (s.gzhead.hcrc) {
	          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
	        }
	        s.gzindex = 0;
	        s.status = EXTRA_STATE;
	      }
	    }
	    else // DEFLATE header
	    {
	      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
	      var level_flags = -1;

	      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
	        level_flags = 0;
	      } else if (s.level < 6) {
	        level_flags = 1;
	      } else if (s.level === 6) {
	        level_flags = 2;
	      } else {
	        level_flags = 3;
	      }
	      header |= (level_flags << 6);
	      if (s.strstart !== 0) { header |= PRESET_DICT; }
	      header += 31 - (header % 31);

	      s.status = BUSY_STATE;
	      putShortMSB(s, header);

	      /* Save the adler32 of the preset dictionary: */
	      if (s.strstart !== 0) {
	        putShortMSB(s, strm.adler >>> 16);
	        putShortMSB(s, strm.adler & 0xffff);
	      }
	      strm.adler = 1; // adler32(0L, Z_NULL, 0);
	    }
	  }

	//#ifdef GZIP
	  if (s.status === EXTRA_STATE) {
	    if (s.gzhead.extra/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */

	      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            break;
	          }
	        }
	        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
	        s.gzindex++;
	      }
	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (s.gzindex === s.gzhead.extra.length) {
	        s.gzindex = 0;
	        s.status = NAME_STATE;
	      }
	    }
	    else {
	      s.status = NAME_STATE;
	    }
	  }
	  if (s.status === NAME_STATE) {
	    if (s.gzhead.name/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.name.length) {
	          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.gzindex = 0;
	        s.status = COMMENT_STATE;
	      }
	    }
	    else {
	      s.status = COMMENT_STATE;
	    }
	  }
	  if (s.status === COMMENT_STATE) {
	    if (s.gzhead.comment/* != Z_NULL*/) {
	      beg = s.pending;  /* start of bytes to update crc */
	      //int val;

	      do {
	        if (s.pending === s.pending_buf_size) {
	          if (s.gzhead.hcrc && s.pending > beg) {
	            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	          }
	          flush_pending(strm);
	          beg = s.pending;
	          if (s.pending === s.pending_buf_size) {
	            val = 1;
	            break;
	          }
	        }
	        // JS specific: little magic to add zero terminator to end of string
	        if (s.gzindex < s.gzhead.comment.length) {
	          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
	        } else {
	          val = 0;
	        }
	        put_byte(s, val);
	      } while (val !== 0);

	      if (s.gzhead.hcrc && s.pending > beg) {
	        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
	      }
	      if (val === 0) {
	        s.status = HCRC_STATE;
	      }
	    }
	    else {
	      s.status = HCRC_STATE;
	    }
	  }
	  if (s.status === HCRC_STATE) {
	    if (s.gzhead.hcrc) {
	      if (s.pending + 2 > s.pending_buf_size) {
	        flush_pending(strm);
	      }
	      if (s.pending + 2 <= s.pending_buf_size) {
	        put_byte(s, strm.adler & 0xff);
	        put_byte(s, (strm.adler >> 8) & 0xff);
	        strm.adler = 0; //crc32(0L, Z_NULL, 0);
	        s.status = BUSY_STATE;
	      }
	    }
	    else {
	      s.status = BUSY_STATE;
	    }
	  }
	//#endif

	  /* Flush as much pending output as possible */
	  if (s.pending !== 0) {
	    flush_pending(strm);
	    if (strm.avail_out === 0) {
	      /* Since avail_out is 0, deflate will be called again with
	       * more output space, but possibly with both pending and
	       * avail_in equal to zero. There won't be anything to do,
	       * but this is not an error situation so make sure we
	       * return OK instead of BUF_ERROR at next call of deflate:
	       */
	      s.last_flush = -1;
	      return Z_OK;
	    }

	    /* Make sure there is something to do and avoid duplicate consecutive
	     * flushes. For repeated and useless calls with Z_FINISH, we keep
	     * returning Z_STREAM_END instead of Z_BUF_ERROR.
	     */
	  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
	    flush !== Z_FINISH) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* User must not provide more input after the first FINISH: */
	  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
	    return err(strm, Z_BUF_ERROR);
	  }

	  /* Start a new block or continue the current one.
	   */
	  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
	    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
	    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
	      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
	        configuration_table[s.level].func(s, flush));

	    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
	      s.status = FINISH_STATE;
	    }
	    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
	      if (strm.avail_out === 0) {
	        s.last_flush = -1;
	        /* avoid BUF_ERROR next call, see above */
	      }
	      return Z_OK;
	      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	       * of deflate should use the same flush parameter to make sure
	       * that the flush is complete. So we don't have to output an
	       * empty block here, this will be done at next call. This also
	       * ensures that for a very small output buffer, we emit at most
	       * one empty block.
	       */
	    }
	    if (bstate === BS_BLOCK_DONE) {
	      if (flush === Z_PARTIAL_FLUSH) {
	        trees._tr_align(s);
	      }
	      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

	        trees._tr_stored_block(s, 0, 0, false);
	        /* For a full flush, this empty block will be recognized
	         * as a special marker by inflate_sync().
	         */
	        if (flush === Z_FULL_FLUSH) {
	          /*** CLEAR_HASH(s); ***/             /* forget history */
	          zero(s.head); // Fill with NIL (= 0);

	          if (s.lookahead === 0) {
	            s.strstart = 0;
	            s.block_start = 0;
	            s.insert = 0;
	          }
	        }
	      }
	      flush_pending(strm);
	      if (strm.avail_out === 0) {
	        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	        return Z_OK;
	      }
	    }
	  }
	  //Assert(strm->avail_out > 0, "bug2");
	  //if (strm.avail_out <= 0) { throw new Error("bug2");}

	  if (flush !== Z_FINISH) { return Z_OK; }
	  if (s.wrap <= 0) { return Z_STREAM_END; }

	  /* Write the trailer */
	  if (s.wrap === 2) {
	    put_byte(s, strm.adler & 0xff);
	    put_byte(s, (strm.adler >> 8) & 0xff);
	    put_byte(s, (strm.adler >> 16) & 0xff);
	    put_byte(s, (strm.adler >> 24) & 0xff);
	    put_byte(s, strm.total_in & 0xff);
	    put_byte(s, (strm.total_in >> 8) & 0xff);
	    put_byte(s, (strm.total_in >> 16) & 0xff);
	    put_byte(s, (strm.total_in >> 24) & 0xff);
	  }
	  else
	  {
	    putShortMSB(s, strm.adler >>> 16);
	    putShortMSB(s, strm.adler & 0xffff);
	  }

	  flush_pending(strm);
	  /* If avail_out is zero, the application will call deflate again
	   * to flush the rest.
	   */
	  if (s.wrap > 0) { s.wrap = -s.wrap; }
	  /* write the trailer only once! */
	  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
	}

	function deflateEnd(strm) {
	  var status;

	  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
	    return Z_STREAM_ERROR;
	  }

	  status = strm.state.status;
	  if (status !== INIT_STATE &&
	    status !== EXTRA_STATE &&
	    status !== NAME_STATE &&
	    status !== COMMENT_STATE &&
	    status !== HCRC_STATE &&
	    status !== BUSY_STATE &&
	    status !== FINISH_STATE
	  ) {
	    return err(strm, Z_STREAM_ERROR);
	  }

	  strm.state = null;

	  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
	}

	/* =========================================================================
	 * Copy the source state to the destination state
	 */
	//function deflateCopy(dest, source) {
	//
	//}

	exports.deflateInit = deflateInit;
	exports.deflateInit2 = deflateInit2;
	exports.deflateReset = deflateReset;
	exports.deflateResetKeep = deflateResetKeep;
	exports.deflateSetHeader = deflateSetHeader;
	exports.deflate = deflate;
	exports.deflateEnd = deflateEnd;
	exports.deflateInfo = 'pako deflate (from Nodeca project)';

	/* Not implemented
	exports.deflateBound = deflateBound;
	exports.deflateCopy = deflateCopy;
	exports.deflateSetDictionary = deflateSetDictionary;
	exports.deflateParams = deflateParams;
	exports.deflatePending = deflatePending;
	exports.deflatePrime = deflatePrime;
	exports.deflateTune = deflateTune;
	*/


/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';


	var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
	                (typeof Uint16Array !== 'undefined') &&
	                (typeof Int32Array !== 'undefined');


	exports.assign = function (obj /*from1, from2, from3, ...*/) {
	  var sources = Array.prototype.slice.call(arguments, 1);
	  while (sources.length) {
	    var source = sources.shift();
	    if (!source) { continue; }

	    if (typeof source !== 'object') {
	      throw new TypeError(source + 'must be non-object');
	    }

	    for (var p in source) {
	      if (source.hasOwnProperty(p)) {
	        obj[p] = source[p];
	      }
	    }
	  }

	  return obj;
	};


	// reduce buffer size, avoiding mem copy
	exports.shrinkBuf = function (buf, size) {
	  if (buf.length === size) { return buf; }
	  if (buf.subarray) { return buf.subarray(0, size); }
	  buf.length = size;
	  return buf;
	};


	var fnTyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    if (src.subarray && dest.subarray) {
	      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
	      return;
	    }
	    // Fallback to ordinary array
	    for (var i=0; i<len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function(chunks) {
	    var i, l, len, pos, chunk, result;

	    // calculate data length
	    len = 0;
	    for (i=0, l=chunks.length; i<l; i++) {
	      len += chunks[i].length;
	    }

	    // join chunks
	    result = new Uint8Array(len);
	    pos = 0;
	    for (i=0, l=chunks.length; i<l; i++) {
	      chunk = chunks[i];
	      result.set(chunk, pos);
	      pos += chunk.length;
	    }

	    return result;
	  }
	};

	var fnUntyped = {
	  arraySet: function (dest, src, src_offs, len, dest_offs) {
	    for (var i=0; i<len; i++) {
	      dest[dest_offs + i] = src[src_offs + i];
	    }
	  },
	  // Join array of chunks to single array.
	  flattenChunks: function(chunks) {
	    return [].concat.apply([], chunks);
	  }
	};


	// Enable/Disable typed arrays use, for testing
	//
	exports.setTyped = function (on) {
	  if (on) {
	    exports.Buf8  = Uint8Array;
	    exports.Buf16 = Uint16Array;
	    exports.Buf32 = Int32Array;
	    exports.assign(exports, fnTyped);
	  } else {
	    exports.Buf8  = Array;
	    exports.Buf16 = Array;
	    exports.Buf32 = Array;
	    exports.assign(exports, fnUntyped);
	  }
	};

	exports.setTyped(TYPED_OK);


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var utils = __webpack_require__(84);

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	//var Z_FILTERED          = 1;
	//var Z_HUFFMAN_ONLY      = 2;
	//var Z_RLE               = 3;
	var Z_FIXED               = 4;
	//var Z_DEFAULT_STRATEGY  = 0;

	/* Possible values of the data_type field (though see inflate()) */
	var Z_BINARY              = 0;
	var Z_TEXT                = 1;
	//var Z_ASCII             = 1; // = Z_TEXT
	var Z_UNKNOWN             = 2;

	/*============================================================================*/


	function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

	// From zutil.h

	var STORED_BLOCK = 0;
	var STATIC_TREES = 1;
	var DYN_TREES    = 2;
	/* The three kinds of block type */

	var MIN_MATCH    = 3;
	var MAX_MATCH    = 258;
	/* The minimum and maximum match lengths */

	// From deflate.h
	/* ===========================================================================
	 * Internal compression state.
	 */

	var LENGTH_CODES  = 29;
	/* number of length codes, not counting the special END_BLOCK code */

	var LITERALS      = 256;
	/* number of literal bytes 0..255 */

	var L_CODES       = LITERALS + 1 + LENGTH_CODES;
	/* number of Literal or Length codes, including the END_BLOCK code */

	var D_CODES       = 30;
	/* number of distance codes */

	var BL_CODES      = 19;
	/* number of codes used to transfer the bit lengths */

	var HEAP_SIZE     = 2*L_CODES + 1;
	/* maximum heap size */

	var MAX_BITS      = 15;
	/* All codes must not exceed MAX_BITS bits */

	var Buf_size      = 16;
	/* size of bit buffer in bi_buf */


	/* ===========================================================================
	 * Constants
	 */

	var MAX_BL_BITS = 7;
	/* Bit length codes must not exceed MAX_BL_BITS bits */

	var END_BLOCK   = 256;
	/* end of block literal code */

	var REP_3_6     = 16;
	/* repeat previous bit length 3-6 times (2 bits of repeat count) */

	var REPZ_3_10   = 17;
	/* repeat a zero length 3-10 times  (3 bits of repeat count) */

	var REPZ_11_138 = 18;
	/* repeat a zero length 11-138 times  (7 bits of repeat count) */

	var extra_lbits =   /* extra bits for each length code */
	  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

	var extra_dbits =   /* extra bits for each distance code */
	  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

	var extra_blbits =  /* extra bits for each bit length code */
	  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

	var bl_order =
	  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
	/* The lengths of the bit length codes are sent in order of decreasing
	 * probability, to avoid transmitting the lengths for unused bit length codes.
	 */

	/* ===========================================================================
	 * Local data. These are initialized only once.
	 */

	// We pre-fill arrays with 0 to avoid uninitialized gaps

	var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

	// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
	var static_ltree  = new Array((L_CODES+2) * 2);
	zero(static_ltree);
	/* The static literal tree. Since the bit lengths are imposed, there is no
	 * need for the L_CODES extra codes used during heap construction. However
	 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
	 * below).
	 */

	var static_dtree  = new Array(D_CODES * 2);
	zero(static_dtree);
	/* The static distance tree. (Actually a trivial tree since all codes use
	 * 5 bits.)
	 */

	var _dist_code    = new Array(DIST_CODE_LEN);
	zero(_dist_code);
	/* Distance codes. The first 256 values correspond to the distances
	 * 3 .. 258, the last 256 values correspond to the top 8 bits of
	 * the 15 bit distances.
	 */

	var _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);
	zero(_length_code);
	/* length code for each normalized match length (0 == MIN_MATCH) */

	var base_length   = new Array(LENGTH_CODES);
	zero(base_length);
	/* First normalized length for each code (0 = MIN_MATCH) */

	var base_dist     = new Array(D_CODES);
	zero(base_dist);
	/* First normalized distance for each code (0 = distance of 1) */


	var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {

	  this.static_tree  = static_tree;  /* static tree or NULL */
	  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
	  this.extra_base   = extra_base;   /* base index for extra_bits */
	  this.elems        = elems;        /* max number of elements in the tree */
	  this.max_length   = max_length;   /* max bit length for the codes */

	  // show if `static_tree` has data or dummy - needed for monomorphic objects
	  this.has_stree    = static_tree && static_tree.length;
	};


	var static_l_desc;
	var static_d_desc;
	var static_bl_desc;


	var TreeDesc = function(dyn_tree, stat_desc) {
	  this.dyn_tree = dyn_tree;     /* the dynamic tree */
	  this.max_code = 0;            /* largest code with non zero frequency */
	  this.stat_desc = stat_desc;   /* the corresponding static tree */
	};



	function d_code(dist) {
	  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	}


	/* ===========================================================================
	 * Output a short LSB first on the stream.
	 * IN assertion: there is enough room in pendingBuf.
	 */
	function put_short (s, w) {
	//    put_byte(s, (uch)((w) & 0xff));
	//    put_byte(s, (uch)((ush)(w) >> 8));
	  s.pending_buf[s.pending++] = (w) & 0xff;
	  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
	}


	/* ===========================================================================
	 * Send a value on a given number of bits.
	 * IN assertion: length <= 16 and value fits in length bits.
	 */
	function send_bits(s, value, length) {
	  if (s.bi_valid > (Buf_size - length)) {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    put_short(s, s.bi_buf);
	    s.bi_buf = value >> (Buf_size - s.bi_valid);
	    s.bi_valid += length - Buf_size;
	  } else {
	    s.bi_buf |= (value << s.bi_valid) & 0xffff;
	    s.bi_valid += length;
	  }
	}


	function send_code(s, c, tree) {
	  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);
	}


	/* ===========================================================================
	 * Reverse the first len bits of a code, using straightforward code (a faster
	 * method would use a table)
	 * IN assertion: 1 <= len <= 15
	 */
	function bi_reverse(code, len) {
	  var res = 0;
	  do {
	    res |= code & 1;
	    code >>>= 1;
	    res <<= 1;
	  } while (--len > 0);
	  return res >>> 1;
	}


	/* ===========================================================================
	 * Flush the bit buffer, keeping at most 7 bits in it.
	 */
	function bi_flush(s) {
	  if (s.bi_valid === 16) {
	    put_short(s, s.bi_buf);
	    s.bi_buf = 0;
	    s.bi_valid = 0;

	  } else if (s.bi_valid >= 8) {
	    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
	    s.bi_buf >>= 8;
	    s.bi_valid -= 8;
	  }
	}


	/* ===========================================================================
	 * Compute the optimal bit lengths for a tree and update the total bit length
	 * for the current block.
	 * IN assertion: the fields freq and dad are set, heap[heap_max] and
	 *    above are the tree nodes sorted by increasing frequency.
	 * OUT assertions: the field len is set to the optimal bit length, the
	 *     array bl_count contains the frequencies for each bit length.
	 *     The length opt_len is updated; static_len is also updated if stree is
	 *     not null.
	 */
	function gen_bitlen(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc;    /* the tree descriptor */
	{
	  var tree            = desc.dyn_tree;
	  var max_code        = desc.max_code;
	  var stree           = desc.stat_desc.static_tree;
	  var has_stree       = desc.stat_desc.has_stree;
	  var extra           = desc.stat_desc.extra_bits;
	  var base            = desc.stat_desc.extra_base;
	  var max_length      = desc.stat_desc.max_length;
	  var h;              /* heap index */
	  var n, m;           /* iterate over the tree elements */
	  var bits;           /* bit length */
	  var xbits;          /* extra bits */
	  var f;              /* frequency */
	  var overflow = 0;   /* number of elements with bit length too large */

	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    s.bl_count[bits] = 0;
	  }

	  /* In a first pass, compute the optimal bit lengths (which may
	   * overflow in the case of the bit length tree).
	   */
	  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */

	  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {
	    n = s.heap[h];
	    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
	    if (bits > max_length) {
	      bits = max_length;
	      overflow++;
	    }
	    tree[n*2 + 1]/*.Len*/ = bits;
	    /* We overwrite tree[n].Dad which is no longer needed */

	    if (n > max_code) { continue; } /* not a leaf node */

	    s.bl_count[bits]++;
	    xbits = 0;
	    if (n >= base) {
	      xbits = extra[n-base];
	    }
	    f = tree[n * 2]/*.Freq*/;
	    s.opt_len += f * (bits + xbits);
	    if (has_stree) {
	      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);
	    }
	  }
	  if (overflow === 0) { return; }

	  // Trace((stderr,"\nbit length overflow\n"));
	  /* This happens for example on obj2 and pic of the Calgary corpus */

	  /* Find the first bit length which could increase: */
	  do {
	    bits = max_length-1;
	    while (s.bl_count[bits] === 0) { bits--; }
	    s.bl_count[bits]--;      /* move one leaf down the tree */
	    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */
	    s.bl_count[max_length]--;
	    /* The brother of the overflow item also moves one step up,
	     * but this does not affect bl_count[max_length]
	     */
	    overflow -= 2;
	  } while (overflow > 0);

	  /* Now recompute all bit lengths, scanning in increasing frequency.
	   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
	   * lengths instead of fixing only the wrong ones. This idea is taken
	   * from 'ar' written by Haruhiko Okumura.)
	   */
	  for (bits = max_length; bits !== 0; bits--) {
	    n = s.bl_count[bits];
	    while (n !== 0) {
	      m = s.heap[--h];
	      if (m > max_code) { continue; }
	      if (tree[m*2 + 1]/*.Len*/ !== bits) {
	        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
	        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;
	        tree[m*2 + 1]/*.Len*/ = bits;
	      }
	      n--;
	    }
	  }
	}


	/* ===========================================================================
	 * Generate the codes for a given tree and bit counts (which need not be
	 * optimal).
	 * IN assertion: the array bl_count contains the bit length statistics for
	 * the given tree and the field len is set for all tree elements.
	 * OUT assertion: the field code is set for all tree elements of non
	 *     zero code length.
	 */
	function gen_codes(tree, max_code, bl_count)
	//    ct_data *tree;             /* the tree to decorate */
	//    int max_code;              /* largest code with non zero frequency */
	//    ushf *bl_count;            /* number of codes at each bit length */
	{
	  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */
	  var code = 0;              /* running code value */
	  var bits;                  /* bit index */
	  var n;                     /* code index */

	  /* The distribution counts are first used to generate the code values
	   * without bit reversal.
	   */
	  for (bits = 1; bits <= MAX_BITS; bits++) {
	    next_code[bits] = code = (code + bl_count[bits-1]) << 1;
	  }
	  /* Check that the bit counts in bl_count are consistent. The last code
	   * must be all ones.
	   */
	  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  //        "inconsistent bit counts");
	  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  for (n = 0;  n <= max_code; n++) {
	    var len = tree[n*2 + 1]/*.Len*/;
	    if (len === 0) { continue; }
	    /* Now reverse the bits */
	    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);

	    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
	    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
	  }
	}


	/* ===========================================================================
	 * Initialize the various 'constant' tables.
	 */
	function tr_static_init() {
	  var n;        /* iterates over tree elements */
	  var bits;     /* bit counter */
	  var length;   /* length value */
	  var code;     /* code value */
	  var dist;     /* distance index */
	  var bl_count = new Array(MAX_BITS+1);
	  /* number of codes at each bit length for an optimal tree */

	  // do check in _tr_init()
	  //if (static_init_done) return;

	  /* For some embedded targets, global variables are not initialized: */
	/*#ifdef NO_INIT_GLOBAL_POINTERS
	  static_l_desc.static_tree = static_ltree;
	  static_l_desc.extra_bits = extra_lbits;
	  static_d_desc.static_tree = static_dtree;
	  static_d_desc.extra_bits = extra_dbits;
	  static_bl_desc.extra_bits = extra_blbits;
	#endif*/

	  /* Initialize the mapping length (0..255) -> length code (0..28) */
	  length = 0;
	  for (code = 0; code < LENGTH_CODES-1; code++) {
	    base_length[code] = length;
	    for (n = 0; n < (1<<extra_lbits[code]); n++) {
	      _length_code[length++] = code;
	    }
	  }
	  //Assert (length == 256, "tr_static_init: length != 256");
	  /* Note that the length 255 (match length 258) can be represented
	   * in two different ways: code 284 + 5 bits or code 285, so we
	   * overwrite length_code[255] to use the best encoding:
	   */
	  _length_code[length-1] = code;

	  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
	  dist = 0;
	  for (code = 0 ; code < 16; code++) {
	    base_dist[code] = dist;
	    for (n = 0; n < (1<<extra_dbits[code]); n++) {
	      _dist_code[dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: dist != 256");
	  dist >>= 7; /* from now on, all distances are divided by 128 */
	  for (; code < D_CODES; code++) {
	    base_dist[code] = dist << 7;
	    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
	      _dist_code[256 + dist++] = code;
	    }
	  }
	  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

	  /* Construct the codes of the static literal tree */
	  for (bits = 0; bits <= MAX_BITS; bits++) {
	    bl_count[bits] = 0;
	  }

	  n = 0;
	  while (n <= 143) {
	    static_ltree[n*2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  while (n <= 255) {
	    static_ltree[n*2 + 1]/*.Len*/ = 9;
	    n++;
	    bl_count[9]++;
	  }
	  while (n <= 279) {
	    static_ltree[n*2 + 1]/*.Len*/ = 7;
	    n++;
	    bl_count[7]++;
	  }
	  while (n <= 287) {
	    static_ltree[n*2 + 1]/*.Len*/ = 8;
	    n++;
	    bl_count[8]++;
	  }
	  /* Codes 286 and 287 do not exist, but we must include them in the
	   * tree construction to get a canonical Huffman tree (longest code
	   * all ones)
	   */
	  gen_codes(static_ltree, L_CODES+1, bl_count);

	  /* The static distance tree is trivial: */
	  for (n = 0; n < D_CODES; n++) {
	    static_dtree[n*2 + 1]/*.Len*/ = 5;
	    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);
	  }

	  // Now data ready and we can init static trees
	  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);
	  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
	  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

	  //static_init_done = true;
	}


	/* ===========================================================================
	 * Initialize a new block.
	 */
	function init_block(s) {
	  var n; /* iterates over tree elements */

	  /* Initialize the trees. */
	  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }
	  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }
	  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }

	  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;
	  s.opt_len = s.static_len = 0;
	  s.last_lit = s.matches = 0;
	}


	/* ===========================================================================
	 * Flush the bit buffer and align the output on a byte boundary
	 */
	function bi_windup(s)
	{
	  if (s.bi_valid > 8) {
	    put_short(s, s.bi_buf);
	  } else if (s.bi_valid > 0) {
	    //put_byte(s, (Byte)s->bi_buf);
	    s.pending_buf[s.pending++] = s.bi_buf;
	  }
	  s.bi_buf = 0;
	  s.bi_valid = 0;
	}

	/* ===========================================================================
	 * Copy a stored block, storing first the length and its
	 * one's complement if requested.
	 */
	function copy_block(s, buf, len, header)
	//DeflateState *s;
	//charf    *buf;    /* the input data */
	//unsigned len;     /* its length */
	//int      header;  /* true if block header must be written */
	{
	  bi_windup(s);        /* align on byte boundary */

	  if (header) {
	    put_short(s, len);
	    put_short(s, ~len);
	  }
	//  while (len--) {
	//    put_byte(s, *buf++);
	//  }
	  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
	  s.pending += len;
	}

	/* ===========================================================================
	 * Compares to subtrees, using the tree depth as tie breaker when
	 * the subtrees have equal frequency. This minimizes the worst case length.
	 */
	function smaller(tree, n, m, depth) {
	  var _n2 = n*2;
	  var _m2 = m*2;
	  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
	         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
	}

	/* ===========================================================================
	 * Restore the heap property by moving down the tree starting at node k,
	 * exchanging a node with the smallest of its two sons if necessary, stopping
	 * when the heap property is re-established (each father smaller than its
	 * two sons).
	 */
	function pqdownheap(s, tree, k)
	//    deflate_state *s;
	//    ct_data *tree;  /* the tree to restore */
	//    int k;               /* node to move down */
	{
	  var v = s.heap[k];
	  var j = k << 1;  /* left son of k */
	  while (j <= s.heap_len) {
	    /* Set j to the smallest of the two sons: */
	    if (j < s.heap_len &&
	      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {
	      j++;
	    }
	    /* Exit if v is smaller than both sons */
	    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

	    /* Exchange v with the smallest son */
	    s.heap[k] = s.heap[j];
	    k = j;

	    /* And continue down the tree, setting j to the left son of k */
	    j <<= 1;
	  }
	  s.heap[k] = v;
	}


	// inlined manually
	// var SMALLEST = 1;

	/* ===========================================================================
	 * Send the block data compressed using the given Huffman trees
	 */
	function compress_block(s, ltree, dtree)
	//    deflate_state *s;
	//    const ct_data *ltree; /* literal tree */
	//    const ct_data *dtree; /* distance tree */
	{
	  var dist;           /* distance of matched string */
	  var lc;             /* match length or unmatched char (if dist == 0) */
	  var lx = 0;         /* running index in l_buf */
	  var code;           /* the code to send */
	  var extra;          /* number of extra bits to send */

	  if (s.last_lit !== 0) {
	    do {
	      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);
	      lc = s.pending_buf[s.l_buf + lx];
	      lx++;

	      if (dist === 0) {
	        send_code(s, lc, ltree); /* send a literal byte */
	        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	      } else {
	        /* Here, lc is the match length - MIN_MATCH */
	        code = _length_code[lc];
	        send_code(s, code+LITERALS+1, ltree); /* send the length code */
	        extra = extra_lbits[code];
	        if (extra !== 0) {
	          lc -= base_length[code];
	          send_bits(s, lc, extra);       /* send the extra length bits */
	        }
	        dist--; /* dist is now the match distance - 1 */
	        code = d_code(dist);
	        //Assert (code < D_CODES, "bad d_code");

	        send_code(s, code, dtree);       /* send the distance code */
	        extra = extra_dbits[code];
	        if (extra !== 0) {
	          dist -= base_dist[code];
	          send_bits(s, dist, extra);   /* send the extra distance bits */
	        }
	      } /* literal or match pair ? */

	      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
	      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
	      //       "pendingBuf overflow");

	    } while (lx < s.last_lit);
	  }

	  send_code(s, END_BLOCK, ltree);
	}


	/* ===========================================================================
	 * Construct one Huffman tree and assigns the code bit strings and lengths.
	 * Update the total bit length for the current block.
	 * IN assertion: the field freq is set for all tree elements.
	 * OUT assertions: the fields len and code are set to the optimal bit length
	 *     and corresponding code. The length opt_len is updated; static_len is
	 *     also updated if stree is not null. The field max_code is set.
	 */
	function build_tree(s, desc)
	//    deflate_state *s;
	//    tree_desc *desc; /* the tree descriptor */
	{
	  var tree     = desc.dyn_tree;
	  var stree    = desc.stat_desc.static_tree;
	  var has_stree = desc.stat_desc.has_stree;
	  var elems    = desc.stat_desc.elems;
	  var n, m;          /* iterate over heap elements */
	  var max_code = -1; /* largest code with non zero frequency */
	  var node;          /* new node being created */

	  /* Construct the initial heap, with least frequent element in
	   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	   * heap[0] is not used.
	   */
	  s.heap_len = 0;
	  s.heap_max = HEAP_SIZE;

	  for (n = 0; n < elems; n++) {
	    if (tree[n * 2]/*.Freq*/ !== 0) {
	      s.heap[++s.heap_len] = max_code = n;
	      s.depth[n] = 0;

	    } else {
	      tree[n*2 + 1]/*.Len*/ = 0;
	    }
	  }

	  /* The pkzip format requires that at least one distance code exists,
	   * and that at least one bit should be sent even if there is only one
	   * possible code. So to avoid special checks later on we force at least
	   * two codes of non zero frequency.
	   */
	  while (s.heap_len < 2) {
	    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
	    tree[node * 2]/*.Freq*/ = 1;
	    s.depth[node] = 0;
	    s.opt_len--;

	    if (has_stree) {
	      s.static_len -= stree[node*2 + 1]/*.Len*/;
	    }
	    /* node is 0 or 1 so it does not have extra bits */
	  }
	  desc.max_code = max_code;

	  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	   * establish sub-heaps of increasing lengths:
	   */
	  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

	  /* Construct the Huffman tree by repeatedly combining the least two
	   * frequent nodes.
	   */
	  node = elems;              /* next internal node of the tree */
	  do {
	    //pqremove(s, tree, n);  /* n = node of least frequency */
	    /*** pqremove ***/
	    n = s.heap[1/*SMALLEST*/];
	    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
	    pqdownheap(s, tree, 1/*SMALLEST*/);
	    /***/

	    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

	    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
	    s.heap[--s.heap_max] = m;

	    /* Create a new node father of n and m */
	    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
	    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
	    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;

	    /* and insert the new node in the heap */
	    s.heap[1/*SMALLEST*/] = node++;
	    pqdownheap(s, tree, 1/*SMALLEST*/);

	  } while (s.heap_len >= 2);

	  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

	  /* At this point, the fields freq and dad are set. We can now
	   * generate the bit lengths.
	   */
	  gen_bitlen(s, desc);

	  /* The field len is now set, we can generate the bit codes */
	  gen_codes(tree, max_code, s.bl_count);
	}


	/* ===========================================================================
	 * Scan a literal or distance tree to determine the frequencies of the codes
	 * in the bit length tree.
	 */
	function scan_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree;   /* the tree to be scanned */
	//    int max_code;    /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }
	  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n+1)*2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      s.bl_tree[curlen * 2]/*.Freq*/ += count;

	    } else if (curlen !== 0) {

	      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
	      s.bl_tree[REP_3_6*2]/*.Freq*/++;

	    } else if (count <= 10) {
	      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;

	    } else {
	      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;
	    }

	    count = 0;
	    prevlen = curlen;

	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Send a literal or distance tree in compressed form, using the codes in
	 * bl_tree.
	 */
	function send_tree(s, tree, max_code)
	//    deflate_state *s;
	//    ct_data *tree; /* the tree to be scanned */
	//    int max_code;       /* and its largest code of non zero frequency */
	{
	  var n;                     /* iterates over all tree elements */
	  var prevlen = -1;          /* last emitted length */
	  var curlen;                /* length of current code */

	  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */

	  var count = 0;             /* repeat count of the current code */
	  var max_count = 7;         /* max repeat count */
	  var min_count = 4;         /* min repeat count */

	  /* tree[max_code+1].Len = -1; */  /* guard already set */
	  if (nextlen === 0) {
	    max_count = 138;
	    min_count = 3;
	  }

	  for (n = 0; n <= max_code; n++) {
	    curlen = nextlen;
	    nextlen = tree[(n+1)*2 + 1]/*.Len*/;

	    if (++count < max_count && curlen === nextlen) {
	      continue;

	    } else if (count < min_count) {
	      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

	    } else if (curlen !== 0) {
	      if (curlen !== prevlen) {
	        send_code(s, curlen, s.bl_tree);
	        count--;
	      }
	      //Assert(count >= 3 && count <= 6, " 3_6?");
	      send_code(s, REP_3_6, s.bl_tree);
	      send_bits(s, count-3, 2);

	    } else if (count <= 10) {
	      send_code(s, REPZ_3_10, s.bl_tree);
	      send_bits(s, count-3, 3);

	    } else {
	      send_code(s, REPZ_11_138, s.bl_tree);
	      send_bits(s, count-11, 7);
	    }

	    count = 0;
	    prevlen = curlen;
	    if (nextlen === 0) {
	      max_count = 138;
	      min_count = 3;

	    } else if (curlen === nextlen) {
	      max_count = 6;
	      min_count = 3;

	    } else {
	      max_count = 7;
	      min_count = 4;
	    }
	  }
	}


	/* ===========================================================================
	 * Construct the Huffman tree for the bit lengths and return the index in
	 * bl_order of the last bit length code to send.
	 */
	function build_bl_tree(s) {
	  var max_blindex;  /* index of last bit length code of non zero freq */

	  /* Determine the bit length frequencies for literal and distance trees */
	  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
	  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

	  /* Build the bit length tree: */
	  build_tree(s, s.bl_desc);
	  /* opt_len now includes the length of the tree representations, except
	   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
	   */

	  /* Determine the number of bit length codes to send. The pkzip format
	   * requires that at least 4 bit length codes be sent. (appnote.txt says
	   * 3 but the actual value used is 4.)
	   */
	  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
	    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {
	      break;
	    }
	  }
	  /* Update opt_len to include the bit length tree and counts */
	  s.opt_len += 3*(max_blindex+1) + 5+5+4;
	  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
	  //        s->opt_len, s->static_len));

	  return max_blindex;
	}


	/* ===========================================================================
	 * Send the header for a block using dynamic Huffman trees: the counts, the
	 * lengths of the bit length codes, the literal tree and the distance tree.
	 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	 */
	function send_all_trees(s, lcodes, dcodes, blcodes)
	//    deflate_state *s;
	//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
	{
	  var rank;                    /* index in bl_order */

	  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
	  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
	  //        "too many codes");
	  //Tracev((stderr, "\nbl counts: "));
	  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
	  send_bits(s, dcodes-1,   5);
	  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
	  for (rank = 0; rank < blcodes; rank++) {
	    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);
	  }
	  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */
	  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

	  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */
	  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
	}


	/* ===========================================================================
	 * Check if the data type is TEXT or BINARY, using the following algorithm:
	 * - TEXT if the two conditions below are satisfied:
	 *    a) There are no non-portable control characters belonging to the
	 *       "black list" (0..6, 14..25, 28..31).
	 *    b) There is at least one printable character belonging to the
	 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
	 * - BINARY otherwise.
	 * - The following partially-portable control characters form a
	 *   "gray list" that is ignored in this detection algorithm:
	 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
	 * IN assertion: the fields Freq of dyn_ltree are set.
	 */
	function detect_data_type(s) {
	  /* black_mask is the bit mask of black-listed bytes
	   * set bits 0..6, 14..25, and 28..31
	   * 0xf3ffc07f = binary 11110011111111111100000001111111
	   */
	  var black_mask = 0xf3ffc07f;
	  var n;

	  /* Check for non-textual ("black-listed") bytes. */
	  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
	    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {
	      return Z_BINARY;
	    }
	  }

	  /* Check for textual ("white-listed") bytes. */
	  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
	      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
	    return Z_TEXT;
	  }
	  for (n = 32; n < LITERALS; n++) {
	    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
	      return Z_TEXT;
	    }
	  }

	  /* There are no "black-listed" or "white-listed" bytes:
	   * this stream either is empty or has tolerated ("gray-listed") bytes only.
	   */
	  return Z_BINARY;
	}


	var static_init_done = false;

	/* ===========================================================================
	 * Initialize the tree data structures for a new zlib stream.
	 */
	function _tr_init(s)
	{

	  if (!static_init_done) {
	    tr_static_init();
	    static_init_done = true;
	  }

	  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
	  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
	  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

	  s.bi_buf = 0;
	  s.bi_valid = 0;

	  /* Initialize the first block of the first file: */
	  init_block(s);
	}


	/* ===========================================================================
	 * Send a stored block
	 */
	function _tr_stored_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */
	  copy_block(s, buf, stored_len, true); /* with header */
	}


	/* ===========================================================================
	 * Send one empty static block to give enough lookahead for inflate.
	 * This takes 10 bits, of which 7 may remain in the bit buffer.
	 */
	function _tr_align(s) {
	  send_bits(s, STATIC_TREES<<1, 3);
	  send_code(s, END_BLOCK, static_ltree);
	  bi_flush(s);
	}


	/* ===========================================================================
	 * Determine the best encoding for the current block: dynamic trees, static
	 * trees or store, and output the encoded block to the zip file.
	 */
	function _tr_flush_block(s, buf, stored_len, last)
	//DeflateState *s;
	//charf *buf;       /* input block, or NULL if too old */
	//ulg stored_len;   /* length of input block */
	//int last;         /* one if this is the last block for a file */
	{
	  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
	  var max_blindex = 0;        /* index of last bit length code of non zero freq */

	  /* Build the Huffman trees unless a stored block is forced */
	  if (s.level > 0) {

	    /* Check if the file is binary or text */
	    if (s.strm.data_type === Z_UNKNOWN) {
	      s.strm.data_type = detect_data_type(s);
	    }

	    /* Construct the literal and distance trees */
	    build_tree(s, s.l_desc);
	    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));

	    build_tree(s, s.d_desc);
	    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
	    //        s->static_len));
	    /* At this point, opt_len and static_len are the total bit lengths of
	     * the compressed block data, excluding the tree representations.
	     */

	    /* Build the bit length tree for the above two trees, and get the index
	     * in bl_order of the last bit length code to send.
	     */
	    max_blindex = build_bl_tree(s);

	    /* Determine the best encoding. Compute the block lengths in bytes. */
	    opt_lenb = (s.opt_len+3+7) >>> 3;
	    static_lenb = (s.static_len+3+7) >>> 3;

	    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
	    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
	    //        s->last_lit));

	    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

	  } else {
	    // Assert(buf != (char*)0, "lost buf");
	    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
	  }

	  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {
	    /* 4: two words for the lengths */

	    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	     * Otherwise we can't have processed more than WSIZE input bytes since
	     * the last block flush, because compression would have been
	     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	     * transform a block into a stored block.
	     */
	    _tr_stored_block(s, buf, stored_len, last);

	  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

	    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);
	    compress_block(s, static_ltree, static_dtree);

	  } else {
	    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);
	    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);
	    compress_block(s, s.dyn_ltree, s.dyn_dtree);
	  }
	  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
	  /* The above check is made mod 2^32, for files larger than 512 MB
	   * and uLong implemented on 32 bits.
	   */
	  init_block(s);

	  if (last) {
	    bi_windup(s);
	  }
	  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
	  //       s->compressed_len-7*last));
	}

	/* ===========================================================================
	 * Save the match info and tally the frequency counts. Return true if
	 * the current block must be flushed.
	 */
	function _tr_tally(s, dist, lc)
	//    deflate_state *s;
	//    unsigned dist;  /* distance of matched string */
	//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
	{
	  //var out_length, in_length, dcode;

	  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
	  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

	  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
	  s.last_lit++;

	  if (dist === 0) {
	    /* lc is the unmatched char */
	    s.dyn_ltree[lc*2]/*.Freq*/++;
	  } else {
	    s.matches++;
	    /* Here, lc is the match length - MIN_MATCH */
	    dist--;             /* dist = match distance - 1 */
	    //Assert((ush)dist < (ush)MAX_DIST(s) &&
	    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
	    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

	    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;
	    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
	  }

	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility

	//#ifdef TRUNCATE_BLOCK
	//  /* Try to guess if it is profitable to stop the current block here */
	//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
	//    /* Compute an upper bound for the compressed length */
	//    out_length = s.last_lit*8;
	//    in_length = s.strstart - s.block_start;
	//
	//    for (dcode = 0; dcode < D_CODES; dcode++) {
	//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
	//    }
	//    out_length >>>= 3;
	//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
	//    //       s->last_lit, in_length, out_length,
	//    //       100L - out_length*100L/in_length));
	//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
	//      return true;
	//    }
	//  }
	//#endif

	  return (s.last_lit === s.lit_bufsize-1);
	  /* We avoid equality with lit_bufsize because of wraparound at 64K
	   * on 16 bit machines and because stored blocks are restricted to
	   * 64K-1 bytes.
	   */
	}

	exports._tr_init  = _tr_init;
	exports._tr_stored_block = _tr_stored_block;
	exports._tr_flush_block  = _tr_flush_block;
	exports._tr_tally = _tr_tally;
	exports._tr_align = _tr_align;


/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';

	// Note: adler32 takes 12% for level 0 and 2% for level 6.
	// It doesn't worth to make additional optimizationa as in original.
	// Small size is preferable.

	function adler32(adler, buf, len, pos) {
	  var s1 = (adler & 0xffff) |0,
	      s2 = ((adler >>> 16) & 0xffff) |0,
	      n = 0;

	  while (len !== 0) {
	    // Set limit ~ twice less than 5552, to keep
	    // s2 in 31-bits, because we force signed ints.
	    // in other case %= will fail.
	    n = len > 2000 ? 2000 : len;
	    len -= n;

	    do {
	      s1 = (s1 + buf[pos++]) |0;
	      s2 = (s2 + s1) |0;
	    } while (--n);

	    s1 %= 65521;
	    s2 %= 65521;
	  }

	  return (s1 | (s2 << 16)) |0;
	}


	module.exports = adler32;


/***/ },
/* 87 */
/***/ function(module, exports) {

	'use strict';

	// Note: we can't get significant speed boost here.
	// So write code to minimize size - no pregenerated tables
	// and array tools dependencies.


	// Use ordinary array, since untyped makes no boost here
	function makeTable() {
	  var c, table = [];

	  for (var n =0; n < 256; n++) {
	    c = n;
	    for (var k =0; k < 8; k++) {
	      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
	    }
	    table[n] = c;
	  }

	  return table;
	}

	// Create table on load. Just 255 signed longs. Not a problem.
	var crcTable = makeTable();


	function crc32(crc, buf, len, pos) {
	  var t = crcTable,
	      end = pos + len;

	  crc = crc ^ (-1);

	  for (var i = pos; i < end; i++) {
	    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
	  }

	  return (crc ^ (-1)); // >>> 0;
	}


	module.exports = crc32;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var utils = __webpack_require__(84);
	var adler32 = __webpack_require__(86);
	var crc32   = __webpack_require__(87);
	var inflate_fast = __webpack_require__(89);
	var inflate_table = __webpack_require__(90);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	/* Public constants ==========================================================*/
	/* ===========================================================================*/


	/* Allowed flush values; see deflate() and inflate() below for details */
	//var Z_NO_FLUSH      = 0;
	//var Z_PARTIAL_FLUSH = 1;
	//var Z_SYNC_FLUSH    = 2;
	//var Z_FULL_FLUSH    = 3;
	var Z_FINISH        = 4;
	var Z_BLOCK         = 5;
	var Z_TREES         = 6;


	/* Return codes for the compression/decompression functions. Negative values
	 * are errors, positive values are used for special but normal events.
	 */
	var Z_OK            = 0;
	var Z_STREAM_END    = 1;
	var Z_NEED_DICT     = 2;
	//var Z_ERRNO         = -1;
	var Z_STREAM_ERROR  = -2;
	var Z_DATA_ERROR    = -3;
	var Z_MEM_ERROR     = -4;
	var Z_BUF_ERROR     = -5;
	//var Z_VERSION_ERROR = -6;

	/* The deflate compression method */
	var Z_DEFLATED  = 8;


	/* STATES ====================================================================*/
	/* ===========================================================================*/


	var    HEAD = 1;       /* i: waiting for magic header */
	var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
	var    TIME = 3;       /* i: waiting for modification time (gzip) */
	var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
	var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
	var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
	var    NAME = 7;       /* i: waiting for end of file name (gzip) */
	var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
	var    HCRC = 9;       /* i: waiting for header crc (gzip) */
	var    DICTID = 10;    /* i: waiting for dictionary check value */
	var    DICT = 11;      /* waiting for inflateSetDictionary() call */
	var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
	var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
	var        STORED = 14;    /* i: waiting for stored size (length and complement) */
	var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
	var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
	var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
	var        LENLENS = 18;   /* i: waiting for code length code lengths */
	var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
	var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
	var            LEN = 21;       /* i: waiting for length/lit/eob code */
	var            LENEXT = 22;    /* i: waiting for length extra bits */
	var            DIST = 23;      /* i: waiting for distance code */
	var            DISTEXT = 24;   /* i: waiting for distance extra bits */
	var            MATCH = 25;     /* o: waiting for output space to copy string */
	var            LIT = 26;       /* o: waiting for output space to write literal */
	var    CHECK = 27;     /* i: waiting for 32-bit check value */
	var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
	var    DONE = 29;      /* finished check, done -- remain here until reset */
	var    BAD = 30;       /* got a data error -- remain here until reset */
	var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
	var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

	/* ===========================================================================*/



	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

	var MAX_WBITS = 15;
	/* 32K LZ77 window */
	var DEF_WBITS = MAX_WBITS;


	function ZSWAP32(q) {
	  return  (((q >>> 24) & 0xff) +
	          ((q >>> 8) & 0xff00) +
	          ((q & 0xff00) << 8) +
	          ((q & 0xff) << 24));
	}


	function InflateState() {
	  this.mode = 0;             /* current inflate mode */
	  this.last = false;          /* true if processing last block */
	  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
	  this.havedict = false;      /* true if dictionary provided */
	  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
	  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
	  this.check = 0;             /* protected copy of check value */
	  this.total = 0;             /* protected copy of output count */
	  // TODO: may be {}
	  this.head = null;           /* where to save gzip header information */

	  /* sliding window */
	  this.wbits = 0;             /* log base 2 of requested window size */
	  this.wsize = 0;             /* window size or zero if not using window */
	  this.whave = 0;             /* valid bytes in the window */
	  this.wnext = 0;             /* window write index */
	  this.window = null;         /* allocated sliding window, if needed */

	  /* bit accumulator */
	  this.hold = 0;              /* input bit accumulator */
	  this.bits = 0;              /* number of bits in "in" */

	  /* for string and stored block copying */
	  this.length = 0;            /* literal or length of data to copy */
	  this.offset = 0;            /* distance back to copy string from */

	  /* for table and code decoding */
	  this.extra = 0;             /* extra bits needed */

	  /* fixed and dynamic code tables */
	  this.lencode = null;          /* starting table for length/literal codes */
	  this.distcode = null;         /* starting table for distance codes */
	  this.lenbits = 0;           /* index bits for lencode */
	  this.distbits = 0;          /* index bits for distcode */

	  /* dynamic table building */
	  this.ncode = 0;             /* number of code length code lengths */
	  this.nlen = 0;              /* number of length code lengths */
	  this.ndist = 0;             /* number of distance code lengths */
	  this.have = 0;              /* number of code lengths in lens[] */
	  this.next = null;              /* next available space in codes[] */

	  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
	  this.work = new utils.Buf16(288); /* work area for code table building */

	  /*
	   because we don't have pointers in js, we use lencode and distcode directly
	   as buffers so we don't need codes
	  */
	  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
	  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
	  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
	  this.sane = 0;                   /* if false, allow invalid distance too far */
	  this.back = 0;                   /* bits back of last unprocessed length/lit */
	  this.was = 0;                    /* initial length of match */
	}

	function inflateResetKeep(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  strm.total_in = strm.total_out = state.total = 0;
	  strm.msg = ''; /*Z_NULL*/
	  if (state.wrap) {       /* to support ill-conceived Java test suite */
	    strm.adler = state.wrap & 1;
	  }
	  state.mode = HEAD;
	  state.last = 0;
	  state.havedict = 0;
	  state.dmax = 32768;
	  state.head = null/*Z_NULL*/;
	  state.hold = 0;
	  state.bits = 0;
	  //state.lencode = state.distcode = state.next = state.codes;
	  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
	  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

	  state.sane = 1;
	  state.back = -1;
	  //Tracev((stderr, "inflate: reset\n"));
	  return Z_OK;
	}

	function inflateReset(strm) {
	  var state;

	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  state.wsize = 0;
	  state.whave = 0;
	  state.wnext = 0;
	  return inflateResetKeep(strm);

	}

	function inflateReset2(strm, windowBits) {
	  var wrap;
	  var state;

	  /* get the state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;

	  /* extract wrap request from windowBits parameter */
	  if (windowBits < 0) {
	    wrap = 0;
	    windowBits = -windowBits;
	  }
	  else {
	    wrap = (windowBits >> 4) + 1;
	    if (windowBits < 48) {
	      windowBits &= 15;
	    }
	  }

	  /* set number of window bits, free window if different */
	  if (windowBits && (windowBits < 8 || windowBits > 15)) {
	    return Z_STREAM_ERROR;
	  }
	  if (state.window !== null && state.wbits !== windowBits) {
	    state.window = null;
	  }

	  /* update state and reset the rest of it */
	  state.wrap = wrap;
	  state.wbits = windowBits;
	  return inflateReset(strm);
	}

	function inflateInit2(strm, windowBits) {
	  var ret;
	  var state;

	  if (!strm) { return Z_STREAM_ERROR; }
	  //strm.msg = Z_NULL;                 /* in case we return an error */

	  state = new InflateState();

	  //if (state === Z_NULL) return Z_MEM_ERROR;
	  //Tracev((stderr, "inflate: allocated\n"));
	  strm.state = state;
	  state.window = null/*Z_NULL*/;
	  ret = inflateReset2(strm, windowBits);
	  if (ret !== Z_OK) {
	    strm.state = null/*Z_NULL*/;
	  }
	  return ret;
	}

	function inflateInit(strm) {
	  return inflateInit2(strm, DEF_WBITS);
	}


	/*
	 Return state with length and distance decoding tables and index sizes set to
	 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
	 If BUILDFIXED is defined, then instead this routine builds the tables the
	 first time it's called, and returns those tables the first time and
	 thereafter.  This reduces the size of the code by about 2K bytes, in
	 exchange for a little execution time.  However, BUILDFIXED should not be
	 used for threaded applications, since the rewriting of the tables and virgin
	 may not be thread-safe.
	 */
	var virgin = true;

	var lenfix, distfix; // We have no pointers in JS, so keep tables separate

	function fixedtables(state) {
	  /* build fixed huffman tables if first call (may not be thread safe) */
	  if (virgin) {
	    var sym;

	    lenfix = new utils.Buf32(512);
	    distfix = new utils.Buf32(32);

	    /* literal/length table */
	    sym = 0;
	    while (sym < 144) { state.lens[sym++] = 8; }
	    while (sym < 256) { state.lens[sym++] = 9; }
	    while (sym < 280) { state.lens[sym++] = 7; }
	    while (sym < 288) { state.lens[sym++] = 8; }

	    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});

	    /* distance table */
	    sym = 0;
	    while (sym < 32) { state.lens[sym++] = 5; }

	    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});

	    /* do this just once */
	    virgin = false;
	  }

	  state.lencode = lenfix;
	  state.lenbits = 9;
	  state.distcode = distfix;
	  state.distbits = 5;
	}


	/*
	 Update the window with the last wsize (normally 32K) bytes written before
	 returning.  If window does not exist yet, create it.  This is only called
	 when a window is already in use, or when output has been written during this
	 inflate call, but the end of the deflate stream has not been reached yet.
	 It is also called to create a window for dictionary data when a dictionary
	 is loaded.

	 Providing output buffers larger than 32K to inflate() should provide a speed
	 advantage, since only the last 32K of output is copied to the sliding window
	 upon return from inflate(), and since all distances after the first 32K of
	 output will fall in the output data, making match copies simpler and faster.
	 The advantage may be dependent on the size of the processor's data caches.
	 */
	function updatewindow(strm, src, end, copy) {
	  var dist;
	  var state = strm.state;

	  /* if it hasn't been done already, allocate space for the window */
	  if (state.window === null) {
	    state.wsize = 1 << state.wbits;
	    state.wnext = 0;
	    state.whave = 0;

	    state.window = new utils.Buf8(state.wsize);
	  }

	  /* copy state->wsize or less output bytes into the circular window */
	  if (copy >= state.wsize) {
	    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);
	    state.wnext = 0;
	    state.whave = state.wsize;
	  }
	  else {
	    dist = state.wsize - state.wnext;
	    if (dist > copy) {
	      dist = copy;
	    }
	    //zmemcpy(state->window + state->wnext, end - copy, dist);
	    utils.arraySet(state.window,src, end - copy, dist, state.wnext);
	    copy -= dist;
	    if (copy) {
	      //zmemcpy(state->window, end - copy, copy);
	      utils.arraySet(state.window,src, end - copy, copy, 0);
	      state.wnext = copy;
	      state.whave = state.wsize;
	    }
	    else {
	      state.wnext += dist;
	      if (state.wnext === state.wsize) { state.wnext = 0; }
	      if (state.whave < state.wsize) { state.whave += dist; }
	    }
	  }
	  return 0;
	}

	function inflate(strm, flush) {
	  var state;
	  var input, output;          // input/output buffers
	  var next;                   /* next input INDEX */
	  var put;                    /* next output INDEX */
	  var have, left;             /* available input and output */
	  var hold;                   /* bit buffer */
	  var bits;                   /* bits in bit buffer */
	  var _in, _out;              /* save starting available input and output */
	  var copy;                   /* number of stored or match bytes to copy */
	  var from;                   /* where to copy match bytes from */
	  var from_source;
	  var here = 0;               /* current decoding table entry */
	  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
	  //var last;                   /* parent table entry */
	  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
	  var len;                    /* length to copy for repeats, bits to drop */
	  var ret;                    /* return code */
	  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
	  var opts;

	  var n; // temporary var for NEED_BITS

	  var order = /* permutation of code lengths */
	    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


	  if (!strm || !strm.state || !strm.output ||
	      (!strm.input && strm.avail_in !== 0)) {
	    return Z_STREAM_ERROR;
	  }

	  state = strm.state;
	  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


	  //--- LOAD() ---
	  put = strm.next_out;
	  output = strm.output;
	  left = strm.avail_out;
	  next = strm.next_in;
	  input = strm.input;
	  have = strm.avail_in;
	  hold = state.hold;
	  bits = state.bits;
	  //---

	  _in = have;
	  _out = left;
	  ret = Z_OK;

	  inf_leave: // goto emulation
	  for (;;) {
	    switch (state.mode) {
	    case HEAD:
	      if (state.wrap === 0) {
	        state.mode = TYPEDO;
	        break;
	      }
	      //=== NEEDBITS(16);
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
	        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//

	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        state.mode = FLAGS;
	        break;
	      }
	      state.flags = 0;           /* expect zlib header */
	      if (state.head) {
	        state.head.done = false;
	      }
	      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
	        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
	        strm.msg = 'incorrect header check';
	        state.mode = BAD;
	        break;
	      }
	      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	      len = (hold & 0x0f)/*BITS(4)*/ + 8;
	      if (state.wbits === 0) {
	        state.wbits = len;
	      }
	      else if (len > state.wbits) {
	        strm.msg = 'invalid window size';
	        state.mode = BAD;
	        break;
	      }
	      state.dmax = 1 << len;
	      //Tracev((stderr, "inflate:   zlib header ok\n"));
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = hold & 0x200 ? DICTID : TYPE;
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      break;
	    case FLAGS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.flags = hold;
	      if ((state.flags & 0xff) !== Z_DEFLATED) {
	        strm.msg = 'unknown compression method';
	        state.mode = BAD;
	        break;
	      }
	      if (state.flags & 0xe000) {
	        strm.msg = 'unknown header flags set';
	        state.mode = BAD;
	        break;
	      }
	      if (state.head) {
	        state.head.text = ((hold >> 8) & 1);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = TIME;
	      /* falls through */
	    case TIME:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.time = hold;
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC4(state.check, hold)
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        hbuf[2] = (hold >>> 16) & 0xff;
	        hbuf[3] = (hold >>> 24) & 0xff;
	        state.check = crc32(state.check, hbuf, 4, 0);
	        //===
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = OS;
	      /* falls through */
	    case OS:
	      //=== NEEDBITS(16); */
	      while (bits < 16) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if (state.head) {
	        state.head.xflags = (hold & 0xff);
	        state.head.os = (hold >> 8);
	      }
	      if (state.flags & 0x0200) {
	        //=== CRC2(state.check, hold);
	        hbuf[0] = hold & 0xff;
	        hbuf[1] = (hold >>> 8) & 0xff;
	        state.check = crc32(state.check, hbuf, 2, 0);
	        //===//
	      }
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = EXLEN;
	      /* falls through */
	    case EXLEN:
	      if (state.flags & 0x0400) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length = hold;
	        if (state.head) {
	          state.head.extra_len = hold;
	        }
	        if (state.flags & 0x0200) {
	          //=== CRC2(state.check, hold);
	          hbuf[0] = hold & 0xff;
	          hbuf[1] = (hold >>> 8) & 0xff;
	          state.check = crc32(state.check, hbuf, 2, 0);
	          //===//
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      else if (state.head) {
	        state.head.extra = null/*Z_NULL*/;
	      }
	      state.mode = EXTRA;
	      /* falls through */
	    case EXTRA:
	      if (state.flags & 0x0400) {
	        copy = state.length;
	        if (copy > have) { copy = have; }
	        if (copy) {
	          if (state.head) {
	            len = state.head.extra_len - state.length;
	            if (!state.head.extra) {
	              // Use untyped array for more conveniend processing later
	              state.head.extra = new Array(state.head.extra_len);
	            }
	            utils.arraySet(
	              state.head.extra,
	              input,
	              next,
	              // extra field is limited to 65536 bytes
	              // - no need for additional size check
	              copy,
	              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
	              len
	            );
	            //zmemcpy(state.head.extra + len, next,
	            //        len + copy > state.head.extra_max ?
	            //        state.head.extra_max - len : copy);
	          }
	          if (state.flags & 0x0200) {
	            state.check = crc32(state.check, input, copy, next);
	          }
	          have -= copy;
	          next += copy;
	          state.length -= copy;
	        }
	        if (state.length) { break inf_leave; }
	      }
	      state.length = 0;
	      state.mode = NAME;
	      /* falls through */
	    case NAME:
	      if (state.flags & 0x0800) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          // TODO: 2 or 1 bytes?
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.name_max*/)) {
	            state.head.name += String.fromCharCode(len);
	          }
	        } while (len && copy < have);

	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.name = null;
	      }
	      state.length = 0;
	      state.mode = COMMENT;
	      /* falls through */
	    case COMMENT:
	      if (state.flags & 0x1000) {
	        if (have === 0) { break inf_leave; }
	        copy = 0;
	        do {
	          len = input[next + copy++];
	          /* use constant limit because in js we should not preallocate memory */
	          if (state.head && len &&
	              (state.length < 65536 /*state.head.comm_max*/)) {
	            state.head.comment += String.fromCharCode(len);
	          }
	        } while (len && copy < have);
	        if (state.flags & 0x0200) {
	          state.check = crc32(state.check, input, copy, next);
	        }
	        have -= copy;
	        next += copy;
	        if (len) { break inf_leave; }
	      }
	      else if (state.head) {
	        state.head.comment = null;
	      }
	      state.mode = HCRC;
	      /* falls through */
	    case HCRC:
	      if (state.flags & 0x0200) {
	        //=== NEEDBITS(16); */
	        while (bits < 16) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.check & 0xffff)) {
	          strm.msg = 'header crc mismatch';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	      }
	      if (state.head) {
	        state.head.hcrc = ((state.flags >> 9) & 1);
	        state.head.done = true;
	      }
	      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      break;
	    case DICTID:
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      strm.adler = state.check = ZSWAP32(hold);
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = DICT;
	      /* falls through */
	    case DICT:
	      if (state.havedict === 0) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        return Z_NEED_DICT;
	      }
	      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
	      state.mode = TYPE;
	      /* falls through */
	    case TYPE:
	      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case TYPEDO:
	      if (state.last) {
	        //--- BYTEBITS() ---//
	        hold >>>= bits & 7;
	        bits -= bits & 7;
	        //---//
	        state.mode = CHECK;
	        break;
	      }
	      //=== NEEDBITS(3); */
	      while (bits < 3) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.last = (hold & 0x01)/*BITS(1)*/;
	      //--- DROPBITS(1) ---//
	      hold >>>= 1;
	      bits -= 1;
	      //---//

	      switch ((hold & 0x03)/*BITS(2)*/) {
	      case 0:                             /* stored block */
	        //Tracev((stderr, "inflate:     stored block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = STORED;
	        break;
	      case 1:                             /* fixed block */
	        fixedtables(state);
	        //Tracev((stderr, "inflate:     fixed codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = LEN_;             /* decode codes */
	        if (flush === Z_TREES) {
	          //--- DROPBITS(2) ---//
	          hold >>>= 2;
	          bits -= 2;
	          //---//
	          break inf_leave;
	        }
	        break;
	      case 2:                             /* dynamic block */
	        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
	        //        state.last ? " (last)" : ""));
	        state.mode = TABLE;
	        break;
	      case 3:
	        strm.msg = 'invalid block type';
	        state.mode = BAD;
	      }
	      //--- DROPBITS(2) ---//
	      hold >>>= 2;
	      bits -= 2;
	      //---//
	      break;
	    case STORED:
	      //--- BYTEBITS() ---// /* go to byte boundary */
	      hold >>>= bits & 7;
	      bits -= bits & 7;
	      //---//
	      //=== NEEDBITS(32); */
	      while (bits < 32) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
	        strm.msg = 'invalid stored block lengths';
	        state.mode = BAD;
	        break;
	      }
	      state.length = hold & 0xffff;
	      //Tracev((stderr, "inflate:       stored length %u\n",
	      //        state.length));
	      //=== INITBITS();
	      hold = 0;
	      bits = 0;
	      //===//
	      state.mode = COPY_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case COPY_:
	      state.mode = COPY;
	      /* falls through */
	    case COPY:
	      copy = state.length;
	      if (copy) {
	        if (copy > have) { copy = have; }
	        if (copy > left) { copy = left; }
	        if (copy === 0) { break inf_leave; }
	        //--- zmemcpy(put, next, copy); ---
	        utils.arraySet(output, input, next, copy, put);
	        //---//
	        have -= copy;
	        next += copy;
	        left -= copy;
	        put += copy;
	        state.length -= copy;
	        break;
	      }
	      //Tracev((stderr, "inflate:       stored end\n"));
	      state.mode = TYPE;
	      break;
	    case TABLE:
	      //=== NEEDBITS(14); */
	      while (bits < 14) {
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	      }
	      //===//
	      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
	      //--- DROPBITS(5) ---//
	      hold >>>= 5;
	      bits -= 5;
	      //---//
	      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
	      //--- DROPBITS(4) ---//
	      hold >>>= 4;
	      bits -= 4;
	      //---//
	//#ifndef PKZIP_BUG_WORKAROUND
	      if (state.nlen > 286 || state.ndist > 30) {
	        strm.msg = 'too many length or distance symbols';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracev((stderr, "inflate:       table sizes ok\n"));
	      state.have = 0;
	      state.mode = LENLENS;
	      /* falls through */
	    case LENLENS:
	      while (state.have < state.ncode) {
	        //=== NEEDBITS(3);
	        while (bits < 3) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
	        //--- DROPBITS(3) ---//
	        hold >>>= 3;
	        bits -= 3;
	        //---//
	      }
	      while (state.have < 19) {
	        state.lens[order[state.have++]] = 0;
	      }
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      //state.next = state.codes;
	      //state.lencode = state.next;
	      // Switch to use dynamic table
	      state.lencode = state.lendyn;
	      state.lenbits = 7;

	      opts = {bits: state.lenbits};
	      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
	      state.lenbits = opts.bits;

	      if (ret) {
	        strm.msg = 'invalid code lengths set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, "inflate:       code lengths ok\n"));
	      state.have = 0;
	      state.mode = CODELENS;
	      /* falls through */
	    case CODELENS:
	      while (state.have < state.nlen + state.ndist) {
	        for (;;) {
	          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        if (here_val < 16) {
	          //--- DROPBITS(here.bits) ---//
	          hold >>>= here_bits;
	          bits -= here_bits;
	          //---//
	          state.lens[state.have++] = here_val;
	        }
	        else {
	          if (here_val === 16) {
	            //=== NEEDBITS(here.bits + 2);
	            n = here_bits + 2;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            if (state.have === 0) {
	              strm.msg = 'invalid bit length repeat';
	              state.mode = BAD;
	              break;
	            }
	            len = state.lens[state.have - 1];
	            copy = 3 + (hold & 0x03);//BITS(2);
	            //--- DROPBITS(2) ---//
	            hold >>>= 2;
	            bits -= 2;
	            //---//
	          }
	          else if (here_val === 17) {
	            //=== NEEDBITS(here.bits + 3);
	            n = here_bits + 3;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 3 + (hold & 0x07);//BITS(3);
	            //--- DROPBITS(3) ---//
	            hold >>>= 3;
	            bits -= 3;
	            //---//
	          }
	          else {
	            //=== NEEDBITS(here.bits + 7);
	            n = here_bits + 7;
	            while (bits < n) {
	              if (have === 0) { break inf_leave; }
	              have--;
	              hold += input[next++] << bits;
	              bits += 8;
	            }
	            //===//
	            //--- DROPBITS(here.bits) ---//
	            hold >>>= here_bits;
	            bits -= here_bits;
	            //---//
	            len = 0;
	            copy = 11 + (hold & 0x7f);//BITS(7);
	            //--- DROPBITS(7) ---//
	            hold >>>= 7;
	            bits -= 7;
	            //---//
	          }
	          if (state.have + copy > state.nlen + state.ndist) {
	            strm.msg = 'invalid bit length repeat';
	            state.mode = BAD;
	            break;
	          }
	          while (copy--) {
	            state.lens[state.have++] = len;
	          }
	        }
	      }

	      /* handle error breaks in while */
	      if (state.mode === BAD) { break; }

	      /* check for end-of-block code (better have one) */
	      if (state.lens[256] === 0) {
	        strm.msg = 'invalid code -- missing end-of-block';
	        state.mode = BAD;
	        break;
	      }

	      /* build code tables -- note: do not change the lenbits or distbits
	         values here (9 and 6) without reading the comments in inftrees.h
	         concerning the ENOUGH constants, which depend on those values */
	      state.lenbits = 9;

	      opts = {bits: state.lenbits};
	      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.lenbits = opts.bits;
	      // state.lencode = state.next;

	      if (ret) {
	        strm.msg = 'invalid literal/lengths set';
	        state.mode = BAD;
	        break;
	      }

	      state.distbits = 6;
	      //state.distcode.copy(state.codes);
	      // Switch to use dynamic table
	      state.distcode = state.distdyn;
	      opts = {bits: state.distbits};
	      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
	      // We have separate tables & no pointers. 2 commented lines below not needed.
	      // state.next_index = opts.table_index;
	      state.distbits = opts.bits;
	      // state.distcode = state.next;

	      if (ret) {
	        strm.msg = 'invalid distances set';
	        state.mode = BAD;
	        break;
	      }
	      //Tracev((stderr, 'inflate:       codes ok\n'));
	      state.mode = LEN_;
	      if (flush === Z_TREES) { break inf_leave; }
	      /* falls through */
	    case LEN_:
	      state.mode = LEN;
	      /* falls through */
	    case LEN:
	      if (have >= 6 && left >= 258) {
	        //--- RESTORE() ---
	        strm.next_out = put;
	        strm.avail_out = left;
	        strm.next_in = next;
	        strm.avail_in = have;
	        state.hold = hold;
	        state.bits = bits;
	        //---
	        inflate_fast(strm, _out);
	        //--- LOAD() ---
	        put = strm.next_out;
	        output = strm.output;
	        left = strm.avail_out;
	        next = strm.next_in;
	        input = strm.input;
	        have = strm.avail_in;
	        hold = state.hold;
	        bits = state.bits;
	        //---

	        if (state.mode === TYPE) {
	          state.back = -1;
	        }
	        break;
	      }
	      state.back = 0;
	      for (;;) {
	        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if (here_bits <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if (here_op && (here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.lencode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      state.length = here_val;
	      if (here_op === 0) {
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        state.mode = LIT;
	        break;
	      }
	      if (here_op & 32) {
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.back = -1;
	        state.mode = TYPE;
	        break;
	      }
	      if (here_op & 64) {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break;
	      }
	      state.extra = here_op & 15;
	      state.mode = LENEXT;
	      /* falls through */
	    case LENEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	      //Tracevv((stderr, "inflate:         length %u\n", state.length));
	      state.was = state.length;
	      state.mode = DIST;
	      /* falls through */
	    case DIST:
	      for (;;) {
	        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/
	        here_bits = here >>> 24;
	        here_op = (here >>> 16) & 0xff;
	        here_val = here & 0xffff;

	        if ((here_bits) <= bits) { break; }
	        //--- PULLBYTE() ---//
	        if (have === 0) { break inf_leave; }
	        have--;
	        hold += input[next++] << bits;
	        bits += 8;
	        //---//
	      }
	      if ((here_op & 0xf0) === 0) {
	        last_bits = here_bits;
	        last_op = here_op;
	        last_val = here_val;
	        for (;;) {
	          here = state.distcode[last_val +
	                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
	          here_bits = here >>> 24;
	          here_op = (here >>> 16) & 0xff;
	          here_val = here & 0xffff;

	          if ((last_bits + here_bits) <= bits) { break; }
	          //--- PULLBYTE() ---//
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	          //---//
	        }
	        //--- DROPBITS(last.bits) ---//
	        hold >>>= last_bits;
	        bits -= last_bits;
	        //---//
	        state.back += last_bits;
	      }
	      //--- DROPBITS(here.bits) ---//
	      hold >>>= here_bits;
	      bits -= here_bits;
	      //---//
	      state.back += here_bits;
	      if (here_op & 64) {
	        strm.msg = 'invalid distance code';
	        state.mode = BAD;
	        break;
	      }
	      state.offset = here_val;
	      state.extra = (here_op) & 15;
	      state.mode = DISTEXT;
	      /* falls through */
	    case DISTEXT:
	      if (state.extra) {
	        //=== NEEDBITS(state.extra);
	        n = state.extra;
	        while (bits < n) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
	        //--- DROPBITS(state.extra) ---//
	        hold >>>= state.extra;
	        bits -= state.extra;
	        //---//
	        state.back += state.extra;
	      }
	//#ifdef INFLATE_STRICT
	      if (state.offset > state.dmax) {
	        strm.msg = 'invalid distance too far back';
	        state.mode = BAD;
	        break;
	      }
	//#endif
	      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
	      state.mode = MATCH;
	      /* falls through */
	    case MATCH:
	      if (left === 0) { break inf_leave; }
	      copy = _out - left;
	      if (state.offset > copy) {         /* copy from window */
	        copy = state.offset - copy;
	        if (copy > state.whave) {
	          if (state.sane) {
	            strm.msg = 'invalid distance too far back';
	            state.mode = BAD;
	            break;
	          }
	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//          Trace((stderr, "inflate.c too far\n"));
	//          copy -= state.whave;
	//          if (copy > state.length) { copy = state.length; }
	//          if (copy > left) { copy = left; }
	//          left -= copy;
	//          state.length -= copy;
	//          do {
	//            output[put++] = 0;
	//          } while (--copy);
	//          if (state.length === 0) { state.mode = LEN; }
	//          break;
	//#endif
	        }
	        if (copy > state.wnext) {
	          copy -= state.wnext;
	          from = state.wsize - copy;
	        }
	        else {
	          from = state.wnext - copy;
	        }
	        if (copy > state.length) { copy = state.length; }
	        from_source = state.window;
	      }
	      else {                              /* copy from output */
	        from_source = output;
	        from = put - state.offset;
	        copy = state.length;
	      }
	      if (copy > left) { copy = left; }
	      left -= copy;
	      state.length -= copy;
	      do {
	        output[put++] = from_source[from++];
	      } while (--copy);
	      if (state.length === 0) { state.mode = LEN; }
	      break;
	    case LIT:
	      if (left === 0) { break inf_leave; }
	      output[put++] = state.length;
	      left--;
	      state.mode = LEN;
	      break;
	    case CHECK:
	      if (state.wrap) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          // Use '|' insdead of '+' to make sure that result is signed
	          hold |= input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        _out -= left;
	        strm.total_out += _out;
	        state.total += _out;
	        if (_out) {
	          strm.adler = state.check =
	              /*UPDATE(state.check, put - _out, _out);*/
	              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

	        }
	        _out = left;
	        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
	        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
	          strm.msg = 'incorrect data check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   check matches trailer\n"));
	      }
	      state.mode = LENGTH;
	      /* falls through */
	    case LENGTH:
	      if (state.wrap && state.flags) {
	        //=== NEEDBITS(32);
	        while (bits < 32) {
	          if (have === 0) { break inf_leave; }
	          have--;
	          hold += input[next++] << bits;
	          bits += 8;
	        }
	        //===//
	        if (hold !== (state.total & 0xffffffff)) {
	          strm.msg = 'incorrect length check';
	          state.mode = BAD;
	          break;
	        }
	        //=== INITBITS();
	        hold = 0;
	        bits = 0;
	        //===//
	        //Tracev((stderr, "inflate:   length matches trailer\n"));
	      }
	      state.mode = DONE;
	      /* falls through */
	    case DONE:
	      ret = Z_STREAM_END;
	      break inf_leave;
	    case BAD:
	      ret = Z_DATA_ERROR;
	      break inf_leave;
	    case MEM:
	      return Z_MEM_ERROR;
	    case SYNC:
	      /* falls through */
	    default:
	      return Z_STREAM_ERROR;
	    }
	  }

	  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

	  /*
	     Return from inflate(), updating the total counts and the check value.
	     If there was no progress during the inflate() call, return a buffer
	     error.  Call updatewindow() to create and/or update the window state.
	     Note: a memory error from inflate() is non-recoverable.
	   */

	  //--- RESTORE() ---
	  strm.next_out = put;
	  strm.avail_out = left;
	  strm.next_in = next;
	  strm.avail_in = have;
	  state.hold = hold;
	  state.bits = bits;
	  //---

	  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
	                      (state.mode < CHECK || flush !== Z_FINISH))) {
	    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
	      state.mode = MEM;
	      return Z_MEM_ERROR;
	    }
	  }
	  _in -= strm.avail_in;
	  _out -= strm.avail_out;
	  strm.total_in += _in;
	  strm.total_out += _out;
	  state.total += _out;
	  if (state.wrap && _out) {
	    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
	      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
	  }
	  strm.data_type = state.bits + (state.last ? 64 : 0) +
	                    (state.mode === TYPE ? 128 : 0) +
	                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
	  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
	    ret = Z_BUF_ERROR;
	  }
	  return ret;
	}

	function inflateEnd(strm) {

	  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
	    return Z_STREAM_ERROR;
	  }

	  var state = strm.state;
	  if (state.window) {
	    state.window = null;
	  }
	  strm.state = null;
	  return Z_OK;
	}

	function inflateGetHeader(strm, head) {
	  var state;

	  /* check state */
	  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
	  state = strm.state;
	  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

	  /* save header structure */
	  state.head = head;
	  head.done = false;
	  return Z_OK;
	}


	exports.inflateReset = inflateReset;
	exports.inflateReset2 = inflateReset2;
	exports.inflateResetKeep = inflateResetKeep;
	exports.inflateInit = inflateInit;
	exports.inflateInit2 = inflateInit2;
	exports.inflate = inflate;
	exports.inflateEnd = inflateEnd;
	exports.inflateGetHeader = inflateGetHeader;
	exports.inflateInfo = 'pako inflate (from Nodeca project)';

	/* Not implemented
	exports.inflateCopy = inflateCopy;
	exports.inflateGetDictionary = inflateGetDictionary;
	exports.inflateMark = inflateMark;
	exports.inflatePrime = inflatePrime;
	exports.inflateSetDictionary = inflateSetDictionary;
	exports.inflateSync = inflateSync;
	exports.inflateSyncPoint = inflateSyncPoint;
	exports.inflateUndermine = inflateUndermine;
	*/


/***/ },
/* 89 */
/***/ function(module, exports) {

	'use strict';

	// See state defs from inflate.js
	var BAD = 30;       /* got a data error -- remain here until reset */
	var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

	/*
	   Decode literal, length, and distance codes and write out the resulting
	   literal and match bytes until either not enough input or output is
	   available, an end-of-block is encountered, or a data error is encountered.
	   When large enough input and output buffers are supplied to inflate(), for
	   example, a 16K input buffer and a 64K output buffer, more than 95% of the
	   inflate execution time is spent in this routine.

	   Entry assumptions:

	        state.mode === LEN
	        strm.avail_in >= 6
	        strm.avail_out >= 258
	        start >= strm.avail_out
	        state.bits < 8

	   On return, state.mode is one of:

	        LEN -- ran out of enough output space or enough available input
	        TYPE -- reached end of block code, inflate() to interpret next block
	        BAD -- error in block data

	   Notes:

	    - The maximum input bits used by a length/distance pair is 15 bits for the
	      length code, 5 bits for the length extra, 15 bits for the distance code,
	      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
	      Therefore if strm.avail_in >= 6, then there is enough input to avoid
	      checking for available input while decoding.

	    - The maximum bytes that a single length/distance pair can output is 258
	      bytes, which is the maximum length that can be coded.  inflate_fast()
	      requires strm.avail_out >= 258 for each loop to avoid checking for
	      output space.
	 */
	module.exports = function inflate_fast(strm, start) {
	  var state;
	  var _in;                    /* local strm.input */
	  var last;                   /* have enough input while in < last */
	  var _out;                   /* local strm.output */
	  var beg;                    /* inflate()'s initial strm.output */
	  var end;                    /* while out < end, enough space available */
	//#ifdef INFLATE_STRICT
	  var dmax;                   /* maximum distance from zlib header */
	//#endif
	  var wsize;                  /* window size or zero if not using window */
	  var whave;                  /* valid bytes in the window */
	  var wnext;                  /* window write index */
	  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
	  var s_window;               /* allocated sliding window, if wsize != 0 */
	  var hold;                   /* local strm.hold */
	  var bits;                   /* local strm.bits */
	  var lcode;                  /* local strm.lencode */
	  var dcode;                  /* local strm.distcode */
	  var lmask;                  /* mask for first level of length codes */
	  var dmask;                  /* mask for first level of distance codes */
	  var here;                   /* retrieved table entry */
	  var op;                     /* code bits, operation, extra bits, or */
	                              /*  window position, window bytes to copy */
	  var len;                    /* match length, unused bytes */
	  var dist;                   /* match distance */
	  var from;                   /* where to copy match from */
	  var from_source;


	  var input, output; // JS specific, because we have no pointers

	  /* copy state to local variables */
	  state = strm.state;
	  //here = state.here;
	  _in = strm.next_in;
	  input = strm.input;
	  last = _in + (strm.avail_in - 5);
	  _out = strm.next_out;
	  output = strm.output;
	  beg = _out - (start - strm.avail_out);
	  end = _out + (strm.avail_out - 257);
	//#ifdef INFLATE_STRICT
	  dmax = state.dmax;
	//#endif
	  wsize = state.wsize;
	  whave = state.whave;
	  wnext = state.wnext;
	  s_window = state.window;
	  hold = state.hold;
	  bits = state.bits;
	  lcode = state.lencode;
	  dcode = state.distcode;
	  lmask = (1 << state.lenbits) - 1;
	  dmask = (1 << state.distbits) - 1;


	  /* decode literals and length/distances until end-of-block or not enough
	     input data or output space */

	  top:
	  do {
	    if (bits < 15) {
	      hold += input[_in++] << bits;
	      bits += 8;
	      hold += input[_in++] << bits;
	      bits += 8;
	    }

	    here = lcode[hold & lmask];

	    dolen:
	    for (;;) { // Goto emulation
	      op = here >>> 24/*here.bits*/;
	      hold >>>= op;
	      bits -= op;
	      op = (here >>> 16) & 0xff/*here.op*/;
	      if (op === 0) {                          /* literal */
	        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
	        //        "inflate:         literal '%c'\n" :
	        //        "inflate:         literal 0x%02x\n", here.val));
	        output[_out++] = here & 0xffff/*here.val*/;
	      }
	      else if (op & 16) {                     /* length base */
	        len = here & 0xffff/*here.val*/;
	        op &= 15;                           /* number of extra bits */
	        if (op) {
	          if (bits < op) {
	            hold += input[_in++] << bits;
	            bits += 8;
	          }
	          len += hold & ((1 << op) - 1);
	          hold >>>= op;
	          bits -= op;
	        }
	        //Tracevv((stderr, "inflate:         length %u\n", len));
	        if (bits < 15) {
	          hold += input[_in++] << bits;
	          bits += 8;
	          hold += input[_in++] << bits;
	          bits += 8;
	        }
	        here = dcode[hold & dmask];

	        dodist:
	        for (;;) { // goto emulation
	          op = here >>> 24/*here.bits*/;
	          hold >>>= op;
	          bits -= op;
	          op = (here >>> 16) & 0xff/*here.op*/;

	          if (op & 16) {                      /* distance base */
	            dist = here & 0xffff/*here.val*/;
	            op &= 15;                       /* number of extra bits */
	            if (bits < op) {
	              hold += input[_in++] << bits;
	              bits += 8;
	              if (bits < op) {
	                hold += input[_in++] << bits;
	                bits += 8;
	              }
	            }
	            dist += hold & ((1 << op) - 1);
	//#ifdef INFLATE_STRICT
	            if (dist > dmax) {
	              strm.msg = 'invalid distance too far back';
	              state.mode = BAD;
	              break top;
	            }
	//#endif
	            hold >>>= op;
	            bits -= op;
	            //Tracevv((stderr, "inflate:         distance %u\n", dist));
	            op = _out - beg;                /* max distance in output */
	            if (dist > op) {                /* see if copy from window */
	              op = dist - op;               /* distance back in window */
	              if (op > whave) {
	                if (state.sane) {
	                  strm.msg = 'invalid distance too far back';
	                  state.mode = BAD;
	                  break top;
	                }

	// (!) This block is disabled in zlib defailts,
	// don't enable it for binary compatibility
	//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
	//                if (len <= op - whave) {
	//                  do {
	//                    output[_out++] = 0;
	//                  } while (--len);
	//                  continue top;
	//                }
	//                len -= op - whave;
	//                do {
	//                  output[_out++] = 0;
	//                } while (--op > whave);
	//                if (op === 0) {
	//                  from = _out - dist;
	//                  do {
	//                    output[_out++] = output[from++];
	//                  } while (--len);
	//                  continue top;
	//                }
	//#endif
	              }
	              from = 0; // window index
	              from_source = s_window;
	              if (wnext === 0) {           /* very common case */
	                from += wsize - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              else if (wnext < op) {      /* wrap around window */
	                from += wsize + wnext - op;
	                op -= wnext;
	                if (op < len) {         /* some from end of window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = 0;
	                  if (wnext < len) {  /* some from start of window */
	                    op = wnext;
	                    len -= op;
	                    do {
	                      output[_out++] = s_window[from++];
	                    } while (--op);
	                    from = _out - dist;      /* rest from output */
	                    from_source = output;
	                  }
	                }
	              }
	              else {                      /* contiguous in window */
	                from += wnext - op;
	                if (op < len) {         /* some from window */
	                  len -= op;
	                  do {
	                    output[_out++] = s_window[from++];
	                  } while (--op);
	                  from = _out - dist;  /* rest from output */
	                  from_source = output;
	                }
	              }
	              while (len > 2) {
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                output[_out++] = from_source[from++];
	                len -= 3;
	              }
	              if (len) {
	                output[_out++] = from_source[from++];
	                if (len > 1) {
	                  output[_out++] = from_source[from++];
	                }
	              }
	            }
	            else {
	              from = _out - dist;          /* copy direct from output */
	              do {                        /* minimum length is three */
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                output[_out++] = output[from++];
	                len -= 3;
	              } while (len > 2);
	              if (len) {
	                output[_out++] = output[from++];
	                if (len > 1) {
	                  output[_out++] = output[from++];
	                }
	              }
	            }
	          }
	          else if ((op & 64) === 0) {          /* 2nd level distance code */
	            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	            continue dodist;
	          }
	          else {
	            strm.msg = 'invalid distance code';
	            state.mode = BAD;
	            break top;
	          }

	          break; // need to emulate goto via "continue"
	        }
	      }
	      else if ((op & 64) === 0) {              /* 2nd level length code */
	        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
	        continue dolen;
	      }
	      else if (op & 32) {                     /* end-of-block */
	        //Tracevv((stderr, "inflate:         end of block\n"));
	        state.mode = TYPE;
	        break top;
	      }
	      else {
	        strm.msg = 'invalid literal/length code';
	        state.mode = BAD;
	        break top;
	      }

	      break; // need to emulate goto via "continue"
	    }
	  } while (_in < last && _out < end);

	  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
	  len = bits >> 3;
	  _in -= len;
	  bits -= len << 3;
	  hold &= (1 << bits) - 1;

	  /* update state and return */
	  strm.next_in = _in;
	  strm.next_out = _out;
	  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
	  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
	  state.hold = hold;
	  state.bits = bits;
	  return;
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var utils = __webpack_require__(84);

	var MAXBITS = 15;
	var ENOUGH_LENS = 852;
	var ENOUGH_DISTS = 592;
	//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

	var CODES = 0;
	var LENS = 1;
	var DISTS = 2;

	var lbase = [ /* Length codes 257..285 base */
	  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	];

	var lext = [ /* Length codes 257..285 extra */
	  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
	  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
	];

	var dbase = [ /* Distance codes 0..29 base */
	  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	  8193, 12289, 16385, 24577, 0, 0
	];

	var dext = [ /* Distance codes 0..29 extra */
	  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
	  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
	  28, 28, 29, 29, 64, 64
	];

	module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
	{
	  var bits = opts.bits;
	      //here = opts.here; /* table entry for duplication */

	  var len = 0;               /* a code's length in bits */
	  var sym = 0;               /* index of code symbols */
	  var min = 0, max = 0;          /* minimum and maximum code lengths */
	  var root = 0;              /* number of index bits for root table */
	  var curr = 0;              /* number of index bits for current table */
	  var drop = 0;              /* code bits to drop for sub-table */
	  var left = 0;                   /* number of prefix codes available */
	  var used = 0;              /* code entries in table used */
	  var huff = 0;              /* Huffman code */
	  var incr;              /* for incrementing code, index */
	  var fill;              /* index for replicating entries */
	  var low;               /* low bits for current root entry */
	  var mask;              /* mask for low root bits */
	  var next;             /* next available space in table */
	  var base = null;     /* base value table to use */
	  var base_index = 0;
	//  var shoextra;    /* extra bits table to use */
	  var end;                    /* use base and extra for symbol > end */
	  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */
	  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */
	  var extra = null;
	  var extra_index = 0;

	  var here_bits, here_op, here_val;

	  /*
	   Process a set of code lengths to create a canonical Huffman code.  The
	   code lengths are lens[0..codes-1].  Each length corresponds to the
	   symbols 0..codes-1.  The Huffman code is generated by first sorting the
	   symbols by length from short to long, and retaining the symbol order
	   for codes with equal lengths.  Then the code starts with all zero bits
	   for the first code of the shortest length, and the codes are integer
	   increments for the same length, and zeros are appended as the length
	   increases.  For the deflate format, these bits are stored backwards
	   from their more natural integer increment ordering, and so when the
	   decoding tables are built in the large loop below, the integer codes
	   are incremented backwards.

	   This routine assumes, but does not check, that all of the entries in
	   lens[] are in the range 0..MAXBITS.  The caller must assure this.
	   1..MAXBITS is interpreted as that code length.  zero means that that
	   symbol does not occur in this code.

	   The codes are sorted by computing a count of codes for each length,
	   creating from that a table of starting indices for each length in the
	   sorted table, and then entering the symbols in order in the sorted
	   table.  The sorted table is work[], with that space being provided by
	   the caller.

	   The length counts are used for other purposes as well, i.e. finding
	   the minimum and maximum length codes, determining if there are any
	   codes at all, checking for a valid set of lengths, and looking ahead
	   at length counts to determine sub-table sizes when building the
	   decoding tables.
	   */

	  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
	  for (len = 0; len <= MAXBITS; len++) {
	    count[len] = 0;
	  }
	  for (sym = 0; sym < codes; sym++) {
	    count[lens[lens_index + sym]]++;
	  }

	  /* bound code lengths, force root to be within code lengths */
	  root = bits;
	  for (max = MAXBITS; max >= 1; max--) {
	    if (count[max] !== 0) { break; }
	  }
	  if (root > max) {
	    root = max;
	  }
	  if (max === 0) {                     /* no symbols to code at all */
	    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
	    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
	    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;


	    //table.op[opts.table_index] = 64;
	    //table.bits[opts.table_index] = 1;
	    //table.val[opts.table_index++] = 0;
	    table[table_index++] = (1 << 24) | (64 << 16) | 0;

	    opts.bits = 1;
	    return 0;     /* no symbols, but wait for decoding to report error */
	  }
	  for (min = 1; min < max; min++) {
	    if (count[min] !== 0) { break; }
	  }
	  if (root < min) {
	    root = min;
	  }

	  /* check for an over-subscribed or incomplete set of lengths */
	  left = 1;
	  for (len = 1; len <= MAXBITS; len++) {
	    left <<= 1;
	    left -= count[len];
	    if (left < 0) {
	      return -1;
	    }        /* over-subscribed */
	  }
	  if (left > 0 && (type === CODES || max !== 1)) {
	    return -1;                      /* incomplete set */
	  }

	  /* generate offsets into symbol table for each length for sorting */
	  offs[1] = 0;
	  for (len = 1; len < MAXBITS; len++) {
	    offs[len + 1] = offs[len] + count[len];
	  }

	  /* sort symbols by length, by symbol order within each length */
	  for (sym = 0; sym < codes; sym++) {
	    if (lens[lens_index + sym] !== 0) {
	      work[offs[lens[lens_index + sym]]++] = sym;
	    }
	  }

	  /*
	   Create and fill in decoding tables.  In this loop, the table being
	   filled is at next and has curr index bits.  The code being used is huff
	   with length len.  That code is converted to an index by dropping drop
	   bits off of the bottom.  For codes where len is less than drop + curr,
	   those top drop + curr - len bits are incremented through all values to
	   fill the table with replicated entries.

	   root is the number of index bits for the root table.  When len exceeds
	   root, sub-tables are created pointed to by the root entry with an index
	   of the low root bits of huff.  This is saved in low to check for when a
	   new sub-table should be started.  drop is zero when the root table is
	   being filled, and drop is root when sub-tables are being filled.

	   When a new sub-table is needed, it is necessary to look ahead in the
	   code lengths to determine what size sub-table is needed.  The length
	   counts are used for this, and so count[] is decremented as codes are
	   entered in the tables.

	   used keeps track of how many table entries have been allocated from the
	   provided *table space.  It is checked for LENS and DIST tables against
	   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
	   the initial root table size constants.  See the comments in inftrees.h
	   for more information.

	   sym increments through all symbols, and the loop terminates when
	   all codes of length max, i.e. all codes, have been processed.  This
	   routine permits incomplete codes, so another loop after this one fills
	   in the rest of the decoding tables with invalid code markers.
	   */

	  /* set up for code type */
	  // poor man optimization - use if-else instead of switch,
	  // to avoid deopts in old v8
	  if (type === CODES) {
	    base = extra = work;    /* dummy value--not used */
	    end = 19;

	  } else if (type === LENS) {
	    base = lbase;
	    base_index -= 257;
	    extra = lext;
	    extra_index -= 257;
	    end = 256;

	  } else {                    /* DISTS */
	    base = dbase;
	    extra = dext;
	    end = -1;
	  }

	  /* initialize opts for loop */
	  huff = 0;                   /* starting code */
	  sym = 0;                    /* starting code symbol */
	  len = min;                  /* starting code length */
	  next = table_index;              /* current table to fill in */
	  curr = root;                /* current table index bits */
	  drop = 0;                   /* current bits to drop from code for index */
	  low = -1;                   /* trigger new sub-table when len > root */
	  used = 1 << root;          /* use root table entries */
	  mask = used - 1;            /* mask for comparing low */

	  /* check available table space */
	  if ((type === LENS && used > ENOUGH_LENS) ||
	    (type === DISTS && used > ENOUGH_DISTS)) {
	    return 1;
	  }

	  var i=0;
	  /* process all codes and make table entries */
	  for (;;) {
	    i++;
	    /* create table entry */
	    here_bits = len - drop;
	    if (work[sym] < end) {
	      here_op = 0;
	      here_val = work[sym];
	    }
	    else if (work[sym] > end) {
	      here_op = extra[extra_index + work[sym]];
	      here_val = base[base_index + work[sym]];
	    }
	    else {
	      here_op = 32 + 64;         /* end of block */
	      here_val = 0;
	    }

	    /* replicate for those indices with low len bits equal to huff */
	    incr = 1 << (len - drop);
	    fill = 1 << curr;
	    min = fill;                 /* save offset to next table */
	    do {
	      fill -= incr;
	      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
	    } while (fill !== 0);

	    /* backwards increment the len-bit code huff */
	    incr = 1 << (len - 1);
	    while (huff & incr) {
	      incr >>= 1;
	    }
	    if (incr !== 0) {
	      huff &= incr - 1;
	      huff += incr;
	    } else {
	      huff = 0;
	    }

	    /* go to next symbol, update count, len */
	    sym++;
	    if (--count[len] === 0) {
	      if (len === max) { break; }
	      len = lens[lens_index + work[sym]];
	    }

	    /* create new sub-table if needed */
	    if (len > root && (huff & mask) !== low) {
	      /* if first time, transition to sub-tables */
	      if (drop === 0) {
	        drop = root;
	      }

	      /* increment past last table */
	      next += min;            /* here min is 1 << curr */

	      /* determine length of next table */
	      curr = len - drop;
	      left = 1 << curr;
	      while (curr + drop < max) {
	        left -= count[curr + drop];
	        if (left <= 0) { break; }
	        curr++;
	        left <<= 1;
	      }

	      /* check for enough space */
	      used += 1 << curr;
	      if ((type === LENS && used > ENOUGH_LENS) ||
	        (type === DISTS && used > ENOUGH_DISTS)) {
	        return 1;
	      }

	      /* point entry in root table to sub-table */
	      low = huff & mask;
	      /*table.op[low] = curr;
	      table.bits[low] = root;
	      table.val[low] = next - opts.table_index;*/
	      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
	    }
	  }

	  /* fill in remaining table entry if code is incomplete (guaranteed to have
	   at most one remaining entry, since if the code is incomplete, the
	   maximum code length that was allowed to get this far is one bit) */
	  if (huff !== 0) {
	    //table.op[next + huff] = 64;            /* invalid code marker */
	    //table.bits[next + huff] = len - drop;
	    //table.val[next + huff] = 0;
	    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
	  }

	  /* set return parameters */
	  //opts.table_index += used;
	  opts.bits = root;
	  return 0;
	};


/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = {

	  /* Allowed flush values; see deflate() and inflate() below for details */
	  Z_NO_FLUSH:         0,
	  Z_PARTIAL_FLUSH:    1,
	  Z_SYNC_FLUSH:       2,
	  Z_FULL_FLUSH:       3,
	  Z_FINISH:           4,
	  Z_BLOCK:            5,
	  Z_TREES:            6,

	  /* Return codes for the compression/decompression functions. Negative values
	  * are errors, positive values are used for special but normal events.
	  */
	  Z_OK:               0,
	  Z_STREAM_END:       1,
	  Z_NEED_DICT:        2,
	  Z_ERRNO:           -1,
	  Z_STREAM_ERROR:    -2,
	  Z_DATA_ERROR:      -3,
	  //Z_MEM_ERROR:     -4,
	  Z_BUF_ERROR:       -5,
	  //Z_VERSION_ERROR: -6,

	  /* compression levels */
	  Z_NO_COMPRESSION:         0,
	  Z_BEST_SPEED:             1,
	  Z_BEST_COMPRESSION:       9,
	  Z_DEFAULT_COMPRESSION:   -1,


	  Z_FILTERED:               1,
	  Z_HUFFMAN_ONLY:           2,
	  Z_RLE:                    3,
	  Z_FIXED:                  4,
	  Z_DEFAULT_STRATEGY:       0,

	  /* Possible values of the data_type field (though see inflate()) */
	  Z_BINARY:                 0,
	  Z_TEXT:                   1,
	  //Z_ASCII:                1, // = Z_TEXT (deprecated)
	  Z_UNKNOWN:                2,

	  /* The deflate compression method */
	  Z_DEFLATED:               8
	  //Z_NULL:                 null // Use -1 or null inline, depending on var type
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(27);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var DuplexStream = __webpack_require__(67)
	  , util         = __webpack_require__(27)

	function BufferList (callback) {
	  if (!(this instanceof BufferList))
	    return new BufferList(callback)

	  this._bufs  = []
	  this.length = 0

	  if (typeof callback == 'function') {
	    this._callback = callback

	    var piper = function (err) {
	      if (this._callback) {
	        this._callback(err)
	        this._callback = null
	      }
	    }.bind(this)

	    this.on('pipe', function (src) {
	      src.on('error', piper)
	    })
	    this.on('unpipe', function (src) {
	      src.removeListener('error', piper)
	    })
	  }
	  else if (Buffer.isBuffer(callback))
	    this.append(callback)
	  else if (Array.isArray(callback)) {
	    callback.forEach(function (b) {
	      Buffer.isBuffer(b) && this.append(b)
	    }.bind(this))
	  }

	  DuplexStream.call(this)
	}

	util.inherits(BufferList, DuplexStream)

	BufferList.prototype._offset = function (offset) {
	  var tot = 0, i = 0, _t
	  for (; i < this._bufs.length; i++) {
	    _t = tot + this._bufs[i].length
	    if (offset < _t)
	      return [ i, offset - tot ]
	    tot = _t
	  }
	}

	BufferList.prototype.append = function (buf) {
	  var isBuffer = Buffer.isBuffer(buf) ||
	                 buf instanceof BufferList

	  // coerce number arguments to strings, since Buffer(number) does
	  // uninitialized memory allocation
	  if (typeof buf == 'number')
	    buf = buf.toString()

	  this._bufs.push(isBuffer ? buf : new Buffer(buf))
	  this.length += buf.length
	  return this
	}

	BufferList.prototype._write = function (buf, encoding, callback) {
	  this.append(buf)
	  if (callback)
	    callback()
	}

	BufferList.prototype._read = function (size) {
	  if (!this.length)
	    return this.push(null)
	  size = Math.min(size, this.length)
	  this.push(this.slice(0, size))
	  this.consume(size)
	}

	BufferList.prototype.end = function (chunk) {
	  DuplexStream.prototype.end.call(this, chunk)

	  if (this._callback) {
	    this._callback(null, this.slice())
	    this._callback = null
	  }
	}

	BufferList.prototype.get = function (index) {
	  return this.slice(index, index + 1)[0]
	}

	BufferList.prototype.slice = function (start, end) {
	  return this.copy(null, 0, start, end)
	}

	BufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart != 'number' || srcStart < 0)
	    srcStart = 0
	  if (typeof srcEnd != 'number' || srcEnd > this.length)
	    srcEnd = this.length
	  if (srcStart >= this.length)
	    return dst || new Buffer(0)
	  if (srcEnd <= 0)
	    return dst || new Buffer(0)

	  var copy   = !!dst
	    , off    = this._offset(srcStart)
	    , len    = srcEnd - srcStart
	    , bytes  = len
	    , bufoff = (copy && dstStart) || 0
	    , start  = off[1]
	    , l
	    , i

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd == this.length) {
	    if (!copy) // slice, just return a full concat
	      return Buffer.concat(this._bufs)

	    // copy, need to copy individual buffers
	    for (i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff)
	      bufoff += this._bufs[i].length
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) // a slice, we need something to copy in to
	    dst = new Buffer(len)

	  for (i = off[0]; i < this._bufs.length; i++) {
	    l = this._bufs[i].length - start

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start)
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes)
	      break
	    }

	    bufoff += l
	    bytes -= l

	    if (start)
	      start = 0
	  }

	  return dst
	}

	BufferList.prototype.toString = function (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	}

	BufferList.prototype.consume = function (bytes) {
	  while (this._bufs.length) {
	    if (bytes > this._bufs[0].length) {
	      bytes -= this._bufs[0].length
	      this.length -= this._bufs[0].length
	      this._bufs.shift()
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes)
	      this.length -= bytes
	      break
	    }
	  }
	  return this
	}

	BufferList.prototype.duplicate = function () {
	  var i = 0
	    , copy = new BufferList()

	  for (; i < this._bufs.length; i++)
	    copy.append(this._bufs[i])

	  return copy
	}

	BufferList.prototype.destroy = function () {
	  this._bufs.length = 0;
	  this.length = 0;
	  this.push(null);
	}

	;(function () {
	  var methods = {
	      'readDoubleBE' : 8
	    , 'readDoubleLE' : 8
	    , 'readFloatBE'  : 4
	    , 'readFloatLE'  : 4
	    , 'readInt32BE'  : 4
	    , 'readInt32LE'  : 4
	    , 'readUInt32BE' : 4
	    , 'readUInt32LE' : 4
	    , 'readInt16BE'  : 2
	    , 'readInt16LE'  : 2
	    , 'readUInt16BE' : 2
	    , 'readUInt16LE' : 2
	    , 'readInt8'     : 1
	    , 'readUInt8'    : 1
	  }

	  for (var m in methods) {
	    (function (m) {
	      BufferList.prototype[m] = function (offset) {
	        return this.slice(offset, offset + methods[m])[m](0)
	      }
	    }(m))
	  }
	}())

	module.exports = BufferList

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 94 */
/***/ function(module, exports) {

	/*
	    HTTP Hawk Authentication Scheme
	    Copyright (c) 2012-2014, Eran Hammer <eran@hammer.io>
	    BSD Licensed
	*/


	// Declare namespace

	var hawk = {
	    internals: {}
	};


	hawk.client = {

	    // Generate an Authorization header for a given request

	    /*
	        uri: 'http://example.com/resource?a=b' or object generated by hawk.utils.parseUri()
	        method: HTTP verb (e.g. 'GET', 'POST')
	        options: {

	            // Required

	            credentials: {
	                id: 'dh37fgj492je',
	                key: 'aoijedoaijsdlaksjdl',
	                algorithm: 'sha256'                                 // 'sha1', 'sha256'
	            },

	            // Optional

	            ext: 'application-specific',                        // Application specific data sent via the ext attribute
	            timestamp: Date.now() / 1000,                       // A pre-calculated timestamp in seconds
	            nonce: '2334f34f',                                  // A pre-generated nonce
	            localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
	            payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
	            contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
	            hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
	            app: '24s23423f34dx',                               // Oz application id
	            dlg: '234sz34tww3sd'                                // Oz delegated-by application id
	        }
	    */

	    header: function (uri, method, options) {

	        var result = {
	            field: '',
	            artifacts: {}
	        };

	        // Validate inputs

	        if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
	            !method || typeof method !== 'string' ||
	            !options || typeof options !== 'object') {

	            result.err = 'Invalid argument type';
	            return result;
	        }

	        // Application time

	        var timestamp = options.timestamp || hawk.utils.now(options.localtimeOffsetMsec);

	        // Validate credentials

	        var credentials = options.credentials;
	        if (!credentials ||
	            !credentials.id ||
	            !credentials.key ||
	            !credentials.algorithm) {

	            result.err = 'Invalid credentials object';
	            return result;
	        }

	        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	            result.err = 'Unknown algorithm';
	            return result;
	        }

	        // Parse URI

	        if (typeof uri === 'string') {
	            uri = hawk.utils.parseUri(uri);
	        }

	        // Calculate signature

	        var artifacts = {
	            ts: timestamp,
	            nonce: options.nonce || hawk.utils.randomString(6),
	            method: method,
	            resource: uri.relative,
	            host: uri.hostname,
	            port: uri.port,
	            hash: options.hash,
	            ext: options.ext,
	            app: options.app,
	            dlg: options.dlg
	        };

	        result.artifacts = artifacts;

	        // Calculate payload hash

	        if (!artifacts.hash &&
	            (options.payload || options.payload === '')) {

	            artifacts.hash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
	        }

	        var mac = hawk.crypto.calculateMac('header', credentials, artifacts);

	        // Construct header

	        var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
	        var header = 'Hawk id="' + credentials.id +
	                     '", ts="' + artifacts.ts +
	                     '", nonce="' + artifacts.nonce +
	                     (artifacts.hash ? '", hash="' + artifacts.hash : '') +
	                     (hasExt ? '", ext="' + hawk.utils.escapeHeaderAttribute(artifacts.ext) : '') +
	                     '", mac="' + mac + '"';

	        if (artifacts.app) {
	            header += ', app="' + artifacts.app +
	                      (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
	        }

	        result.field = header;

	        return result;
	    },

	    // Generate a bewit value for a given URI

	    /*
	        uri: 'http://example.com/resource?a=b'
	        options: {

	            // Required

	            credentials: {
	            id: 'dh37fgj492je',
	            key: 'aoijedoaijsdlaksjdl',
	            algorithm: 'sha256'                             // 'sha1', 'sha256'
	            },
	            ttlSec: 60 * 60,                                    // TTL in seconds

	            // Optional

	            ext: 'application-specific',                        // Application specific data sent via the ext attribute
	            localtimeOffsetMsec: 400                            // Time offset to sync with server time
	         };
	    */

	    bewit: function (uri, options) {

	        // Validate inputs

	        if (!uri ||
	            (typeof uri !== 'string') ||
	            !options ||
	            typeof options !== 'object' ||
	            !options.ttlSec) {

	            return '';
	        }

	        options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

	        // Application time

	        var now = hawk.utils.now(options.localtimeOffsetMsec);

	        // Validate credentials

	        var credentials = options.credentials;
	        if (!credentials ||
	            !credentials.id ||
	            !credentials.key ||
	            !credentials.algorithm) {

	            return '';
	        }

	        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	            return '';
	        }

	        // Parse URI

	        uri = hawk.utils.parseUri(uri);

	        // Calculate signature

	        var exp = now + options.ttlSec;
	        var mac = hawk.crypto.calculateMac('bewit', credentials, {
	            ts: exp,
	            nonce: '',
	            method: 'GET',
	            resource: uri.relative,                            // Maintain trailing '?' and query params
	            host: uri.hostname,
	            port: uri.port,
	            ext: options.ext
	        });

	        // Construct bewit: id\exp\mac\ext

	        var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
	        return hawk.utils.base64urlEncode(bewit);
	    },

	    // Validate server response

	    /*
	        request:    object created via 'new XMLHttpRequest()' after response received
	        artifacts:  object received from header().artifacts
	        options: {
	            payload:    optional payload received
	            required:   specifies if a Server-Authorization header is required. Defaults to 'false'
	        }
	    */

	    authenticate: function (request, credentials, artifacts, options) {

	        options = options || {};

	        var getHeader = function (name) {

	            return request.getResponseHeader ? request.getResponseHeader(name) : request.getHeader(name);
	        };

	        var wwwAuthenticate = getHeader('www-authenticate');
	        if (wwwAuthenticate) {

	            // Parse HTTP WWW-Authenticate header

	            var attributes = hawk.utils.parseAuthorizationHeader(wwwAuthenticate, ['ts', 'tsm', 'error']);
	            if (!attributes) {
	                return false;
	            }

	            if (attributes.ts) {
	                var tsm = hawk.crypto.calculateTsMac(attributes.ts, credentials);
	                if (tsm !== attributes.tsm) {
	                    return false;
	                }

	                hawk.utils.setNtpOffset(attributes.ts - Math.floor((new Date()).getTime() / 1000));     // Keep offset at 1 second precision
	            }
	        }

	        // Parse HTTP Server-Authorization header

	        var serverAuthorization = getHeader('server-authorization');
	        if (!serverAuthorization &&
	            !options.required) {

	            return true;
	        }

	        var attributes = hawk.utils.parseAuthorizationHeader(serverAuthorization, ['mac', 'ext', 'hash']);
	        if (!attributes) {
	            return false;
	        }

	        var modArtifacts = {
	            ts: artifacts.ts,
	            nonce: artifacts.nonce,
	            method: artifacts.method,
	            resource: artifacts.resource,
	            host: artifacts.host,
	            port: artifacts.port,
	            hash: attributes.hash,
	            ext: attributes.ext,
	            app: artifacts.app,
	            dlg: artifacts.dlg
	        };

	        var mac = hawk.crypto.calculateMac('response', credentials, modArtifacts);
	        if (mac !== attributes.mac) {
	            return false;
	        }

	        if (!options.payload &&
	            options.payload !== '') {

	            return true;
	        }

	        if (!attributes.hash) {
	            return false;
	        }

	        var calculatedHash = hawk.crypto.calculatePayloadHash(options.payload, credentials.algorithm, getHeader('content-type'));
	        return (calculatedHash === attributes.hash);
	    },

	    message: function (host, port, message, options) {

	        // Validate inputs

	        if (!host || typeof host !== 'string' ||
	            !port || typeof port !== 'number' ||
	            message === null || message === undefined || typeof message !== 'string' ||
	            !options || typeof options !== 'object') {

	            return null;
	        }

	        // Application time

	        var timestamp = options.timestamp || hawk.utils.now(options.localtimeOffsetMsec);

	        // Validate credentials

	        var credentials = options.credentials;
	        if (!credentials ||
	            !credentials.id ||
	            !credentials.key ||
	            !credentials.algorithm) {

	            // Invalid credential object
	            return null;
	        }

	        if (hawk.crypto.algorithms.indexOf(credentials.algorithm) === -1) {
	            return null;
	        }

	        // Calculate signature

	        var artifacts = {
	            ts: timestamp,
	            nonce: options.nonce || hawk.utils.randomString(6),
	            host: host,
	            port: port,
	            hash: hawk.crypto.calculatePayloadHash(message, credentials.algorithm)
	        };

	        // Construct authorization

	        var result = {
	            id: credentials.id,
	            ts: artifacts.ts,
	            nonce: artifacts.nonce,
	            hash: artifacts.hash,
	            mac: hawk.crypto.calculateMac('message', credentials, artifacts)
	        };

	        return result;
	    },

	    authenticateTimestamp: function (message, credentials, updateClock) {           // updateClock defaults to true

	        var tsm = hawk.crypto.calculateTsMac(message.ts, credentials);
	        if (tsm !== message.tsm) {
	            return false;
	        }

	        if (updateClock !== false) {
	            hawk.utils.setNtpOffset(message.ts - Math.floor((new Date()).getTime() / 1000));    // Keep offset at 1 second precision
	        }

	        return true;
	    }
	};


	hawk.crypto = {

	    headerVersion: '1',

	    algorithms: ['sha1', 'sha256'],

	    calculateMac: function (type, credentials, options) {

	        var normalized = hawk.crypto.generateNormalizedString(type, options);

	        var hmac = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()](normalized, credentials.key);
	        return hmac.toString(CryptoJS.enc.Base64);
	    },

	    generateNormalizedString: function (type, options) {

	        var normalized = 'hawk.' + hawk.crypto.headerVersion + '.' + type + '\n' +
	                         options.ts + '\n' +
	                         options.nonce + '\n' +
	                         (options.method || '').toUpperCase() + '\n' +
	                         (options.resource || '') + '\n' +
	                         options.host.toLowerCase() + '\n' +
	                         options.port + '\n' +
	                         (options.hash || '') + '\n';

	        if (options.ext) {
	            normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
	        }

	        normalized += '\n';

	        if (options.app) {
	            normalized += options.app + '\n' +
	                          (options.dlg || '') + '\n';
	        }

	        return normalized;
	    },

	    calculatePayloadHash: function (payload, algorithm, contentType) {

	        var hash = CryptoJS.algo[algorithm.toUpperCase()].create();
	        hash.update('hawk.' + hawk.crypto.headerVersion + '.payload\n');
	        hash.update(hawk.utils.parseContentType(contentType) + '\n');
	        hash.update(payload);
	        hash.update('\n');
	        return hash.finalize().toString(CryptoJS.enc.Base64);
	    },

	    calculateTsMac: function (ts, credentials) {

	        var hash = CryptoJS['Hmac' + credentials.algorithm.toUpperCase()]('hawk.' + hawk.crypto.headerVersion + '.ts\n' + ts + '\n', credentials.key);
	        return hash.toString(CryptoJS.enc.Base64);
	    }
	};


	// localStorage compatible interface

	hawk.internals.LocalStorage = function () {

	    this._cache = {};
	    this.length = 0;

	    this.getItem = function (key) {

	        return this._cache.hasOwnProperty(key) ? String(this._cache[key]) : null;
	    };

	    this.setItem = function (key, value) {

	        this._cache[key] = String(value);
	        this.length = Object.keys(this._cache).length;
	    };

	    this.removeItem = function (key) {

	        delete this._cache[key];
	        this.length = Object.keys(this._cache).length;
	    };

	    this.clear = function () {

	        this._cache = {};
	        this.length = 0;
	    };

	    this.key = function (i) {

	        return Object.keys(this._cache)[i || 0];
	    };
	};


	hawk.utils = {

	    storage: new hawk.internals.LocalStorage(),

	    setStorage: function (storage) {

	        var ntpOffset = hawk.utils.storage.getItem('hawk_ntp_offset');
	        hawk.utils.storage = storage;
	        if (ntpOffset) {
	            hawk.utils.setNtpOffset(ntpOffset);
	        }
	    },

	    setNtpOffset: function (offset) {

	        try {
	            hawk.utils.storage.setItem('hawk_ntp_offset', offset);
	        }
	        catch (err) {
	            console.error('[hawk] could not write to storage.');
	            console.error(err);
	        }
	    },

	    getNtpOffset: function () {

	        var offset = hawk.utils.storage.getItem('hawk_ntp_offset');
	        if (!offset) {
	            return 0;
	        }

	        return parseInt(offset, 10);
	    },

	    now: function (localtimeOffsetMsec) {

	        return Math.floor(((new Date()).getTime() + (localtimeOffsetMsec || 0)) / 1000) + hawk.utils.getNtpOffset();
	    },

	    escapeHeaderAttribute: function (attribute) {

	        return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
	    },

	    parseContentType: function (header) {

	        if (!header) {
	            return '';
	        }

	        return header.split(';')[0].replace(/^\s+|\s+$/g, '').toLowerCase();
	    },

	    parseAuthorizationHeader: function (header, keys) {

	        if (!header) {
	            return null;
	        }

	        var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
	        if (!headerParts) {
	            return null;
	        }

	        var scheme = headerParts[1];
	        if (scheme.toLowerCase() !== 'hawk') {
	            return null;
	        }

	        var attributesString = headerParts[2];
	        if (!attributesString) {
	            return null;
	        }

	        var attributes = {};
	        var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {

	            // Check valid attribute names

	            if (keys.indexOf($1) === -1) {
	                return;
	            }

	            // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9

	            if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
	                return;
	            }

	            // Check for duplicates

	            if (attributes.hasOwnProperty($1)) {
	                return;
	            }

	            attributes[$1] = $2;
	            return '';
	        });

	        if (verify !== '') {
	            return null;
	        }

	        return attributes;
	    },

	    randomString: function (size) {

	        var randomSource = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
	        var len = randomSource.length;

	        var result = [];
	        for (var i = 0; i < size; ++i) {
	            result[i] = randomSource[Math.floor(Math.random() * len)];
	        }

	        return result.join('');
	    },

	    parseUri: function (input) {

	        // Based on: parseURI 1.2.2
	        // http://blog.stevenlevithan.com/archives/parseuri
	        // (c) Steven Levithan <stevenlevithan.com>
	        // MIT License

	        var keys = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'hostname', 'port', 'resource', 'relative', 'pathname', 'directory', 'file', 'query', 'fragment'];

	        var uriRegex = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?)(?:#(.*))?)/;
	        var uriByNumber = input.match(uriRegex);
	        var uri = {};

	        for (var i = 0, il = keys.length; i < il; ++i) {
	            uri[keys[i]] = uriByNumber[i] || '';
	        }

	        if (uri.port === '') {
	            uri.port = (uri.protocol.toLowerCase() === 'http' ? '80' : (uri.protocol.toLowerCase() === 'https' ? '443' : ''));
	        }

	        return uri;
	    },

	    base64urlEncode: function (value) {

	        var wordArray = CryptoJS.enc.Utf8.parse(value);
	        var encoded = CryptoJS.enc.Base64.stringify(wordArray);
	        return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
	    }
	};


	// $lab:coverage:off$

	// Based on: Crypto-JS v3.1.2
	// Copyright (c) 2009-2013, Jeff Mott. All rights reserved.
	// http://code.google.com/p/crypto-js/
	// http://code.google.com/p/crypto-js/wiki/License

	var CryptoJS = CryptoJS || function (h, r) { var k = {}, l = k.lib = {}, n = function () { }, f = l.Base = { extend: function (a) { n.prototype = this; var b = new n; a && b.mixIn(a); b.hasOwnProperty("init") || (b.init = function () { b.$super.init.apply(this, arguments) }); b.init.prototype = b; b.$super = this; return b }, create: function () { var a = this.extend(); a.init.apply(a, arguments); return a }, init: function () { }, mixIn: function (a) { for (var b in a) a.hasOwnProperty(b) && (this[b] = a[b]); a.hasOwnProperty("toString") && (this.toString = a.toString) }, clone: function () { return this.init.prototype.extend(this) } }, j = l.WordArray = f.extend({ init: function (a, b) { a = this.words = a || []; this.sigBytes = b != r ? b : 4 * a.length }, toString: function (a) { return (a || s).stringify(this) }, concat: function (a) { var b = this.words, d = a.words, c = this.sigBytes; a = a.sigBytes; this.clamp(); if (c % 4) for (var e = 0; e < a; e++) b[c + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((c + e) % 4); else if (65535 < d.length) for (e = 0; e < a; e += 4) b[c + e >>> 2] = d[e >>> 2]; else b.push.apply(b, d); this.sigBytes += a; return this }, clamp: function () { var a = this.words, b = this.sigBytes; a[b >>> 2] &= 4294967295 << 32 - 8 * (b % 4); a.length = h.ceil(b / 4) }, clone: function () { var a = f.clone.call(this); a.words = this.words.slice(0); return a }, random: function (a) { for (var b = [], d = 0; d < a; d += 4) b.push(4294967296 * h.random() | 0); return new j.init(b, a) } }), m = k.enc = {}, s = m.Hex = { stringify: function (a) { var b = a.words; a = a.sigBytes; for (var d = [], c = 0; c < a; c++) { var e = b[c >>> 2] >>> 24 - 8 * (c % 4) & 255; d.push((e >>> 4).toString(16)); d.push((e & 15).toString(16)) } return d.join("") }, parse: function (a) { for (var b = a.length, d = [], c = 0; c < b; c += 2) d[c >>> 3] |= parseInt(a.substr(c, 2), 16) << 24 - 4 * (c % 8); return new j.init(d, b / 2) } }, p = m.Latin1 = { stringify: function (a) { var b = a.words; a = a.sigBytes; for (var d = [], c = 0; c < a; c++) d.push(String.fromCharCode(b[c >>> 2] >>> 24 - 8 * (c % 4) & 255)); return d.join("") }, parse: function (a) { for (var b = a.length, d = [], c = 0; c < b; c++) d[c >>> 2] |= (a.charCodeAt(c) & 255) << 24 - 8 * (c % 4); return new j.init(d, b) } }, t = m.Utf8 = { stringify: function (a) { try { return decodeURIComponent(escape(p.stringify(a))) } catch (b) { throw Error("Malformed UTF-8 data"); } }, parse: function (a) { return p.parse(unescape(encodeURIComponent(a))) } }, q = l.BufferedBlockAlgorithm = f.extend({ reset: function () { this._data = new j.init; this._nDataBytes = 0 }, _append: function (a) { "string" == typeof a && (a = t.parse(a)); this._data.concat(a); this._nDataBytes += a.sigBytes }, _process: function (a) { var b = this._data, d = b.words, c = b.sigBytes, e = this.blockSize, f = c / (4 * e), f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0); a = f * e; c = h.min(4 * a, c); if (a) { for (var g = 0; g < a; g += e) this._doProcessBlock(d, g); g = d.splice(0, a); b.sigBytes -= c } return new j.init(g, c) }, clone: function () { var a = f.clone.call(this); a._data = this._data.clone(); return a }, _minBufferSize: 0 }); l.Hasher = q.extend({ cfg: f.extend(), init: function (a) { this.cfg = this.cfg.extend(a); this.reset() }, reset: function () { q.reset.call(this); this._doReset() }, update: function (a) { this._append(a); this._process(); return this }, finalize: function (a) { a && this._append(a); return this._doFinalize() }, blockSize: 16, _createHelper: function (a) { return function (b, d) { return (new a.init(d)).finalize(b) } }, _createHmacHelper: function (a) { return function (b, d) { return (new u.HMAC.init(a, d)).finalize(b) } } }); var u = k.algo = {}; return k }(Math);
	(function () { var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend({ _doReset: function () { this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (n, p) { for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++) { if (16 > c) d[c] = n[p + c] | 0; else { var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16]; d[c] = g << 1 | g >>> 31 } g = (e << 5 | e >>> 27) + b + d[c]; g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^ j) - 899497514); b = j; j = h; h = f << 30 | f >>> 2; f = e; e = g } a[0] = a[0] + e | 0; a[1] = a[1] + f | 0; a[2] = a[2] + h | 0; a[3] = a[3] + j | 0; a[4] = a[4] + b | 0 }, _doFinalize: function () { var b = this._data, d = b.words, a = 8 * this._nDataBytes, e = 8 * b.sigBytes; d[e >>> 5] |= 128 << 24 - e % 32; d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296); d[(e + 64 >>> 9 << 4) + 15] = a; b.sigBytes = 4 * d.length; this._process(); return this._hash }, clone: function () { var b = l.clone.call(this); b._hash = this._hash.clone(); return b } }); k.SHA1 = l._createHelper(b); k.HmacSHA1 = l._createHmacHelper(b) })();
	(function (k) { for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function (q) { return 4294967296 * (q - (q | 0)) | 0 }, l = 2, b = 0; 64 > b;) { var d; a: { d = l; for (var w = k.sqrt(d), r = 2; r <= w; r++) if (!(d % r)) { d = !1; break a } d = !0 } d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++); l++ } var n = [], h = h.SHA256 = j.extend({ _doReset: function () { this._hash = new v.init(s.slice(0)) }, _doProcessBlock: function (q, h) { for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++) { if (16 > e) n[e] = q[h + e] | 0; else { var m = n[e - 15], p = n[e - 2]; n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16] } m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e]; p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b); l = j; j = g; g = f; f = k + m | 0; k = b; b = d; d = c; c = m + p | 0 } a[0] = a[0] + c | 0; a[1] = a[1] + d | 0; a[2] = a[2] + b | 0; a[3] = a[3] + k | 0; a[4] = a[4] + f | 0; a[5] = a[5] + g | 0; a[6] = a[6] + j | 0; a[7] = a[7] + l | 0 }, _doFinalize: function () { var d = this._data, b = d.words, a = 8 * this._nDataBytes, c = 8 * d.sigBytes; b[c >>> 5] |= 128 << 24 - c % 32; b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296); b[(c + 64 >>> 9 << 4) + 15] = a; d.sigBytes = 4 * b.length; this._process(); return this._hash }, clone: function () { var b = j.clone.call(this); b._hash = this._hash.clone(); return b } }); g.SHA256 = j._createHelper(h); g.HmacSHA256 = j._createHmacHelper(h) })(Math);
	(function () { var c = CryptoJS, k = c.enc.Utf8; c.algo.HMAC = c.lib.Base.extend({ init: function (a, b) { a = this._hasher = new a.init; "string" == typeof b && (b = k.parse(b)); var c = a.blockSize, e = 4 * c; b.sigBytes > e && (b = a.finalize(b)); b.clamp(); for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++) h[d] ^= 1549556828, j[d] ^= 909522486; f.sigBytes = g.sigBytes = e; this.reset() }, reset: function () { var a = this._hasher; a.reset(); a.update(this._iKey) }, update: function (a) { this._hasher.update(a); return this }, finalize: function (a) { var b = this._hasher; a = b.finalize(a); b.reset(); return b.finalize(this._oKey.clone().concat(a)) } }) })();
	(function () { var h = CryptoJS, j = h.lib.WordArray; h.enc.Base64 = { stringify: function (b) { var e = b.words, f = b.sigBytes, c = this._map; b.clamp(); b = []; for (var a = 0; a < f; a += 3) for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++) b.push(c.charAt(d >>> 6 * (3 - g) & 63)); if (e = c.charAt(64)) for (; b.length % 4;) b.push(e); return b.join("") }, parse: function (b) { var e = b.length, f = this._map, c = f.charAt(64); c && (c = b.indexOf(c), -1 != c && (e = c)); for (var c = [], a = 0, d = 0; d < e; d++) if (d % 4) { var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4), h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4); c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4); a++ } return j.create(c, a) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" } })();

	hawk.crypto.internals = CryptoJS;


	// Export if used as a module

	if (typeof module !== 'undefined' && module.exports) {
	    module.exports = hawk;
	}

	// $lab:coverage:on$


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	
	/*!
	 * knox - auth
	 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
	 * MIT Licensed
	 */

	/**
	 * Module dependencies.
	 */

	var crypto = __webpack_require__(37)
	  , parse = __webpack_require__(15).parse
	  ;

	/**
	 * Valid keys.
	 */

	var keys = 
	  [ 'acl'
	  , 'location'
	  , 'logging'
	  , 'notification'
	  , 'partNumber'
	  , 'policy'
	  , 'requestPayment'
	  , 'torrent'
	  , 'uploadId'
	  , 'uploads'
	  , 'versionId'
	  , 'versioning'
	  , 'versions'
	  , 'website'
	  ]

	/**
	 * Return an "Authorization" header value with the given `options`
	 * in the form of "AWS <key>:<signature>"
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function authorization (options) {
	  return 'AWS ' + options.key + ':' + sign(options)
	}

	module.exports = authorization
	module.exports.authorization = authorization

	/**
	 * Simple HMAC-SHA1 Wrapper
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */ 

	function hmacSha1 (options) {
	  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
	}

	module.exports.hmacSha1 = hmacSha1

	/**
	 * Create a base64 sha1 HMAC for `options`. 
	 * 
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function sign (options) {
	  options.message = stringToSign(options)
	  return hmacSha1(options)
	}
	module.exports.sign = sign

	/**
	 * Create a base64 sha1 HMAC for `options`. 
	 *
	 * Specifically to be used with S3 presigned URLs
	 * 
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function signQuery (options) {
	  options.message = queryStringToSign(options)
	  return hmacSha1(options)
	}
	module.exports.signQuery= signQuery

	/**
	 * Return a string for sign() with the given `options`.
	 *
	 * Spec:
	 * 
	 *    <verb>\n
	 *    <md5>\n
	 *    <content-type>\n
	 *    <date>\n
	 *    [headers\n]
	 *    <resource>
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function stringToSign (options) {
	  var headers = options.amazonHeaders || ''
	  if (headers) headers += '\n'
	  var r = 
	    [ options.verb
	    , options.md5
	    , options.contentType
	    , options.date ? options.date.toUTCString() : ''
	    , headers + options.resource
	    ]
	  return r.join('\n')
	}
	module.exports.queryStringToSign = stringToSign

	/**
	 * Return a string for sign() with the given `options`, but is meant exclusively
	 * for S3 presigned URLs
	 *
	 * Spec:
	 * 
	 *    <date>\n
	 *    <resource>
	 *
	 * @param {Object} options
	 * @return {String}
	 * @api private
	 */

	function queryStringToSign (options){
	  return 'GET\n\n\n' + options.date + '\n' + options.resource
	}
	module.exports.queryStringToSign = queryStringToSign

	/**
	 * Perform the following:
	 *
	 *  - ignore non-amazon headers
	 *  - lowercase fields
	 *  - sort lexicographically
	 *  - trim whitespace between ":"
	 *  - join with newline
	 *
	 * @param {Object} headers
	 * @return {String}
	 * @api private
	 */

	function canonicalizeHeaders (headers) {
	  var buf = []
	    , fields = Object.keys(headers)
	    ;
	  for (var i = 0, len = fields.length; i < len; ++i) {
	    var field = fields[i]
	      , val = headers[field]
	      , field = field.toLowerCase()
	      ;
	    if (0 !== field.indexOf('x-amz')) continue
	    buf.push(field + ':' + val)
	  }
	  return buf.sort().join('\n')
	}
	module.exports.canonicalizeHeaders = canonicalizeHeaders

	/**
	 * Perform the following:
	 *
	 *  - ignore non sub-resources
	 *  - sort lexicographically
	 *
	 * @param {String} resource
	 * @return {String}
	 * @api private
	 */

	function canonicalizeResource (resource) {
	  var url = parse(resource, true)
	    , path = url.pathname
	    , buf = []
	    ;

	  Object.keys(url.query).forEach(function(key){
	    if (!~keys.indexOf(key)) return
	    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
	    buf.push(key + val)
	  })

	  return path + (buf.length ? '?' + buf.sort().join('&') : '')
	}
	module.exports.canonicalizeResource = canonicalizeResource


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.

	var parser = __webpack_require__(97);
	var signer = __webpack_require__(99);
	var verify = __webpack_require__(100);
	var util = __webpack_require__(101);



	///--- API

	module.exports = {

	  parse: parser.parseRequest,
	  parseRequest: parser.parseRequest,

	  sign: signer.signRequest,
	  signRequest: signer.signRequest,

	  sshKeyToPEM: util.sshKeyToPEM,
	  sshKeyFingerprint: util.fingerprint,
	  pemToRsaSSHKey: util.pemToRsaSSHKey,

	  verify: verify.verifySignature,
	  verifySignature: verify.verifySignature,
	  verifyHMAC: verify.verifyHMAC
	};


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = __webpack_require__(98);
	var util = __webpack_require__(27);



	///--- Globals

	var Algorithms = {
	  'rsa-sha1': true,
	  'rsa-sha256': true,
	  'rsa-sha512': true,
	  'dsa-sha1': true,
	  'hmac-sha1': true,
	  'hmac-sha256': true,
	  'hmac-sha512': true
	};

	var State = {
	  New: 0,
	  Params: 1
	};

	var ParamsState = {
	  Name: 0,
	  Quote: 1,
	  Value: 2,
	  Comma: 3
	};



	///--- Specific Errors

	function HttpSignatureError(message, caller) {
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, caller || HttpSignatureError);

	  this.message = message;
	  this.name = caller.name;
	}
	util.inherits(HttpSignatureError, Error);

	function ExpiredRequestError(message) {
	  HttpSignatureError.call(this, message, ExpiredRequestError);
	}
	util.inherits(ExpiredRequestError, HttpSignatureError);


	function InvalidHeaderError(message) {
	  HttpSignatureError.call(this, message, InvalidHeaderError);
	}
	util.inherits(InvalidHeaderError, HttpSignatureError);


	function InvalidParamsError(message) {
	  HttpSignatureError.call(this, message, InvalidParamsError);
	}
	util.inherits(InvalidParamsError, HttpSignatureError);


	function MissingHeaderError(message) {
	  HttpSignatureError.call(this, message, MissingHeaderError);
	}
	util.inherits(MissingHeaderError, HttpSignatureError);



	///--- Exported API

	module.exports = {

	  /**
	   * Parses the 'Authorization' header out of an http.ServerRequest object.
	   *
	   * Note that this API will fully validate the Authorization header, and throw
	   * on any error.  It will not however check the signature, or the keyId format
	   * as those are specific to your environment.  You can use the options object
	   * to pass in extra constraints.
	   *
	   * As a response object you can expect this:
	   *
	   *     {
	   *       "scheme": "Signature",
	   *       "params": {
	   *         "keyId": "foo",
	   *         "algorithm": "rsa-sha256",
	   *         "headers": [
	   *           "date" or "x-date",
	   *           "content-md5"
	   *         ],
	   *         "signature": "base64"
	   *       },
	   *       "signingString": "ready to be passed to crypto.verify()"
	   *     }
	   *
	   * @param {Object} request an http.ServerRequest.
	   * @param {Object} options an optional options object with:
	   *                   - clockSkew: allowed clock skew in seconds (default 300).
	   *                   - headers: required header names (def: date or x-date)
	   *                   - algorithms: algorithms to support (default: all).
	   * @return {Object} parsed out object (see above).
	   * @throws {TypeError} on invalid input.
	   * @throws {InvalidHeaderError} on an invalid Authorization header error.
	   * @throws {InvalidParamsError} if the params in the scheme are invalid.
	   * @throws {MissingHeaderError} if the params indicate a header not present,
	   *                              either in the request headers from the params,
	   *                              or not in the params from a required header
	   *                              in options.
	   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
	   */
	  parseRequest: function parseRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(request.headers, 'request.headers');
	    if (options === undefined) {
	      options = {};
	    }
	    if (options.headers === undefined) {
	      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
	    }
	    assert.object(options, 'options');
	    assert.arrayOfString(options.headers, 'options.headers');
	    assert.optionalNumber(options.clockSkew, 'options.clockSkew');

	    if (!request.headers.authorization)
	      throw new MissingHeaderError('no authorization header present in ' +
	                                   'the request');

	    options.clockSkew = options.clockSkew || 300;


	    var i = 0;
	    var state = State.New;
	    var substate = ParamsState.Name;
	    var tmpName = '';
	    var tmpValue = '';

	    var parsed = {
	      scheme: '',
	      params: {},
	      signingString: '',

	      get algorithm() {
	        return this.params.algorithm.toUpperCase();
	      },

	      get keyId() {
	        return this.params.keyId;
	      }

	    };

	    var authz = request.headers.authorization;
	    for (i = 0; i < authz.length; i++) {
	      var c = authz.charAt(i);

	      switch (Number(state)) {

	      case State.New:
	        if (c !== ' ') parsed.scheme += c;
	        else state = State.Params;
	        break;

	      case State.Params:
	        switch (Number(substate)) {

	        case ParamsState.Name:
	          var code = c.charCodeAt(0);
	          // restricted name of A-Z / a-z
	          if ((code >= 0x41 && code <= 0x5a) || // A-Z
	              (code >= 0x61 && code <= 0x7a)) { // a-z
	            tmpName += c;
	          } else if (c === '=') {
	            if (tmpName.length === 0)
	              throw new InvalidHeaderError('bad param format');
	            substate = ParamsState.Quote;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        case ParamsState.Quote:
	          if (c === '"') {
	            tmpValue = '';
	            substate = ParamsState.Value;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        case ParamsState.Value:
	          if (c === '"') {
	            parsed.params[tmpName] = tmpValue;
	            substate = ParamsState.Comma;
	          } else {
	            tmpValue += c;
	          }
	          break;

	        case ParamsState.Comma:
	          if (c === ',') {
	            tmpName = '';
	            substate = ParamsState.Name;
	          } else {
	            throw new InvalidHeaderError('bad param format');
	          }
	          break;

	        default:
	          throw new Error('Invalid substate');
	        }
	        break;

	      default:
	        throw new Error('Invalid substate');
	      }

	    }

	    if (!parsed.params.headers || parsed.params.headers === '') {
	      if (request.headers['x-date']) {
	        parsed.params.headers = ['x-date'];
	      } else {
	        parsed.params.headers = ['date'];
	      }
	    } else {
	      parsed.params.headers = parsed.params.headers.split(' ');
	    }

	    // Minimally validate the parsed object
	    if (!parsed.scheme || parsed.scheme !== 'Signature')
	      throw new InvalidHeaderError('scheme was not "Signature"');

	    if (!parsed.params.keyId)
	      throw new InvalidHeaderError('keyId was not specified');

	    if (!parsed.params.algorithm)
	      throw new InvalidHeaderError('algorithm was not specified');

	    if (!parsed.params.signature)
	      throw new InvalidHeaderError('signature was not specified');

	    // Check the algorithm against the official list
	    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
	    if (!Algorithms[parsed.params.algorithm])
	      throw new InvalidParamsError(parsed.params.algorithm +
	                                   ' is not supported');

	    // Build the signingString
	    for (i = 0; i < parsed.params.headers.length; i++) {
	      var h = parsed.params.headers[i].toLowerCase();
	      parsed.params.headers[i] = h;

	      if (h !== 'request-line') {
	        var value = request.headers[h];
	        if (!value)
	          throw new MissingHeaderError(h + ' was not in the request');
	        parsed.signingString += h + ': ' + value;
	      } else {
	        parsed.signingString +=
	          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
	      }

	      if ((i + 1) < parsed.params.headers.length)
	        parsed.signingString += '\n';
	    }

	    // Check against the constraints
	    var date;
	    if (request.headers.date || request.headers['x-date']) {
	        if (request.headers['x-date']) {
	          date = new Date(request.headers['x-date']);
	        } else {
	          date = new Date(request.headers.date);
	        }
	      var now = new Date();
	      var skew = Math.abs(now.getTime() - date.getTime());

	      if (skew > options.clockSkew * 1000) {
	        throw new ExpiredRequestError('clock skew of ' +
	                                      (skew / 1000) +
	                                      's was greater than ' +
	                                      options.clockSkew + 's');
	      }
	    }

	    options.headers.forEach(function (hdr) {
	      // Remember that we already checked any headers in the params
	      // were in the request, so if this passes we're good.
	      if (parsed.params.headers.indexOf(hdr) < 0)
	        throw new MissingHeaderError(hdr + ' was not a signed header');
	    });

	    if (options.algorithms) {
	      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
	        throw new InvalidParamsError(parsed.params.algorithm +
	                                     ' is not a supported algorithm');
	    }

	    return parsed;
	  }

	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer) {// Copyright (c) 2012, Mark Cavage. All rights reserved.

	var assert = __webpack_require__(92);
	var Stream = __webpack_require__(56).Stream;
	var util = __webpack_require__(27);



	///--- Globals

	var NDEBUG = process.env.NODE_NDEBUG || false;
	var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;



	///--- Messages

	var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
	var TYPE_REQUIRED = '%s (%s) is required';



	///--- Internal

	function capitalize(str) {
	        return (str.charAt(0).toUpperCase() + str.slice(1));
	}

	function uncapitalize(str) {
	        return (str.charAt(0).toLowerCase() + str.slice(1));
	}

	function _() {
	        return (util.format.apply(util, arguments));
	}


	function _assert(arg, type, name, stackFunc) {
	        if (!NDEBUG) {
	                name = name || type;
	                stackFunc = stackFunc || _assert.caller;
	                var t = typeof (arg);

	                if (t !== type) {
	                        throw new assert.AssertionError({
	                                message: _(TYPE_REQUIRED, name, type),
	                                actual: t,
	                                expected: type,
	                                operator: '===',
	                                stackStartFunction: stackFunc
	                        });
	                }
	        }
	}


	function _instanceof(arg, type, name, stackFunc) {
	        if (!NDEBUG) {
	                name = name || type;
	                stackFunc = stackFunc || _instanceof.caller;

	                if (!(arg instanceof type)) {
	                        throw new assert.AssertionError({
	                                message: _(TYPE_REQUIRED, name, type.name),
	                                actual: _getClass(arg),
	                                expected: type.name,
	                                operator: 'instanceof',
	                                stackStartFunction: stackFunc
	                        });
	                }
	        }
	}

	function _getClass(object) {
	        return (Object.prototype.toString.call(object).slice(8, -1));
	};



	///--- API

	function array(arr, type, name) {
	        if (!NDEBUG) {
	                name = name || type;

	                if (!Array.isArray(arr)) {
	                        throw new assert.AssertionError({
	                                message: _(ARRAY_TYPE_REQUIRED, name, type),
	                                actual: typeof (arr),
	                                expected: 'array',
	                                operator: 'Array.isArray',
	                                stackStartFunction: array.caller
	                        });
	                }

	                for (var i = 0; i < arr.length; i++) {
	                        _assert(arr[i], type, name, array);
	                }
	        }
	}


	function bool(arg, name) {
	        _assert(arg, 'boolean', name, bool);
	}


	function buffer(arg, name) {
	        if (!Buffer.isBuffer(arg)) {
	                throw new assert.AssertionError({
	                        message: _(TYPE_REQUIRED, name || '', 'Buffer'),
	                        actual: typeof (arg),
	                        expected: 'buffer',
	                        operator: 'Buffer.isBuffer',
	                        stackStartFunction: buffer
	                });
	        }
	}


	function func(arg, name) {
	        _assert(arg, 'function', name);
	}


	function number(arg, name) {
	        _assert(arg, 'number', name);
	        if (!NDEBUG && (isNaN(arg) || !isFinite(arg))) {
	                throw new assert.AssertionError({
	                        message: _(TYPE_REQUIRED, name, 'number'),
	                        actual: arg,
	                        expected: 'number',
	                        operator: 'isNaN',
	                        stackStartFunction: number
	                });
	        }
	}


	function object(arg, name) {
	        _assert(arg, 'object', name);
	}


	function stream(arg, name) {
	        _instanceof(arg, Stream, name);
	}


	function date(arg, name) {
	        _instanceof(arg, Date, name);
	}

	function regexp(arg, name) {
	        _instanceof(arg, RegExp, name);
	}


	function string(arg, name) {
	        _assert(arg, 'string', name);
	}


	function uuid(arg, name) {
	        string(arg, name);
	        if (!NDEBUG && !UUID_REGEXP.test(arg)) {
	                throw new assert.AssertionError({
	                        message: _(TYPE_REQUIRED, name, 'uuid'),
	                        actual: 'string',
	                        expected: 'uuid',
	                        operator: 'test',
	                        stackStartFunction: uuid
	                });
	        }
	}


	///--- Exports

	module.exports = {
	        bool: bool,
	        buffer: buffer,
	        date: date,
	        func: func,
	        number: number,
	        object: object,
	        regexp: regexp,
	        stream: stream,
	        string: string,
	        uuid: uuid
	};


	Object.keys(module.exports).forEach(function (k) {
	        if (k === 'buffer')
	                return;

	        var name = 'arrayOf' + capitalize(k);

	        if (k === 'bool')
	                k = 'boolean';
	        if (k === 'func')
	                k = 'function';
	        module.exports[name] = function (arg, name) {
	                array(arg, k, name);
	        };
	});

	Object.keys(module.exports).forEach(function (k) {
	        var _name = 'optional' + capitalize(k);
	        var s = uncapitalize(k.replace('arrayOf', ''));
	        if (s === 'bool')
	                s = 'boolean';
	        if (s === 'func')
	                s = 'function';

	        if (k.indexOf('arrayOf') !== -1) {
	          module.exports[_name] = function (arg, name) {
	                  if (!NDEBUG && arg !== undefined) {
	                          array(arg, s, name);
	                  }
	          };
	        } else {
	          module.exports[_name] = function (arg, name) {
	                  if (!NDEBUG && arg !== undefined) {
	                          _assert(arg, s, name);
	                  }
	          };
	        }
	});


	// Reexport built-in assertions
	Object.keys(assert).forEach(function (k) {
	        if (k === 'AssertionError') {
	                module.exports[k] = assert[k];
	                return;
	        }

	        module.exports[k] = function () {
	                if (!NDEBUG) {
	                        assert[k].apply(assert[k], arguments);
	                }
	        };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7), __webpack_require__(32).Buffer))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = __webpack_require__(98);
	var crypto = __webpack_require__(37);
	var http = __webpack_require__(53);

	var sprintf = __webpack_require__(27).format;



	///--- Globals

	var Algorithms = {
	  'rsa-sha1': true,
	  'rsa-sha256': true,
	  'rsa-sha512': true,
	  'dsa-sha1': true,
	  'hmac-sha1': true,
	  'hmac-sha256': true,
	  'hmac-sha512': true
	};

	var Authorization =
	  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';



	///--- Specific Errors

	function MissingHeaderError(message) {
	    this.name = 'MissingHeaderError';
	    this.message = message;
	    this.stack = (new Error()).stack;
	}
	MissingHeaderError.prototype = new Error();


	function InvalidAlgorithmError(message) {
	    this.name = 'InvalidAlgorithmError';
	    this.message = message;
	    this.stack = (new Error()).stack;
	}
	InvalidAlgorithmError.prototype = new Error();



	///--- Internal Functions

	function _pad(val) {
	  if (parseInt(val, 10) < 10) {
	    val = '0' + val;
	  }
	  return val;
	}


	function _rfc1123() {
	  var date = new Date();

	  var months = ['Jan',
	                'Feb',
	                'Mar',
	                'Apr',
	                'May',
	                'Jun',
	                'Jul',
	                'Aug',
	                'Sep',
	                'Oct',
	                'Nov',
	                'Dec'];
	  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	  return days[date.getUTCDay()] + ', ' +
	    _pad(date.getUTCDate()) + ' ' +
	    months[date.getUTCMonth()] + ' ' +
	    date.getUTCFullYear() + ' ' +
	    _pad(date.getUTCHours()) + ':' +
	    _pad(date.getUTCMinutes()) + ':' +
	    _pad(date.getUTCSeconds()) +
	    ' GMT';
	}



	///--- Exported API

	module.exports = {

	  /**
	   * Adds an 'Authorization' header to an http.ClientRequest object.
	   *
	   * Note that this API will add a Date header if it's not already set. Any
	   * other headers in the options.headers array MUST be present, or this
	   * will throw.
	   *
	   * You shouldn't need to check the return type; it's just there if you want
	   * to be pedantic.
	   *
	   * @param {Object} request an instance of http.ClientRequest.
	   * @param {Object} options signing parameters object:
	   *                   - {String} keyId required.
	   *                   - {String} key required (either a PEM or HMAC key).
	   *                   - {Array} headers optional; defaults to ['date'].
	   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
	   *                   - {String} httpVersion optional; defaults to '1.1'.
	   * @return {Boolean} true if Authorization (and optionally Date) were added.
	   * @throws {TypeError} on bad parameter types (input).
	   * @throws {InvalidAlgorithmError} if algorithm was bad.
	   * @throws {MissingHeaderError} if a header to be signed was specified but
	   *                              was not present.
	   */
	  signRequest: function signRequest(request, options) {
	    assert.object(request, 'request');
	    assert.object(options, 'options');
	    assert.optionalString(options.algorithm, 'options.algorithm');
	    assert.string(options.keyId, 'options.keyId');
	    assert.optionalArrayOfString(options.headers, 'options.headers');
	    assert.optionalString(options.httpVersion, 'options.httpVersion');

	    if (!request.getHeader('Date'))
	      request.setHeader('Date', _rfc1123());
	    if (!options.headers)
	      options.headers = ['date'];
	    if (!options.algorithm)
	      options.algorithm = 'rsa-sha256';
	    if (!options.httpVersion)
	      options.httpVersion = '1.1';

	    options.algorithm = options.algorithm.toLowerCase();

	    if (!Algorithms[options.algorithm])
	      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');

	    var i;
	    var stringToSign = '';
	    for (i = 0; i < options.headers.length; i++) {
	      if (typeof (options.headers[i]) !== 'string')
	        throw new TypeError('options.headers must be an array of Strings');

	      var h = options.headers[i].toLowerCase();

	      if (h !== 'request-line') {
	        var value = request.getHeader(h);
	        if (!value) {
	          throw new MissingHeaderError(h + ' was not in the request');
	        }
	        stringToSign += h + ': ' + value;
	      } else {
	        stringToSign +=
	          request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
	      }

	      if ((i + 1) < options.headers.length)
	        stringToSign += '\n';
	    }

	    var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
	    var signature;
	    if (alg[1] === 'hmac') {
	      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
	      hmac.update(stringToSign);
	      signature = hmac.digest('base64');
	    } else {
	      var signer = crypto.createSign(options.algorithm.toUpperCase());
	      signer.update(stringToSign);
	      signature = signer.sign(options.key, 'base64');
	    }

	    request.setHeader('Authorization', sprintf(Authorization,
	                                               options.keyId,
	                                               options.algorithm,
	                                               options.headers.join(' '),
	                                               signature));

	    return true;
	  }

	};


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2015 Joyent, Inc.

	var assert = __webpack_require__(98);
	var crypto = __webpack_require__(37);



	///--- Exported API

	module.exports = {
	  /**
	   * Verify RSA/DSA signature against public key.  You are expected to pass in
	   * an object that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} pubkey RSA/DSA private key PEM.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   */
	  verifySignature: function verifySignature(parsedSignature, pubkey) {
	    assert.object(parsedSignature, 'parsedSignature');
	    assert.string(pubkey, 'pubkey');

	    var alg = parsedSignature.algorithm.match(/^(RSA|DSA)-(\w+)/);
	    if (!alg || alg.length !== 3)
	      throw new TypeError('parsedSignature: unsupported algorithm ' +
	                          parsedSignature.algorithm);

	    var verify = crypto.createVerify(alg[0]);
	    verify.update(parsedSignature.signingString);
	    return verify.verify(pubkey, parsedSignature.params.signature, 'base64');
	  },

	  /**
	   * Verify HMAC against shared secret.  You are expected to pass in an object
	   * that was returned from `parse()`.
	   *
	   * @param {Object} parsedSignature the object you got from `parse`.
	   * @param {String} secret HMAC shared secret.
	   * @return {Boolean} true if valid, false otherwise.
	   * @throws {TypeError} if you pass in bad arguments.
	   */
	  verifyHMAC: function verifyHMAC(parsedSignature, secret) {
	    assert.object(parsedSignature, 'parsedHMAC');
	    assert.string(secret, 'secret');

	    var alg = parsedSignature.algorithm.match(/^HMAC-(\w+)/);
	    if (!alg || alg.length !== 2)
	      throw new TypeError('parsedSignature: unsupported algorithm ' +
	                          parsedSignature.algorithm);

	    var hmac = crypto.createHmac(alg[1].toUpperCase(), secret);
	    hmac.update(parsedSignature.signingString);
	    return (hmac.digest('base64') === parsedSignature.params.signature);
	  }
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2012 Joyent, Inc.  All rights reserved.

	var assert = __webpack_require__(98);
	var crypto = __webpack_require__(37);

	var asn1 = __webpack_require__(102);
	var ctype = __webpack_require__(108);



	///--- Helpers

	function readNext(buffer, offset) {
	  var len = ctype.ruint32(buffer, 'big', offset);
	  offset += 4;

	  var newOffset = offset + len;

	  return {
	    data: buffer.slice(offset, newOffset),
	    offset: newOffset
	  };
	}


	function writeInt(writer, buffer) {
	  writer.writeByte(0x02); // ASN1.Integer
	  writer.writeLength(buffer.length);

	  for (var i = 0; i < buffer.length; i++)
	    writer.writeByte(buffer[i]);

	  return writer;
	}


	function rsaToPEM(key) {
	  var buffer;
	  var der;
	  var exponent;
	  var i;
	  var modulus;
	  var newKey = '';
	  var offset = 0;
	  var type;
	  var tmp;

	  try {
	    buffer = new Buffer(key.split(' ')[1], 'base64');

	    tmp = readNext(buffer, offset);
	    type = tmp.data.toString();
	    offset = tmp.offset;

	    if (type !== 'ssh-rsa')
	      throw new Error('Invalid ssh key type: ' + type);

	    tmp = readNext(buffer, offset);
	    exponent = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    modulus = tmp.data;
	  } catch (e) {
	    throw new Error('Invalid ssh key: ' + key);
	  }

	  // DER is a subset of BER
	  der = new asn1.BerWriter();

	  der.startSequence();

	  der.startSequence();
	  der.writeOID('1.2.840.113549.1.1.1');
	  der.writeNull();
	  der.endSequence();

	  der.startSequence(0x03); // bit string
	  der.writeByte(0x00);

	  // Actual key
	  der.startSequence();
	  writeInt(der, modulus);
	  writeInt(der, exponent);
	  der.endSequence();

	  // bit string
	  der.endSequence();

	  der.endSequence();

	  tmp = der.buffer.toString('base64');
	  for (i = 0; i < tmp.length; i++) {
	    if ((i % 64) === 0)
	      newKey += '\n';
	    newKey += tmp.charAt(i);
	  }

	  if (!/\\n$/.test(newKey))
	    newKey += '\n';

	  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
	}


	function dsaToPEM(key) {
	  var buffer;
	  var offset = 0;
	  var tmp;
	  var der;
	  var newKey = '';

	  var type;
	  var p;
	  var q;
	  var g;
	  var y;

	  try {
	    buffer = new Buffer(key.split(' ')[1], 'base64');

	    tmp = readNext(buffer, offset);
	    type = tmp.data.toString();
	    offset = tmp.offset;

	    /* JSSTYLED */
	    if (!/^ssh-ds[as].*/.test(type))
	      throw new Error('Invalid ssh key type: ' + type);

	    tmp = readNext(buffer, offset);
	    p = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    q = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    g = tmp.data;
	    offset = tmp.offset;

	    tmp = readNext(buffer, offset);
	    y = tmp.data;
	  } catch (e) {
	    console.log(e.stack);
	    throw new Error('Invalid ssh key: ' + key);
	  }

	  // DER is a subset of BER
	  der = new asn1.BerWriter();

	  der.startSequence();

	  der.startSequence();
	  der.writeOID('1.2.840.10040.4.1');

	  der.startSequence();
	  writeInt(der, p);
	  writeInt(der, q);
	  writeInt(der, g);
	  der.endSequence();

	  der.endSequence();

	  der.startSequence(0x03); // bit string
	  der.writeByte(0x00);
	  writeInt(der, y);
	  der.endSequence();

	  der.endSequence();

	  tmp = der.buffer.toString('base64');
	  for (var i = 0; i < tmp.length; i++) {
	    if ((i % 64) === 0)
	      newKey += '\n';
	    newKey += tmp.charAt(i);
	  }

	  if (!/\\n$/.test(newKey))
	    newKey += '\n';

	  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
	}


	///--- API

	module.exports = {

	  /**
	   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
	   *
	   * The intent of this module is to interoperate with OpenSSL only,
	   * specifically the node crypto module's `verify` method.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} PEM encoded form of the RSA public key.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} on invalid ssh key formatted data.
	   */
	  sshKeyToPEM: function sshKeyToPEM(key) {
	    assert.string(key, 'ssh_key');

	    /* JSSTYLED */
	    if (/^ssh-rsa.*/.test(key))
	      return rsaToPEM(key);

	    /* JSSTYLED */
	    if (/^ssh-ds[as].*/.test(key))
	      return dsaToPEM(key);

	    throw new Error('Only RSA and DSA public keys are allowed');
	  },


	  /**
	   * Generates an OpenSSH fingerprint from an ssh public key.
	   *
	   * @param {String} key an OpenSSH public key.
	   * @return {String} key fingerprint.
	   * @throws {TypeError} on bad input.
	   * @throws {Error} if what you passed doesn't look like an ssh public key.
	   */
	  fingerprint: function fingerprint(key) {
	    assert.string(key, 'ssh_key');

	    var pieces = key.split(' ');
	    if (!pieces || !pieces.length || pieces.length < 2)
	      throw new Error('invalid ssh key');

	    var data = new Buffer(pieces[1], 'base64');

	    var hash = crypto.createHash('md5');
	    hash.update(data);
	    var digest = hash.digest('hex');

	    var fp = '';
	    for (var i = 0; i < digest.length; i++) {
	      if (i && i % 2 === 0)
	        fp += ':';

	      fp += digest[i];
	    }

	    return fp;
	  },

	  /**
	   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
	   *
	   * The reverse of the above function.
	   */
	  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
	    assert.equal('string', typeof (pem), 'typeof pem');

	    // chop off the BEGIN PUBLIC KEY and END PUBLIC KEY portion
	    var cleaned = pem.split('\n').slice(1, -2).join('');

	    var buf = new Buffer(cleaned, 'base64');

	    var der = new asn1.BerReader(buf);

	    der.readSequence();
	    der.readSequence();

	    var oid = der.readOID();
	    assert.equal(oid, '1.2.840.113549.1.1.1', 'pem not in RSA format');

	    // Null -- XXX this probably isn't good practice
	    der.readByte();
	    der.readByte();

	    // bit string sequence
	    der.readSequence(0x03);
	    der.readByte();
	    der.readSequence();

	    // modulus
	    assert.equal(der.peek(), asn1.Ber.Integer, 'modulus not an integer');
	    der._offset = der.readLength(der.offset + 1);
	    var modulus = der._buf.slice(der.offset, der.offset + der.length);
	    der._offset += der.length;

	    // exponent
	    assert.equal(der.peek(), asn1.Ber.Integer, 'exponent not an integer');
	    der._offset = der.readLength(der.offset + 1);
	    var exponent = der._buf.slice(der.offset, der.offset + der.length);
	    der._offset += der.length;

	    // now, make the key
	    var type = new Buffer('ssh-rsa');
	    var buffer = new Buffer(4 + type.length + 4 + modulus.length +
	      4 + exponent.length);
	    var i = 0;
	    buffer.writeUInt32BE(type.length, i);     i += 4;
	    type.copy(buffer, i);                     i += type.length;
	    buffer.writeUInt32BE(exponent.length, i); i += 4;
	    exponent.copy(buffer, i);                 i += exponent.length;
	    buffer.writeUInt32BE(modulus.length, i);  i += 4;
	    modulus.copy(buffer, i);                  i += modulus.length;

	    var s = (type.toString() + ' ' + buffer.toString('base64') + ' ' +
	      (comment || ''));
	    return s;
	  }
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	// If you have no idea what ASN.1 or BER is, see this:
	// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

	var Ber = __webpack_require__(103);



	///--- Exported API

	module.exports = {

	  Ber: Ber,

	  BerReader: Ber.Reader,

	  BerWriter: Ber.Writer

	};


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var errors = __webpack_require__(104);
	var types = __webpack_require__(105);

	var Reader = __webpack_require__(106);
	var Writer = __webpack_require__(107);


	///--- Exports

	module.exports = {

	  Reader: Reader,

	  Writer: Writer

	};

	for (var t in types) {
	  if (types.hasOwnProperty(t))
	    module.exports[t] = types[t];
	}
	for (var e in errors) {
	  if (errors.hasOwnProperty(e))
	    module.exports[e] = errors[e];
	}


/***/ },
/* 104 */
/***/ function(module, exports) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


	module.exports = {

	  newInvalidAsn1Error: function(msg) {
	    var e = new Error();
	    e.name = 'InvalidAsn1Error';
	    e.message = msg || '';
	    return e;
	  }

	};


/***/ },
/* 105 */
/***/ function(module, exports) {

	// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


	module.exports = {
	  EOC: 0,
	  Boolean: 1,
	  Integer: 2,
	  BitString: 3,
	  OctetString: 4,
	  Null: 5,
	  OID: 6,
	  ObjectDescriptor: 7,
	  External: 8,
	  Real: 9, // float
	  Enumeration: 10,
	  PDV: 11,
	  Utf8String: 12,
	  RelativeOID: 13,
	  Sequence: 16,
	  Set: 17,
	  NumericString: 18,
	  PrintableString: 19,
	  T61String: 20,
	  VideotexString: 21,
	  IA5String: 22,
	  UTCTime: 23,
	  GeneralizedTime: 24,
	  GraphicString: 25,
	  VisibleString: 26,
	  GeneralString: 28,
	  UniversalString: 29,
	  CharacterString: 30,
	  BMPString: 31,
	  Constructor: 32,
	  Context: 128
	};


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var assert = __webpack_require__(92);

	var ASN1 = __webpack_require__(105);
	var errors = __webpack_require__(104);


	///--- Globals

	var newInvalidAsn1Error = errors.newInvalidAsn1Error;



	///--- API

	function Reader(data) {
	  if (!data || !Buffer.isBuffer(data))
	    throw new TypeError('data must be a node Buffer');

	  this._buf = data;
	  this._size = data.length;

	  // These hold the "current" state
	  this._len = 0;
	  this._offset = 0;

	  var self = this;
	  this.__defineGetter__('length', function() { return self._len; });
	  this.__defineGetter__('offset', function() { return self._offset; });
	  this.__defineGetter__('remain', function() {
	    return self._size - self._offset;
	  });
	  this.__defineGetter__('buffer', function() {
	    return self._buf.slice(self._offset);
	  });
	}


	/**
	 * Reads a single byte and advances offset; you can pass in `true` to make this
	 * a "peek" operation (i.e., get the byte, but don't advance the offset).
	 *
	 * @param {Boolean} peek true means don't move offset.
	 * @return {Number} the next byte, null if not enough data.
	 */
	Reader.prototype.readByte = function(peek) {
	  if (this._size - this._offset < 1)
	    return null;

	  var b = this._buf[this._offset] & 0xff;

	  if (!peek)
	    this._offset += 1;

	  return b;
	};


	Reader.prototype.peek = function() {
	  return this.readByte(true);
	};


	/**
	 * Reads a (potentially) variable length off the BER buffer.  This call is
	 * not really meant to be called directly, as callers have to manipulate
	 * the internal buffer afterwards.
	 *
	 * As a result of this call, you can call `Reader.length`, until the
	 * next thing called that does a readLength.
	 *
	 * @return {Number} the amount of offset to advance the buffer.
	 * @throws {InvalidAsn1Error} on bad ASN.1
	 */
	Reader.prototype.readLength = function(offset) {
	  if (offset === undefined)
	    offset = this._offset;

	  if (offset >= this._size)
	    return null;

	  var lenB = this._buf[offset++] & 0xff;
	  if (lenB === null)
	    return null;

	  if ((lenB & 0x80) == 0x80) {
	    lenB &= 0x7f;

	    if (lenB == 0)
	      throw newInvalidAsn1Error('Indefinite length not supported');

	    if (lenB > 4)
	      throw newInvalidAsn1Error('encoding too long');

	    if (this._size - offset < lenB)
	      return null;

	    this._len = 0;
	    for (var i = 0; i < lenB; i++)
	      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

	  } else {
	    // Wasn't a variable length
	    this._len = lenB;
	  }

	  return offset;
	};


	/**
	 * Parses the next sequence in this BER buffer.
	 *
	 * To get the length of the sequence, call `Reader.length`.
	 *
	 * @return {Number} the sequence's tag.
	 */
	Reader.prototype.readSequence = function(tag) {
	  var seq = this.peek();
	  if (seq === null)
	    return null;
	  if (tag !== undefined && tag !== seq)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + seq.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  this._offset = o;
	  return seq;
	};


	Reader.prototype.readInt = function() {
	  return this._readTag(ASN1.Integer);
	};


	Reader.prototype.readBoolean = function() {
	  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
	};


	Reader.prototype.readEnumeration = function() {
	  return this._readTag(ASN1.Enumeration);
	};


	Reader.prototype.readString = function(tag, retbuf) {
	  if (!tag)
	    tag = ASN1.OctetString;

	  var b = this.peek();
	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`

	  if (o === null)
	    return null;

	  if (this.length > this._size - o)
	    return null;

	  this._offset = o;

	  if (this.length === 0)
	    return '';

	  var str = this._buf.slice(this._offset, this._offset + this.length);
	  this._offset += this.length;

	  return retbuf ? str : str.toString('utf8');
	};

	Reader.prototype.readOID = function(tag) {
	  if (!tag)
	    tag = ASN1.OID;

	  var b = this.peek();
	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  if (this.length > this._size - o)
	    return null;

	  this._offset = o;

	  var values = [];
	  var value = 0;

	  for (var i = 0; i < this.length; i++) {
	    var byte = this._buf[this._offset++] & 0xff;

	    value <<= 7;
	    value += byte & 0x7f;
	    if ((byte & 0x80) == 0) {
	      values.push(value);
	      value = 0;
	    }
	  }

	  value = values.shift();
	  values.unshift(value % 40);
	  values.unshift((value / 40) >> 0);

	  return values.join('.');
	};


	Reader.prototype._readTag = function(tag) {
	  assert.ok(tag !== undefined);

	  var b = this.peek();

	  if (b === null)
	    return null;

	  if (b !== tag)
	    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
	                              ': got 0x' + b.toString(16));

	  var o = this.readLength(this._offset + 1); // stored in `length`
	  if (o === null)
	    return null;

	  if (this.length > 4)
	    throw newInvalidAsn1Error('Integer too long: ' + this.length);

	  if (this.length > this._size - o)
	    return null;
	  this._offset = o;

	  var fb = this._buf[this._offset++];
	  var value = 0;

	  value = fb & 0x7F;
	  for (var i = 1; i < this.length; i++) {
	    value <<= 8;
	    value |= (this._buf[this._offset++] & 0xff);
	  }

	  if ((fb & 0x80) == 0x80)
	    value = -value;

	  return value;
	};



	///--- Exported API

	module.exports = Reader;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

	var assert = __webpack_require__(92);
	var ASN1 = __webpack_require__(105);
	var errors = __webpack_require__(104);


	///--- Globals

	var newInvalidAsn1Error = errors.newInvalidAsn1Error;

	var DEFAULT_OPTS = {
	  size: 1024,
	  growthFactor: 8
	};


	///--- Helpers

	function merge(from, to) {
	  assert.ok(from);
	  assert.equal(typeof(from), 'object');
	  assert.ok(to);
	  assert.equal(typeof(to), 'object');

	  var keys = Object.getOwnPropertyNames(from);
	  keys.forEach(function(key) {
	    if (to[key])
	      return;

	    var value = Object.getOwnPropertyDescriptor(from, key);
	    Object.defineProperty(to, key, value);
	  });

	  return to;
	}



	///--- API

	function Writer(options) {
	  options = merge(DEFAULT_OPTS, options || {});

	  this._buf = new Buffer(options.size || 1024);
	  this._size = this._buf.length;
	  this._offset = 0;
	  this._options = options;

	  // A list of offsets in the buffer where we need to insert
	  // sequence tag/len pairs.
	  this._seq = [];

	  var self = this;
	  this.__defineGetter__('buffer', function() {
	    if (self._seq.length)
	      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');

	    return self._buf.slice(0, self._offset);
	  });
	}


	Writer.prototype.writeByte = function(b) {
	  if (typeof(b) !== 'number')
	    throw new TypeError('argument must be a Number');

	  this._ensure(1);
	  this._buf[this._offset++] = b;
	};


	Writer.prototype.writeInt = function(i, tag) {
	  if (typeof(i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Integer;

	  var sz = 4;

	  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&
	         (sz > 1)) {
	    sz--;
	    i <<= 8;
	  }

	  if (sz > 4)
	    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

	  this._ensure(2 + sz);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = sz;

	  while (sz-- > 0) {
	    this._buf[this._offset++] = ((i & 0xff000000) >> 24);
	    i <<= 8;
	  }

	};


	Writer.prototype.writeNull = function() {
	  this.writeByte(ASN1.Null);
	  this.writeByte(0x00);
	};


	Writer.prototype.writeEnumeration = function(i, tag) {
	  if (typeof(i) !== 'number')
	    throw new TypeError('argument must be a Number');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Enumeration;

	  return this.writeInt(i, tag);
	};


	Writer.prototype.writeBoolean = function(b, tag) {
	  if (typeof(b) !== 'boolean')
	    throw new TypeError('argument must be a Boolean');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Boolean;

	  this._ensure(3);
	  this._buf[this._offset++] = tag;
	  this._buf[this._offset++] = 0x01;
	  this._buf[this._offset++] = b ? 0xff : 0x00;
	};


	Writer.prototype.writeString = function(s, tag) {
	  if (typeof(s) !== 'string')
	    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.OctetString;

	  var len = Buffer.byteLength(s);
	  this.writeByte(tag);
	  this.writeLength(len);
	  if (len) {
	    this._ensure(len);
	    this._buf.write(s, this._offset);
	    this._offset += len;
	  }
	};


	Writer.prototype.writeBuffer = function(buf, tag) {
	  if (typeof(tag) !== 'number')
	    throw new TypeError('tag must be a number');
	  if (!Buffer.isBuffer(buf))
	    throw new TypeError('argument must be a buffer');

	  this.writeByte(tag);
	  this.writeLength(buf.length);
	  this._ensure(buf.length);
	  buf.copy(this._buf, this._offset, 0, buf.length);
	  this._offset += buf.length;
	};


	Writer.prototype.writeStringArray = function(strings) {
	  if ((!strings instanceof Array))
	    throw new TypeError('argument must be an Array[String]');

	  var self = this;
	  strings.forEach(function(s) {
	    self.writeString(s);
	  });
	};

	// This is really to solve DER cases, but whatever for now
	Writer.prototype.writeOID = function(s, tag) {
	  if (typeof(s) !== 'string')
	    throw new TypeError('argument must be a string');
	  if (typeof(tag) !== 'number')
	    tag = ASN1.OID;

	  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
	    throw new Error('argument is not a valid OID string');

	  function encodeOctet(bytes, octet) {
	    if (octet < 128) {
	        bytes.push(octet);
	    } else if (octet < 16384) {
	        bytes.push((octet >>> 7) | 0x80);
	        bytes.push(octet & 0x7F);
	    } else if (octet < 2097152) {
	      bytes.push((octet >>> 14) | 0x80);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else if (octet < 268435456) {
	      bytes.push((octet >>> 21) | 0x80);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    } else {
	      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
	      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
	      bytes.push(octet & 0x7F);
	    }
	  }

	  var tmp = s.split('.');
	  var bytes = [];
	  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
	  tmp.slice(2).forEach(function(b) {
	    encodeOctet(bytes, parseInt(b, 10));
	  });

	  var self = this;
	  this._ensure(2 + bytes.length);
	  this.writeByte(tag);
	  this.writeLength(bytes.length);
	  bytes.forEach(function(b) {
	    self.writeByte(b);
	  });
	};


	Writer.prototype.writeLength = function(len) {
	  if (typeof(len) !== 'number')
	    throw new TypeError('argument must be a Number');

	  this._ensure(4);

	  if (len <= 0x7f) {
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xff) {
	    this._buf[this._offset++] = 0x81;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffff) {
	    this._buf[this._offset++] = 0x82;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else if (len <= 0xffffff) {
	    this._shift(start, len, 1);
	    this._buf[this._offset++] = 0x83;
	    this._buf[this._offset++] = len >> 16;
	    this._buf[this._offset++] = len >> 8;
	    this._buf[this._offset++] = len;
	  } else {
	    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
	  }
	};

	Writer.prototype.startSequence = function(tag) {
	  if (typeof(tag) !== 'number')
	    tag = ASN1.Sequence | ASN1.Constructor;

	  this.writeByte(tag);
	  this._seq.push(this._offset);
	  this._ensure(3);
	  this._offset += 3;
	};


	Writer.prototype.endSequence = function() {
	  var seq = this._seq.pop();
	  var start = seq + 3;
	  var len = this._offset - start;

	  if (len <= 0x7f) {
	    this._shift(start, len, -2);
	    this._buf[seq] = len;
	  } else if (len <= 0xff) {
	    this._shift(start, len, -1);
	    this._buf[seq] = 0x81;
	    this._buf[seq + 1] = len;
	  } else if (len <= 0xffff) {
	    this._buf[seq] = 0x82;
	    this._buf[seq + 1] = len >> 8;
	    this._buf[seq + 2] = len;
	  } else if (len <= 0xffffff) {
	    this._shift(start, len, 1);
	    this._buf[seq] = 0x83;
	    this._buf[seq + 1] = len >> 16;
	    this._buf[seq + 2] = len >> 8;
	    this._buf[seq + 3] = len;
	  } else {
	    throw new InvalidAsn1Error('Sequence too long');
	  }
	};


	Writer.prototype._shift = function(start, len, shift) {
	  assert.ok(start !== undefined);
	  assert.ok(len !== undefined);
	  assert.ok(shift);

	  this._buf.copy(this._buf, start + shift, start, start + len);
	  this._offset += shift;
	};

	Writer.prototype._ensure = function(len) {
	  assert.ok(len);

	  if (this._size - this._offset < len) {
	    var sz = this._size * this._options.growthFactor;
	    if (sz - this._offset < len)
	      sz += len;

	    var buf = new Buffer(sz);

	    this._buf.copy(buf, 0, 0, this._offset);
	    this._buf = buf;
	    this._size = sz;
	  }
	};



	///--- Exported API

	module.exports = Writer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
	 * rm - Feb 2011
	 * ctype.js
	 *
	 * This module provides a simple abstraction towards reading and writing
	 * different types of binary data. It is designed to use ctio.js and provide a
	 * richer and more expressive API on top of it.
	 *
	 * By default we support the following as built in basic types:
	 *	int8_t
	 *	int16_t
	 *	int32_t
	 *	uint8_t
	 *	uint16_t
	 *	uint32_t
	 *	uint64_t
	 *	float
	 *	double
	 *	char
	 *	char[]
	 *
	 * Each type is returned as a Number, with the exception of char and char[]
	 * which are returned as Node Buffers. A char is considered a uint8_t.
	 *
	 * Requests to read and write data are specified as an array of JSON objects.
	 * This is also the same way that one declares structs. Even if just a single
	 * value is requested, it must be done as a struct. The array order determines
	 * the order that we try and read values. Each entry has the following format
	 * with values marked with a * being optional.
	 *
	 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
	 *
	 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
	 * value. Value is defined when we're writing out data, otherwise it's ignored.
	 *
	 */

	var mod_ctf = __webpack_require__(109);
	var mod_ctio = __webpack_require__(110);
	var mod_assert = __webpack_require__(92);

	/*
	 * This is the set of basic types that we support.
	 *
	 *	read		The function to call to read in a value from a buffer
	 *
	 *	write		The function to call to write a value to a buffer
	 *
	 */
	var deftypes = {
	    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
	    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
	    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
	    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
	    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
	    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
	    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
	    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
	    'float': { read: ctReadFloat, write: ctWriteFloat },
	    'double': { read: ctReadDouble, write: ctWriteDouble },
	    'char': { read: ctReadChar, write: ctWriteChar },
	    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
	};

	/*
	 * The following are wrappers around the CType IO low level API. They encode
	 * knowledge about the size and return something in the expected format.
	 */
	function ctReadUint8(endian, buffer, offset)
	{
		var val = mod_ctio.ruint8(buffer, endian, offset);
		return ({ value: val, size: 1 });
	}

	function ctReadUint16(endian, buffer, offset)
	{
		var val = mod_ctio.ruint16(buffer, endian, offset);
		return ({ value: val, size: 2 });
	}

	function ctReadUint32(endian, buffer, offset)
	{
		var val = mod_ctio.ruint32(buffer, endian, offset);
		return ({ value: val, size: 4 });
	}

	function ctReadUint64(endian, buffer, offset)
	{
		var val = mod_ctio.ruint64(buffer, endian, offset);
		return ({ value: val, size: 8 });
	}

	function ctReadSint8(endian, buffer, offset)
	{
		var val = mod_ctio.rsint8(buffer, endian, offset);
		return ({ value: val, size: 1 });
	}

	function ctReadSint16(endian, buffer, offset)
	{
		var val = mod_ctio.rsint16(buffer, endian, offset);
		return ({ value: val, size: 2 });
	}

	function ctReadSint32(endian, buffer, offset)
	{
		var val = mod_ctio.rsint32(buffer, endian, offset);
		return ({ value: val, size: 4 });
	}

	function ctReadSint64(endian, buffer, offset)
	{
		var val = mod_ctio.rsint64(buffer, endian, offset);
		return ({ value: val, size: 8 });
	}

	function ctReadFloat(endian, buffer, offset)
	{
		var val = mod_ctio.rfloat(buffer, endian, offset);
		return ({ value: val, size: 4 });
	}

	function ctReadDouble(endian, buffer, offset)
	{
		var val = mod_ctio.rdouble(buffer, endian, offset);
		return ({ value: val, size: 8 });
	}

	/*
	 * Reads a single character into a node buffer
	 */
	function ctReadChar(endian, buffer, offset)
	{
		var res = new Buffer(1);
		res[0] = mod_ctio.ruint8(buffer, endian, offset);
		return ({ value: res, size: 1 });
	}

	function ctReadCharArray(length, endian, buffer, offset)
	{
		var ii;
		var res = new Buffer(length);

		for (ii = 0; ii < length; ii++)
			res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

		return ({ value: res, size: length });
	}

	function ctWriteUint8(value, endian, buffer, offset)
	{
		mod_ctio.wuint8(value, endian, buffer, offset);
		return (1);
	}

	function ctWriteUint16(value, endian, buffer, offset)
	{
		mod_ctio.wuint16(value, endian, buffer, offset);
		return (2);
	}

	function ctWriteUint32(value, endian, buffer, offset)
	{
		mod_ctio.wuint32(value, endian, buffer, offset);
		return (4);
	}

	function ctWriteUint64(value, endian, buffer, offset)
	{
		mod_ctio.wuint64(value, endian, buffer, offset);
		return (8);
	}

	function ctWriteSint8(value, endian, buffer, offset)
	{
		mod_ctio.wsint8(value, endian, buffer, offset);
		return (1);
	}

	function ctWriteSint16(value, endian, buffer, offset)
	{
		mod_ctio.wsint16(value, endian, buffer, offset);
		return (2);
	}

	function ctWriteSint32(value, endian, buffer, offset)
	{
		mod_ctio.wsint32(value, endian, buffer, offset);
		return (4);
	}

	function ctWriteSint64(value, endian, buffer, offset)
	{
		mod_ctio.wsint64(value, endian, buffer, offset);
		return (8);
	}

	function ctWriteFloat(value, endian, buffer, offset)
	{
		mod_ctio.wfloat(value, endian, buffer, offset);
		return (4);
	}

	function ctWriteDouble(value, endian, buffer, offset)
	{
		mod_ctio.wdouble(value, endian, buffer, offset);
		return (8);
	}

	/*
	 * Writes a single character into a node buffer
	 */
	function ctWriteChar(value, endian, buffer, offset)
	{
		if (!(value instanceof Buffer))
			throw (new Error('Input must be a buffer'));

		mod_ctio.ruint8(value[0], endian, buffer, offset);
		return (1);
	}

	/*
	 * We're going to write 0s into the buffer if the string is shorter than the
	 * length of the array.
	 */
	function ctWriteCharArray(value, length, endian, buffer, offset)
	{
		var ii;

		if (!(value instanceof Buffer))
			throw (new Error('Input must be a buffer'));

		if (value.length > length)
			throw (new Error('value length greater than array length'));

		for (ii = 0; ii < value.length && ii < length; ii++)
			mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

		for (; ii < length; ii++)
			mod_ctio.wuint8(0, endian, offset + ii);


		return (length);
	}

	/*
	 * Each parser has their own set of types. We want to make sure that they each
	 * get their own copy as they may need to modify it.
	 */
	function ctGetBasicTypes()
	{
		var ret = {};
		var key;
		for (key in deftypes)
			ret[key] = deftypes[key];

		return (ret);
	}

	/*
	 * Given a string in the form of type[length] we want to split this into an
	 * object that extracts that information. We want to note that we could possibly
	 * have nested arrays so this should only check the furthest one. It may also be
	 * the case that we have no [] pieces, in which case we just return the current
	 * type.
	 */
	function ctParseType(str)
	{
		var begInd, endInd;
		var type, len;
		if (typeof (str) != 'string')
			throw (new Error('type must be a Javascript string'));

		endInd = str.lastIndexOf(']');
		if (endInd == -1) {
			if (str.lastIndexOf('[') != -1)
				throw (new Error('found invalid type with \'[\' but ' +
				    'no corresponding \']\''));

			return ({ type: str });
		}

		begInd = str.lastIndexOf('[');
		if (begInd == -1)
			throw (new Error('found invalid type with \']\' but ' +
			    'no corresponding \'[\''));

		if (begInd >= endInd)
			throw (new Error('malformed type, \']\' appears before \'[\''));

		type = str.substring(0, begInd);
		len = str.substring(begInd + 1, endInd);

		return ({ type: type, len: len });
	}

	/*
	 * Given a request validate that all of the fields for it are valid and make
	 * sense. This includes verifying the following notions:
	 *  - Each type requested is present in types
	 *  - Only allow a name for a field to be specified once
	 *  - If an array is specified, validate that the requested field exists and
	 *    comes before it.
	 *  - If fields is defined, check that each entry has the occurrence of field
	 */
	function ctCheckReq(def, types, fields)
	{
		var ii, jj;
		var req, keys, key;
		var found = {};

		if (!(def instanceof Array))
			throw (new Error('definition is not an array'));

		if (def.length === 0)
			throw (new Error('definition must have at least one element'));

		for (ii = 0; ii < def.length; ii++) {
			req = def[ii];
			if (!(req instanceof Object))
				throw (new Error('definition must be an array of' +
				    'objects'));

			keys = Object.keys(req);
			if (keys.length != 1)
				throw (new Error('definition entry must only have ' +
				    'one key'));

			if (keys[0] in found)
				throw (new Error('Specified name already ' +
				    'specified: ' + keys[0]));

			if (!('type' in req[keys[0]]))
				throw (new Error('missing required type definition'));

			key = ctParseType(req[keys[0]]['type']);

			/*
			 * We may have nested arrays, we need to check the validity of
			 * the types until the len field is undefined in key. However,
			 * each time len is defined we need to verify it is either an
			 * integer or corresponds to an already seen key.
			 */
			while (key['len'] !== undefined) {
				if (isNaN(parseInt(key['len'], 10))) {
					if (!(key['len'] in found))
						throw (new Error('Given an array ' +
						    'length without a matching type'));

				}

				key = ctParseType(key['type']);
			}

			/* Now we can validate if the type is valid */
			if (!(key['type'] in types))
				throw (new Error('type not found or typdefed: ' +
				    key['type']));

			/* Check for any required fields */
			if (fields !== undefined) {
				for (jj = 0; jj < fields.length; jj++) {
					if (!(fields[jj] in req[keys[0]]))
						throw (new Error('Missing required ' +
						    'field: ' + fields[jj]));
				}
			}

			found[keys[0]] = true;
		}
	}


	/*
	 * Create a new instance of the parser. Each parser has its own store of
	 * typedefs and endianness. Conf is an object with the following required
	 * values:
	 *
	 *	endian		Either 'big' or 'little' do determine the endianness we
	 *			want to read from or write to.
	 *
	 * And the following optional values:
	 *
	 * 	char-type	Valid options here are uint8 and int8. If uint8 is
	 * 			specified this changes the default behavior of a single
	 * 			char from being a buffer of a single character to being
	 * 			a uint8_t. If int8, it becomes an int8_t instead.
	 */
	function CTypeParser(conf)
	{
		if (!conf) throw (new Error('missing required argument'));

		if (!('endian' in conf))
			throw (new Error('missing required endian value'));

		if (conf['endian'] != 'big' && conf['endian'] != 'little')
			throw (new Error('Invalid endian type'));

		if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
		    conf['char-type'] != 'int8'))
			throw (new Error('invalid option for char-type: ' +
			    conf['char-type']));

		this.endian = conf['endian'];
		this.types = ctGetBasicTypes();

		/*
		 * There may be a more graceful way to do this, but this will have to
		 * serve.
		 */
		if ('char-type' in conf && conf['char-type'] == 'uint8')
			this.types['char'] = this.types['uint8_t'];

		if ('char-type' in conf && conf['char-type'] == 'int8')
			this.types['char'] = this.types['int8_t'];
	}

	/*
	 * Sets the current endian value for the Parser. If the value is not valid,
	 * throws an Error.
	 *
	 *	endian		Either 'big' or 'little' do determine the endianness we
	 *			want to read from or write to.
	 *
	 */
	CTypeParser.prototype.setEndian = function (endian)
	{
		if (endian != 'big' && endian != 'little')
			throw (new Error('invalid endian type, must be big or ' +
			    'little'));

		this.endian = endian;
	};

	/*
	 * Returns the current value of the endian value for the parser.
	 */
	CTypeParser.prototype.getEndian = function ()
	{
		return (this.endian);
	};

	/*
	 * A user has requested to add a type, let us honor their request. Yet, if their
	 * request doth spurn us, send them unto the Hells which Dante describes.
	 *
	 * 	name		The string for the type definition we're adding
	 *
	 *	value		Either a string that is a type/array name or an object
	 *			that describes a struct.
	 */
	CTypeParser.prototype.typedef = function (name, value)
	{
		var type;

		if (name === undefined)
			throw (new (Error('missing required typedef argument: name')));

		if (value === undefined)
			throw (new (Error('missing required typedef argument: value')));

		if (typeof (name) != 'string')
			throw (new (Error('the name of a type must be a string')));

		type = ctParseType(name);

		if (type['len'] !== undefined)
			throw (new Error('Cannot have an array in the typedef name'));

		if (name in this.types)
			throw (new Error('typedef name already present: ' + name));

		if (typeof (value) != 'string' && !(value instanceof Array))
			throw (new Error('typedef value must either be a string or ' +
			    'struct'));

		if (typeof (value) == 'string') {
			type = ctParseType(value);
			if (type['len'] !== undefined) {
				if (isNaN(parseInt(type['len'], 10)))
					throw (new (Error('typedef value must use ' +
					    'fixed size array when outside of a ' +
					    'struct')));
			}

			this.types[name] = value;
		} else {
			/* We have a struct, validate it */
			ctCheckReq(value, this.types);
			this.types[name] = value;
		}
	};

	/*
	 * Include all of the typedefs, but none of the built in types. This should be
	 * treated as read-only.
	 */
	CTypeParser.prototype.lstypes = function ()
	{
		var key;
		var ret = {};

		for (key in this.types) {
			if (key in deftypes)
				continue;
			ret[key] = this.types[key];
		}

		return (ret);
	};

	/*
	 * Given a type string that may have array types that aren't numbers, try and
	 * fill them in from the values object. The object should be of the format where
	 * indexing into it should return a number for that type.
	 *
	 *	str		The type string
	 *
	 *	values		An object that can be used to fulfill type information
	 */
	function ctResolveArray(str, values)
	{
		var ret = '';
		var type = ctParseType(str);

		while (type['len'] !== undefined) {
			if (isNaN(parseInt(type['len'], 10))) {
				if (typeof (values[type['len']]) != 'number')
					throw (new Error('cannot sawp in non-number ' +
					    'for array value'));
				ret = '[' + values[type['len']] + ']' + ret;
			} else {
				ret = '[' + type['len'] + ']' + ret;
			}
			type = ctParseType(type['type']);
		}

		ret = type['type'] + ret;

		return (ret);
	}

	/*
	 * [private] Either the typedef resolves to another type string or to a struct.
	 * If it resolves to a struct, we just pass it off to read struct. If not, we
	 * can just pass it off to read entry.
	 */
	CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
	    offset, value)
	{
		var pt;

		mod_assert.ok(type in this.types);
		if (typeof (this.types[type]) == 'string') {
			pt = ctParseType(this.types[type]);
			if (dispatch == 'read')
				return (this.readEntry(pt, buffer, offset));
			else if (dispatch == 'write')
				return (this.writeEntry(value, pt, buffer, offset));
			else
				throw (new Error('invalid dispatch type to ' +
				    'resolveTypedef'));
		} else {
			if (dispatch == 'read')
				return (this.readStruct(this.types[type], buffer,
				    offset));
			else if (dispatch == 'write')
				return (this.writeStruct(value, this.types[type],
				    buffer, offset));
			else
				throw (new Error('invalid dispatch type to ' +
				    'resolveTypedef'));
		}

	};

	/*
	 * [private] Try and read in the specific entry.
	 */
	CTypeParser.prototype.readEntry = function (type, buffer, offset)
	{
		var parse, len;

		/*
		 * Because we want to special case char[]s this is unfortunately
		 * a bit uglier than it really should be. We want to special
		 * case char[]s so that we return a node buffer, thus they are a
		 * first class type where as all other arrays just call into a
		 * generic array routine which calls their data-specific routine
		 * the specified number of times.
		 *
		 * The valid dispatch options we have are:
		 *  - Array and char => char[] handler
		 *  - Generic array handler
		 *  - Generic typedef handler
		 *  - Basic type handler
		 */
		if (type['len'] !== undefined) {
			len = parseInt(type['len'], 10);
			if (isNaN(len))
				throw (new Error('somehow got a non-numeric length'));

			if (type['type'] == 'char')
				parse = this.types['char[]']['read'](len,
				    this.endian, buffer, offset);
			else
				parse = this.readArray(type['type'],
				    len, buffer, offset);
		} else {
			if (type['type'] in deftypes)
				parse = this.types[type['type']]['read'](this.endian,
				    buffer, offset);
			else
				parse = this.resolveTypedef(type['type'], 'read',
				    buffer, offset);
		}

		return (parse);
	};

	/*
	 * [private] Read an array of data
	 */
	CTypeParser.prototype.readArray = function (type, length, buffer, offset)
	{
		var ii, ent, pt;
		var baseOffset = offset;
		var ret = new Array(length);
		pt = ctParseType(type);

		for (ii = 0; ii < length; ii++) {
			ent = this.readEntry(pt, buffer, offset);
			offset += ent['size'];
			ret[ii] = ent['value'];
		}

		return ({ value: ret, size: offset - baseOffset });
	};

	/*
	 * [private] Read a single struct in.
	 */
	CTypeParser.prototype.readStruct = function (def, buffer, offset)
	{
		var parse, ii, type, entry, key;
		var baseOffset = offset;
		var ret = {};

		/* Walk it and handle doing what's necessary */
		for (ii = 0; ii < def.length; ii++) {
			key = Object.keys(def[ii])[0];
			entry = def[ii][key];

			/* Resolve all array values */
			type = ctParseType(ctResolveArray(entry['type'], ret));

			if ('offset' in entry)
				offset = baseOffset + entry['offset'];

			parse = this.readEntry(type, buffer, offset);

			offset += parse['size'];
			ret[key] = parse['value'];
		}

		return ({ value: ret, size: (offset-baseOffset)});
	};

	/*
	 * This is what we were born to do. We read the data from a buffer and return it
	 * in an object whose keys match the values from the object.
	 *
	 *	def		The array definition of the data to read in
	 *
	 *	buffer		The buffer to read data from
	 *
	 *	offset		The offset to start writing to
	 *
	 * Returns an object where each key corresponds to an entry in def and the value
	 * is the read value.
	 */
	CTypeParser.prototype.readData = function (def, buffer, offset)
	{
		/* Sanity check for arguments */
		if (def === undefined)
			throw (new Error('missing definition for what we should be' +
			    'parsing'));

		if (buffer === undefined)
			throw (new Error('missing buffer for what we should be ' +
			    'parsing'));

		if (offset === undefined)
			throw (new Error('missing offset for what we should be ' +
			    'parsing'));

		/* Sanity check the object definition */
		ctCheckReq(def, this.types);

		return (this.readStruct(def, buffer, offset)['value']);
	};

	/*
	 * [private] Write out an array of data
	 */
	CTypeParser.prototype.writeArray = function (value, type, length, buffer,
	    offset)
	{
		var ii, pt;
		var baseOffset = offset;
		if (!(value instanceof Array))
			throw (new Error('asked to write an array, but value is not ' +
			    'an array'));

		if (value.length != length)
			throw (new Error('asked to write array of length ' + length +
			    ' but that does not match value length: ' + value.length));

		pt = ctParseType(type);
		for (ii = 0; ii < length; ii++)
			offset += this.writeEntry(value[ii], pt, buffer, offset);

		return (offset - baseOffset);
	};

	/*
	 * [private] Write the specific entry
	 */
	CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
	{
		var len, ret;

		if (type['len'] !== undefined) {
			len = parseInt(type['len'], 10);
			if (isNaN(len))
				throw (new Error('somehow got a non-numeric length'));

			if (type['type'] == 'char')
				ret = this.types['char[]']['write'](value, len,
				    this.endian, buffer, offset);
			else
				ret = this.writeArray(value, type['type'],
				    len, buffer, offset);
		} else {
			if (type['type'] in deftypes)
				ret = this.types[type['type']]['write'](value,
				    this.endian, buffer, offset);
			else
				ret = this.resolveTypedef(type['type'], 'write',
				    buffer, offset, value);
		}

		return (ret);
	};

	/*
	 * [private] Write a single struct out.
	 */
	CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
	{
		var ii, entry, type, key;
		var baseOffset = offset;
		var vals = {};

		for (ii = 0; ii < def.length; ii++) {
			key = Object.keys(def[ii])[0];
			entry = def[ii][key];

			type = ctParseType(ctResolveArray(entry['type'], vals));

			if ('offset' in entry)
				offset = baseOffset + entry['offset'];

			offset += this.writeEntry(value[ii], type, buffer, offset);
			/* Now that we've written it out, we can use it for arrays */
			vals[key] = value[ii];
		}

		return (offset);
	};

	/*
	 * Unfortunately, we're stuck with the sins of an initial poor design. Because
	 * of that, we are going to have to support the old way of writing data via
	 * writeData. There we insert the values that you want to write into the
	 * definition. A little baroque. Internally, we use the new model. So we need to
	 * just get those values out of there. But to maintain the principle of least
	 * surprise, we're not going to modify the input data.
	 */
	function getValues(def)
	{
		var ii, out, key;
		out = [];
		for (ii = 0; ii < def.length; ii++) {
			key = Object.keys(def[ii])[0];
			mod_assert.ok('value' in def[ii][key]);
			out.push(def[ii][key]['value']);
		}

		return (out);
	}

	/*
	 * This is the second half of what we were born to do, write out the data
	 * itself. Historically this function required you to put your values in the
	 * definition section. This was not the smartest thing to do and a bit of an
	 * oversight to be honest. As such, this function now takes a values argument.
	 * If values is non-null and non-undefined, it will be used to determine the
	 * values. This means that the old method is still supported, but is no longer
	 * acceptable.
	 *
	 *	def		The array definition of the data to write out with
	 *			values
	 *
	 *	buffer		The buffer to write to
	 *
	 *	offset		The offset in the buffer to write to
	 *
	 *	values		An array of values to write.
	 */
	CTypeParser.prototype.writeData = function (def, buffer, offset, values)
	{
		var hv;

		if (def === undefined)
			throw (new Error('missing definition for what we should be' +
			    'parsing'));

		if (buffer === undefined)
			throw (new Error('missing buffer for what we should be ' +
			    'parsing'));

		if (offset === undefined)
			throw (new Error('missing offset for what we should be ' +
			    'parsing'));

		hv = (values != null && values != undefined);
		if (hv) {
			if (!Array.isArray(values))
				throw (new Error('missing values for writing'));
			ctCheckReq(def, this.types);
		} else {
			ctCheckReq(def, this.types, [ 'value' ]);
		}

		this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
	};

	/*
	 * Functions to go to and from 64 bit numbers in a way that is compatible with
	 * Javascript limitations. There are two sets. One where the user is okay with
	 * an approximation and one where they are definitely not okay with an
	 * approximation.
	 */

	/*
	 * Attempts to convert an array of two integers returned from rsint64 / ruint64
	 * into an absolute 64 bit number. If however the value would exceed 2^52 this
	 * will instead throw an error. The mantissa in a double is a 52 bit number and
	 * rather than potentially give you a value that is an approximation this will
	 * error. If you would rather an approximation, please see toApprox64.
	 *
	 *	val		An array of two 32-bit integers
	 */
	function toAbs64(val)
	{
		if (val === undefined)
			throw (new Error('missing required arg: value'));

		if (!Array.isArray(val))
			throw (new Error('value must be an array'));

		if (val.length != 2)
			throw (new Error('value must be an array of length 2'));

		/* We have 20 bits worth of precision in this range */
		if (val[0] >= 0x100000)
			throw (new Error('value would become approximated'));

		return (val[0] * Math.pow(2, 32) + val[1]);
	}

	/*
	 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
	 * to a value as close as it can. Note that Javascript stores all numbers as a
	 * double and the mantissa only has 52 bits. Thus this version may approximate
	 * the value.
	 *
	 *	val		An array of two 32-bit integers
	 */
	function toApprox64(val)
	{
		if (val === undefined)
			throw (new Error('missing required arg: value'));

		if (!Array.isArray(val))
			throw (new Error('value must be an array'));

		if (val.length != 2)
			throw (new Error('value must be an array of length 2'));

		return (Math.pow(2, 32) * val[0] + val[1]);
	}

	function parseCTF(json, conf)
	{
		var ctype = new CTypeParser(conf);
		mod_ctf.ctfParseJson(json, ctype);

		return (ctype);
	}

	/*
	 * Export the few things we actually want to. Currently this is just the CType
	 * Parser and ctio.
	 */
	exports.Parser = CTypeParser;
	exports.toAbs64 = toAbs64;
	exports.toApprox64 = toApprox64;

	exports.parseCTF = parseCTF;

	exports.ruint8 = mod_ctio.ruint8;
	exports.ruint16 = mod_ctio.ruint16;
	exports.ruint32 = mod_ctio.ruint32;
	exports.ruint64 = mod_ctio.ruint64;
	exports.wuint8 = mod_ctio.wuint8;
	exports.wuint16 = mod_ctio.wuint16;
	exports.wuint32 = mod_ctio.wuint32;
	exports.wuint64 = mod_ctio.wuint64;

	exports.rsint8 = mod_ctio.rsint8;
	exports.rsint16 = mod_ctio.rsint16;
	exports.rsint32 = mod_ctio.rsint32;
	exports.rsint64 = mod_ctio.rsint64;
	exports.wsint8 = mod_ctio.wsint8;
	exports.wsint16 = mod_ctio.wsint16;
	exports.wsint32 = mod_ctio.wsint32;
	exports.wsint64 = mod_ctio.wsint64;

	exports.rfloat = mod_ctio.rfloat;
	exports.rdouble = mod_ctio.rdouble;
	exports.wfloat = mod_ctio.wfloat;
	exports.wdouble = mod_ctio.wdouble;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * ctf.js
	 *
	 * Understand and parse all of the different JSON formats of CTF data and
	 * translate that into a series of node-ctype friendly pieces. The reason for
	 * the abstraction is to handle different changes in the file format.
	 *
	 * We have to be careful here that we don't end up using a name that is already
	 * a built in type.
	 */
	var mod_assert = __webpack_require__(92);
	var ASSERT = mod_assert.ok;

	var ctf_versions = [ '1.0' ];
	var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
	var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
	    'uint32_t', 'float', 'double' ];

	function ctfParseInteger(entry, ctype)
	{
		var name, sign, len, type;

		name = entry['name'];
		if (!('signed' in entry['integer']))
			throw (new Error('Malformed CTF JSON: integer missing ' +
			    'signed value'));


		if (!('length' in entry['integer']))
			throw (new Error('Malformed CTF JSON: integer missing ' +
			    'length value'));

		sign = entry['integer']['signed'];
		len = entry['integer']['length'];
		type = null;

		if (sign && len == 1)
			type = 'int8_t';
		else if (len == 1)
			type = 'uint8_t';
		else if (sign && len == 2)
			type = 'int16_t';
		else if (len == 2)
			type = 'uint16_t';
		else if (sign && len == 4)
			type = 'int32_t';
		else if (len == 4)
			type = 'uint32_t';
		else if (sign && len == 8)
			type = 'int64_t';
		else if (len == 8)
			type = 'uint64_t';

		if (type === null)
			throw (new Error('Malformed CTF JSON: integer has ' +
			    'unsupported length and sign - ' + len + '/' + sign));

		/*
		 * This means that this is the same as one of our built in types. If
		 * that's the case defining it would be an error. So instead of trying
		 * to typedef it, we'll return here.
		 */
		if (name == type)
			return;

		if (name == 'char') {
			ASSERT(type == 'int8_t');
			return;
		}

		ctype.typedef(name, type);
	}

	function ctfParseFloat(entry, ctype)
	{
		var name, len;

		name = entry['name'];
		if (!('length' in entry['float']))
			throw (new Error('Malformed CTF JSON: float missing ' +
			    'length value'));

		len = entry['float']['length'];
		if (len != 4 && len != 8)
			throw (new Error('Malformed CTF JSON: float has invalid ' +
			    'length value'));

		if (len == 4) {
			if (name == 'float')
				return;
			ctype.typedef(name, 'float');
		} else if (len == 8) {
			if (name == 'double')
				return;
			ctype.typedef(name, 'double');
		}
	}

	function ctfParseTypedef(entry, ctype)
	{
		var name, type, ii;

		name = entry['name'];
		if (typeof (entry['typedef']) != 'string')
			throw (new Error('Malformed CTF JSON: typedef value in not ' +
			    'a string'));

		type = entry['typedef'];

		/*
		 * We need to ensure that we're not looking at type that's one of our
		 * built in types. Traditionally in C a uint32_t would be a typedef to
		 * some kind of integer. However, those size types are built ins.
		 */
		for (ii = 0; ii < ctf_deftypes.length; ii++) {
			if (name == ctf_deftypes[ii])
				return;
		}

		ctype.typedef(name, type);
	}

	function ctfParseStruct(entry, ctype)
	{
		var name, type, ii, val, index, member, push;

		member = [];
		if (!Array.isArray(entry['struct']))
			throw (new Error('Malformed CTF JSON: struct value is not ' +
			    'an array'));

		for (ii = 0; ii < entry['struct'].length; ii++) {
			val = entry['struct'][ii];
			if (!('name' in val))
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'missing name'));

			if (!('type' in val))
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'missing type'));

			if (typeof (val['name']) != 'string')
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'name isn\'t a string'));

			if (typeof (val['type']) != 'string')
				throw (new Error('Malformed CTF JSON: struct member ' +
				    'type isn\'t a string'));

			/*
			 * CTF version 2 specifies array names as <type> [<num>] where
			 * as node-ctype does this as <type>[<num>].
			 */
			name = val['name'];
			type = val['type'];
			index = type.indexOf(' [');
			if (index != -1) {
				type = type.substring(0, index) +
				    type.substring(index + 1, type.length);
			}
			push = {};
			push[name] = { 'type': type };
			member.push(push);
		}

		name = entry['name'];
		ctype.typedef(name, member);
	}

	function ctfParseEntry(entry, ctype)
	{
		var ii, found;

		if (!('name' in entry))
			throw (new Error('Malformed CTF JSON: entry missing "name" ' +
			    'section'));

		for (ii = 0; ii < ctf_entries.length; ii++) {
			if (ctf_entries[ii] in entry)
				found++;
		}

		if (found === 0)
			throw (new Error('Malformed CTF JSON: found no entries'));

		if (found >= 2)
			throw (new Error('Malformed CTF JSON: found more than one ' +
			    'entry'));

		if ('integer' in entry) {
			ctfParseInteger(entry, ctype);
			return;
		}

		if ('float' in entry) {
			ctfParseFloat(entry, ctype);
			return;
		}

		if ('typedef' in entry) {
			ctfParseTypedef(entry, ctype);
			return;
		}

		if ('struct' in entry) {
			ctfParseStruct(entry, ctype);
			return;
		}

		ASSERT(false, 'shouldn\'t reach here');
	}

	function ctfParseJson(json, ctype)
	{
		var version, ii;

		ASSERT(json);
		ASSERT(ctype);
		if (!('metadata' in json))
			throw (new Error('Invalid CTF JSON: missing metadata section'));

		if (!('ctf2json_version' in json['metadata']))
			throw (new Error('Invalid CTF JSON: missing ctf2json_version'));

		version = json['metadata']['ctf2json_version'];
		for (ii = 0; ii < ctf_versions.length; ii++) {
			if (ctf_versions[ii] == version)
				break;
		}

		if (ii == ctf_versions.length)
			throw (new Error('Unsuported ctf2json_version: ' + version));

		if (!('data' in json))
			throw (new Error('Invalid CTF JSON: missing data section'));

		if (!Array.isArray(json['data']))
			throw (new Error('Malformed CTF JSON: data section is not ' +
			    'an array'));

		for (ii = 0; ii < json['data'].length; ii++)
			ctfParseEntry(json['data'][ii], ctype);
	}

	exports.ctfParseJson = ctfParseJson;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * rm - Feb 2011
	 * ctio.js:
	 *
	 * A simple way to read and write simple ctypes. Of course, as you'll find the
	 * code isn't as simple as it might appear. The following types are currently
	 * supported in big and little endian formats:
	 *
	 * 	uint8_t			int8_t
	 * 	uint16_t		int16_t
	 * 	uint32_t		int32_t
	 *	float (single precision IEEE 754)
	 *	double (double precision IEEE 754)
	 *
	 * This is designed to work in Node and v8. It may in fact work in other
	 * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
	 * If you find that it does in fact work, that's pretty cool. Try and pass word
	 * back to the original author.
	 *
	 * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
	 * weird.
	 */

	/*
	 * Numbers in Javascript have a secret: all numbers must be represented with an
	 * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
	 * implicit one. Thus the range of integers that can be represented is limited
	 * to the size of the mantissa, this makes reading and writing 64-bit integers
	 * difficult, but far from impossible.
	 *
	 * Another side effect of this representation is what happens when you use the
	 * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
	 * each operand and the result is cast to a signed 32-bit number. However, in
	 * the case of >>> the values are cast to an unsigned number.
	 */

	/*
	 * A reminder on endian related issues:
	 *
	 * Big Endian: MSB -> First byte
	 * Little Endian: MSB->Last byte
	 */
	var mod_assert = __webpack_require__(92);

	/*
	 * An 8 bit unsigned integer involves doing no significant work.
	 */
	function ruint8(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (buffer[offset]);
	}

	/*
	 * For 16 bit unsigned numbers we can do all the casting that we want to do.
	 */
	function rgint16(buffer, endian, offset)
	{
		var val = 0;

		if (endian == 'big') {
			val = buffer[offset] << 8;
			val |=  buffer[offset+1];
		} else {
			val = buffer[offset];
			val |= buffer[offset+1] << 8;
		}

		return (val);

	}

	function ruint16(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (rgint16(buffer, endian, offset));
	}

	/*
	 * Because most bitshifting is done using signed numbers, if we would go into
	 * the realm where we use that 32nd bit, we'll end up going into the negative
	 * range. i.e.:
	 * > 200 << 24
	 * -939524096
	 *
	 * Not the value you'd expect. To work around this, we end up having to do some
	 * abuse of the JavaScript standard. in this case, we know that a >>> shift is
	 * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
	 * use that instead to save us some additional math, though it does feel a
	 * little weird and it isn't obvious as to why you woul dwant to do this at
	 * first.
	 */
	function rgint32(buffer, endian, offset)
	{
		var val = 0;

		if (endian == 'big') {
			val = buffer[offset+1] << 16;
			val |= buffer[offset+2] << 8;
			val |= buffer[offset+3];
			val = val + (buffer[offset] << 24 >>> 0);
		} else {
			val = buffer[offset+2] << 16;
			val |= buffer[offset+1] << 8;
			val |= buffer[offset];
			val = val + (buffer[offset + 3] << 24 >>> 0);
		}

		return (val);
	}

	function ruint32(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (rgint32(buffer, endian, offset));
	}

	/*
	 * Reads a 64-bit unsigned number. The astue observer will note that this
	 * doesn't quite work. Javascript has chosen to only have numbers that can be
	 * represented by a double. A double only has 52 bits of mantissa with an
	 * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
	 * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
	 * could you have possibly wanted to represent that was larger than that? Oh,
	 * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
	 * that happen?
	 *
	 * To get around this egregious language issue, we're going to instead construct
	 * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
	 * give the actual number. However, note that the above code probably won't
	 * produce the desired results because of the way Javascript numbers are
	 * doubles.
	 */
	function rgint64(buffer, endian, offset)
	{
		var val = new Array(2);

		if (endian == 'big') {
			val[0] = ruint32(buffer, endian, offset);
			val[1] = ruint32(buffer, endian, offset+4);
		} else {
			val[0] = ruint32(buffer, endian, offset+4);
			val[1] = ruint32(buffer, endian, offset);
		}

		return (val);
	}

	function ruint64(buffer, endian, offset)
	{
		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		return (rgint64(buffer, endian, offset));
	}


	/*
	 * Signed integer types, yay team! A reminder on how two's complement actually
	 * works. The first bit is the signed bit, i.e. tells us whether or not the
	 * number should be positive or negative. If the two's complement value is
	 * positive, then we're done, as it's equivalent to the unsigned representation.
	 *
	 * Now if the number is positive, you're pretty much done, you can just leverage
	 * the unsigned translations and return those. Unfortunately, negative numbers
	 * aren't quite that straightforward.
	 *
	 * At first glance, one might be inclined to use the traditional formula to
	 * translate binary numbers between the positive and negative values in two's
	 * complement. (Though it doesn't quite work for the most negative value)
	 * Mainly:
	 *  - invert all the bits
	 *  - add one to the result
	 *
	 * Of course, this doesn't quite work in Javascript. Take for example the value
	 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
	 * course, Javascript will do the following:
	 *
	 * > ~0xff80
	 * -65409
	 *
	 * Whoh there, Javascript, that's not quite right. But wait, according to
	 * Javascript that's perfectly correct. When Javascript ends up seeing the
	 * constant 0xff80, it has no notion that it is actually a signed number. It
	 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
	 * binary negation, it casts it into a signed value, (positive 0xff80). Then
	 * when you perform binary negation on that, it turns it into a negative number.
	 *
	 * Instead, we're going to have to use the following general formula, that works
	 * in a rather Javascript friendly way. I'm glad we don't support this kind of
	 * weird numbering scheme in the kernel.
	 *
	 * (BIT-MAX - (unsigned)val + 1) * -1
	 *
	 * The astute observer, may think that this doesn't make sense for 8-bit numbers
	 * (really it isn't necessary for them). However, when you get 16-bit numbers,
	 * you do. Let's go back to our prior example and see how this will look:
	 *
	 * (0xffff - 0xff80 + 1) * -1
	 * (0x007f + 1) * -1
	 * (0x0080) * -1
	 *
	 * Doing it this way ends up allowing us to treat it appropriately in
	 * Javascript. Sigh, that's really quite ugly for what should just be a few bit
	 * shifts, ~ and &.
	 */

	/*
	 * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
	 * this case because the more traditional methods work, but for consistency,
	 * we'll keep doing this the same way.
	 */
	function rsint8(buffer, endian, offset)
	{
		var neg;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		neg = buffer[offset] & 0x80;
		if (!neg)
			return (buffer[offset]);

		return ((0xff - buffer[offset] + 1) * -1);
	}

	/*
	 * The 16-bit version requires a bit more effort. In this case, we can leverage
	 * our unsigned code to generate the value we want to return.
	 */
	function rsint16(buffer, endian, offset)
	{
		var neg, val;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = rgint16(buffer, endian, offset);
		neg = val & 0x8000;
		if (!neg)
			return (val);

		return ((0xffff - val + 1) * -1);
	}

	/*
	 * We really shouldn't leverage our 32-bit code here and instead utilize the
	 * fact that we know that since these are signed numbers, we can do all the
	 * shifting and binary anding to generate the 32-bit number. But, for
	 * consistency we'll do the same. If we want to do otherwise, we should instead
	 * make the 32 bit unsigned code do the optimization. But as long as there
	 * aren't floats secretly under the hood for that, we /should/ be okay.
	 */
	function rsint32(buffer, endian, offset)
	{
		var neg, val;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = rgint32(buffer, endian, offset);
		neg = val & 0x80000000;
		if (!neg)
			return (val);

		return ((0xffffffff - val + 1) * -1);
	}

	/*
	 * The signed version of this code suffers from all of the same problems of the
	 * other 64 bit version.
	 */
	function rsint64(buffer, endian, offset)
	{
		var neg, val;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = rgint64(buffer, endian, offset);
		neg = val[0] & 0x80000000;

		if (!neg)
			return (val);

		val[0] = (0xffffffff - val[0]) * -1;
		val[1] = (0xffffffff - val[1] + 1) * -1;

		/*
		 * If we had the key 0x8000000000000000, that would leave the lower 32
		 * bits as 0xffffffff, however, since we're goint to add one, that would
		 * actually leave the lower 32-bits as 0x100000000, which would break
		 * our ability to write back a value that we received. To work around
		 * this, if we actually get that value, we're going to bump the upper
		 * portion by 1 and set this to zero.
		 */
		mod_assert.ok(val[1] <= 0x100000000);
		if (val[1] == -0x100000000) {
			val[1] = 0;
			val[0]--;
		}

		return (val);
	}

	/*
	 * We now move onto IEEE 754: The traditional form for floating point numbers
	 * and what is secretly hiding at the heart of everything in this. I really hope
	 * that someone is actually using this, as otherwise, this effort is probably
	 * going to be more wasted.
	 *
	 * One might be tempted to use parseFloat here, but that wouldn't work at all
	 * for several reasons. Mostly due to the way floats actually work, and
	 * parseFloat only actually works in base 10. I don't see base 10 anywhere near
	 * this file.
	 *
	 * In this case we'll implement the single and double precision versions. The
	 * quadruple precision, while probably useful, wouldn't really be accepted by
	 * Javascript, so let's not even waste our time.
	 *
	 * So let's review how this format looks like. A single precision value is 32
	 * bits and has three parts:
	 *   -  Sign bit
	 *   -  Exponent (Using bias notation)
	 *   -  Mantissa
	 *
	 * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
	 * 31| 30-23  |  22    	-       0       |
	 *
	 * The exponent is stored in a biased input. The bias in this case 127.
	 * Therefore, our exponent is equal to the 8-bit value - 127.
	 *
	 * By default, a number is normalized in IEEE, that means that the mantissa has
	 * an implicit one that we don't see. So really the value stored is 1.m.
	 * However, if the exponent is all zeros, then instead we have to shift
	 * everything to the right one and there is no more implicit one.
	 *
	 * Special values:
	 *  - Positive Infinity:
	 *	Sign:		0
	 *	Exponent: 	All 1s
	 *	Mantissa:	0
	 *  - Negative Infinity:
	 *	Sign:		1
	 *	Exponent: 	All 1s
	 *	Mantissa:	0
	 *  - NaN:
	 *	Sign:		*
	 *	Exponent: 	All 1s
	 *	Mantissa:	non-zero
	 *  - Zero:
	 *	Sign:		*
	 *	Exponent:	All 0s
	 *	Mantissa:	0
	 *
	 * In the case of zero, the sign bit determines whether we get a positive or
	 * negative zero. However, since Javascript cannot determine the difference
	 * between the two: i.e. -0 == 0, we just always return 0.
	 *
	 */
	function rfloat(buffer, endian, offset)
	{
		var bytes = [];
		var sign, exponent, mantissa, val;
		var bias = 127;
		var maxexp = 0xff;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		/* Normalize the bytes to be in endian order */
		if (endian == 'big') {
			bytes[0] = buffer[offset];
			bytes[1] = buffer[offset+1];
			bytes[2] = buffer[offset+2];
			bytes[3] = buffer[offset+3];
		} else {
			bytes[3] = buffer[offset];
			bytes[2] = buffer[offset+1];
			bytes[1] = buffer[offset+2];
			bytes[0] = buffer[offset+3];
		}

		sign = bytes[0] & 0x80;
		exponent = (bytes[0] & 0x7f) << 1;
		exponent |= (bytes[1] & 0x80) >>> 7;
		mantissa = (bytes[1] & 0x7f) << 16;
		mantissa |= bytes[2] << 8;
		mantissa |= bytes[3];

		/* Check for special cases before we do general parsing */
		if (!sign && exponent == maxexp && mantissa === 0)
			return (Number.POSITIVE_INFINITY);

		if (sign && exponent == maxexp && mantissa === 0)
			return (Number.NEGATIVE_INFINITY);

		if (exponent == maxexp && mantissa !== 0)
			return (Number.NaN);

		/*
		 * Javascript really doesn't have support for positive or negative zero.
		 * So we're not going to try and give it to you. That would be just
		 * plain weird. Besides -0 == 0.
		 */
		if (exponent === 0 && mantissa === 0)
			return (0);

		/*
		 * Now we can deal with the bias and the determine whether the mantissa
		 * has the implicit one or not.
		 */
		exponent -= bias;
		if (exponent == -bias) {
			exponent++;
			val = 0;
		} else {
			val = 1;
		}

		val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);

		if (sign)
			val *= -1;

		return (val);
	}

	/*
	 * Doubles in IEEE 754 are like their brothers except for a few changes and
	 * increases in size:
	 *   - The exponent is now 11 bits
	 *   - The mantissa is now 52 bits
	 *   - The bias is now 1023
	 *
	 * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
	 * 63| 62 - 52   | 	51		-			0     |
	 * 63| 62 - 52   |      51              -                       0     |
	 *
	 * While the size has increased a fair amount, we're going to end up keeping the
	 * same general formula for calculating the final value. As a reminder, this
	 * formula is:
	 *
	 * (-1)^s * (n + m) * 2^(e-b)
	 *
	 * Where:
	 *	s	is the sign bit
	 *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
	 *					     or not
	 *	m	is the mantissa
	 *	e	is the exponent specified
	 *	b	is the bias for the exponent
	 *
	 */
	function rdouble(buffer, endian, offset)
	{
		var bytes = [];
		var sign, exponent, mantissa, val, lowmant;
		var bias = 1023;
		var maxexp = 0x7ff;

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		/* Normalize the bytes to be in endian order */
		if (endian == 'big') {
			bytes[0] = buffer[offset];
			bytes[1] = buffer[offset+1];
			bytes[2] = buffer[offset+2];
			bytes[3] = buffer[offset+3];
			bytes[4] = buffer[offset+4];
			bytes[5] = buffer[offset+5];
			bytes[6] = buffer[offset+6];
			bytes[7] = buffer[offset+7];
		} else {
			bytes[7] = buffer[offset];
			bytes[6] = buffer[offset+1];
			bytes[5] = buffer[offset+2];
			bytes[4] = buffer[offset+3];
			bytes[3] = buffer[offset+4];
			bytes[2] = buffer[offset+5];
			bytes[1] = buffer[offset+6];
			bytes[0] = buffer[offset+7];
		}

		/*
		 * We can construct the exponent and mantissa the same way as we did in
		 * the case of a float, just increase the range of the exponent.
		 */
		sign = bytes[0] & 0x80;
		exponent = (bytes[0] & 0x7f) << 4;
		exponent |= (bytes[1] & 0xf0) >>> 4;

		/*
		 * This is going to be ugly but then again, we're dealing with IEEE 754.
		 * This could probably be done as a node add on in a few lines of C++,
		 * but oh we'll, we've made it this far so let's be native the rest of
		 * the way...
		 *
		 * What we're going to do is break the mantissa into two parts, the
		 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
		 * by the appropriate power and then add in the lower 24-bits. Not
		 * really that great. It's pretty much a giant kludge to deal with
		 * Javascript eccentricities around numbers.
		 */
		lowmant = bytes[7];
		lowmant |= bytes[6] << 8;
		lowmant |= bytes[5] << 16;
		mantissa = bytes[4];
		mantissa |= bytes[3] << 8;
		mantissa |= bytes[2] << 16;
		mantissa |= (bytes[1] & 0x0f) << 24;
		mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
		mantissa += lowmant;

		/* Check for special cases before we do general parsing */
		if (!sign && exponent == maxexp && mantissa === 0)
			return (Number.POSITIVE_INFINITY);

		if (sign && exponent == maxexp && mantissa === 0)
			return (Number.NEGATIVE_INFINITY);

		if (exponent == maxexp && mantissa !== 0)
			return (Number.NaN);

		/*
		 * Javascript really doesn't have support for positive or negative zero.
		 * So we're not going to try and give it to you. That would be just
		 * plain weird. Besides -0 == 0.
		 */
		if (exponent === 0 && mantissa === 0)
			return (0);

		/*
		 * Now we can deal with the bias and the determine whether the mantissa
		 * has the implicit one or not.
		 */
		exponent -= bias;
		if (exponent == -bias) {
			exponent++;
			val = 0;
		} else {
			val = 1;
		}

		val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

		if (sign)
			val *= -1;

		return (val);
	}

	/*
	 * Now that we have gone through the pain of reading the individual types, we're
	 * probably going to want some way to write these back. None of this is going to
	 * be good. But since we have Javascript numbers this should certainly be more
	 * interesting. Though we can constrain this end a little bit more in what is
	 * valid. For now, let's go back to our friends the unsigned value.
	 */

	/*
	 * Unsigned numbers seem deceptively easy. Here are the general steps and rules
	 * that we are going to take:
	 *   -  If the number is negative, throw an Error
	 *   -  Truncate any floating point portion
	 *   -  Take the modulus of the number in our base
	 *   -  Write it out to the buffer in the endian format requested at the offset
	 */

	/*
	 * We have to make sure that the value is a valid integer. This means that it is
	 * non-negative. It has no fractional component and that it does not exceed the
	 * maximum allowed value.
	 *
	 *	value		The number to check for validity
	 *
	 *	max		The maximum value
	 */
	function prepuint(value, max)
	{
		if (typeof (value) != 'number')
			throw (new (Error('cannot write a non-number as a number')));

		if (value < 0)
			throw (new Error('specified a negative value for writing an ' +
			    'unsigned value'));

		if (value > max)
			throw (new Error('value is larger than maximum value for ' +
			    'type'));

		if (Math.floor(value) !== value)
			throw (new Error('value has a fractional component'));

		return (value);
	}

	/*
	 * 8-bit version, classy. We can ignore endianness which is good.
	 */
	function wuint8(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepuint(value, 0xff);
		buffer[offset] = val;
	}

	/*
	 * Pretty much the same as the 8-bit version, just this time we need to worry
	 * about endian related issues.
	 */
	function wgint16(val, endian, buffer, offset)
	{
		if (endian == 'big') {
			buffer[offset] = (val & 0xff00) >>> 8;
			buffer[offset+1] = val & 0x00ff;
		} else {
			buffer[offset+1] = (val & 0xff00) >>> 8;
			buffer[offset] = val & 0x00ff;
		}
	}

	function wuint16(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepuint(value, 0xffff);
		wgint16(val, endian, buffer, offset);
	}

	/*
	 * The 32-bit version is going to have to be a little different unfortunately.
	 * We can't quite bitshift to get the largest byte, because that would end up
	 * getting us caught by the signed values.
	 *
	 * And yes, we do want to subtract out the lower part by default. This means
	 * that when we do the division, it will be treated as a bit shift and we won't
	 * end up generating a floating point value. If we did generate a floating point
	 * value we'd have to truncate it intelligently, this saves us that problem and
	 * may even be somewhat faster under the hood.
	 */
	function wgint32(val, endian, buffer, offset)
	{
		if (endian == 'big') {
			buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
			buffer[offset+1] = (val >>> 16) & 0xff;
			buffer[offset+2] = (val >>> 8) & 0xff;
			buffer[offset+3] = val & 0xff;
		} else {
			buffer[offset+3] = (val - (val & 0x00ffffff)) /
			    Math.pow(2, 24);
			buffer[offset+2] = (val >>> 16) & 0xff;
			buffer[offset+1] = (val >>> 8) & 0xff;
			buffer[offset] = val & 0xff;
		}
	}

	function wuint32(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepuint(value, 0xffffffff);
		wgint32(val, endian, buffer, offset);
	}

	/*
	 * Unlike the other versions, we expect the value to be in the form of two
	 * arrays where value[0] << 32 + value[1] would result in the value that we
	 * want.
	 */
	function wgint64(value, endian, buffer, offset)
	{
		if (endian == 'big') {
			wgint32(value[0], endian, buffer, offset);
			wgint32(value[1], endian, buffer, offset+4);
		} else {
			wgint32(value[0], endian, buffer, offset+4);
			wgint32(value[1], endian, buffer, offset);
		}
	}

	function wuint64(value, endian, buffer, offset)
	{
		if (value === undefined)
			throw (new Error('missing value'));

		if (!(value instanceof Array))
			throw (new Error('value must be an array'));

		if (value.length != 2)
			throw (new Error('value must be an array of length 2'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		prepuint(value[0], 0xffffffff);
		prepuint(value[1], 0xffffffff);
		wgint64(value, endian, buffer, offset);
	}

	/*
	 * We now move onto our friends in the signed number category. Unlike unsigned
	 * numbers, we're going to have to worry a bit more about how we put values into
	 * arrays. Since we are only worrying about signed 32-bit values, we're in
	 * slightly better shape. Unfortunately, we really can't do our favorite binary
	 * & in this system. It really seems to do the wrong thing. For example:
	 *
	 * > -32 & 0xff
	 * 224
	 *
	 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
	 * this aren't treated as a signed number. Ultimately a bad thing.
	 *
	 * What we're going to want to do is basically create the unsigned equivalent of
	 * our representation and pass that off to the wuint* functions. To do that
	 * we're going to do the following:
	 *
	 *  - if the value is positive
	 *	we can pass it directly off to the equivalent wuint
	 *  - if the value is negative
	 *	we do the following computation:
	 *	mb + val + 1, where
	 *	mb	is the maximum unsigned value in that byte size
	 *	val	is the Javascript negative integer
	 *
	 *
	 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
	 * you do out the computations:
	 *
	 * 0xffff - 128 + 1
	 * 0xffff - 127
	 * 0xff80
	 *
	 * You can then encode this value as the signed version. This is really rather
	 * hacky, but it should work and get the job done which is our goal here.
	 *
	 * Thus the overall flow is:
	 *   -  Truncate the floating point part of the number
	 *   -  We don't have to take the modulus, because the unsigned versions will
	 *   	take care of that for us. And we don't have to worry about that
	 *   	potentially causing bad things to happen because of sign extension
	 *   -  Pass it off to the appropriate unsigned version, potentially modifying
	 *	the negative portions as necessary.
	 */

	/*
	 * A series of checks to make sure we actually have a signed 32-bit number
	 */
	function prepsint(value, max, min)
	{
		if (typeof (value) != 'number')
			throw (new (Error('cannot write a non-number as a number')));

		if (value > max)
			throw (new Error('value larger than maximum allowed value'));

		if (value < min)
			throw (new Error('value smaller than minimum allowed value'));

		if (Math.floor(value) !== value)
			throw (new Error('value has a fractional component'));

		return (value);
	}

	/*
	 * The 8-bit version of the signed value. Overall, fairly straightforward.
	 */
	function wsint8(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepsint(value, 0x7f, -0x80);
		if (val >= 0)
			wuint8(val, endian, buffer, offset);
		else
			wuint8(0xff + val + 1, endian, buffer, offset);
	}

	/*
	 * The 16-bit version of the signed value. Also, fairly straightforward.
	 */
	function wsint16(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 1 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepsint(value, 0x7fff, -0x8000);
		if (val >= 0)
			wgint16(val, endian, buffer, offset);
		else
			wgint16(0xffff + val + 1, endian, buffer, offset);

	}

	/*
	 * We can do this relatively easily by leveraging the code used for 32-bit
	 * unsigned code.
	 */
	function wsint32(value, endian, buffer, offset)
	{
		var val;

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		val = prepsint(value, 0x7fffffff, -0x80000000);
		if (val >= 0)
			wgint32(val, endian, buffer, offset);
		else
			wgint32(0xffffffff + val + 1, endian, buffer, offset);
	}

	/*
	 * The signed 64 bit integer should by in the same format as when received.
	 * Mainly it should ensure that the value is an array of two integers where
	 * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
	 * need to be equal.
	 */
	function wsint64(value, endian, buffer, offset)
	{
		var vzpos, vopos;
		var vals = new Array(2);

		if (value === undefined)
			throw (new Error('missing value'));

		if (!(value instanceof Array))
			throw (new Error('value must be an array'));

		if (value.length != 2)
			throw (new Error('value must be an array of length 2'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));

		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		/*
		 * We need to make sure that we have the same sign on both values. The
		 * hokiest way to to do this is to multiply the number by +inf. If we do
		 * this, we'll get either +/-inf depending on the sign of the value.
		 * Once we have this, we can compare it to +inf to see if the number is
		 * positive or not.
		 */
		vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
		    Number.POSITIVE_INFINITY;
		vopos = (value[1] * Number.POSITIVE_INFINITY) ==
		    Number.POSITIVE_INFINITY;

		/*
		 * If either of these is zero, then we don't actually need this check.
		 */
		if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
			throw (new Error('Both entries in the array must have ' +
			    'the same sign'));

		/*
		 * Doing verification for a signed 64-bit integer is actually a big
		 * trickier than it appears. We can't quite use our standard techniques
		 * because we need to compare both sets of values. The first value is
		 * pretty straightforward. If the first value is beond the extremes than
		 * we error out. However, the valid range of the second value varies
		 * based on the first one. If the first value is negative, and *not* the
		 * largest negative value, than it can be any integer within the range [
		 * 0, 0xffffffff ]. If it is the largest negative number, it must be
		 * zero.
		 *
		 * If the first number is positive, than it doesn't matter what the
		 * value is. We just simply have to make sure we have a valid positive
		 * integer.
		 */
		if (vzpos) {
			prepuint(value[0], 0x7fffffff);
			prepuint(value[1], 0xffffffff);
		} else {
			prepsint(value[0], 0, -0x80000000);
			prepsint(value[1], 0, -0xffffffff);
			if (value[0] == -0x80000000 && value[1] != 0)
				throw (new Error('value smaller than minimum ' +
				    'allowed value'));
		}

		/* Fix negative numbers */
		if (value[0] < 0 || value[1] < 0) {
			vals[0] = 0xffffffff - Math.abs(value[0]);
			vals[1] = 0x100000000 - Math.abs(value[1]);
			if (vals[1] == 0x100000000) {
				vals[1] = 0;
				vals[0]++;
			}
		} else {
			vals[0] = value[0];
			vals[1] = value[1];
		}
		wgint64(vals, endian, buffer, offset);
	}

	/*
	 * Now we are moving onto the weirder of these, the float and double. For this
	 * we're going to just have to do something that's pretty weird. First off, we
	 * have no way to get at the underlying float representation, at least not
	 * easily. But that doesn't mean we can't figure it out, we just have to use our
	 * heads.
	 *
	 * One might propose to use Number.toString(2). Of course, this is not really
	 * that good, because the ECMAScript 262 v3 Standard says the following Section
	 * 15.7.4.2-Number.prototype.toString (radix):
	 *
	 * If radix is an integer from 2 to 36, but not 10, the result is a string, the
	 * choice of which is implementation-dependent.
	 *
	 * Well that doesn't really help us one bit now does it? We could use the
	 * standard base 10 version of the string, but that's just going to create more
	 * errors as we end up trying to convert it back to a binary value. So, really
	 * this just means we have to be non-lazy and parse the structure intelligently.
	 *
	 * First off, we can do the basic checks: NaN, positive and negative infinity.
	 *
	 * Now that those are done we can work backwards to generate the mantissa and
	 * exponent.
	 *
	 * The first thing we need to do is determine the sign bit, easy to do, check
	 * whether the value is less than 0. And convert the number to its absolute
	 * value representation. Next, we need to determine if the value is less than
	 * one or greater than or equal to one and from there determine what power was
	 * used to get there. What follows is now specific to floats, though the general
	 * ideas behind this will hold for doubles as well, but the exact numbers
	 * involved will change.
	 *
	 * Once we have that power we can determine the exponent and the mantissa. Call
	 * the value that has the number of bits to reach the power ebits. In the
	 * general case they have the following values:
	 *
	 *	exponent	127 + ebits
	 *	mantissa	value * 2^(23 - ebits) & 0x7fffff
	 *
	 * In the case where the value of ebits is <= -127 we are now in the case where
	 * we no longer have normalized numbers. In this case the values take on the
	 * following values:
	 *
	 * 	exponent	0
	 *	mantissa	value * 2^149 & 0x7fffff
	 *
	 * Once we have the values for the sign, mantissa, and exponent. We reconstruct
	 * the four bytes as follows:
	 *
	 *	byte0		sign bit and seven most significant bits from the exp
	 *			sign << 7 | (exponent & 0xfe) >>> 1
	 *
	 *	byte1		lsb from the exponent and 7 top bits from the mantissa
	 *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
	 *
	 *	byte2		bits 8-15 (zero indexing) from mantissa
	 *			mantissa & 0xff00 >> 8
	 *
	 *	byte3		bits 0-7 from mantissa
	 *			mantissa & 0xff
	 *
	 * Once we have this we have to assign them into the buffer in proper endian
	 * order.
	 */

	/*
	 * Compute the log base 2 of the value. Now, someone who remembers basic
	 * properties of logarithms will point out that we could use the change of base
	 * formula for logs, and in fact that would be astute, because that's what we'll
	 * do for now. It feels cleaner, albeit it may be less efficient than just
	 * iterating and dividing by 2. We may want to come back and revisit that some
	 * day.
	 */
	function log2(value)
	{
		return (Math.log(value) / Math.log(2));
	}

	/*
	 * Helper to determine the exponent of the number we're looking at.
	 */
	function intexp(value)
	{
		return (Math.floor(log2(value)));
	}

	/*
	 * Helper to determine the exponent of the fractional part of the value.
	 */
	function fracexp(value)
	{
		return (Math.floor(log2(value)));
	}

	function wfloat(value, endian, buffer, offset)
	{
		var sign, exponent, mantissa, ebits;
		var bytes = [];

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));


		if (offset + 3 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		if (isNaN(value)) {
			sign = 0;
			exponent = 0xff;
			mantissa = 23;
		} else if (value == Number.POSITIVE_INFINITY) {
			sign = 0;
			exponent = 0xff;
			mantissa = 0;
		} else if (value == Number.NEGATIVE_INFINITY) {
			sign = 1;
			exponent = 0xff;
			mantissa = 0;
		} else {
			/* Well we have some work to do */

			/* Thankfully the sign bit is trivial */
			if (value < 0) {
				sign = 1;
				value = Math.abs(value);
			} else {
				sign = 0;
			}

			/* Use the correct function to determine number of bits */
			if (value < 1)
				ebits = fracexp(value);
			else
				ebits = intexp(value);

			/* Time to deal with the issues surrounding normalization */
			if (ebits <= -127) {
				exponent = 0;
				mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
			} else {
				exponent = 127 + ebits;
				mantissa = value * Math.pow(2, 23 - ebits);
				mantissa &= 0x7fffff;
			}
		}

		bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
		bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
		bytes[2] = (mantissa & 0x00ff00) >>> 8;
		bytes[3] = mantissa & 0x0000ff;

		if (endian == 'big') {
			buffer[offset] = bytes[0];
			buffer[offset+1] = bytes[1];
			buffer[offset+2] = bytes[2];
			buffer[offset+3] = bytes[3];
		} else {
			buffer[offset] = bytes[3];
			buffer[offset+1] = bytes[2];
			buffer[offset+2] = bytes[1];
			buffer[offset+3] = bytes[0];
		}
	}

	/*
	 * Now we move onto doubles. Doubles are similar to floats in pretty much all
	 * ways except that the processing isn't quite as straightforward because we
	 * can't always use shifting, i.e. we have > 32 bit values.
	 *
	 * We're going to proceed in an identical fashion to floats and utilize the same
	 * helper functions. All that really is changing are the specific values that we
	 * use to do the calculations. Thus, to review we have to do the following.
	 *
	 * First get the sign bit and convert the value to its absolute value
	 * representation. Next, we determine the number of bits that we used to get to
	 * the value, branching whether the value is greater than or less than 1. Once
	 * we have that value which we will again call ebits, we have to do the
	 * following in the general case:
	 *
	 *	exponent	1023 + ebits
	 *	mantissa	[value * 2^(52 - ebits)] % 2^52
	 *
	 * In the case where the value of ebits <= -1023 we no longer use normalized
	 * numbers, thus like with floats we have to do slightly different processing:
	 *
	 *	exponent	0
	 *	mantissa	[value * 2^1074] % 2^52
	 *
	 * Once we have determined the sign, exponent and mantissa we can construct the
	 * bytes as follows:
	 *
	 *	byte0		sign bit and seven most significant bits form the exp
	 *			sign << 7 | (exponent & 0x7f0) >>> 4
	 *
	 *	byte1		Remaining 4 bits from the exponent and the four most
	 *			significant bits from the mantissa 48-51
	 *			(exponent & 0x00f) << 4 | mantissa >>> 48
	 *
	 *	byte2		Bits 40-47 from the mantissa
	 *			(mantissa >>> 40) & 0xff
	 *
	 *	byte3		Bits 32-39 from the mantissa
	 *			(mantissa >>> 32) & 0xff
	 *
	 *	byte4		Bits 24-31 from the mantissa
	 *			(mantissa >>> 24) & 0xff
	 *
	 *	byte5		Bits 16-23 from the Mantissa
	 *			(mantissa >>> 16) & 0xff
	 *
	 *	byte6		Bits 8-15 from the mantissa
	 *			(mantissa >>> 8) & 0xff
	 *
	 *	byte7		Bits 0-7 from the mantissa
	 *			mantissa & 0xff
	 *
	 * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
	 * we'll have extended too far and we'll lose those values when we try and do
	 * the shift. Instead we have to use an alternate approach. To try and stay out
	 * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
	 * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
	 * that's ugly, but it seems to avoid using floating point (just based on how v8
	 * seems to be optimizing for base 2 arithmetic).
	 */
	function wdouble(value, endian, buffer, offset)
	{
		var sign, exponent, mantissa, ebits;
		var bytes = [];

		if (value === undefined)
			throw (new Error('missing value'));

		if (endian === undefined)
			throw (new Error('missing endian'));

		if (buffer === undefined)
			throw (new Error('missing buffer'));

		if (offset === undefined)
			throw (new Error('missing offset'));


		if (offset + 7 >= buffer.length)
			throw (new Error('Trying to read beyond buffer length'));

		if (isNaN(value)) {
			sign = 0;
			exponent = 0x7ff;
			mantissa = 23;
		} else if (value == Number.POSITIVE_INFINITY) {
			sign = 0;
			exponent = 0x7ff;
			mantissa = 0;
		} else if (value == Number.NEGATIVE_INFINITY) {
			sign = 1;
			exponent = 0x7ff;
			mantissa = 0;
		} else {
			/* Well we have some work to do */

			/* Thankfully the sign bit is trivial */
			if (value < 0) {
				sign = 1;
				value = Math.abs(value);
			} else {
				sign = 0;
			}

			/* Use the correct function to determine number of bits */
			if (value < 1)
				ebits = fracexp(value);
			else
				ebits = intexp(value);

			/*
			 * This is a total hack to determine a denormalized value.
			 * Unfortunately, we sometimes do not get a proper value for
			 * ebits, i.e. we lose the values that would get rounded off.
			 *
			 *
			 * The astute observer may wonder why we would be
			 * multiplying by two Math.pows rather than just summing
			 * them. Well, that's to get around a small bug in the
			 * way v8 seems to implement the function. On occasion
			 * doing:
			 *
			 * foo * Math.pow(2, 1023 + 51)
			 *
			 * Causes us to overflow to infinity, where as doing:
			 *
			 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
			 *
			 * Does not cause us to overflow. Go figure.
			 *
			 */
			if (value <= 2.225073858507201e-308 || ebits <= -1023) {
				exponent = 0;
				mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
				mantissa %= Math.pow(2, 52);
			} else {
				/*
				 * We might have gotten fucked by our floating point
				 * logarithm magic. This is rather crappy, but that's
				 * our luck. If we just had a log base 2 or access to
				 * the stupid underlying representation this would have
				 * been much easier and we wouldn't have such stupid
				 * kludges or hacks.
				 */
				if (ebits > 1023)
					ebits = 1023;
				exponent = 1023 + ebits;
				mantissa = value * Math.pow(2, -ebits);
				mantissa *= Math.pow(2, 52);
				mantissa %= Math.pow(2, 52);
			}
		}

		/* Fill the bytes in backwards to deal with the size issues */
		bytes[7] = mantissa & 0xff;
		bytes[6] = (mantissa >>> 8) & 0xff;
		bytes[5] = (mantissa >>> 16) & 0xff;
		mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
		bytes[4] = mantissa & 0xff;
		bytes[3] = (mantissa >>> 8) & 0xff;
		bytes[2] = (mantissa >>> 16) & 0xff;
		bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
		bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;

		if (endian == 'big') {
			buffer[offset] = bytes[0];
			buffer[offset+1] = bytes[1];
			buffer[offset+2] = bytes[2];
			buffer[offset+3] = bytes[3];
			buffer[offset+4] = bytes[4];
			buffer[offset+5] = bytes[5];
			buffer[offset+6] = bytes[6];
			buffer[offset+7] = bytes[7];
		} else {
			buffer[offset+7] = bytes[0];
			buffer[offset+6] = bytes[1];
			buffer[offset+5] = bytes[2];
			buffer[offset+4] = bytes[3];
			buffer[offset+3] = bytes[4];
			buffer[offset+2] = bytes[5];
			buffer[offset+1] = bytes[6];
			buffer[offset] = bytes[7];
		}
	}

	/*
	 * Actually export our work above. One might argue that we shouldn't expose
	 * these interfaces and just force people to use the higher level abstractions
	 * around this work. However, unlike say other libraries we've come across, this
	 * interface has several properties: it makes sense, it's simple, and it's
	 * useful.
	 */
	exports.ruint8 = ruint8;
	exports.ruint16 = ruint16;
	exports.ruint32 = ruint32;
	exports.ruint64 = ruint64;
	exports.wuint8 = wuint8;
	exports.wuint16 = wuint16;
	exports.wuint32 = wuint32;
	exports.wuint64 = wuint64;

	exports.rsint8 = rsint8;
	exports.rsint16 = rsint16;
	exports.rsint32 = rsint32;
	exports.rsint64 = rsint64;
	exports.wsint8 = wsint8;
	exports.wsint16 = wsint16;
	exports.wsint32 = wsint32;
	exports.wsint64 = wsint64;

	exports.rfloat = rfloat;
	exports.rdouble = rdouble;
	exports.wfloat = wfloat;
	exports.wdouble = wdouble;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	
	var db = __webpack_require__(112)

	// types[extension] = type
	exports.types = Object.create(null)
	// extensions[type] = [extensions]
	exports.extensions = Object.create(null)

	Object.keys(db).forEach(function (name) {
	  var mime = db[name]
	  var exts = mime.extensions
	  if (!exts || !exts.length) return
	  exports.extensions[name] = exts
	  exts.forEach(function (ext) {
	    exports.types[ext] = name
	  })
	})

	exports.lookup = function (string) {
	  if (!string || typeof string !== "string") return false
	  // remove any leading paths, though we should just use path.basename
	  string = string.replace(/.*[\.\/\\]/, '').toLowerCase()
	  if (!string) return false
	  return exports.types[string] || false
	}

	exports.extension = function (type) {
	  if (!type || typeof type !== "string") return false
	  // to do: use media-typer
	  type = type.match(/^\s*([^;\s]*)(?:;|\s|$)/)
	  if (!type) return false
	  var exts = exports.extensions[type[1].toLowerCase()]
	  if (!exts || !exts.length) return false
	  return exts[0]
	}

	// type has to be an exact mime type
	exports.charset = function (type) {
	  var mime = db[type]
	  if (mime && mime.charset) return mime.charset

	  // default text/* to utf-8
	  if (/^text\//.test(type)) return 'UTF-8'

	  return false
	}

	// backwards compatibility
	exports.charsets = {
	  lookup: exports.charset
	}

	// to do: maybe use set-type module or something
	exports.contentType = function (type) {
	  if (!type || typeof type !== "string") return false
	  if (!~type.indexOf('/')) type = exports.lookup(type)
	  if (!type) return false
	  if (!~type.indexOf('charset')) {
	    var charset = exports.charset(type)
	    if (charset) type += '; charset=' + charset.toLowerCase()
	  }
	  return type
	}


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 */

	module.exports = __webpack_require__(113)


/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = {
		"application/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"application/3gpdash-qoe-report+xml": {
			"source": "iana"
		},
		"application/3gpp-ims+xml": {
			"source": "iana"
		},
		"application/a2l": {
			"source": "iana"
		},
		"application/activemessage": {
			"source": "iana"
		},
		"application/alto-costmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-costmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-directory+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcost+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointcostparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointprop+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-endpointpropparams+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-error+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/alto-networkmapfilter+json": {
			"source": "iana",
			"compressible": true
		},
		"application/aml": {
			"source": "iana"
		},
		"application/andrew-inset": {
			"source": "iana",
			"extensions": [
				"ez"
			]
		},
		"application/applefile": {
			"source": "iana"
		},
		"application/applixware": {
			"source": "apache",
			"extensions": [
				"aw"
			]
		},
		"application/atf": {
			"source": "iana"
		},
		"application/atfx": {
			"source": "iana"
		},
		"application/atom+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"atom"
			]
		},
		"application/atomcat+xml": {
			"source": "iana",
			"extensions": [
				"atomcat"
			]
		},
		"application/atomdeleted+xml": {
			"source": "iana"
		},
		"application/atomicmail": {
			"source": "iana"
		},
		"application/atomsvc+xml": {
			"source": "iana",
			"extensions": [
				"atomsvc"
			]
		},
		"application/atxml": {
			"source": "iana"
		},
		"application/auth-policy+xml": {
			"source": "iana"
		},
		"application/bacnet-xdd+zip": {
			"source": "iana"
		},
		"application/batch-smtp": {
			"source": "iana"
		},
		"application/bdoc": {
			"compressible": false,
			"extensions": [
				"bdoc"
			]
		},
		"application/beep+xml": {
			"source": "iana"
		},
		"application/calendar+json": {
			"source": "iana",
			"compressible": true
		},
		"application/calendar+xml": {
			"source": "iana"
		},
		"application/call-completion": {
			"source": "iana"
		},
		"application/cals-1840": {
			"source": "iana"
		},
		"application/cbor": {
			"source": "iana"
		},
		"application/ccmp+xml": {
			"source": "iana"
		},
		"application/ccxml+xml": {
			"source": "iana",
			"extensions": [
				"ccxml"
			]
		},
		"application/cdfx+xml": {
			"source": "iana"
		},
		"application/cdmi-capability": {
			"source": "iana",
			"extensions": [
				"cdmia"
			]
		},
		"application/cdmi-container": {
			"source": "iana",
			"extensions": [
				"cdmic"
			]
		},
		"application/cdmi-domain": {
			"source": "iana",
			"extensions": [
				"cdmid"
			]
		},
		"application/cdmi-object": {
			"source": "iana",
			"extensions": [
				"cdmio"
			]
		},
		"application/cdmi-queue": {
			"source": "iana",
			"extensions": [
				"cdmiq"
			]
		},
		"application/cea": {
			"source": "iana"
		},
		"application/cea-2018+xml": {
			"source": "iana"
		},
		"application/cellml+xml": {
			"source": "iana"
		},
		"application/cfw": {
			"source": "iana"
		},
		"application/cms": {
			"source": "iana"
		},
		"application/cnrp+xml": {
			"source": "iana"
		},
		"application/coap-group+json": {
			"source": "iana",
			"compressible": true
		},
		"application/commonground": {
			"source": "iana"
		},
		"application/conference-info+xml": {
			"source": "iana"
		},
		"application/cpl+xml": {
			"source": "iana"
		},
		"application/csrattrs": {
			"source": "iana"
		},
		"application/csta+xml": {
			"source": "iana"
		},
		"application/cstadata+xml": {
			"source": "iana"
		},
		"application/cu-seeme": {
			"source": "apache",
			"extensions": [
				"cu"
			]
		},
		"application/cybercash": {
			"source": "iana"
		},
		"application/dart": {
			"compressible": true
		},
		"application/dash+xml": {
			"source": "iana",
			"extensions": [
				"mdp"
			]
		},
		"application/dashdelta": {
			"source": "iana"
		},
		"application/davmount+xml": {
			"source": "iana",
			"extensions": [
				"davmount"
			]
		},
		"application/dca-rft": {
			"source": "iana"
		},
		"application/dcd": {
			"source": "iana"
		},
		"application/dec-dx": {
			"source": "iana"
		},
		"application/dialog-info+xml": {
			"source": "iana"
		},
		"application/dicom": {
			"source": "iana"
		},
		"application/dii": {
			"source": "iana"
		},
		"application/dit": {
			"source": "iana"
		},
		"application/dns": {
			"source": "iana"
		},
		"application/docbook+xml": {
			"source": "apache",
			"extensions": [
				"dbk"
			]
		},
		"application/dskpp+xml": {
			"source": "iana"
		},
		"application/dssc+der": {
			"source": "iana",
			"extensions": [
				"dssc"
			]
		},
		"application/dssc+xml": {
			"source": "iana",
			"extensions": [
				"xdssc"
			]
		},
		"application/dvcs": {
			"source": "iana"
		},
		"application/ecmascript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ecma"
			]
		},
		"application/edi-consent": {
			"source": "iana"
		},
		"application/edi-x12": {
			"source": "iana",
			"compressible": false
		},
		"application/edifact": {
			"source": "iana",
			"compressible": false
		},
		"application/emma+xml": {
			"source": "iana",
			"extensions": [
				"emma"
			]
		},
		"application/emotionml+xml": {
			"source": "iana"
		},
		"application/encaprtp": {
			"source": "iana"
		},
		"application/epp+xml": {
			"source": "iana"
		},
		"application/epub+zip": {
			"source": "iana",
			"extensions": [
				"epub"
			]
		},
		"application/eshop": {
			"source": "iana"
		},
		"application/exi": {
			"source": "iana",
			"extensions": [
				"exi"
			]
		},
		"application/fastinfoset": {
			"source": "iana"
		},
		"application/fastsoap": {
			"source": "iana"
		},
		"application/fdt+xml": {
			"source": "iana"
		},
		"application/fits": {
			"source": "iana"
		},
		"application/font-sfnt": {
			"source": "iana"
		},
		"application/font-tdpfr": {
			"source": "iana",
			"extensions": [
				"pfr"
			]
		},
		"application/font-woff": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"woff"
			]
		},
		"application/font-woff2": {
			"compressible": false,
			"extensions": [
				"woff2"
			]
		},
		"application/framework-attributes+xml": {
			"source": "iana"
		},
		"application/gml+xml": {
			"source": "apache",
			"extensions": [
				"gml"
			]
		},
		"application/gpx+xml": {
			"source": "apache",
			"extensions": [
				"gpx"
			]
		},
		"application/gxf": {
			"source": "apache",
			"extensions": [
				"gxf"
			]
		},
		"application/gzip": {
			"source": "iana",
			"compressible": false
		},
		"application/h224": {
			"source": "iana"
		},
		"application/held+xml": {
			"source": "iana"
		},
		"application/http": {
			"source": "iana"
		},
		"application/hyperstudio": {
			"source": "iana",
			"extensions": [
				"stk"
			]
		},
		"application/ibe-key-request+xml": {
			"source": "iana"
		},
		"application/ibe-pkg-reply+xml": {
			"source": "iana"
		},
		"application/ibe-pp-data": {
			"source": "iana"
		},
		"application/iges": {
			"source": "iana"
		},
		"application/im-iscomposing+xml": {
			"source": "iana"
		},
		"application/index": {
			"source": "iana"
		},
		"application/index.cmd": {
			"source": "iana"
		},
		"application/index.obj": {
			"source": "iana"
		},
		"application/index.response": {
			"source": "iana"
		},
		"application/index.vnd": {
			"source": "iana"
		},
		"application/inkml+xml": {
			"source": "iana",
			"extensions": [
				"ink",
				"inkml"
			]
		},
		"application/iotp": {
			"source": "iana"
		},
		"application/ipfix": {
			"source": "iana",
			"extensions": [
				"ipfix"
			]
		},
		"application/ipp": {
			"source": "iana"
		},
		"application/isup": {
			"source": "iana"
		},
		"application/its+xml": {
			"source": "iana"
		},
		"application/java-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jar"
			]
		},
		"application/java-serialized-object": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"ser"
			]
		},
		"application/java-vm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"class"
			]
		},
		"application/javascript": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"js"
			]
		},
		"application/jose": {
			"source": "iana"
		},
		"application/jose+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jrd+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json": {
			"source": "iana",
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"json",
				"map"
			]
		},
		"application/json-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/json-seq": {
			"source": "iana"
		},
		"application/json5": {
			"extensions": [
				"json5"
			]
		},
		"application/jsonml+json": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"jsonml"
			]
		},
		"application/jwk+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwk-set+json": {
			"source": "iana",
			"compressible": true
		},
		"application/jwt": {
			"source": "iana"
		},
		"application/kpml-request+xml": {
			"source": "iana"
		},
		"application/kpml-response+xml": {
			"source": "iana"
		},
		"application/ld+json": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"jsonld"
			]
		},
		"application/link-format": {
			"source": "iana"
		},
		"application/load-control+xml": {
			"source": "iana"
		},
		"application/lost+xml": {
			"source": "iana",
			"extensions": [
				"lostxml"
			]
		},
		"application/lostsync+xml": {
			"source": "iana"
		},
		"application/lxf": {
			"source": "iana"
		},
		"application/mac-binhex40": {
			"source": "iana",
			"extensions": [
				"hqx"
			]
		},
		"application/mac-compactpro": {
			"source": "apache",
			"extensions": [
				"cpt"
			]
		},
		"application/macwriteii": {
			"source": "iana"
		},
		"application/mads+xml": {
			"source": "iana",
			"extensions": [
				"mads"
			]
		},
		"application/manifest+json": {
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"webmanifest"
			]
		},
		"application/marc": {
			"source": "iana",
			"extensions": [
				"mrc"
			]
		},
		"application/marcxml+xml": {
			"source": "iana",
			"extensions": [
				"mrcx"
			]
		},
		"application/mathematica": {
			"source": "iana",
			"extensions": [
				"ma",
				"nb",
				"mb"
			]
		},
		"application/mathml+xml": {
			"source": "iana",
			"extensions": [
				"mathml"
			]
		},
		"application/mathml-content+xml": {
			"source": "iana"
		},
		"application/mathml-presentation+xml": {
			"source": "iana"
		},
		"application/mbms-associated-procedure-description+xml": {
			"source": "iana"
		},
		"application/mbms-deregister+xml": {
			"source": "iana"
		},
		"application/mbms-envelope+xml": {
			"source": "iana"
		},
		"application/mbms-msk+xml": {
			"source": "iana"
		},
		"application/mbms-msk-response+xml": {
			"source": "iana"
		},
		"application/mbms-protection-description+xml": {
			"source": "iana"
		},
		"application/mbms-reception-report+xml": {
			"source": "iana"
		},
		"application/mbms-register+xml": {
			"source": "iana"
		},
		"application/mbms-register-response+xml": {
			"source": "iana"
		},
		"application/mbms-schedule+xml": {
			"source": "iana"
		},
		"application/mbms-user-service-description+xml": {
			"source": "iana"
		},
		"application/mbox": {
			"source": "iana",
			"extensions": [
				"mbox"
			]
		},
		"application/media-policy-dataset+xml": {
			"source": "iana"
		},
		"application/media_control+xml": {
			"source": "iana"
		},
		"application/mediaservercontrol+xml": {
			"source": "iana",
			"extensions": [
				"mscml"
			]
		},
		"application/merge-patch+json": {
			"source": "iana",
			"compressible": true
		},
		"application/metalink+xml": {
			"source": "apache",
			"extensions": [
				"metalink"
			]
		},
		"application/metalink4+xml": {
			"source": "iana",
			"extensions": [
				"meta4"
			]
		},
		"application/mets+xml": {
			"source": "iana",
			"extensions": [
				"mets"
			]
		},
		"application/mf4": {
			"source": "iana"
		},
		"application/mikey": {
			"source": "iana"
		},
		"application/mods+xml": {
			"source": "iana",
			"extensions": [
				"mods"
			]
		},
		"application/moss-keys": {
			"source": "iana"
		},
		"application/moss-signature": {
			"source": "iana"
		},
		"application/mosskey-data": {
			"source": "iana"
		},
		"application/mosskey-request": {
			"source": "iana"
		},
		"application/mp21": {
			"source": "iana",
			"extensions": [
				"m21",
				"mp21"
			]
		},
		"application/mp4": {
			"source": "iana",
			"extensions": [
				"mp4s",
				"m4p"
			]
		},
		"application/mpeg4-generic": {
			"source": "iana"
		},
		"application/mpeg4-iod": {
			"source": "iana"
		},
		"application/mpeg4-iod-xmt": {
			"source": "iana"
		},
		"application/mrb-consumer+xml": {
			"source": "iana"
		},
		"application/mrb-publish+xml": {
			"source": "iana"
		},
		"application/msc-ivr+xml": {
			"source": "iana"
		},
		"application/msc-mixer+xml": {
			"source": "iana"
		},
		"application/msword": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"doc",
				"dot"
			]
		},
		"application/mxf": {
			"source": "iana",
			"extensions": [
				"mxf"
			]
		},
		"application/nasdata": {
			"source": "iana"
		},
		"application/news-checkgroups": {
			"source": "iana"
		},
		"application/news-groupinfo": {
			"source": "iana"
		},
		"application/news-transmission": {
			"source": "iana"
		},
		"application/nlsml+xml": {
			"source": "iana"
		},
		"application/nss": {
			"source": "iana"
		},
		"application/ocsp-request": {
			"source": "iana"
		},
		"application/ocsp-response": {
			"source": "iana"
		},
		"application/octet-stream": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"buffer"
			]
		},
		"application/oda": {
			"source": "iana",
			"extensions": [
				"oda"
			]
		},
		"application/odx": {
			"source": "iana"
		},
		"application/oebps-package+xml": {
			"source": "iana",
			"extensions": [
				"opf"
			]
		},
		"application/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ogx"
			]
		},
		"application/omdoc+xml": {
			"source": "apache",
			"extensions": [
				"omdoc"
			]
		},
		"application/onenote": {
			"source": "apache",
			"extensions": [
				"onetoc",
				"onetoc2",
				"onetmp",
				"onepkg"
			]
		},
		"application/oxps": {
			"source": "iana",
			"extensions": [
				"oxps"
			]
		},
		"application/p2p-overlay+xml": {
			"source": "iana"
		},
		"application/parityfec": {
			"source": "iana"
		},
		"application/patch-ops-error+xml": {
			"source": "iana",
			"extensions": [
				"xer"
			]
		},
		"application/pdf": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pdf"
			]
		},
		"application/pdx": {
			"source": "iana"
		},
		"application/pgp-encrypted": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pgp"
			]
		},
		"application/pgp-keys": {
			"source": "iana"
		},
		"application/pgp-signature": {
			"source": "iana",
			"extensions": [
				"asc",
				"sig"
			]
		},
		"application/pics-rules": {
			"source": "apache",
			"extensions": [
				"prf"
			]
		},
		"application/pidf+xml": {
			"source": "iana"
		},
		"application/pidf-diff+xml": {
			"source": "iana"
		},
		"application/pkcs10": {
			"source": "iana",
			"extensions": [
				"p10"
			]
		},
		"application/pkcs7-mime": {
			"source": "iana",
			"extensions": [
				"p7m",
				"p7c"
			]
		},
		"application/pkcs7-signature": {
			"source": "iana",
			"extensions": [
				"p7s"
			]
		},
		"application/pkcs8": {
			"source": "iana",
			"extensions": [
				"p8"
			]
		},
		"application/pkix-attr-cert": {
			"source": "iana",
			"extensions": [
				"ac"
			]
		},
		"application/pkix-cert": {
			"source": "iana",
			"extensions": [
				"cer"
			]
		},
		"application/pkix-crl": {
			"source": "iana",
			"extensions": [
				"crl"
			]
		},
		"application/pkix-pkipath": {
			"source": "iana",
			"extensions": [
				"pkipath"
			]
		},
		"application/pkixcmp": {
			"source": "iana",
			"extensions": [
				"pki"
			]
		},
		"application/pls+xml": {
			"source": "iana",
			"extensions": [
				"pls"
			]
		},
		"application/poc-settings+xml": {
			"source": "iana"
		},
		"application/postscript": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"ai",
				"eps",
				"ps"
			]
		},
		"application/provenance+xml": {
			"source": "iana"
		},
		"application/prs.alvestrand.titrax-sheet": {
			"source": "iana"
		},
		"application/prs.cww": {
			"source": "iana",
			"extensions": [
				"cww"
			]
		},
		"application/prs.hpub+zip": {
			"source": "iana"
		},
		"application/prs.nprend": {
			"source": "iana"
		},
		"application/prs.plucker": {
			"source": "iana"
		},
		"application/prs.rdf-xml-crypt": {
			"source": "iana"
		},
		"application/prs.xsf+xml": {
			"source": "iana"
		},
		"application/pskc+xml": {
			"source": "iana",
			"extensions": [
				"pskcxml"
			]
		},
		"application/qsig": {
			"source": "iana"
		},
		"application/raptorfec": {
			"source": "iana"
		},
		"application/rdap+json": {
			"source": "iana",
			"compressible": true
		},
		"application/rdf+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rdf"
			]
		},
		"application/reginfo+xml": {
			"source": "iana",
			"extensions": [
				"rif"
			]
		},
		"application/relax-ng-compact-syntax": {
			"source": "iana",
			"extensions": [
				"rnc"
			]
		},
		"application/remote-printing": {
			"source": "iana"
		},
		"application/reputon+json": {
			"source": "iana",
			"compressible": true
		},
		"application/resource-lists+xml": {
			"source": "iana",
			"extensions": [
				"rl"
			]
		},
		"application/resource-lists-diff+xml": {
			"source": "iana",
			"extensions": [
				"rld"
			]
		},
		"application/riscos": {
			"source": "iana"
		},
		"application/rlmi+xml": {
			"source": "iana"
		},
		"application/rls-services+xml": {
			"source": "iana",
			"extensions": [
				"rs"
			]
		},
		"application/rpki-ghostbusters": {
			"source": "iana",
			"extensions": [
				"gbr"
			]
		},
		"application/rpki-manifest": {
			"source": "iana",
			"extensions": [
				"mft"
			]
		},
		"application/rpki-roa": {
			"source": "iana",
			"extensions": [
				"roa"
			]
		},
		"application/rpki-updown": {
			"source": "iana"
		},
		"application/rsd+xml": {
			"source": "apache",
			"extensions": [
				"rsd"
			]
		},
		"application/rss+xml": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"rss"
			]
		},
		"application/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtf"
			]
		},
		"application/rtploopback": {
			"source": "iana"
		},
		"application/rtx": {
			"source": "iana"
		},
		"application/samlassertion+xml": {
			"source": "iana"
		},
		"application/samlmetadata+xml": {
			"source": "iana"
		},
		"application/sbml+xml": {
			"source": "iana",
			"extensions": [
				"sbml"
			]
		},
		"application/scaip+xml": {
			"source": "iana"
		},
		"application/scvp-cv-request": {
			"source": "iana",
			"extensions": [
				"scq"
			]
		},
		"application/scvp-cv-response": {
			"source": "iana",
			"extensions": [
				"scs"
			]
		},
		"application/scvp-vp-request": {
			"source": "iana",
			"extensions": [
				"spq"
			]
		},
		"application/scvp-vp-response": {
			"source": "iana",
			"extensions": [
				"spp"
			]
		},
		"application/sdp": {
			"source": "iana",
			"extensions": [
				"sdp"
			]
		},
		"application/sep+xml": {
			"source": "iana"
		},
		"application/sep-exi": {
			"source": "iana"
		},
		"application/session-info": {
			"source": "iana"
		},
		"application/set-payment": {
			"source": "iana"
		},
		"application/set-payment-initiation": {
			"source": "iana",
			"extensions": [
				"setpay"
			]
		},
		"application/set-registration": {
			"source": "iana"
		},
		"application/set-registration-initiation": {
			"source": "iana",
			"extensions": [
				"setreg"
			]
		},
		"application/sgml": {
			"source": "iana"
		},
		"application/sgml-open-catalog": {
			"source": "iana"
		},
		"application/shf+xml": {
			"source": "iana",
			"extensions": [
				"shf"
			]
		},
		"application/sieve": {
			"source": "iana"
		},
		"application/simple-filter+xml": {
			"source": "iana"
		},
		"application/simple-message-summary": {
			"source": "iana"
		},
		"application/simplesymbolcontainer": {
			"source": "iana"
		},
		"application/slate": {
			"source": "iana"
		},
		"application/smil": {
			"source": "iana"
		},
		"application/smil+xml": {
			"source": "iana",
			"extensions": [
				"smi",
				"smil"
			]
		},
		"application/smpte336m": {
			"source": "iana"
		},
		"application/soap+fastinfoset": {
			"source": "iana"
		},
		"application/soap+xml": {
			"source": "iana",
			"compressible": true
		},
		"application/sparql-query": {
			"source": "iana",
			"extensions": [
				"rq"
			]
		},
		"application/sparql-results+xml": {
			"source": "iana",
			"extensions": [
				"srx"
			]
		},
		"application/spirits-event+xml": {
			"source": "iana"
		},
		"application/sql": {
			"source": "iana"
		},
		"application/srgs": {
			"source": "iana",
			"extensions": [
				"gram"
			]
		},
		"application/srgs+xml": {
			"source": "iana",
			"extensions": [
				"grxml"
			]
		},
		"application/sru+xml": {
			"source": "iana",
			"extensions": [
				"sru"
			]
		},
		"application/ssdl+xml": {
			"source": "apache",
			"extensions": [
				"ssdl"
			]
		},
		"application/ssml+xml": {
			"source": "iana",
			"extensions": [
				"ssml"
			]
		},
		"application/tamp-apex-update": {
			"source": "iana"
		},
		"application/tamp-apex-update-confirm": {
			"source": "iana"
		},
		"application/tamp-community-update": {
			"source": "iana"
		},
		"application/tamp-community-update-confirm": {
			"source": "iana"
		},
		"application/tamp-error": {
			"source": "iana"
		},
		"application/tamp-sequence-adjust": {
			"source": "iana"
		},
		"application/tamp-sequence-adjust-confirm": {
			"source": "iana"
		},
		"application/tamp-status-query": {
			"source": "iana"
		},
		"application/tamp-status-response": {
			"source": "iana"
		},
		"application/tamp-update": {
			"source": "iana"
		},
		"application/tamp-update-confirm": {
			"source": "iana"
		},
		"application/tar": {
			"compressible": true
		},
		"application/tei+xml": {
			"source": "iana",
			"extensions": [
				"tei",
				"teicorpus"
			]
		},
		"application/thraud+xml": {
			"source": "iana",
			"extensions": [
				"tfi"
			]
		},
		"application/timestamp-query": {
			"source": "iana"
		},
		"application/timestamp-reply": {
			"source": "iana"
		},
		"application/timestamped-data": {
			"source": "iana",
			"extensions": [
				"tsd"
			]
		},
		"application/ttml+xml": {
			"source": "iana"
		},
		"application/tve-trigger": {
			"source": "iana"
		},
		"application/ulpfec": {
			"source": "iana"
		},
		"application/urc-grpsheet+xml": {
			"source": "iana"
		},
		"application/urc-ressheet+xml": {
			"source": "iana"
		},
		"application/urc-targetdesc+xml": {
			"source": "iana"
		},
		"application/urc-uisocketdesc+xml": {
			"source": "iana"
		},
		"application/vcard+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vcard+xml": {
			"source": "iana"
		},
		"application/vemmi": {
			"source": "iana"
		},
		"application/vividence.scriptfile": {
			"source": "apache"
		},
		"application/vnd.3gpp.bsf+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp.pic-bw-large": {
			"source": "iana",
			"extensions": [
				"plb"
			]
		},
		"application/vnd.3gpp.pic-bw-small": {
			"source": "iana",
			"extensions": [
				"psb"
			]
		},
		"application/vnd.3gpp.pic-bw-var": {
			"source": "iana",
			"extensions": [
				"pvb"
			]
		},
		"application/vnd.3gpp.sms": {
			"source": "iana"
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			"source": "iana"
		},
		"application/vnd.3gpp2.sms": {
			"source": "iana"
		},
		"application/vnd.3gpp2.tcap": {
			"source": "iana",
			"extensions": [
				"tcap"
			]
		},
		"application/vnd.3m.post-it-notes": {
			"source": "iana",
			"extensions": [
				"pwn"
			]
		},
		"application/vnd.accpac.simply.aso": {
			"source": "iana",
			"extensions": [
				"aso"
			]
		},
		"application/vnd.accpac.simply.imp": {
			"source": "iana",
			"extensions": [
				"imp"
			]
		},
		"application/vnd.acucobol": {
			"source": "iana",
			"extensions": [
				"acu"
			]
		},
		"application/vnd.acucorp": {
			"source": "iana",
			"extensions": [
				"atc",
				"acutc"
			]
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			"source": "apache",
			"extensions": [
				"air"
			]
		},
		"application/vnd.adobe.flash.movie": {
			"source": "iana"
		},
		"application/vnd.adobe.formscentral.fcdt": {
			"source": "iana",
			"extensions": [
				"fcdt"
			]
		},
		"application/vnd.adobe.fxp": {
			"source": "iana",
			"extensions": [
				"fxp",
				"fxpl"
			]
		},
		"application/vnd.adobe.partial-upload": {
			"source": "iana"
		},
		"application/vnd.adobe.xdp+xml": {
			"source": "iana",
			"extensions": [
				"xdp"
			]
		},
		"application/vnd.adobe.xfdf": {
			"source": "iana",
			"extensions": [
				"xfdf"
			]
		},
		"application/vnd.aether.imp": {
			"source": "iana"
		},
		"application/vnd.ah-barcode": {
			"source": "iana"
		},
		"application/vnd.ahead.space": {
			"source": "iana",
			"extensions": [
				"ahead"
			]
		},
		"application/vnd.airzip.filesecure.azf": {
			"source": "iana",
			"extensions": [
				"azf"
			]
		},
		"application/vnd.airzip.filesecure.azs": {
			"source": "iana",
			"extensions": [
				"azs"
			]
		},
		"application/vnd.amazon.ebook": {
			"source": "apache",
			"extensions": [
				"azw"
			]
		},
		"application/vnd.americandynamics.acc": {
			"source": "iana",
			"extensions": [
				"acc"
			]
		},
		"application/vnd.amiga.ami": {
			"source": "iana",
			"extensions": [
				"ami"
			]
		},
		"application/vnd.amundsen.maze+xml": {
			"source": "iana"
		},
		"application/vnd.android.package-archive": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"apk"
			]
		},
		"application/vnd.anser-web-certificate-issue-initiation": {
			"source": "iana",
			"extensions": [
				"cii"
			]
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			"source": "apache",
			"extensions": [
				"fti"
			]
		},
		"application/vnd.antix.game-component": {
			"source": "iana",
			"extensions": [
				"atx"
			]
		},
		"application/vnd.apache.thrift.binary": {
			"source": "iana"
		},
		"application/vnd.apache.thrift.compact": {
			"source": "iana"
		},
		"application/vnd.apache.thrift.json": {
			"source": "iana"
		},
		"application/vnd.api+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.apple.installer+xml": {
			"source": "iana",
			"extensions": [
				"mpkg"
			]
		},
		"application/vnd.apple.mpegurl": {
			"source": "iana",
			"extensions": [
				"m3u8"
			]
		},
		"application/vnd.arastra.swi": {
			"source": "iana"
		},
		"application/vnd.aristanetworks.swi": {
			"source": "iana",
			"extensions": [
				"swi"
			]
		},
		"application/vnd.artsquare": {
			"source": "iana"
		},
		"application/vnd.astraea-software.iota": {
			"source": "iana",
			"extensions": [
				"iota"
			]
		},
		"application/vnd.audiograph": {
			"source": "iana",
			"extensions": [
				"aep"
			]
		},
		"application/vnd.autopackage": {
			"source": "iana"
		},
		"application/vnd.avistar+xml": {
			"source": "iana"
		},
		"application/vnd.balsamiq.bmml+xml": {
			"source": "iana"
		},
		"application/vnd.balsamiq.bmpr": {
			"source": "iana"
		},
		"application/vnd.bekitzur-stech+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.blueice.multipass": {
			"source": "iana",
			"extensions": [
				"mpm"
			]
		},
		"application/vnd.bluetooth.ep.oob": {
			"source": "iana"
		},
		"application/vnd.bluetooth.le.oob": {
			"source": "iana"
		},
		"application/vnd.bmi": {
			"source": "iana",
			"extensions": [
				"bmi"
			]
		},
		"application/vnd.businessobjects": {
			"source": "iana",
			"extensions": [
				"rep"
			]
		},
		"application/vnd.cab-jscript": {
			"source": "iana"
		},
		"application/vnd.canon-cpdl": {
			"source": "iana"
		},
		"application/vnd.canon-lips": {
			"source": "iana"
		},
		"application/vnd.cendio.thinlinc.clientconf": {
			"source": "iana"
		},
		"application/vnd.century-systems.tcp_stream": {
			"source": "iana"
		},
		"application/vnd.chemdraw+xml": {
			"source": "iana",
			"extensions": [
				"cdxml"
			]
		},
		"application/vnd.chipnuts.karaoke-mmd": {
			"source": "iana",
			"extensions": [
				"mmd"
			]
		},
		"application/vnd.cinderella": {
			"source": "iana",
			"extensions": [
				"cdy"
			]
		},
		"application/vnd.cirpack.isdn-ext": {
			"source": "iana"
		},
		"application/vnd.citationstyles.style+xml": {
			"source": "iana"
		},
		"application/vnd.claymore": {
			"source": "iana",
			"extensions": [
				"cla"
			]
		},
		"application/vnd.cloanto.rp9": {
			"source": "iana",
			"extensions": [
				"rp9"
			]
		},
		"application/vnd.clonk.c4group": {
			"source": "iana",
			"extensions": [
				"c4g",
				"c4d",
				"c4f",
				"c4p",
				"c4u"
			]
		},
		"application/vnd.cluetrust.cartomobile-config": {
			"source": "iana",
			"extensions": [
				"c11amc"
			]
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			"source": "iana",
			"extensions": [
				"c11amz"
			]
		},
		"application/vnd.coffeescript": {
			"source": "iana"
		},
		"application/vnd.collection+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.doc+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.collection.next+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.commerce-battelle": {
			"source": "iana"
		},
		"application/vnd.commonspace": {
			"source": "iana",
			"extensions": [
				"csp"
			]
		},
		"application/vnd.contact.cmsg": {
			"source": "iana",
			"extensions": [
				"cdbcmsg"
			]
		},
		"application/vnd.cosmocaller": {
			"source": "iana",
			"extensions": [
				"cmc"
			]
		},
		"application/vnd.crick.clicker": {
			"source": "iana",
			"extensions": [
				"clkx"
			]
		},
		"application/vnd.crick.clicker.keyboard": {
			"source": "iana",
			"extensions": [
				"clkk"
			]
		},
		"application/vnd.crick.clicker.palette": {
			"source": "iana",
			"extensions": [
				"clkp"
			]
		},
		"application/vnd.crick.clicker.template": {
			"source": "iana",
			"extensions": [
				"clkt"
			]
		},
		"application/vnd.crick.clicker.wordbank": {
			"source": "iana",
			"extensions": [
				"clkw"
			]
		},
		"application/vnd.criticaltools.wbs+xml": {
			"source": "iana",
			"extensions": [
				"wbs"
			]
		},
		"application/vnd.ctc-posml": {
			"source": "iana",
			"extensions": [
				"pml"
			]
		},
		"application/vnd.ctct.ws+xml": {
			"source": "iana"
		},
		"application/vnd.cups-pdf": {
			"source": "iana"
		},
		"application/vnd.cups-postscript": {
			"source": "iana"
		},
		"application/vnd.cups-ppd": {
			"source": "iana",
			"extensions": [
				"ppd"
			]
		},
		"application/vnd.cups-raster": {
			"source": "iana"
		},
		"application/vnd.cups-raw": {
			"source": "iana"
		},
		"application/vnd.curl": {
			"source": "iana"
		},
		"application/vnd.curl.car": {
			"source": "apache",
			"extensions": [
				"car"
			]
		},
		"application/vnd.curl.pcurl": {
			"source": "apache",
			"extensions": [
				"pcurl"
			]
		},
		"application/vnd.cyan.dean.root+xml": {
			"source": "iana"
		},
		"application/vnd.cybank": {
			"source": "iana"
		},
		"application/vnd.dart": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"dart"
			]
		},
		"application/vnd.data-vision.rdz": {
			"source": "iana",
			"extensions": [
				"rdz"
			]
		},
		"application/vnd.debian.binary-package": {
			"source": "iana"
		},
		"application/vnd.dece.data": {
			"source": "iana",
			"extensions": [
				"uvf",
				"uvvf",
				"uvd",
				"uvvd"
			]
		},
		"application/vnd.dece.ttml+xml": {
			"source": "iana",
			"extensions": [
				"uvt",
				"uvvt"
			]
		},
		"application/vnd.dece.unspecified": {
			"source": "iana",
			"extensions": [
				"uvx",
				"uvvx"
			]
		},
		"application/vnd.dece.zip": {
			"source": "iana",
			"extensions": [
				"uvz",
				"uvvz"
			]
		},
		"application/vnd.denovo.fcselayout-link": {
			"source": "iana",
			"extensions": [
				"fe_launch"
			]
		},
		"application/vnd.desmume-movie": {
			"source": "iana"
		},
		"application/vnd.dir-bi.plate-dl-nosuffix": {
			"source": "iana"
		},
		"application/vnd.dm.delegation+xml": {
			"source": "iana"
		},
		"application/vnd.dna": {
			"source": "iana",
			"extensions": [
				"dna"
			]
		},
		"application/vnd.document+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.dolby.mlp": {
			"source": "apache",
			"extensions": [
				"mlp"
			]
		},
		"application/vnd.dolby.mobile.1": {
			"source": "iana"
		},
		"application/vnd.dolby.mobile.2": {
			"source": "iana"
		},
		"application/vnd.doremir.scorecloud-binary-document": {
			"source": "iana"
		},
		"application/vnd.dpgraph": {
			"source": "iana",
			"extensions": [
				"dpg"
			]
		},
		"application/vnd.dreamfactory": {
			"source": "iana",
			"extensions": [
				"dfac"
			]
		},
		"application/vnd.ds-keypoint": {
			"source": "apache",
			"extensions": [
				"kpxx"
			]
		},
		"application/vnd.dtg.local": {
			"source": "iana"
		},
		"application/vnd.dtg.local.flash": {
			"source": "iana"
		},
		"application/vnd.dtg.local.html": {
			"source": "iana"
		},
		"application/vnd.dvb.ait": {
			"source": "iana",
			"extensions": [
				"ait"
			]
		},
		"application/vnd.dvb.dvbj": {
			"source": "iana"
		},
		"application/vnd.dvb.esgcontainer": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcdftnotifaccess": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgaccess": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgaccess2": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcesgpdd": {
			"source": "iana"
		},
		"application/vnd.dvb.ipdcroaming": {
			"source": "iana"
		},
		"application/vnd.dvb.iptv.alfec-base": {
			"source": "iana"
		},
		"application/vnd.dvb.iptv.alfec-enhancement": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-aggregate-root+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-container+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-generic+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.notif-init+xml": {
			"source": "iana"
		},
		"application/vnd.dvb.pfr": {
			"source": "iana"
		},
		"application/vnd.dvb.service": {
			"source": "iana",
			"extensions": [
				"svc"
			]
		},
		"application/vnd.dxr": {
			"source": "iana"
		},
		"application/vnd.dynageo": {
			"source": "iana",
			"extensions": [
				"geo"
			]
		},
		"application/vnd.dzr": {
			"source": "iana"
		},
		"application/vnd.easykaraoke.cdgdownload": {
			"source": "iana"
		},
		"application/vnd.ecdis-update": {
			"source": "iana"
		},
		"application/vnd.ecowin.chart": {
			"source": "iana",
			"extensions": [
				"mag"
			]
		},
		"application/vnd.ecowin.filerequest": {
			"source": "iana"
		},
		"application/vnd.ecowin.fileupdate": {
			"source": "iana"
		},
		"application/vnd.ecowin.series": {
			"source": "iana"
		},
		"application/vnd.ecowin.seriesrequest": {
			"source": "iana"
		},
		"application/vnd.ecowin.seriesupdate": {
			"source": "iana"
		},
		"application/vnd.emclient.accessrequest+xml": {
			"source": "iana"
		},
		"application/vnd.enliven": {
			"source": "iana",
			"extensions": [
				"nml"
			]
		},
		"application/vnd.enphase.envoy": {
			"source": "iana"
		},
		"application/vnd.eprints.data+xml": {
			"source": "iana"
		},
		"application/vnd.epson.esf": {
			"source": "iana",
			"extensions": [
				"esf"
			]
		},
		"application/vnd.epson.msf": {
			"source": "iana",
			"extensions": [
				"msf"
			]
		},
		"application/vnd.epson.quickanime": {
			"source": "iana",
			"extensions": [
				"qam"
			]
		},
		"application/vnd.epson.salt": {
			"source": "iana",
			"extensions": [
				"slt"
			]
		},
		"application/vnd.epson.ssf": {
			"source": "iana",
			"extensions": [
				"ssf"
			]
		},
		"application/vnd.ericsson.quickcall": {
			"source": "iana"
		},
		"application/vnd.eszigno3+xml": {
			"source": "iana",
			"extensions": [
				"es3",
				"et3"
			]
		},
		"application/vnd.etsi.aoc+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.asic-e+zip": {
			"source": "iana"
		},
		"application/vnd.etsi.asic-s+zip": {
			"source": "iana"
		},
		"application/vnd.etsi.cug+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvcommand+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvprofile+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvservice+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvsync+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.mcid+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.mheg5": {
			"source": "iana"
		},
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.pstn+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.sci+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.simservs+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.timestamp-token": {
			"source": "iana"
		},
		"application/vnd.etsi.tsl+xml": {
			"source": "iana"
		},
		"application/vnd.etsi.tsl.der": {
			"source": "iana"
		},
		"application/vnd.eudora.data": {
			"source": "iana"
		},
		"application/vnd.ezpix-album": {
			"source": "iana",
			"extensions": [
				"ez2"
			]
		},
		"application/vnd.ezpix-package": {
			"source": "iana",
			"extensions": [
				"ez3"
			]
		},
		"application/vnd.f-secure.mobile": {
			"source": "iana"
		},
		"application/vnd.fastcopy-disk-image": {
			"source": "iana"
		},
		"application/vnd.fdf": {
			"source": "iana",
			"extensions": [
				"fdf"
			]
		},
		"application/vnd.fdsn.mseed": {
			"source": "iana",
			"extensions": [
				"mseed"
			]
		},
		"application/vnd.fdsn.seed": {
			"source": "iana",
			"extensions": [
				"seed",
				"dataless"
			]
		},
		"application/vnd.ffsns": {
			"source": "iana"
		},
		"application/vnd.fints": {
			"source": "iana"
		},
		"application/vnd.flographit": {
			"source": "iana",
			"extensions": [
				"gph"
			]
		},
		"application/vnd.fluxtime.clip": {
			"source": "iana",
			"extensions": [
				"ftc"
			]
		},
		"application/vnd.font-fontforge-sfd": {
			"source": "iana"
		},
		"application/vnd.framemaker": {
			"source": "iana",
			"extensions": [
				"fm",
				"frame",
				"maker",
				"book"
			]
		},
		"application/vnd.frogans.fnc": {
			"source": "iana",
			"extensions": [
				"fnc"
			]
		},
		"application/vnd.frogans.ltf": {
			"source": "iana",
			"extensions": [
				"ltf"
			]
		},
		"application/vnd.fsc.weblaunch": {
			"source": "iana",
			"extensions": [
				"fsc"
			]
		},
		"application/vnd.fujitsu.oasys": {
			"source": "iana",
			"extensions": [
				"oas"
			]
		},
		"application/vnd.fujitsu.oasys2": {
			"source": "iana",
			"extensions": [
				"oa2"
			]
		},
		"application/vnd.fujitsu.oasys3": {
			"source": "iana",
			"extensions": [
				"oa3"
			]
		},
		"application/vnd.fujitsu.oasysgp": {
			"source": "iana",
			"extensions": [
				"fg5"
			]
		},
		"application/vnd.fujitsu.oasysprs": {
			"source": "iana",
			"extensions": [
				"bh2"
			]
		},
		"application/vnd.fujixerox.art-ex": {
			"source": "iana"
		},
		"application/vnd.fujixerox.art4": {
			"source": "iana"
		},
		"application/vnd.fujixerox.ddd": {
			"source": "iana",
			"extensions": [
				"ddd"
			]
		},
		"application/vnd.fujixerox.docuworks": {
			"source": "iana",
			"extensions": [
				"xdw"
			]
		},
		"application/vnd.fujixerox.docuworks.binder": {
			"source": "iana",
			"extensions": [
				"xbd"
			]
		},
		"application/vnd.fujixerox.docuworks.container": {
			"source": "iana"
		},
		"application/vnd.fujixerox.hbpl": {
			"source": "iana"
		},
		"application/vnd.fut-misnet": {
			"source": "iana"
		},
		"application/vnd.fuzzysheet": {
			"source": "iana",
			"extensions": [
				"fzs"
			]
		},
		"application/vnd.genomatix.tuxedo": {
			"source": "iana",
			"extensions": [
				"txd"
			]
		},
		"application/vnd.geo+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.geocube+xml": {
			"source": "iana"
		},
		"application/vnd.geogebra.file": {
			"source": "iana",
			"extensions": [
				"ggb"
			]
		},
		"application/vnd.geogebra.tool": {
			"source": "iana",
			"extensions": [
				"ggt"
			]
		},
		"application/vnd.geometry-explorer": {
			"source": "iana",
			"extensions": [
				"gex",
				"gre"
			]
		},
		"application/vnd.geonext": {
			"source": "iana",
			"extensions": [
				"gxt"
			]
		},
		"application/vnd.geoplan": {
			"source": "iana",
			"extensions": [
				"g2w"
			]
		},
		"application/vnd.geospace": {
			"source": "iana",
			"extensions": [
				"g3w"
			]
		},
		"application/vnd.gerber": {
			"source": "iana"
		},
		"application/vnd.globalplatform.card-content-mgt": {
			"source": "iana"
		},
		"application/vnd.globalplatform.card-content-mgt-response": {
			"source": "iana"
		},
		"application/vnd.gmx": {
			"source": "iana",
			"extensions": [
				"gmx"
			]
		},
		"application/vnd.google-earth.kml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"kml"
			]
		},
		"application/vnd.google-earth.kmz": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"kmz"
			]
		},
		"application/vnd.gov.sk.e-form+xml": {
			"source": "iana"
		},
		"application/vnd.gov.sk.e-form+zip": {
			"source": "iana"
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			"source": "iana"
		},
		"application/vnd.grafeq": {
			"source": "iana",
			"extensions": [
				"gqf",
				"gqs"
			]
		},
		"application/vnd.gridmp": {
			"source": "iana"
		},
		"application/vnd.groove-account": {
			"source": "iana",
			"extensions": [
				"gac"
			]
		},
		"application/vnd.groove-help": {
			"source": "iana",
			"extensions": [
				"ghf"
			]
		},
		"application/vnd.groove-identity-message": {
			"source": "iana",
			"extensions": [
				"gim"
			]
		},
		"application/vnd.groove-injector": {
			"source": "iana",
			"extensions": [
				"grv"
			]
		},
		"application/vnd.groove-tool-message": {
			"source": "iana",
			"extensions": [
				"gtm"
			]
		},
		"application/vnd.groove-tool-template": {
			"source": "iana",
			"extensions": [
				"tpl"
			]
		},
		"application/vnd.groove-vcard": {
			"source": "iana",
			"extensions": [
				"vcg"
			]
		},
		"application/vnd.hal+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hal+xml": {
			"source": "iana",
			"extensions": [
				"hal"
			]
		},
		"application/vnd.handheld-entertainment+xml": {
			"source": "iana",
			"extensions": [
				"zmm"
			]
		},
		"application/vnd.hbci": {
			"source": "iana",
			"extensions": [
				"hbci"
			]
		},
		"application/vnd.hcl-bireports": {
			"source": "iana"
		},
		"application/vnd.heroku+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hhe.lesson-player": {
			"source": "iana",
			"extensions": [
				"les"
			]
		},
		"application/vnd.hp-hpgl": {
			"source": "iana",
			"extensions": [
				"hpgl"
			]
		},
		"application/vnd.hp-hpid": {
			"source": "iana",
			"extensions": [
				"hpid"
			]
		},
		"application/vnd.hp-hps": {
			"source": "iana",
			"extensions": [
				"hps"
			]
		},
		"application/vnd.hp-jlyt": {
			"source": "iana",
			"extensions": [
				"jlt"
			]
		},
		"application/vnd.hp-pcl": {
			"source": "iana",
			"extensions": [
				"pcl"
			]
		},
		"application/vnd.hp-pclxl": {
			"source": "iana",
			"extensions": [
				"pclxl"
			]
		},
		"application/vnd.httphone": {
			"source": "iana"
		},
		"application/vnd.hydrostatix.sof-data": {
			"source": "iana",
			"extensions": [
				"sfd-hdstx"
			]
		},
		"application/vnd.hyperdrive+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.hzn-3d-crossword": {
			"source": "iana"
		},
		"application/vnd.ibm.afplinedata": {
			"source": "iana"
		},
		"application/vnd.ibm.electronic-media": {
			"source": "iana"
		},
		"application/vnd.ibm.minipay": {
			"source": "iana",
			"extensions": [
				"mpy"
			]
		},
		"application/vnd.ibm.modcap": {
			"source": "iana",
			"extensions": [
				"afp",
				"listafp",
				"list3820"
			]
		},
		"application/vnd.ibm.rights-management": {
			"source": "iana",
			"extensions": [
				"irm"
			]
		},
		"application/vnd.ibm.secure-container": {
			"source": "iana",
			"extensions": [
				"sc"
			]
		},
		"application/vnd.iccprofile": {
			"source": "iana",
			"extensions": [
				"icc",
				"icm"
			]
		},
		"application/vnd.ieee.1905": {
			"source": "iana"
		},
		"application/vnd.igloader": {
			"source": "iana",
			"extensions": [
				"igl"
			]
		},
		"application/vnd.immervision-ivp": {
			"source": "iana",
			"extensions": [
				"ivp"
			]
		},
		"application/vnd.immervision-ivu": {
			"source": "iana",
			"extensions": [
				"ivu"
			]
		},
		"application/vnd.ims.imsccv1p1": {
			"source": "iana"
		},
		"application/vnd.ims.imsccv1p2": {
			"source": "iana"
		},
		"application/vnd.ims.imsccv1p3": {
			"source": "iana"
		},
		"application/vnd.ims.lis.v2.result+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.informedcontrol.rms+xml": {
			"source": "iana"
		},
		"application/vnd.informix-visionary": {
			"source": "iana"
		},
		"application/vnd.infotech.project": {
			"source": "iana"
		},
		"application/vnd.infotech.project+xml": {
			"source": "iana"
		},
		"application/vnd.innopath.wamp.notification": {
			"source": "iana"
		},
		"application/vnd.insors.igm": {
			"source": "iana",
			"extensions": [
				"igm"
			]
		},
		"application/vnd.intercon.formnet": {
			"source": "iana",
			"extensions": [
				"xpw",
				"xpx"
			]
		},
		"application/vnd.intergeo": {
			"source": "iana",
			"extensions": [
				"i2g"
			]
		},
		"application/vnd.intertrust.digibox": {
			"source": "iana"
		},
		"application/vnd.intertrust.nncp": {
			"source": "iana"
		},
		"application/vnd.intu.qbo": {
			"source": "iana",
			"extensions": [
				"qbo"
			]
		},
		"application/vnd.intu.qfx": {
			"source": "iana",
			"extensions": [
				"qfx"
			]
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			"source": "iana"
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			"source": "iana"
		},
		"application/vnd.ipunplugged.rcprofile": {
			"source": "iana",
			"extensions": [
				"rcprofile"
			]
		},
		"application/vnd.irepository.package+xml": {
			"source": "iana",
			"extensions": [
				"irp"
			]
		},
		"application/vnd.is-xpr": {
			"source": "iana",
			"extensions": [
				"xpr"
			]
		},
		"application/vnd.isac.fcs": {
			"source": "iana",
			"extensions": [
				"fcs"
			]
		},
		"application/vnd.jam": {
			"source": "iana",
			"extensions": [
				"jam"
			]
		},
		"application/vnd.japannet-directory-service": {
			"source": "iana"
		},
		"application/vnd.japannet-jpnstore-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-payment-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-registration": {
			"source": "iana"
		},
		"application/vnd.japannet-registration-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-setstore-wakeup": {
			"source": "iana"
		},
		"application/vnd.japannet-verification": {
			"source": "iana"
		},
		"application/vnd.japannet-verification-wakeup": {
			"source": "iana"
		},
		"application/vnd.jcp.javame.midlet-rms": {
			"source": "iana",
			"extensions": [
				"rms"
			]
		},
		"application/vnd.jisp": {
			"source": "iana",
			"extensions": [
				"jisp"
			]
		},
		"application/vnd.joost.joda-archive": {
			"source": "iana",
			"extensions": [
				"joda"
			]
		},
		"application/vnd.jsk.isdn-ngn": {
			"source": "iana"
		},
		"application/vnd.kahootz": {
			"source": "iana",
			"extensions": [
				"ktz",
				"ktr"
			]
		},
		"application/vnd.kde.karbon": {
			"source": "iana",
			"extensions": [
				"karbon"
			]
		},
		"application/vnd.kde.kchart": {
			"source": "iana",
			"extensions": [
				"chrt"
			]
		},
		"application/vnd.kde.kformula": {
			"source": "iana",
			"extensions": [
				"kfo"
			]
		},
		"application/vnd.kde.kivio": {
			"source": "iana",
			"extensions": [
				"flw"
			]
		},
		"application/vnd.kde.kontour": {
			"source": "iana",
			"extensions": [
				"kon"
			]
		},
		"application/vnd.kde.kpresenter": {
			"source": "iana",
			"extensions": [
				"kpr",
				"kpt"
			]
		},
		"application/vnd.kde.kspread": {
			"source": "iana",
			"extensions": [
				"ksp"
			]
		},
		"application/vnd.kde.kword": {
			"source": "iana",
			"extensions": [
				"kwd",
				"kwt"
			]
		},
		"application/vnd.kenameaapp": {
			"source": "iana",
			"extensions": [
				"htke"
			]
		},
		"application/vnd.kidspiration": {
			"source": "iana",
			"extensions": [
				"kia"
			]
		},
		"application/vnd.kinar": {
			"source": "iana",
			"extensions": [
				"kne",
				"knp"
			]
		},
		"application/vnd.koan": {
			"source": "iana",
			"extensions": [
				"skp",
				"skd",
				"skt",
				"skm"
			]
		},
		"application/vnd.kodak-descriptor": {
			"source": "iana",
			"extensions": [
				"sse"
			]
		},
		"application/vnd.las.las+xml": {
			"source": "iana",
			"extensions": [
				"lasxml"
			]
		},
		"application/vnd.liberty-request+xml": {
			"source": "iana"
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			"source": "iana",
			"extensions": [
				"lbd"
			]
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			"source": "iana",
			"extensions": [
				"lbe"
			]
		},
		"application/vnd.lotus-1-2-3": {
			"source": "iana",
			"extensions": [
				"123"
			]
		},
		"application/vnd.lotus-approach": {
			"source": "iana",
			"extensions": [
				"apr"
			]
		},
		"application/vnd.lotus-freelance": {
			"source": "iana",
			"extensions": [
				"pre"
			]
		},
		"application/vnd.lotus-notes": {
			"source": "iana",
			"extensions": [
				"nsf"
			]
		},
		"application/vnd.lotus-organizer": {
			"source": "iana",
			"extensions": [
				"org"
			]
		},
		"application/vnd.lotus-screencam": {
			"source": "iana",
			"extensions": [
				"scm"
			]
		},
		"application/vnd.lotus-wordpro": {
			"source": "iana",
			"extensions": [
				"lwp"
			]
		},
		"application/vnd.macports.portpkg": {
			"source": "iana",
			"extensions": [
				"portpkg"
			]
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.license+xml": {
			"source": "iana"
		},
		"application/vnd.marlin.drm.mdcf": {
			"source": "iana"
		},
		"application/vnd.mason+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.maxmind.maxmind-db": {
			"source": "iana"
		},
		"application/vnd.mcd": {
			"source": "iana",
			"extensions": [
				"mcd"
			]
		},
		"application/vnd.medcalcdata": {
			"source": "iana",
			"extensions": [
				"mc1"
			]
		},
		"application/vnd.mediastation.cdkey": {
			"source": "iana",
			"extensions": [
				"cdkey"
			]
		},
		"application/vnd.meridian-slingshot": {
			"source": "iana"
		},
		"application/vnd.mfer": {
			"source": "iana",
			"extensions": [
				"mwf"
			]
		},
		"application/vnd.mfmp": {
			"source": "iana",
			"extensions": [
				"mfm"
			]
		},
		"application/vnd.micro+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.micrografx.flo": {
			"source": "iana",
			"extensions": [
				"flo"
			]
		},
		"application/vnd.micrografx.igx": {
			"source": "iana",
			"extensions": [
				"igx"
			]
		},
		"application/vnd.microsoft.portable-executable": {
			"source": "iana"
		},
		"application/vnd.miele+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.mif": {
			"source": "iana",
			"extensions": [
				"mif"
			]
		},
		"application/vnd.minisoft-hp3000-save": {
			"source": "iana"
		},
		"application/vnd.mitsubishi.misty-guard.trustweb": {
			"source": "iana"
		},
		"application/vnd.mobius.daf": {
			"source": "iana",
			"extensions": [
				"daf"
			]
		},
		"application/vnd.mobius.dis": {
			"source": "iana",
			"extensions": [
				"dis"
			]
		},
		"application/vnd.mobius.mbk": {
			"source": "iana",
			"extensions": [
				"mbk"
			]
		},
		"application/vnd.mobius.mqy": {
			"source": "iana",
			"extensions": [
				"mqy"
			]
		},
		"application/vnd.mobius.msl": {
			"source": "iana",
			"extensions": [
				"msl"
			]
		},
		"application/vnd.mobius.plc": {
			"source": "iana",
			"extensions": [
				"plc"
			]
		},
		"application/vnd.mobius.txf": {
			"source": "iana",
			"extensions": [
				"txf"
			]
		},
		"application/vnd.mophun.application": {
			"source": "iana",
			"extensions": [
				"mpn"
			]
		},
		"application/vnd.mophun.certificate": {
			"source": "iana",
			"extensions": [
				"mpc"
			]
		},
		"application/vnd.motorola.flexsuite": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.adsi": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.fis": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.gotap": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.kmr": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.ttc": {
			"source": "iana"
		},
		"application/vnd.motorola.flexsuite.wem": {
			"source": "iana"
		},
		"application/vnd.motorola.iprm": {
			"source": "iana"
		},
		"application/vnd.mozilla.xul+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xul"
			]
		},
		"application/vnd.ms-3mfdocument": {
			"source": "iana"
		},
		"application/vnd.ms-artgalry": {
			"source": "iana",
			"extensions": [
				"cil"
			]
		},
		"application/vnd.ms-asf": {
			"source": "iana"
		},
		"application/vnd.ms-cab-compressed": {
			"source": "iana",
			"extensions": [
				"cab"
			]
		},
		"application/vnd.ms-color.iccprofile": {
			"source": "apache"
		},
		"application/vnd.ms-excel": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xls",
				"xlm",
				"xla",
				"xlc",
				"xlt",
				"xlw"
			]
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlam"
			]
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlsb"
			]
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xlsm"
			]
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"xltm"
			]
		},
		"application/vnd.ms-fontobject": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"eot"
			]
		},
		"application/vnd.ms-htmlhelp": {
			"source": "iana",
			"extensions": [
				"chm"
			]
		},
		"application/vnd.ms-ims": {
			"source": "iana",
			"extensions": [
				"ims"
			]
		},
		"application/vnd.ms-lrm": {
			"source": "iana",
			"extensions": [
				"lrm"
			]
		},
		"application/vnd.ms-office.activex+xml": {
			"source": "iana"
		},
		"application/vnd.ms-officetheme": {
			"source": "iana",
			"extensions": [
				"thmx"
			]
		},
		"application/vnd.ms-opentype": {
			"source": "apache",
			"compressible": true
		},
		"application/vnd.ms-package.obfuscated-opentype": {
			"source": "apache"
		},
		"application/vnd.ms-pki.seccat": {
			"source": "apache",
			"extensions": [
				"cat"
			]
		},
		"application/vnd.ms-pki.stl": {
			"source": "apache",
			"extensions": [
				"stl"
			]
		},
		"application/vnd.ms-playready.initiator+xml": {
			"source": "iana"
		},
		"application/vnd.ms-powerpoint": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ppt",
				"pps",
				"pot"
			]
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"ppam"
			]
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"pptm"
			]
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"sldm"
			]
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"ppsm"
			]
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"potm"
			]
		},
		"application/vnd.ms-printing.printticket+xml": {
			"source": "apache"
		},
		"application/vnd.ms-project": {
			"source": "iana",
			"extensions": [
				"mpp",
				"mpt"
			]
		},
		"application/vnd.ms-tnef": {
			"source": "iana"
		},
		"application/vnd.ms-windows.printerpairing": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.lic-chlg-req": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.lic-resp": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.meter-chlg-req": {
			"source": "iana"
		},
		"application/vnd.ms-wmdrm.meter-resp": {
			"source": "iana"
		},
		"application/vnd.ms-word.document.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"docm"
			]
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			"source": "iana",
			"extensions": [
				"dotm"
			]
		},
		"application/vnd.ms-works": {
			"source": "iana",
			"extensions": [
				"wps",
				"wks",
				"wcm",
				"wdb"
			]
		},
		"application/vnd.ms-wpl": {
			"source": "iana",
			"extensions": [
				"wpl"
			]
		},
		"application/vnd.ms-xpsdocument": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xps"
			]
		},
		"application/vnd.msa-disk-image": {
			"source": "iana"
		},
		"application/vnd.mseq": {
			"source": "iana",
			"extensions": [
				"mseq"
			]
		},
		"application/vnd.msign": {
			"source": "iana"
		},
		"application/vnd.multiad.creator": {
			"source": "iana"
		},
		"application/vnd.multiad.creator.cif": {
			"source": "iana"
		},
		"application/vnd.music-niff": {
			"source": "iana"
		},
		"application/vnd.musician": {
			"source": "iana",
			"extensions": [
				"mus"
			]
		},
		"application/vnd.muvee.style": {
			"source": "iana",
			"extensions": [
				"msty"
			]
		},
		"application/vnd.mynfc": {
			"source": "iana",
			"extensions": [
				"taglet"
			]
		},
		"application/vnd.ncd.control": {
			"source": "iana"
		},
		"application/vnd.ncd.reference": {
			"source": "iana"
		},
		"application/vnd.nervana": {
			"source": "iana"
		},
		"application/vnd.netfpx": {
			"source": "iana"
		},
		"application/vnd.neurolanguage.nlu": {
			"source": "iana",
			"extensions": [
				"nlu"
			]
		},
		"application/vnd.nintendo.nitro.rom": {
			"source": "iana"
		},
		"application/vnd.nintendo.snes.rom": {
			"source": "iana"
		},
		"application/vnd.nitf": {
			"source": "iana",
			"extensions": [
				"ntf",
				"nitf"
			]
		},
		"application/vnd.noblenet-directory": {
			"source": "iana",
			"extensions": [
				"nnd"
			]
		},
		"application/vnd.noblenet-sealer": {
			"source": "iana",
			"extensions": [
				"nns"
			]
		},
		"application/vnd.noblenet-web": {
			"source": "iana",
			"extensions": [
				"nnw"
			]
		},
		"application/vnd.nokia.catalogs": {
			"source": "iana"
		},
		"application/vnd.nokia.conml+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.conml+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.iptv.config+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.isds-radio-presets": {
			"source": "iana"
		},
		"application/vnd.nokia.landmark+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.landmark+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.n-gage.data": {
			"source": "iana",
			"extensions": [
				"ngdat"
			]
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			"source": "iana",
			"extensions": [
				"n-gage"
			]
		},
		"application/vnd.nokia.ncd": {
			"source": "iana"
		},
		"application/vnd.nokia.pcd+wbxml": {
			"source": "iana"
		},
		"application/vnd.nokia.pcd+xml": {
			"source": "iana"
		},
		"application/vnd.nokia.radio-preset": {
			"source": "iana",
			"extensions": [
				"rpst"
			]
		},
		"application/vnd.nokia.radio-presets": {
			"source": "iana",
			"extensions": [
				"rpss"
			]
		},
		"application/vnd.novadigm.edm": {
			"source": "iana",
			"extensions": [
				"edm"
			]
		},
		"application/vnd.novadigm.edx": {
			"source": "iana",
			"extensions": [
				"edx"
			]
		},
		"application/vnd.novadigm.ext": {
			"source": "iana",
			"extensions": [
				"ext"
			]
		},
		"application/vnd.ntt-local.content-share": {
			"source": "iana"
		},
		"application/vnd.ntt-local.file-transfer": {
			"source": "iana"
		},
		"application/vnd.ntt-local.ogw_remote-access": {
			"source": "iana"
		},
		"application/vnd.ntt-local.sip-ta_remote": {
			"source": "iana"
		},
		"application/vnd.ntt-local.sip-ta_tcp_stream": {
			"source": "iana"
		},
		"application/vnd.oasis.opendocument.chart": {
			"source": "iana",
			"extensions": [
				"odc"
			]
		},
		"application/vnd.oasis.opendocument.chart-template": {
			"source": "iana",
			"extensions": [
				"otc"
			]
		},
		"application/vnd.oasis.opendocument.database": {
			"source": "iana",
			"extensions": [
				"odb"
			]
		},
		"application/vnd.oasis.opendocument.formula": {
			"source": "iana",
			"extensions": [
				"odf"
			]
		},
		"application/vnd.oasis.opendocument.formula-template": {
			"source": "iana",
			"extensions": [
				"odft"
			]
		},
		"application/vnd.oasis.opendocument.graphics": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odg"
			]
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			"source": "iana",
			"extensions": [
				"otg"
			]
		},
		"application/vnd.oasis.opendocument.image": {
			"source": "iana",
			"extensions": [
				"odi"
			]
		},
		"application/vnd.oasis.opendocument.image-template": {
			"source": "iana",
			"extensions": [
				"oti"
			]
		},
		"application/vnd.oasis.opendocument.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odp"
			]
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			"source": "iana",
			"extensions": [
				"otp"
			]
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"ods"
			]
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			"source": "iana",
			"extensions": [
				"ots"
			]
		},
		"application/vnd.oasis.opendocument.text": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"odt"
			]
		},
		"application/vnd.oasis.opendocument.text-master": {
			"source": "iana",
			"extensions": [
				"odm"
			]
		},
		"application/vnd.oasis.opendocument.text-template": {
			"source": "iana",
			"extensions": [
				"ott"
			]
		},
		"application/vnd.oasis.opendocument.text-web": {
			"source": "iana",
			"extensions": [
				"oth"
			]
		},
		"application/vnd.obn": {
			"source": "iana"
		},
		"application/vnd.oftn.l10n+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.cspg-hexbinary": {
			"source": "iana"
		},
		"application/vnd.oipf.dae.svg+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.pae.gem": {
			"source": "iana"
		},
		"application/vnd.oipf.spdiscovery+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.spdlist+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.ueprofile+xml": {
			"source": "iana"
		},
		"application/vnd.oipf.userprofile+xml": {
			"source": "iana"
		},
		"application/vnd.olpc-sugar": {
			"source": "iana",
			"extensions": [
				"xo"
			]
		},
		"application/vnd.oma-scws-config": {
			"source": "iana"
		},
		"application/vnd.oma-scws-http-request": {
			"source": "iana"
		},
		"application/vnd.oma-scws-http-response": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.imd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.ltkm": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.notification+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.provisioningtrigger": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgboot": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgdd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sgdu": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.simple-symbol-container": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.sprov+xml": {
			"source": "iana"
		},
		"application/vnd.oma.bcast.stkm": {
			"source": "iana"
		},
		"application/vnd.oma.cab-address-book+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-pcc+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			"source": "iana"
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			"source": "iana"
		},
		"application/vnd.oma.dcd": {
			"source": "iana"
		},
		"application/vnd.oma.dcdc": {
			"source": "iana"
		},
		"application/vnd.oma.dd2+xml": {
			"source": "iana",
			"extensions": [
				"dd2"
			]
		},
		"application/vnd.oma.drm.risd+xml": {
			"source": "iana"
		},
		"application/vnd.oma.group-usage-list+xml": {
			"source": "iana"
		},
		"application/vnd.oma.pal+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.final-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.groups+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			"source": "iana"
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			"source": "iana"
		},
		"application/vnd.oma.push": {
			"source": "iana"
		},
		"application/vnd.oma.scidm.messages+xml": {
			"source": "iana"
		},
		"application/vnd.oma.xcap-directory+xml": {
			"source": "iana"
		},
		"application/vnd.omads-email+xml": {
			"source": "iana"
		},
		"application/vnd.omads-file+xml": {
			"source": "iana"
		},
		"application/vnd.omads-folder+xml": {
			"source": "iana"
		},
		"application/vnd.omaloc-supl-init": {
			"source": "iana"
		},
		"application/vnd.openeye.oeb": {
			"source": "iana"
		},
		"application/vnd.openofficeorg.extension": {
			"source": "apache",
			"extensions": [
				"oxt"
			]
		},
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"pptx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			"source": "iana",
			"extensions": [
				"sldx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			"source": "iana",
			"extensions": [
				"ppsx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			"source": "apache",
			"extensions": [
				"potx"
			]
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"xlsx"
			]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			"source": "apache",
			"extensions": [
				"xltx"
			]
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml-template": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"docx"
			]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			"source": "apache",
			"extensions": [
				"dotx"
			]
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			"source": "iana"
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			"source": "iana"
		},
		"application/vnd.oracle.resource+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.orange.indata": {
			"source": "iana"
		},
		"application/vnd.osa.netdeploy": {
			"source": "iana"
		},
		"application/vnd.osgeo.mapguide.package": {
			"source": "iana",
			"extensions": [
				"mgp"
			]
		},
		"application/vnd.osgi.bundle": {
			"source": "iana"
		},
		"application/vnd.osgi.dp": {
			"source": "iana",
			"extensions": [
				"dp"
			]
		},
		"application/vnd.osgi.subsystem": {
			"source": "iana",
			"extensions": [
				"esa"
			]
		},
		"application/vnd.otps.ct-kip+xml": {
			"source": "iana"
		},
		"application/vnd.palm": {
			"source": "iana",
			"extensions": [
				"pdb",
				"pqa",
				"oprc"
			]
		},
		"application/vnd.panoply": {
			"source": "iana"
		},
		"application/vnd.paos+xml": {
			"source": "iana"
		},
		"application/vnd.paos.xml": {
			"source": "apache"
		},
		"application/vnd.pawaafile": {
			"source": "iana",
			"extensions": [
				"paw"
			]
		},
		"application/vnd.pcos": {
			"source": "iana"
		},
		"application/vnd.pg.format": {
			"source": "iana",
			"extensions": [
				"str"
			]
		},
		"application/vnd.pg.osasli": {
			"source": "iana",
			"extensions": [
				"ei6"
			]
		},
		"application/vnd.piaccess.application-licence": {
			"source": "iana"
		},
		"application/vnd.picsel": {
			"source": "iana",
			"extensions": [
				"efif"
			]
		},
		"application/vnd.pmi.widget": {
			"source": "iana",
			"extensions": [
				"wg"
			]
		},
		"application/vnd.poc.group-advertisement+xml": {
			"source": "iana"
		},
		"application/vnd.pocketlearn": {
			"source": "iana",
			"extensions": [
				"plf"
			]
		},
		"application/vnd.powerbuilder6": {
			"source": "iana",
			"extensions": [
				"pbd"
			]
		},
		"application/vnd.powerbuilder6-s": {
			"source": "iana"
		},
		"application/vnd.powerbuilder7": {
			"source": "iana"
		},
		"application/vnd.powerbuilder7-s": {
			"source": "iana"
		},
		"application/vnd.powerbuilder75": {
			"source": "iana"
		},
		"application/vnd.powerbuilder75-s": {
			"source": "iana"
		},
		"application/vnd.preminet": {
			"source": "iana"
		},
		"application/vnd.previewsystems.box": {
			"source": "iana",
			"extensions": [
				"box"
			]
		},
		"application/vnd.proteus.magazine": {
			"source": "iana",
			"extensions": [
				"mgz"
			]
		},
		"application/vnd.publishare-delta-tree": {
			"source": "iana",
			"extensions": [
				"qps"
			]
		},
		"application/vnd.pvi.ptid1": {
			"source": "iana",
			"extensions": [
				"ptid"
			]
		},
		"application/vnd.pwg-multiplexed": {
			"source": "iana"
		},
		"application/vnd.pwg-xhtml-print+xml": {
			"source": "iana"
		},
		"application/vnd.qualcomm.brew-app-res": {
			"source": "iana"
		},
		"application/vnd.quark.quarkxpress": {
			"source": "iana",
			"extensions": [
				"qxd",
				"qxt",
				"qwd",
				"qwt",
				"qxl",
				"qxb"
			]
		},
		"application/vnd.quobject-quoxdocument": {
			"source": "iana"
		},
		"application/vnd.radisys.moml+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-conf+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			"source": "iana"
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			"source": "iana"
		},
		"application/vnd.rainstor.data": {
			"source": "iana"
		},
		"application/vnd.rapid": {
			"source": "iana"
		},
		"application/vnd.realvnc.bed": {
			"source": "iana",
			"extensions": [
				"bed"
			]
		},
		"application/vnd.recordare.musicxml": {
			"source": "iana",
			"extensions": [
				"mxl"
			]
		},
		"application/vnd.recordare.musicxml+xml": {
			"source": "iana",
			"extensions": [
				"musicxml"
			]
		},
		"application/vnd.renlearn.rlprint": {
			"source": "iana"
		},
		"application/vnd.rig.cryptonote": {
			"source": "iana",
			"extensions": [
				"cryptonote"
			]
		},
		"application/vnd.rim.cod": {
			"source": "apache",
			"extensions": [
				"cod"
			]
		},
		"application/vnd.rn-realmedia": {
			"source": "apache",
			"extensions": [
				"rm"
			]
		},
		"application/vnd.rn-realmedia-vbr": {
			"source": "apache",
			"extensions": [
				"rmvb"
			]
		},
		"application/vnd.route66.link66+xml": {
			"source": "iana",
			"extensions": [
				"link66"
			]
		},
		"application/vnd.rs-274x": {
			"source": "iana"
		},
		"application/vnd.ruckus.download": {
			"source": "iana"
		},
		"application/vnd.s3sms": {
			"source": "iana"
		},
		"application/vnd.sailingtracker.track": {
			"source": "iana",
			"extensions": [
				"st"
			]
		},
		"application/vnd.sbm.cid": {
			"source": "iana"
		},
		"application/vnd.sbm.mid2": {
			"source": "iana"
		},
		"application/vnd.scribus": {
			"source": "iana"
		},
		"application/vnd.sealed.3df": {
			"source": "iana"
		},
		"application/vnd.sealed.csf": {
			"source": "iana"
		},
		"application/vnd.sealed.doc": {
			"source": "iana"
		},
		"application/vnd.sealed.eml": {
			"source": "iana"
		},
		"application/vnd.sealed.mht": {
			"source": "iana"
		},
		"application/vnd.sealed.net": {
			"source": "iana"
		},
		"application/vnd.sealed.ppt": {
			"source": "iana"
		},
		"application/vnd.sealed.tiff": {
			"source": "iana"
		},
		"application/vnd.sealed.xls": {
			"source": "iana"
		},
		"application/vnd.sealedmedia.softseal.html": {
			"source": "iana"
		},
		"application/vnd.sealedmedia.softseal.pdf": {
			"source": "iana"
		},
		"application/vnd.seemail": {
			"source": "iana",
			"extensions": [
				"see"
			]
		},
		"application/vnd.sema": {
			"source": "iana",
			"extensions": [
				"sema"
			]
		},
		"application/vnd.semd": {
			"source": "iana",
			"extensions": [
				"semd"
			]
		},
		"application/vnd.semf": {
			"source": "iana",
			"extensions": [
				"semf"
			]
		},
		"application/vnd.shana.informed.formdata": {
			"source": "iana",
			"extensions": [
				"ifm"
			]
		},
		"application/vnd.shana.informed.formtemplate": {
			"source": "iana",
			"extensions": [
				"itp"
			]
		},
		"application/vnd.shana.informed.interchange": {
			"source": "iana",
			"extensions": [
				"iif"
			]
		},
		"application/vnd.shana.informed.package": {
			"source": "iana",
			"extensions": [
				"ipk"
			]
		},
		"application/vnd.simtech-mindmapper": {
			"source": "iana",
			"extensions": [
				"twd",
				"twds"
			]
		},
		"application/vnd.siren+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.smaf": {
			"source": "iana",
			"extensions": [
				"mmf"
			]
		},
		"application/vnd.smart.notebook": {
			"source": "iana"
		},
		"application/vnd.smart.teacher": {
			"source": "iana",
			"extensions": [
				"teacher"
			]
		},
		"application/vnd.software602.filler.form+xml": {
			"source": "iana"
		},
		"application/vnd.software602.filler.form-xml-zip": {
			"source": "iana"
		},
		"application/vnd.solent.sdkm+xml": {
			"source": "iana",
			"extensions": [
				"sdkm",
				"sdkd"
			]
		},
		"application/vnd.spotfire.dxp": {
			"source": "iana",
			"extensions": [
				"dxp"
			]
		},
		"application/vnd.spotfire.sfs": {
			"source": "iana",
			"extensions": [
				"sfs"
			]
		},
		"application/vnd.sss-cod": {
			"source": "iana"
		},
		"application/vnd.sss-dtf": {
			"source": "iana"
		},
		"application/vnd.sss-ntf": {
			"source": "iana"
		},
		"application/vnd.stardivision.calc": {
			"source": "apache",
			"extensions": [
				"sdc"
			]
		},
		"application/vnd.stardivision.draw": {
			"source": "apache",
			"extensions": [
				"sda"
			]
		},
		"application/vnd.stardivision.impress": {
			"source": "apache",
			"extensions": [
				"sdd"
			]
		},
		"application/vnd.stardivision.math": {
			"source": "apache",
			"extensions": [
				"smf"
			]
		},
		"application/vnd.stardivision.writer": {
			"source": "apache",
			"extensions": [
				"sdw",
				"vor"
			]
		},
		"application/vnd.stardivision.writer-global": {
			"source": "apache",
			"extensions": [
				"sgl"
			]
		},
		"application/vnd.stepmania.package": {
			"source": "iana",
			"extensions": [
				"smzip"
			]
		},
		"application/vnd.stepmania.stepchart": {
			"source": "iana",
			"extensions": [
				"sm"
			]
		},
		"application/vnd.street-stream": {
			"source": "iana"
		},
		"application/vnd.sun.wadl+xml": {
			"source": "iana"
		},
		"application/vnd.sun.xml.calc": {
			"source": "apache",
			"extensions": [
				"sxc"
			]
		},
		"application/vnd.sun.xml.calc.template": {
			"source": "apache",
			"extensions": [
				"stc"
			]
		},
		"application/vnd.sun.xml.draw": {
			"source": "apache",
			"extensions": [
				"sxd"
			]
		},
		"application/vnd.sun.xml.draw.template": {
			"source": "apache",
			"extensions": [
				"std"
			]
		},
		"application/vnd.sun.xml.impress": {
			"source": "apache",
			"extensions": [
				"sxi"
			]
		},
		"application/vnd.sun.xml.impress.template": {
			"source": "apache",
			"extensions": [
				"sti"
			]
		},
		"application/vnd.sun.xml.math": {
			"source": "apache",
			"extensions": [
				"sxm"
			]
		},
		"application/vnd.sun.xml.writer": {
			"source": "apache",
			"extensions": [
				"sxw"
			]
		},
		"application/vnd.sun.xml.writer.global": {
			"source": "apache",
			"extensions": [
				"sxg"
			]
		},
		"application/vnd.sun.xml.writer.template": {
			"source": "apache",
			"extensions": [
				"stw"
			]
		},
		"application/vnd.sus-calendar": {
			"source": "iana",
			"extensions": [
				"sus",
				"susp"
			]
		},
		"application/vnd.svd": {
			"source": "iana",
			"extensions": [
				"svd"
			]
		},
		"application/vnd.swiftview-ics": {
			"source": "iana"
		},
		"application/vnd.symbian.install": {
			"source": "apache",
			"extensions": [
				"sis",
				"sisx"
			]
		},
		"application/vnd.syncml+xml": {
			"source": "iana",
			"extensions": [
				"xsm"
			]
		},
		"application/vnd.syncml.dm+wbxml": {
			"source": "iana",
			"extensions": [
				"bdm"
			]
		},
		"application/vnd.syncml.dm+xml": {
			"source": "iana",
			"extensions": [
				"xdm"
			]
		},
		"application/vnd.syncml.dm.notification": {
			"source": "iana"
		},
		"application/vnd.syncml.dmddf+wbxml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmddf+xml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmtnds+wbxml": {
			"source": "iana"
		},
		"application/vnd.syncml.dmtnds+xml": {
			"source": "iana"
		},
		"application/vnd.syncml.ds.notification": {
			"source": "iana"
		},
		"application/vnd.tao.intent-module-archive": {
			"source": "iana",
			"extensions": [
				"tao"
			]
		},
		"application/vnd.tcpdump.pcap": {
			"source": "iana",
			"extensions": [
				"pcap",
				"cap",
				"dmp"
			]
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			"source": "iana"
		},
		"application/vnd.tmobile-livetv": {
			"source": "iana",
			"extensions": [
				"tmo"
			]
		},
		"application/vnd.trid.tpt": {
			"source": "iana",
			"extensions": [
				"tpt"
			]
		},
		"application/vnd.triscape.mxs": {
			"source": "iana",
			"extensions": [
				"mxs"
			]
		},
		"application/vnd.trueapp": {
			"source": "iana",
			"extensions": [
				"tra"
			]
		},
		"application/vnd.truedoc": {
			"source": "iana"
		},
		"application/vnd.ubisoft.webplayer": {
			"source": "iana"
		},
		"application/vnd.ufdl": {
			"source": "iana",
			"extensions": [
				"ufd",
				"ufdl"
			]
		},
		"application/vnd.uiq.theme": {
			"source": "iana",
			"extensions": [
				"utz"
			]
		},
		"application/vnd.umajin": {
			"source": "iana",
			"extensions": [
				"umj"
			]
		},
		"application/vnd.unity": {
			"source": "iana",
			"extensions": [
				"unityweb"
			]
		},
		"application/vnd.uoml+xml": {
			"source": "iana",
			"extensions": [
				"uoml"
			]
		},
		"application/vnd.uplanet.alert": {
			"source": "iana"
		},
		"application/vnd.uplanet.alert-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.bearer-choice": {
			"source": "iana"
		},
		"application/vnd.uplanet.bearer-choice-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.cacheop": {
			"source": "iana"
		},
		"application/vnd.uplanet.cacheop-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.channel": {
			"source": "iana"
		},
		"application/vnd.uplanet.channel-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.list": {
			"source": "iana"
		},
		"application/vnd.uplanet.list-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.listcmd": {
			"source": "iana"
		},
		"application/vnd.uplanet.listcmd-wbxml": {
			"source": "iana"
		},
		"application/vnd.uplanet.signal": {
			"source": "iana"
		},
		"application/vnd.valve.source.material": {
			"source": "iana"
		},
		"application/vnd.vcx": {
			"source": "iana",
			"extensions": [
				"vcx"
			]
		},
		"application/vnd.vd-study": {
			"source": "iana"
		},
		"application/vnd.vectorworks": {
			"source": "iana"
		},
		"application/vnd.verimatrix.vcas": {
			"source": "iana"
		},
		"application/vnd.vidsoft.vidconference": {
			"source": "iana"
		},
		"application/vnd.visio": {
			"source": "iana",
			"extensions": [
				"vsd",
				"vst",
				"vss",
				"vsw"
			]
		},
		"application/vnd.visionary": {
			"source": "iana",
			"extensions": [
				"vis"
			]
		},
		"application/vnd.vividence.scriptfile": {
			"source": "iana"
		},
		"application/vnd.vsf": {
			"source": "iana",
			"extensions": [
				"vsf"
			]
		},
		"application/vnd.wap.sic": {
			"source": "iana"
		},
		"application/vnd.wap.slc": {
			"source": "iana"
		},
		"application/vnd.wap.wbxml": {
			"source": "iana",
			"extensions": [
				"wbxml"
			]
		},
		"application/vnd.wap.wmlc": {
			"source": "iana",
			"extensions": [
				"wmlc"
			]
		},
		"application/vnd.wap.wmlscriptc": {
			"source": "iana",
			"extensions": [
				"wmlsc"
			]
		},
		"application/vnd.webturbo": {
			"source": "iana",
			"extensions": [
				"wtb"
			]
		},
		"application/vnd.wfa.p2p": {
			"source": "iana"
		},
		"application/vnd.wfa.wsc": {
			"source": "iana"
		},
		"application/vnd.windows.devicepairing": {
			"source": "iana"
		},
		"application/vnd.wmc": {
			"source": "iana"
		},
		"application/vnd.wmf.bootstrap": {
			"source": "iana"
		},
		"application/vnd.wolfram.mathematica": {
			"source": "iana"
		},
		"application/vnd.wolfram.mathematica.package": {
			"source": "iana"
		},
		"application/vnd.wolfram.player": {
			"source": "iana",
			"extensions": [
				"nbp"
			]
		},
		"application/vnd.wordperfect": {
			"source": "iana",
			"extensions": [
				"wpd"
			]
		},
		"application/vnd.wqd": {
			"source": "iana",
			"extensions": [
				"wqd"
			]
		},
		"application/vnd.wrq-hp3000-labelled": {
			"source": "iana"
		},
		"application/vnd.wt.stf": {
			"source": "iana",
			"extensions": [
				"stf"
			]
		},
		"application/vnd.wv.csp+wbxml": {
			"source": "iana"
		},
		"application/vnd.wv.csp+xml": {
			"source": "iana"
		},
		"application/vnd.wv.ssp+xml": {
			"source": "iana"
		},
		"application/vnd.xacml+json": {
			"source": "iana",
			"compressible": true
		},
		"application/vnd.xara": {
			"source": "iana",
			"extensions": [
				"xar"
			]
		},
		"application/vnd.xfdl": {
			"source": "iana",
			"extensions": [
				"xfdl"
			]
		},
		"application/vnd.xfdl.webform": {
			"source": "iana"
		},
		"application/vnd.xmi+xml": {
			"source": "iana"
		},
		"application/vnd.xmpie.cpkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.dpkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.plan": {
			"source": "iana"
		},
		"application/vnd.xmpie.ppkg": {
			"source": "iana"
		},
		"application/vnd.xmpie.xlim": {
			"source": "iana"
		},
		"application/vnd.yamaha.hv-dic": {
			"source": "iana",
			"extensions": [
				"hvd"
			]
		},
		"application/vnd.yamaha.hv-script": {
			"source": "iana",
			"extensions": [
				"hvs"
			]
		},
		"application/vnd.yamaha.hv-voice": {
			"source": "iana",
			"extensions": [
				"hvp"
			]
		},
		"application/vnd.yamaha.openscoreformat": {
			"source": "iana",
			"extensions": [
				"osf"
			]
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			"source": "iana",
			"extensions": [
				"osfpvg"
			]
		},
		"application/vnd.yamaha.remote-setup": {
			"source": "iana"
		},
		"application/vnd.yamaha.smaf-audio": {
			"source": "iana",
			"extensions": [
				"saf"
			]
		},
		"application/vnd.yamaha.smaf-phrase": {
			"source": "iana",
			"extensions": [
				"spf"
			]
		},
		"application/vnd.yamaha.through-ngn": {
			"source": "iana"
		},
		"application/vnd.yamaha.tunnel-udpencap": {
			"source": "iana"
		},
		"application/vnd.yaoweme": {
			"source": "iana"
		},
		"application/vnd.yellowriver-custom-menu": {
			"source": "iana",
			"extensions": [
				"cmp"
			]
		},
		"application/vnd.zul": {
			"source": "iana",
			"extensions": [
				"zir",
				"zirz"
			]
		},
		"application/vnd.zzazz.deck+xml": {
			"source": "iana",
			"extensions": [
				"zaz"
			]
		},
		"application/voicexml+xml": {
			"source": "iana",
			"extensions": [
				"vxml"
			]
		},
		"application/vq-rtcpxr": {
			"source": "iana"
		},
		"application/watcherinfo+xml": {
			"source": "iana"
		},
		"application/whoispp-query": {
			"source": "iana"
		},
		"application/whoispp-response": {
			"source": "iana"
		},
		"application/widget": {
			"source": "iana",
			"extensions": [
				"wgt"
			]
		},
		"application/winhlp": {
			"source": "apache",
			"extensions": [
				"hlp"
			]
		},
		"application/wita": {
			"source": "iana"
		},
		"application/wordperfect5.1": {
			"source": "iana"
		},
		"application/wsdl+xml": {
			"source": "iana",
			"extensions": [
				"wsdl"
			]
		},
		"application/wspolicy+xml": {
			"source": "iana",
			"extensions": [
				"wspolicy"
			]
		},
		"application/x-7z-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"7z"
			]
		},
		"application/x-abiword": {
			"source": "apache",
			"extensions": [
				"abw"
			]
		},
		"application/x-ace-compressed": {
			"source": "apache",
			"extensions": [
				"ace"
			]
		},
		"application/x-amf": {
			"source": "apache"
		},
		"application/x-apple-diskimage": {
			"source": "apache",
			"extensions": [
				"dmg"
			]
		},
		"application/x-authorware-bin": {
			"source": "apache",
			"extensions": [
				"aab",
				"x32",
				"u32",
				"vox"
			]
		},
		"application/x-authorware-map": {
			"source": "apache",
			"extensions": [
				"aam"
			]
		},
		"application/x-authorware-seg": {
			"source": "apache",
			"extensions": [
				"aas"
			]
		},
		"application/x-bcpio": {
			"source": "apache",
			"extensions": [
				"bcpio"
			]
		},
		"application/x-bdoc": {
			"compressible": false,
			"extensions": [
				"bdoc"
			]
		},
		"application/x-bittorrent": {
			"source": "apache",
			"extensions": [
				"torrent"
			]
		},
		"application/x-blorb": {
			"source": "apache",
			"extensions": [
				"blb",
				"blorb"
			]
		},
		"application/x-bzip": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"bz"
			]
		},
		"application/x-bzip2": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"bz2",
				"boz"
			]
		},
		"application/x-cbr": {
			"source": "apache",
			"extensions": [
				"cbr",
				"cba",
				"cbt",
				"cbz",
				"cb7"
			]
		},
		"application/x-cdlink": {
			"source": "apache",
			"extensions": [
				"vcd"
			]
		},
		"application/x-cfs-compressed": {
			"source": "apache",
			"extensions": [
				"cfs"
			]
		},
		"application/x-chat": {
			"source": "apache",
			"extensions": [
				"chat"
			]
		},
		"application/x-chess-pgn": {
			"source": "apache",
			"extensions": [
				"pgn"
			]
		},
		"application/x-chrome-extension": {
			"extensions": [
				"crx"
			]
		},
		"application/x-compress": {
			"source": "apache"
		},
		"application/x-conference": {
			"source": "apache",
			"extensions": [
				"nsc"
			]
		},
		"application/x-cpio": {
			"source": "apache",
			"extensions": [
				"cpio"
			]
		},
		"application/x-csh": {
			"source": "apache",
			"extensions": [
				"csh"
			]
		},
		"application/x-deb": {
			"compressible": false
		},
		"application/x-debian-package": {
			"source": "apache",
			"extensions": [
				"deb",
				"udeb"
			]
		},
		"application/x-dgc-compressed": {
			"source": "apache",
			"extensions": [
				"dgc"
			]
		},
		"application/x-director": {
			"source": "apache",
			"extensions": [
				"dir",
				"dcr",
				"dxr",
				"cst",
				"cct",
				"cxt",
				"w3d",
				"fgd",
				"swa"
			]
		},
		"application/x-doom": {
			"source": "apache",
			"extensions": [
				"wad"
			]
		},
		"application/x-dtbncx+xml": {
			"source": "apache",
			"extensions": [
				"ncx"
			]
		},
		"application/x-dtbook+xml": {
			"source": "apache",
			"extensions": [
				"dtb"
			]
		},
		"application/x-dtbresource+xml": {
			"source": "apache",
			"extensions": [
				"res"
			]
		},
		"application/x-dvi": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"dvi"
			]
		},
		"application/x-envoy": {
			"source": "apache",
			"extensions": [
				"evy"
			]
		},
		"application/x-eva": {
			"source": "apache",
			"extensions": [
				"eva"
			]
		},
		"application/x-font-bdf": {
			"source": "apache",
			"extensions": [
				"bdf"
			]
		},
		"application/x-font-dos": {
			"source": "apache"
		},
		"application/x-font-framemaker": {
			"source": "apache"
		},
		"application/x-font-ghostscript": {
			"source": "apache",
			"extensions": [
				"gsf"
			]
		},
		"application/x-font-libgrx": {
			"source": "apache"
		},
		"application/x-font-linux-psf": {
			"source": "apache",
			"extensions": [
				"psf"
			]
		},
		"application/x-font-otf": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"otf"
			]
		},
		"application/x-font-pcf": {
			"source": "apache",
			"extensions": [
				"pcf"
			]
		},
		"application/x-font-snf": {
			"source": "apache",
			"extensions": [
				"snf"
			]
		},
		"application/x-font-speedo": {
			"source": "apache"
		},
		"application/x-font-sunos-news": {
			"source": "apache"
		},
		"application/x-font-ttf": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"ttf",
				"ttc"
			]
		},
		"application/x-font-type1": {
			"source": "apache",
			"extensions": [
				"pfa",
				"pfb",
				"pfm",
				"afm"
			]
		},
		"application/x-font-vfont": {
			"source": "apache"
		},
		"application/x-freearc": {
			"source": "apache",
			"extensions": [
				"arc"
			]
		},
		"application/x-futuresplash": {
			"source": "apache",
			"extensions": [
				"spl"
			]
		},
		"application/x-gca-compressed": {
			"source": "apache",
			"extensions": [
				"gca"
			]
		},
		"application/x-glulx": {
			"source": "apache",
			"extensions": [
				"ulx"
			]
		},
		"application/x-gnumeric": {
			"source": "apache",
			"extensions": [
				"gnumeric"
			]
		},
		"application/x-gramps-xml": {
			"source": "apache",
			"extensions": [
				"gramps"
			]
		},
		"application/x-gtar": {
			"source": "apache",
			"extensions": [
				"gtar"
			]
		},
		"application/x-gzip": {
			"source": "apache"
		},
		"application/x-hdf": {
			"source": "apache",
			"extensions": [
				"hdf"
			]
		},
		"application/x-install-instructions": {
			"source": "apache",
			"extensions": [
				"install"
			]
		},
		"application/x-iso9660-image": {
			"source": "apache",
			"extensions": [
				"iso"
			]
		},
		"application/x-java-jnlp-file": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"jnlp"
			]
		},
		"application/x-javascript": {
			"compressible": true
		},
		"application/x-latex": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"latex"
			]
		},
		"application/x-lua-bytecode": {
			"extensions": [
				"luac"
			]
		},
		"application/x-lzh-compressed": {
			"source": "apache",
			"extensions": [
				"lzh",
				"lha"
			]
		},
		"application/x-mie": {
			"source": "apache",
			"extensions": [
				"mie"
			]
		},
		"application/x-mobipocket-ebook": {
			"source": "apache",
			"extensions": [
				"prc",
				"mobi"
			]
		},
		"application/x-mpegurl": {
			"compressible": false
		},
		"application/x-ms-application": {
			"source": "apache",
			"extensions": [
				"application"
			]
		},
		"application/x-ms-shortcut": {
			"source": "apache",
			"extensions": [
				"lnk"
			]
		},
		"application/x-ms-wmd": {
			"source": "apache",
			"extensions": [
				"wmd"
			]
		},
		"application/x-ms-wmz": {
			"source": "apache",
			"extensions": [
				"wmz"
			]
		},
		"application/x-ms-xbap": {
			"source": "apache",
			"extensions": [
				"xbap"
			]
		},
		"application/x-msaccess": {
			"source": "apache",
			"extensions": [
				"mdb"
			]
		},
		"application/x-msbinder": {
			"source": "apache",
			"extensions": [
				"obd"
			]
		},
		"application/x-mscardfile": {
			"source": "apache",
			"extensions": [
				"crd"
			]
		},
		"application/x-msclip": {
			"source": "apache",
			"extensions": [
				"clp"
			]
		},
		"application/x-msdownload": {
			"source": "apache",
			"extensions": [
				"exe",
				"dll",
				"com",
				"bat",
				"msi"
			]
		},
		"application/x-msmediaview": {
			"source": "apache",
			"extensions": [
				"mvb",
				"m13",
				"m14"
			]
		},
		"application/x-msmetafile": {
			"source": "apache",
			"extensions": [
				"wmf",
				"wmz",
				"emf",
				"emz"
			]
		},
		"application/x-msmoney": {
			"source": "apache",
			"extensions": [
				"mny"
			]
		},
		"application/x-mspublisher": {
			"source": "apache",
			"extensions": [
				"pub"
			]
		},
		"application/x-msschedule": {
			"source": "apache",
			"extensions": [
				"scd"
			]
		},
		"application/x-msterminal": {
			"source": "apache",
			"extensions": [
				"trm"
			]
		},
		"application/x-mswrite": {
			"source": "apache",
			"extensions": [
				"wri"
			]
		},
		"application/x-netcdf": {
			"source": "apache",
			"extensions": [
				"nc",
				"cdf"
			]
		},
		"application/x-ns-proxy-autoconfig": {
			"compressible": true,
			"extensions": [
				"pac"
			]
		},
		"application/x-nzb": {
			"source": "apache",
			"extensions": [
				"nzb"
			]
		},
		"application/x-pkcs12": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"p12",
				"pfx"
			]
		},
		"application/x-pkcs7-certificates": {
			"source": "apache",
			"extensions": [
				"p7b",
				"spc"
			]
		},
		"application/x-pkcs7-certreqresp": {
			"source": "apache",
			"extensions": [
				"p7r"
			]
		},
		"application/x-rar-compressed": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"rar"
			]
		},
		"application/x-research-info-systems": {
			"source": "apache",
			"extensions": [
				"ris"
			]
		},
		"application/x-sh": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"sh"
			]
		},
		"application/x-shar": {
			"source": "apache",
			"extensions": [
				"shar"
			]
		},
		"application/x-shockwave-flash": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"swf"
			]
		},
		"application/x-silverlight-app": {
			"source": "apache",
			"extensions": [
				"xap"
			]
		},
		"application/x-sql": {
			"source": "apache",
			"extensions": [
				"sql"
			]
		},
		"application/x-stuffit": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"sit"
			]
		},
		"application/x-stuffitx": {
			"source": "apache",
			"extensions": [
				"sitx"
			]
		},
		"application/x-subrip": {
			"source": "apache",
			"extensions": [
				"srt"
			]
		},
		"application/x-sv4cpio": {
			"source": "apache",
			"extensions": [
				"sv4cpio"
			]
		},
		"application/x-sv4crc": {
			"source": "apache",
			"extensions": [
				"sv4crc"
			]
		},
		"application/x-t3vm-image": {
			"source": "apache",
			"extensions": [
				"t3"
			]
		},
		"application/x-tads": {
			"source": "apache",
			"extensions": [
				"gam"
			]
		},
		"application/x-tar": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"tar"
			]
		},
		"application/x-tcl": {
			"source": "apache",
			"extensions": [
				"tcl"
			]
		},
		"application/x-tex": {
			"source": "apache",
			"extensions": [
				"tex"
			]
		},
		"application/x-tex-tfm": {
			"source": "apache",
			"extensions": [
				"tfm"
			]
		},
		"application/x-texinfo": {
			"source": "apache",
			"extensions": [
				"texinfo",
				"texi"
			]
		},
		"application/x-tgif": {
			"source": "apache",
			"extensions": [
				"obj"
			]
		},
		"application/x-ustar": {
			"source": "apache",
			"extensions": [
				"ustar"
			]
		},
		"application/x-wais-source": {
			"source": "apache",
			"extensions": [
				"src"
			]
		},
		"application/x-web-app-manifest+json": {
			"compressible": true,
			"extensions": [
				"webapp"
			]
		},
		"application/x-www-form-urlencoded": {
			"source": "iana",
			"compressible": true
		},
		"application/x-x509-ca-cert": {
			"source": "apache",
			"extensions": [
				"der",
				"crt"
			]
		},
		"application/x-xfig": {
			"source": "apache",
			"extensions": [
				"fig"
			]
		},
		"application/x-xliff+xml": {
			"source": "apache",
			"extensions": [
				"xlf"
			]
		},
		"application/x-xpinstall": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"xpi"
			]
		},
		"application/x-xz": {
			"source": "apache",
			"extensions": [
				"xz"
			]
		},
		"application/x-zmachine": {
			"source": "apache",
			"extensions": [
				"z1",
				"z2",
				"z3",
				"z4",
				"z5",
				"z6",
				"z7",
				"z8"
			]
		},
		"application/x400-bp": {
			"source": "iana"
		},
		"application/xacml+xml": {
			"source": "iana"
		},
		"application/xaml+xml": {
			"source": "apache",
			"extensions": [
				"xaml"
			]
		},
		"application/xcap-att+xml": {
			"source": "iana"
		},
		"application/xcap-caps+xml": {
			"source": "iana"
		},
		"application/xcap-diff+xml": {
			"source": "iana",
			"extensions": [
				"xdf"
			]
		},
		"application/xcap-el+xml": {
			"source": "iana"
		},
		"application/xcap-error+xml": {
			"source": "iana"
		},
		"application/xcap-ns+xml": {
			"source": "iana"
		},
		"application/xcon-conference-info+xml": {
			"source": "iana"
		},
		"application/xcon-conference-info-diff+xml": {
			"source": "iana"
		},
		"application/xenc+xml": {
			"source": "iana",
			"extensions": [
				"xenc"
			]
		},
		"application/xhtml+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xhtml",
				"xht"
			]
		},
		"application/xhtml-voice+xml": {
			"source": "apache"
		},
		"application/xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xml",
				"xsl",
				"xsd"
			]
		},
		"application/xml-dtd": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"dtd"
			]
		},
		"application/xml-external-parsed-entity": {
			"source": "iana"
		},
		"application/xml-patch+xml": {
			"source": "iana"
		},
		"application/xmpp+xml": {
			"source": "iana"
		},
		"application/xop+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"xop"
			]
		},
		"application/xproc+xml": {
			"source": "apache",
			"extensions": [
				"xpl"
			]
		},
		"application/xslt+xml": {
			"source": "iana",
			"extensions": [
				"xslt"
			]
		},
		"application/xspf+xml": {
			"source": "apache",
			"extensions": [
				"xspf"
			]
		},
		"application/xv+xml": {
			"source": "iana",
			"extensions": [
				"mxml",
				"xhvml",
				"xvml",
				"xvm"
			]
		},
		"application/yang": {
			"source": "iana",
			"extensions": [
				"yang"
			]
		},
		"application/yin+xml": {
			"source": "iana",
			"extensions": [
				"yin"
			]
		},
		"application/zip": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"zip"
			]
		},
		"application/zlib": {
			"source": "iana"
		},
		"audio/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"audio/32kadpcm": {
			"source": "iana"
		},
		"audio/3gpp": {
			"source": "iana"
		},
		"audio/3gpp2": {
			"source": "iana"
		},
		"audio/ac3": {
			"source": "iana"
		},
		"audio/adpcm": {
			"source": "apache",
			"extensions": [
				"adp"
			]
		},
		"audio/amr": {
			"source": "iana"
		},
		"audio/amr-wb": {
			"source": "iana"
		},
		"audio/amr-wb+": {
			"source": "iana"
		},
		"audio/aptx": {
			"source": "iana"
		},
		"audio/asc": {
			"source": "iana"
		},
		"audio/atrac-advanced-lossless": {
			"source": "iana"
		},
		"audio/atrac-x": {
			"source": "iana"
		},
		"audio/atrac3": {
			"source": "iana"
		},
		"audio/basic": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"au",
				"snd"
			]
		},
		"audio/bv16": {
			"source": "iana"
		},
		"audio/bv32": {
			"source": "iana"
		},
		"audio/clearmode": {
			"source": "iana"
		},
		"audio/cn": {
			"source": "iana"
		},
		"audio/dat12": {
			"source": "iana"
		},
		"audio/dls": {
			"source": "iana"
		},
		"audio/dsr-es201108": {
			"source": "iana"
		},
		"audio/dsr-es202050": {
			"source": "iana"
		},
		"audio/dsr-es202211": {
			"source": "iana"
		},
		"audio/dsr-es202212": {
			"source": "iana"
		},
		"audio/dv": {
			"source": "iana"
		},
		"audio/dvi4": {
			"source": "iana"
		},
		"audio/eac3": {
			"source": "iana"
		},
		"audio/encaprtp": {
			"source": "iana"
		},
		"audio/evrc": {
			"source": "iana"
		},
		"audio/evrc-qcp": {
			"source": "iana"
		},
		"audio/evrc0": {
			"source": "iana"
		},
		"audio/evrc1": {
			"source": "iana"
		},
		"audio/evrcb": {
			"source": "iana"
		},
		"audio/evrcb0": {
			"source": "iana"
		},
		"audio/evrcb1": {
			"source": "iana"
		},
		"audio/evrcnw": {
			"source": "iana"
		},
		"audio/evrcnw0": {
			"source": "iana"
		},
		"audio/evrcnw1": {
			"source": "iana"
		},
		"audio/evrcwb": {
			"source": "iana"
		},
		"audio/evrcwb0": {
			"source": "iana"
		},
		"audio/evrcwb1": {
			"source": "iana"
		},
		"audio/fwdred": {
			"source": "iana"
		},
		"audio/g719": {
			"source": "iana"
		},
		"audio/g722": {
			"source": "iana"
		},
		"audio/g7221": {
			"source": "iana"
		},
		"audio/g723": {
			"source": "iana"
		},
		"audio/g726-16": {
			"source": "iana"
		},
		"audio/g726-24": {
			"source": "iana"
		},
		"audio/g726-32": {
			"source": "iana"
		},
		"audio/g726-40": {
			"source": "iana"
		},
		"audio/g728": {
			"source": "iana"
		},
		"audio/g729": {
			"source": "iana"
		},
		"audio/g7291": {
			"source": "iana"
		},
		"audio/g729d": {
			"source": "iana"
		},
		"audio/g729e": {
			"source": "iana"
		},
		"audio/gsm": {
			"source": "iana"
		},
		"audio/gsm-efr": {
			"source": "iana"
		},
		"audio/gsm-hr-08": {
			"source": "iana"
		},
		"audio/ilbc": {
			"source": "iana"
		},
		"audio/ip-mr_v2.5": {
			"source": "iana"
		},
		"audio/isac": {
			"source": "apache"
		},
		"audio/l16": {
			"source": "iana"
		},
		"audio/l20": {
			"source": "iana"
		},
		"audio/l24": {
			"source": "iana",
			"compressible": false
		},
		"audio/l8": {
			"source": "iana"
		},
		"audio/lpc": {
			"source": "iana"
		},
		"audio/midi": {
			"source": "apache",
			"extensions": [
				"mid",
				"midi",
				"kar",
				"rmi"
			]
		},
		"audio/mobile-xmf": {
			"source": "iana"
		},
		"audio/mp4": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mp4a",
				"m4a"
			]
		},
		"audio/mp4a-latm": {
			"source": "iana"
		},
		"audio/mpa": {
			"source": "iana"
		},
		"audio/mpa-robust": {
			"source": "iana"
		},
		"audio/mpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"mpga",
				"mp2",
				"mp2a",
				"mp3",
				"m2a",
				"m3a"
			]
		},
		"audio/mpeg4-generic": {
			"source": "iana"
		},
		"audio/musepack": {
			"source": "apache"
		},
		"audio/ogg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"oga",
				"ogg",
				"spx"
			]
		},
		"audio/opus": {
			"source": "iana"
		},
		"audio/parityfec": {
			"source": "iana"
		},
		"audio/pcma": {
			"source": "iana"
		},
		"audio/pcma-wb": {
			"source": "iana"
		},
		"audio/pcmu": {
			"source": "iana"
		},
		"audio/pcmu-wb": {
			"source": "iana"
		},
		"audio/prs.sid": {
			"source": "iana"
		},
		"audio/qcelp": {
			"source": "iana"
		},
		"audio/raptorfec": {
			"source": "iana"
		},
		"audio/red": {
			"source": "iana"
		},
		"audio/rtp-enc-aescm128": {
			"source": "iana"
		},
		"audio/rtp-midi": {
			"source": "iana"
		},
		"audio/rtploopback": {
			"source": "iana"
		},
		"audio/rtx": {
			"source": "iana"
		},
		"audio/s3m": {
			"source": "apache",
			"extensions": [
				"s3m"
			]
		},
		"audio/silk": {
			"source": "apache",
			"extensions": [
				"sil"
			]
		},
		"audio/smv": {
			"source": "iana"
		},
		"audio/smv-qcp": {
			"source": "iana"
		},
		"audio/smv0": {
			"source": "iana"
		},
		"audio/sp-midi": {
			"source": "iana"
		},
		"audio/speex": {
			"source": "iana"
		},
		"audio/t140c": {
			"source": "iana"
		},
		"audio/t38": {
			"source": "iana"
		},
		"audio/telephone-event": {
			"source": "iana"
		},
		"audio/tone": {
			"source": "iana"
		},
		"audio/uemclip": {
			"source": "iana"
		},
		"audio/ulpfec": {
			"source": "iana"
		},
		"audio/vdvi": {
			"source": "iana"
		},
		"audio/vmr-wb": {
			"source": "iana"
		},
		"audio/vnd.3gpp.iufp": {
			"source": "iana"
		},
		"audio/vnd.4sb": {
			"source": "iana"
		},
		"audio/vnd.audiokoz": {
			"source": "iana"
		},
		"audio/vnd.celp": {
			"source": "iana"
		},
		"audio/vnd.cisco.nse": {
			"source": "iana"
		},
		"audio/vnd.cmles.radio-events": {
			"source": "iana"
		},
		"audio/vnd.cns.anp1": {
			"source": "iana"
		},
		"audio/vnd.cns.inf1": {
			"source": "iana"
		},
		"audio/vnd.dece.audio": {
			"source": "iana",
			"extensions": [
				"uva",
				"uvva"
			]
		},
		"audio/vnd.digital-winds": {
			"source": "iana",
			"extensions": [
				"eol"
			]
		},
		"audio/vnd.dlna.adts": {
			"source": "iana"
		},
		"audio/vnd.dolby.heaac.1": {
			"source": "iana"
		},
		"audio/vnd.dolby.heaac.2": {
			"source": "iana"
		},
		"audio/vnd.dolby.mlp": {
			"source": "iana"
		},
		"audio/vnd.dolby.mps": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2x": {
			"source": "iana"
		},
		"audio/vnd.dolby.pl2z": {
			"source": "iana"
		},
		"audio/vnd.dolby.pulse.1": {
			"source": "iana"
		},
		"audio/vnd.dra": {
			"source": "iana",
			"extensions": [
				"dra"
			]
		},
		"audio/vnd.dts": {
			"source": "iana",
			"extensions": [
				"dts"
			]
		},
		"audio/vnd.dts.hd": {
			"source": "iana",
			"extensions": [
				"dtshd"
			]
		},
		"audio/vnd.dvb.file": {
			"source": "iana"
		},
		"audio/vnd.everad.plj": {
			"source": "iana"
		},
		"audio/vnd.hns.audio": {
			"source": "iana"
		},
		"audio/vnd.lucent.voice": {
			"source": "iana",
			"extensions": [
				"lvp"
			]
		},
		"audio/vnd.ms-playready.media.pya": {
			"source": "iana",
			"extensions": [
				"pya"
			]
		},
		"audio/vnd.nokia.mobile-xmf": {
			"source": "iana"
		},
		"audio/vnd.nortel.vbk": {
			"source": "iana"
		},
		"audio/vnd.nuera.ecelp4800": {
			"source": "iana",
			"extensions": [
				"ecelp4800"
			]
		},
		"audio/vnd.nuera.ecelp7470": {
			"source": "iana",
			"extensions": [
				"ecelp7470"
			]
		},
		"audio/vnd.nuera.ecelp9600": {
			"source": "iana",
			"extensions": [
				"ecelp9600"
			]
		},
		"audio/vnd.octel.sbc": {
			"source": "iana"
		},
		"audio/vnd.qcelp": {
			"source": "iana"
		},
		"audio/vnd.rhetorex.32kadpcm": {
			"source": "iana"
		},
		"audio/vnd.rip": {
			"source": "iana",
			"extensions": [
				"rip"
			]
		},
		"audio/vnd.rn-realaudio": {
			"compressible": false
		},
		"audio/vnd.sealedmedia.softseal.mpeg": {
			"source": "iana"
		},
		"audio/vnd.vmx.cvsd": {
			"source": "iana"
		},
		"audio/vnd.wave": {
			"compressible": false
		},
		"audio/vorbis": {
			"source": "iana",
			"compressible": false
		},
		"audio/vorbis-config": {
			"source": "iana"
		},
		"audio/wav": {
			"compressible": false,
			"extensions": [
				"wav"
			]
		},
		"audio/wave": {
			"compressible": false,
			"extensions": [
				"wav"
			]
		},
		"audio/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"weba"
			]
		},
		"audio/x-aac": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"aac"
			]
		},
		"audio/x-aiff": {
			"source": "apache",
			"extensions": [
				"aif",
				"aiff",
				"aifc"
			]
		},
		"audio/x-caf": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"caf"
			]
		},
		"audio/x-flac": {
			"source": "apache",
			"extensions": [
				"flac"
			]
		},
		"audio/x-matroska": {
			"source": "apache",
			"extensions": [
				"mka"
			]
		},
		"audio/x-mpegurl": {
			"source": "apache",
			"extensions": [
				"m3u"
			]
		},
		"audio/x-ms-wax": {
			"source": "apache",
			"extensions": [
				"wax"
			]
		},
		"audio/x-ms-wma": {
			"source": "apache",
			"extensions": [
				"wma"
			]
		},
		"audio/x-pn-realaudio": {
			"source": "apache",
			"extensions": [
				"ram",
				"ra"
			]
		},
		"audio/x-pn-realaudio-plugin": {
			"source": "apache",
			"extensions": [
				"rmp"
			]
		},
		"audio/x-tta": {
			"source": "apache"
		},
		"audio/x-wav": {
			"source": "apache",
			"extensions": [
				"wav"
			]
		},
		"audio/xm": {
			"source": "apache",
			"extensions": [
				"xm"
			]
		},
		"chemical/x-cdx": {
			"source": "apache",
			"extensions": [
				"cdx"
			]
		},
		"chemical/x-cif": {
			"source": "apache",
			"extensions": [
				"cif"
			]
		},
		"chemical/x-cmdf": {
			"source": "apache",
			"extensions": [
				"cmdf"
			]
		},
		"chemical/x-cml": {
			"source": "apache",
			"extensions": [
				"cml"
			]
		},
		"chemical/x-csml": {
			"source": "apache",
			"extensions": [
				"csml"
			]
		},
		"chemical/x-pdb": {
			"source": "apache"
		},
		"chemical/x-xyz": {
			"source": "apache",
			"extensions": [
				"xyz"
			]
		},
		"font/opentype": {
			"compressible": true,
			"extensions": [
				"otf"
			]
		},
		"image/bmp": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"bmp"
			]
		},
		"image/cgm": {
			"source": "iana",
			"extensions": [
				"cgm"
			]
		},
		"image/fits": {
			"source": "iana"
		},
		"image/g3fax": {
			"source": "iana",
			"extensions": [
				"g3"
			]
		},
		"image/gif": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"gif"
			]
		},
		"image/ief": {
			"source": "iana",
			"extensions": [
				"ief"
			]
		},
		"image/jp2": {
			"source": "iana"
		},
		"image/jpeg": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"jpeg",
				"jpg",
				"jpe"
			]
		},
		"image/jpm": {
			"source": "iana"
		},
		"image/jpx": {
			"source": "iana"
		},
		"image/ktx": {
			"source": "iana",
			"extensions": [
				"ktx"
			]
		},
		"image/naplps": {
			"source": "iana"
		},
		"image/pjpeg": {
			"compressible": false
		},
		"image/png": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"png"
			]
		},
		"image/prs.btif": {
			"source": "iana",
			"extensions": [
				"btif"
			]
		},
		"image/prs.pti": {
			"source": "iana"
		},
		"image/pwg-raster": {
			"source": "iana"
		},
		"image/sgi": {
			"source": "apache",
			"extensions": [
				"sgi"
			]
		},
		"image/svg+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"svg",
				"svgz"
			]
		},
		"image/t38": {
			"source": "iana"
		},
		"image/tiff": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"tiff",
				"tif"
			]
		},
		"image/tiff-fx": {
			"source": "iana"
		},
		"image/vnd.adobe.photoshop": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"psd"
			]
		},
		"image/vnd.airzip.accelerator.azv": {
			"source": "iana"
		},
		"image/vnd.cns.inf2": {
			"source": "iana"
		},
		"image/vnd.dece.graphic": {
			"source": "iana",
			"extensions": [
				"uvi",
				"uvvi",
				"uvg",
				"uvvg"
			]
		},
		"image/vnd.djvu": {
			"source": "iana",
			"extensions": [
				"djvu",
				"djv"
			]
		},
		"image/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": [
				"sub"
			]
		},
		"image/vnd.dwg": {
			"source": "iana",
			"extensions": [
				"dwg"
			]
		},
		"image/vnd.dxf": {
			"source": "iana",
			"extensions": [
				"dxf"
			]
		},
		"image/vnd.fastbidsheet": {
			"source": "iana",
			"extensions": [
				"fbs"
			]
		},
		"image/vnd.fpx": {
			"source": "iana",
			"extensions": [
				"fpx"
			]
		},
		"image/vnd.fst": {
			"source": "iana",
			"extensions": [
				"fst"
			]
		},
		"image/vnd.fujixerox.edmics-mmr": {
			"source": "iana",
			"extensions": [
				"mmr"
			]
		},
		"image/vnd.fujixerox.edmics-rlc": {
			"source": "iana",
			"extensions": [
				"rlc"
			]
		},
		"image/vnd.globalgraphics.pgb": {
			"source": "iana"
		},
		"image/vnd.microsoft.icon": {
			"source": "iana"
		},
		"image/vnd.mix": {
			"source": "iana"
		},
		"image/vnd.ms-modi": {
			"source": "iana",
			"extensions": [
				"mdi"
			]
		},
		"image/vnd.ms-photo": {
			"source": "apache",
			"extensions": [
				"wdp"
			]
		},
		"image/vnd.net-fpx": {
			"source": "iana",
			"extensions": [
				"npx"
			]
		},
		"image/vnd.radiance": {
			"source": "iana"
		},
		"image/vnd.sealed.png": {
			"source": "iana"
		},
		"image/vnd.sealedmedia.softseal.gif": {
			"source": "iana"
		},
		"image/vnd.sealedmedia.softseal.jpg": {
			"source": "iana"
		},
		"image/vnd.svf": {
			"source": "iana"
		},
		"image/vnd.tencent.tap": {
			"source": "iana"
		},
		"image/vnd.valve.source.texture": {
			"source": "iana"
		},
		"image/vnd.wap.wbmp": {
			"source": "iana",
			"extensions": [
				"wbmp"
			]
		},
		"image/vnd.xiff": {
			"source": "iana",
			"extensions": [
				"xif"
			]
		},
		"image/vnd.zbrush.pcx": {
			"source": "iana"
		},
		"image/webp": {
			"source": "apache",
			"extensions": [
				"webp"
			]
		},
		"image/x-3ds": {
			"source": "apache",
			"extensions": [
				"3ds"
			]
		},
		"image/x-cmu-raster": {
			"source": "apache",
			"extensions": [
				"ras"
			]
		},
		"image/x-cmx": {
			"source": "apache",
			"extensions": [
				"cmx"
			]
		},
		"image/x-freehand": {
			"source": "apache",
			"extensions": [
				"fh",
				"fhc",
				"fh4",
				"fh5",
				"fh7"
			]
		},
		"image/x-icon": {
			"source": "apache",
			"compressible": true,
			"extensions": [
				"ico"
			]
		},
		"image/x-mrsid-image": {
			"source": "apache",
			"extensions": [
				"sid"
			]
		},
		"image/x-ms-bmp": {
			"compressible": true,
			"extensions": [
				"bmp"
			]
		},
		"image/x-pcx": {
			"source": "apache",
			"extensions": [
				"pcx"
			]
		},
		"image/x-pict": {
			"source": "apache",
			"extensions": [
				"pic",
				"pct"
			]
		},
		"image/x-portable-anymap": {
			"source": "apache",
			"extensions": [
				"pnm"
			]
		},
		"image/x-portable-bitmap": {
			"source": "apache",
			"extensions": [
				"pbm"
			]
		},
		"image/x-portable-graymap": {
			"source": "apache",
			"extensions": [
				"pgm"
			]
		},
		"image/x-portable-pixmap": {
			"source": "apache",
			"extensions": [
				"ppm"
			]
		},
		"image/x-rgb": {
			"source": "apache",
			"extensions": [
				"rgb"
			]
		},
		"image/x-tga": {
			"source": "apache",
			"extensions": [
				"tga"
			]
		},
		"image/x-xbitmap": {
			"source": "apache",
			"extensions": [
				"xbm"
			]
		},
		"image/x-xcf": {
			"compressible": false
		},
		"image/x-xpixmap": {
			"source": "apache",
			"extensions": [
				"xpm"
			]
		},
		"image/x-xwindowdump": {
			"source": "apache",
			"extensions": [
				"xwd"
			]
		},
		"message/cpim": {
			"source": "iana"
		},
		"message/delivery-status": {
			"source": "iana"
		},
		"message/disposition-notification": {
			"source": "iana"
		},
		"message/external-body": {
			"source": "iana"
		},
		"message/feedback-report": {
			"source": "iana"
		},
		"message/global": {
			"source": "iana"
		},
		"message/global-delivery-status": {
			"source": "iana"
		},
		"message/global-disposition-notification": {
			"source": "iana"
		},
		"message/global-headers": {
			"source": "iana"
		},
		"message/http": {
			"source": "iana",
			"compressible": false
		},
		"message/imdn+xml": {
			"source": "iana",
			"compressible": true
		},
		"message/news": {
			"source": "iana"
		},
		"message/partial": {
			"source": "iana",
			"compressible": false
		},
		"message/rfc822": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"eml",
				"mime"
			]
		},
		"message/s-http": {
			"source": "iana"
		},
		"message/sip": {
			"source": "iana"
		},
		"message/sipfrag": {
			"source": "iana"
		},
		"message/tracking-status": {
			"source": "iana"
		},
		"message/vnd.si.simp": {
			"source": "iana"
		},
		"message/vnd.wfa.wsc": {
			"source": "iana"
		},
		"model/iges": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"igs",
				"iges"
			]
		},
		"model/mesh": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"msh",
				"mesh",
				"silo"
			]
		},
		"model/vnd.collada+xml": {
			"source": "iana",
			"extensions": [
				"dae"
			]
		},
		"model/vnd.dwf": {
			"source": "iana",
			"extensions": [
				"dwf"
			]
		},
		"model/vnd.flatland.3dml": {
			"source": "iana"
		},
		"model/vnd.gdl": {
			"source": "iana",
			"extensions": [
				"gdl"
			]
		},
		"model/vnd.gs-gdl": {
			"source": "apache"
		},
		"model/vnd.gs.gdl": {
			"source": "iana"
		},
		"model/vnd.gtw": {
			"source": "iana",
			"extensions": [
				"gtw"
			]
		},
		"model/vnd.moml+xml": {
			"source": "iana"
		},
		"model/vnd.mts": {
			"source": "iana",
			"extensions": [
				"mts"
			]
		},
		"model/vnd.opengex": {
			"source": "iana"
		},
		"model/vnd.parasolid.transmit.binary": {
			"source": "iana"
		},
		"model/vnd.parasolid.transmit.text": {
			"source": "iana"
		},
		"model/vnd.valve.source.compiled-map": {
			"source": "iana"
		},
		"model/vnd.vtu": {
			"source": "iana",
			"extensions": [
				"vtu"
			]
		},
		"model/vrml": {
			"source": "iana",
			"compressible": false,
			"extensions": [
				"wrl",
				"vrml"
			]
		},
		"model/x3d+binary": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"x3db",
				"x3dbz"
			]
		},
		"model/x3d+fastinfoset": {
			"source": "iana"
		},
		"model/x3d+vrml": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"x3dv",
				"x3dvz"
			]
		},
		"model/x3d+xml": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"x3d",
				"x3dz"
			]
		},
		"model/x3d-vrml": {
			"source": "iana"
		},
		"multipart/alternative": {
			"source": "iana",
			"compressible": false
		},
		"multipart/appledouble": {
			"source": "iana"
		},
		"multipart/byteranges": {
			"source": "iana"
		},
		"multipart/digest": {
			"source": "iana"
		},
		"multipart/encrypted": {
			"source": "iana",
			"compressible": false
		},
		"multipart/form-data": {
			"source": "iana",
			"compressible": false
		},
		"multipart/header-set": {
			"source": "iana"
		},
		"multipart/mixed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/parallel": {
			"source": "iana"
		},
		"multipart/related": {
			"source": "iana",
			"compressible": false
		},
		"multipart/report": {
			"source": "iana"
		},
		"multipart/signed": {
			"source": "iana",
			"compressible": false
		},
		"multipart/voice-message": {
			"source": "iana"
		},
		"multipart/x-mixed-replace": {
			"source": "iana"
		},
		"text/1d-interleaved-parityfec": {
			"source": "iana"
		},
		"text/cache-manifest": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"appcache",
				"manifest"
			]
		},
		"text/calendar": {
			"source": "iana",
			"extensions": [
				"ics",
				"ifb"
			]
		},
		"text/calender": {
			"compressible": true
		},
		"text/cmd": {
			"compressible": true
		},
		"text/coffeescript": {
			"extensions": [
				"coffee",
				"litcoffee"
			]
		},
		"text/css": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"css"
			]
		},
		"text/csv": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"csv"
			]
		},
		"text/csv-schema": {
			"source": "iana"
		},
		"text/directory": {
			"source": "iana"
		},
		"text/dns": {
			"source": "iana"
		},
		"text/ecmascript": {
			"source": "iana"
		},
		"text/encaprtp": {
			"source": "iana"
		},
		"text/enriched": {
			"source": "iana"
		},
		"text/fwdred": {
			"source": "iana"
		},
		"text/grammar-ref-list": {
			"source": "iana"
		},
		"text/hjson": {
			"extensions": [
				"hjson"
			]
		},
		"text/html": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"html",
				"htm"
			]
		},
		"text/jade": {
			"extensions": [
				"jade"
			]
		},
		"text/javascript": {
			"source": "iana",
			"compressible": true
		},
		"text/jcr-cnd": {
			"source": "iana"
		},
		"text/jsx": {
			"compressible": true,
			"extensions": [
				"jsx"
			]
		},
		"text/less": {
			"extensions": [
				"less"
			]
		},
		"text/markdown": {
			"source": "iana"
		},
		"text/mizar": {
			"source": "iana"
		},
		"text/n3": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"n3"
			]
		},
		"text/parameters": {
			"source": "iana"
		},
		"text/parityfec": {
			"source": "iana"
		},
		"text/plain": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"txt",
				"text",
				"conf",
				"def",
				"list",
				"log",
				"in",
				"ini"
			]
		},
		"text/provenance-notation": {
			"source": "iana"
		},
		"text/prs.fallenstein.rst": {
			"source": "iana"
		},
		"text/prs.lines.tag": {
			"source": "iana",
			"extensions": [
				"dsc"
			]
		},
		"text/raptorfec": {
			"source": "iana"
		},
		"text/red": {
			"source": "iana"
		},
		"text/rfc822-headers": {
			"source": "iana"
		},
		"text/richtext": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtx"
			]
		},
		"text/rtf": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"rtf"
			]
		},
		"text/rtp-enc-aescm128": {
			"source": "iana"
		},
		"text/rtploopback": {
			"source": "iana"
		},
		"text/rtx": {
			"source": "iana"
		},
		"text/sgml": {
			"source": "iana",
			"extensions": [
				"sgml",
				"sgm"
			]
		},
		"text/stylus": {
			"extensions": [
				"stylus",
				"styl"
			]
		},
		"text/t140": {
			"source": "iana"
		},
		"text/tab-separated-values": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"tsv"
			]
		},
		"text/troff": {
			"source": "iana",
			"extensions": [
				"t",
				"tr",
				"roff",
				"man",
				"me",
				"ms"
			]
		},
		"text/turtle": {
			"source": "iana",
			"extensions": [
				"ttl"
			]
		},
		"text/ulpfec": {
			"source": "iana"
		},
		"text/uri-list": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"uri",
				"uris",
				"urls"
			]
		},
		"text/vcard": {
			"source": "iana",
			"compressible": true,
			"extensions": [
				"vcard"
			]
		},
		"text/vnd.a": {
			"source": "iana"
		},
		"text/vnd.abc": {
			"source": "iana"
		},
		"text/vnd.curl": {
			"source": "iana",
			"extensions": [
				"curl"
			]
		},
		"text/vnd.curl.dcurl": {
			"source": "apache",
			"extensions": [
				"dcurl"
			]
		},
		"text/vnd.curl.mcurl": {
			"source": "apache",
			"extensions": [
				"mcurl"
			]
		},
		"text/vnd.curl.scurl": {
			"source": "apache",
			"extensions": [
				"scurl"
			]
		},
		"text/vnd.debian.copyright": {
			"source": "iana"
		},
		"text/vnd.dmclientscript": {
			"source": "iana"
		},
		"text/vnd.dvb.subtitle": {
			"source": "iana",
			"extensions": [
				"sub"
			]
		},
		"text/vnd.esmertec.theme-descriptor": {
			"source": "iana"
		},
		"text/vnd.fly": {
			"source": "iana",
			"extensions": [
				"fly"
			]
		},
		"text/vnd.fmi.flexstor": {
			"source": "iana",
			"extensions": [
				"flx"
			]
		},
		"text/vnd.graphviz": {
			"source": "iana",
			"extensions": [
				"gv"
			]
		},
		"text/vnd.in3d.3dml": {
			"source": "iana",
			"extensions": [
				"3dml"
			]
		},
		"text/vnd.in3d.spot": {
			"source": "iana",
			"extensions": [
				"spot"
			]
		},
		"text/vnd.iptc.newsml": {
			"source": "iana"
		},
		"text/vnd.iptc.nitf": {
			"source": "iana"
		},
		"text/vnd.latex-z": {
			"source": "iana"
		},
		"text/vnd.motorola.reflex": {
			"source": "iana"
		},
		"text/vnd.ms-mediapackage": {
			"source": "iana"
		},
		"text/vnd.net2phone.commcenter.command": {
			"source": "iana"
		},
		"text/vnd.radisys.msml-basic-layout": {
			"source": "iana"
		},
		"text/vnd.si.uricatalogue": {
			"source": "iana"
		},
		"text/vnd.sun.j2me.app-descriptor": {
			"source": "iana",
			"extensions": [
				"jad"
			]
		},
		"text/vnd.trolltech.linguist": {
			"source": "iana"
		},
		"text/vnd.wap.si": {
			"source": "iana"
		},
		"text/vnd.wap.sl": {
			"source": "iana"
		},
		"text/vnd.wap.wml": {
			"source": "iana",
			"extensions": [
				"wml"
			]
		},
		"text/vnd.wap.wmlscript": {
			"source": "iana",
			"extensions": [
				"wmls"
			]
		},
		"text/vtt": {
			"charset": "UTF-8",
			"compressible": true,
			"extensions": [
				"vtt"
			]
		},
		"text/x-asm": {
			"source": "apache",
			"extensions": [
				"s",
				"asm"
			]
		},
		"text/x-c": {
			"source": "apache",
			"extensions": [
				"c",
				"cc",
				"cxx",
				"cpp",
				"h",
				"hh",
				"dic"
			]
		},
		"text/x-component": {
			"extensions": [
				"htc"
			]
		},
		"text/x-fortran": {
			"source": "apache",
			"extensions": [
				"f",
				"for",
				"f77",
				"f90"
			]
		},
		"text/x-gwt-rpc": {
			"compressible": true
		},
		"text/x-handlebars-template": {
			"extensions": [
				"hbs"
			]
		},
		"text/x-java-source": {
			"source": "apache",
			"extensions": [
				"java"
			]
		},
		"text/x-jquery-tmpl": {
			"compressible": true
		},
		"text/x-lua": {
			"extensions": [
				"lua"
			]
		},
		"text/x-markdown": {
			"compressible": true,
			"extensions": [
				"markdown",
				"md",
				"mkd"
			]
		},
		"text/x-nfo": {
			"source": "apache",
			"extensions": [
				"nfo"
			]
		},
		"text/x-opml": {
			"source": "apache",
			"extensions": [
				"opml"
			]
		},
		"text/x-pascal": {
			"source": "apache",
			"extensions": [
				"p",
				"pas"
			]
		},
		"text/x-sass": {
			"extensions": [
				"sass"
			]
		},
		"text/x-scss": {
			"extensions": [
				"scss"
			]
		},
		"text/x-setext": {
			"source": "apache",
			"extensions": [
				"etx"
			]
		},
		"text/x-sfv": {
			"source": "apache",
			"extensions": [
				"sfv"
			]
		},
		"text/x-uuencode": {
			"source": "apache",
			"extensions": [
				"uu"
			]
		},
		"text/x-vcalendar": {
			"source": "apache",
			"extensions": [
				"vcs"
			]
		},
		"text/x-vcard": {
			"source": "apache",
			"extensions": [
				"vcf"
			]
		},
		"text/xml": {
			"source": "iana",
			"compressible": true
		},
		"text/xml-external-parsed-entity": {
			"source": "iana"
		},
		"text/yaml": {
			"extensions": [
				"yaml",
				"yml"
			]
		},
		"video/1d-interleaved-parityfec": {
			"source": "apache"
		},
		"video/3gpp": {
			"source": "apache",
			"extensions": [
				"3gp"
			]
		},
		"video/3gpp-tt": {
			"source": "apache"
		},
		"video/3gpp2": {
			"source": "apache",
			"extensions": [
				"3g2"
			]
		},
		"video/bmpeg": {
			"source": "apache"
		},
		"video/bt656": {
			"source": "apache"
		},
		"video/celb": {
			"source": "apache"
		},
		"video/dv": {
			"source": "apache"
		},
		"video/h261": {
			"source": "apache",
			"extensions": [
				"h261"
			]
		},
		"video/h263": {
			"source": "apache",
			"extensions": [
				"h263"
			]
		},
		"video/h263-1998": {
			"source": "apache"
		},
		"video/h263-2000": {
			"source": "apache"
		},
		"video/h264": {
			"source": "apache",
			"extensions": [
				"h264"
			]
		},
		"video/h264-rcdo": {
			"source": "apache"
		},
		"video/h264-svc": {
			"source": "apache"
		},
		"video/jpeg": {
			"source": "apache",
			"extensions": [
				"jpgv"
			]
		},
		"video/jpeg2000": {
			"source": "apache"
		},
		"video/jpm": {
			"source": "apache",
			"extensions": [
				"jpm",
				"jpgm"
			]
		},
		"video/mj2": {
			"source": "apache",
			"extensions": [
				"mj2",
				"mjp2"
			]
		},
		"video/mp1s": {
			"source": "apache"
		},
		"video/mp2p": {
			"source": "apache"
		},
		"video/mp2t": {
			"source": "apache",
			"extensions": [
				"ts"
			]
		},
		"video/mp4": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mp4",
				"mp4v",
				"mpg4"
			]
		},
		"video/mp4v-es": {
			"source": "apache"
		},
		"video/mpeg": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mpeg",
				"mpg",
				"mpe",
				"m1v",
				"m2v"
			]
		},
		"video/mpeg4-generic": {
			"source": "apache"
		},
		"video/mpv": {
			"source": "apache"
		},
		"video/nv": {
			"source": "apache"
		},
		"video/ogg": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"ogv"
			]
		},
		"video/parityfec": {
			"source": "apache"
		},
		"video/pointer": {
			"source": "apache"
		},
		"video/quicktime": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"qt",
				"mov"
			]
		},
		"video/raw": {
			"source": "apache"
		},
		"video/rtp-enc-aescm128": {
			"source": "apache"
		},
		"video/rtx": {
			"source": "apache"
		},
		"video/smpte292m": {
			"source": "apache"
		},
		"video/ulpfec": {
			"source": "apache"
		},
		"video/vc1": {
			"source": "apache"
		},
		"video/vnd.cctv": {
			"source": "apache"
		},
		"video/vnd.dece.hd": {
			"source": "apache",
			"extensions": [
				"uvh",
				"uvvh"
			]
		},
		"video/vnd.dece.mobile": {
			"source": "apache",
			"extensions": [
				"uvm",
				"uvvm"
			]
		},
		"video/vnd.dece.mp4": {
			"source": "apache"
		},
		"video/vnd.dece.pd": {
			"source": "apache",
			"extensions": [
				"uvp",
				"uvvp"
			]
		},
		"video/vnd.dece.sd": {
			"source": "apache",
			"extensions": [
				"uvs",
				"uvvs"
			]
		},
		"video/vnd.dece.video": {
			"source": "apache",
			"extensions": [
				"uvv",
				"uvvv"
			]
		},
		"video/vnd.directv.mpeg": {
			"source": "apache"
		},
		"video/vnd.directv.mpeg-tts": {
			"source": "apache"
		},
		"video/vnd.dlna.mpeg-tts": {
			"source": "apache"
		},
		"video/vnd.dvb.file": {
			"source": "apache",
			"extensions": [
				"dvb"
			]
		},
		"video/vnd.fvt": {
			"source": "apache",
			"extensions": [
				"fvt"
			]
		},
		"video/vnd.hns.video": {
			"source": "apache"
		},
		"video/vnd.iptvforum.1dparityfec-1010": {
			"source": "apache"
		},
		"video/vnd.iptvforum.1dparityfec-2005": {
			"source": "apache"
		},
		"video/vnd.iptvforum.2dparityfec-1010": {
			"source": "apache"
		},
		"video/vnd.iptvforum.2dparityfec-2005": {
			"source": "apache"
		},
		"video/vnd.iptvforum.ttsavc": {
			"source": "apache"
		},
		"video/vnd.iptvforum.ttsmpeg2": {
			"source": "apache"
		},
		"video/vnd.motorola.video": {
			"source": "apache"
		},
		"video/vnd.motorola.videop": {
			"source": "apache"
		},
		"video/vnd.mpegurl": {
			"source": "apache",
			"extensions": [
				"mxu",
				"m4u"
			]
		},
		"video/vnd.ms-playready.media.pyv": {
			"source": "apache",
			"extensions": [
				"pyv"
			]
		},
		"video/vnd.nokia.interleaved-multimedia": {
			"source": "apache"
		},
		"video/vnd.nokia.videovoip": {
			"source": "apache"
		},
		"video/vnd.objectvideo": {
			"source": "apache"
		},
		"video/vnd.sealed.mpeg1": {
			"source": "apache"
		},
		"video/vnd.sealed.mpeg4": {
			"source": "apache"
		},
		"video/vnd.sealed.swf": {
			"source": "apache"
		},
		"video/vnd.sealedmedia.softseal.mov": {
			"source": "apache"
		},
		"video/vnd.uvvu.mp4": {
			"source": "apache",
			"extensions": [
				"uvu",
				"uvvu"
			]
		},
		"video/vnd.vivo": {
			"source": "apache",
			"extensions": [
				"viv"
			]
		},
		"video/webm": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"webm"
			]
		},
		"video/x-f4v": {
			"source": "apache",
			"extensions": [
				"f4v"
			]
		},
		"video/x-fli": {
			"source": "apache",
			"extensions": [
				"fli"
			]
		},
		"video/x-flv": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"flv"
			]
		},
		"video/x-m4v": {
			"source": "apache",
			"extensions": [
				"m4v"
			]
		},
		"video/x-matroska": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"mkv",
				"mk3d",
				"mks"
			]
		},
		"video/x-mng": {
			"source": "apache",
			"extensions": [
				"mng"
			]
		},
		"video/x-ms-asf": {
			"source": "apache",
			"extensions": [
				"asf",
				"asx"
			]
		},
		"video/x-ms-vob": {
			"source": "apache",
			"extensions": [
				"vob"
			]
		},
		"video/x-ms-wm": {
			"source": "apache",
			"extensions": [
				"wm"
			]
		},
		"video/x-ms-wmv": {
			"source": "apache",
			"compressible": false,
			"extensions": [
				"wmv"
			]
		},
		"video/x-ms-wmx": {
			"source": "apache",
			"extensions": [
				"wmx"
			]
		},
		"video/x-ms-wvx": {
			"source": "apache",
			"extensions": [
				"wvx"
			]
		},
		"video/x-msvideo": {
			"source": "apache",
			"extensions": [
				"avi"
			]
		},
		"video/x-sgi-movie": {
			"source": "apache",
			"extensions": [
				"movie"
			]
		},
		"video/x-smv": {
			"source": "apache",
			"extensions": [
				"smv"
			]
		},
		"x-conference/x-cooltalk": {
			"source": "apache",
			"extensions": [
				"ice"
			]
		},
		"x-shader/x-fragment": {
			"compressible": true
		},
		"x-shader/x-vertex": {
			"compressible": true
		}
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(27)
	var Stream = __webpack_require__(56)
	var StringDecoder = __webpack_require__(61).StringDecoder

	module.exports = StringStream
	module.exports.AlignedStringDecoder = AlignedStringDecoder

	function StringStream(from, to) {
	  if (!(this instanceof StringStream)) return new StringStream(from, to)

	  Stream.call(this)

	  if (from == null) from = 'utf8'

	  this.readable = this.writable = true
	  this.paused = false
	  this.toEncoding = (to == null ? from : to)
	  this.fromEncoding = (to == null ? '' : from)
	  this.decoder = new AlignedStringDecoder(this.toEncoding)
	}
	util.inherits(StringStream, Stream)

	StringStream.prototype.write = function(data) {
	  if (!this.writable) {
	    var err = new Error('stream not writable')
	    err.code = 'EPIPE'
	    this.emit('error', err)
	    return false
	  }
	  if (this.fromEncoding) {
	    if (Buffer.isBuffer(data)) data = data.toString()
	    data = new Buffer(data, this.fromEncoding)
	  }
	  var string = this.decoder.write(data)
	  if (string.length) this.emit('data', string)
	  return !this.paused
	}

	StringStream.prototype.flush = function() {
	  if (this.decoder.flush) {
	    var string = this.decoder.flush()
	    if (string.length) this.emit('data', string)
	  }
	}

	StringStream.prototype.end = function() {
	  if (!this.writable && !this.readable) return
	  this.flush()
	  this.emit('end')
	  this.writable = this.readable = false
	  this.destroy()
	}

	StringStream.prototype.destroy = function() {
	  this.decoder = null
	  this.writable = this.readable = false
	  this.emit('close')
	}

	StringStream.prototype.pause = function() {
	  this.paused = true
	}

	StringStream.prototype.resume = function () {
	  if (this.paused) this.emit('drain')
	  this.paused = false
	}

	function AlignedStringDecoder(encoding) {
	  StringDecoder.call(this, encoding)

	  switch (this.encoding) {
	    case 'base64':
	      this.write = alignedWrite
	      this.alignedBuffer = new Buffer(3)
	      this.alignedBytes = 0
	      break
	  }
	}
	util.inherits(AlignedStringDecoder, StringDecoder)

	AlignedStringDecoder.prototype.flush = function() {
	  if (!this.alignedBuffer || !this.alignedBytes) return ''
	  var leftover = this.alignedBuffer.toString(this.encoding, 0, this.alignedBytes)
	  this.alignedBytes = 0
	  return leftover
	}

	function alignedWrite(buffer) {
	  var rem = (this.alignedBytes + buffer.length) % this.alignedBuffer.length
	  if (!rem && !this.alignedBytes) return buffer.toString(this.encoding)

	  var returnBuffer = new Buffer(this.alignedBytes + buffer.length - rem)

	  this.alignedBuffer.copy(returnBuffer, 0, 0, this.alignedBytes)
	  buffer.copy(returnBuffer, this.alignedBytes, 0, buffer.length - rem)

	  buffer.copy(this.alignedBuffer, 0, buffer.length - rem, buffer.length)
	  this.alignedBytes = rem

	  return returnBuffer.toString(this.encoding)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 115 */
/***/ function(module, exports) {

	function Caseless (dict) {
	  this.dict = dict || {}
	}
	Caseless.prototype.set = function (name, value, clobber) {
	  if (typeof name === 'object') {
	    for (var i in name) {
	      this.set(i, name[i], value)
	    }
	  } else {
	    if (typeof clobber === 'undefined') clobber = true
	    var has = this.has(name)

	    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value
	    else this.dict[has || name] = value
	    return has
	  }
	}
	Caseless.prototype.has = function (name) {
	  var keys = Object.keys(this.dict)
	    , name = name.toLowerCase()
	    ;
	  for (var i=0;i<keys.length;i++) {
	    if (keys[i].toLowerCase() === name) return keys[i]
	  }
	  return false
	}
	Caseless.prototype.get = function (name) {
	  name = name.toLowerCase()
	  var result, _key
	  var headers = this.dict
	  Object.keys(headers).forEach(function (key) {
	    _key = key.toLowerCase()
	    if (name === _key) result = headers[key]
	  })
	  return result
	}
	Caseless.prototype.swap = function (name) {
	  var has = this.has(name)
	  if (!has) throw new Error('There is no header than matches "'+name+'"')
	  this.dict[name] = this.dict[has]
	  delete this.dict[has]
	}
	Caseless.prototype.del = function (name) {
	  var has = this.has(name)
	  return delete this.dict[has || name]
	}

	module.exports = function (dict) {return new Caseless(dict)}
	module.exports.httpify = function (resp, headers) {
	  var c = new Caseless(headers)
	  resp.setHeader = function (key, value, clobber) {
	    return c.set(key, value, clobber)
	  }
	  resp.hasHeader = function (key) {
	    return c.has(key)
	  }
	  resp.getHeader = function (key) {
	    return c.get(key)
	  }
	  resp.removeHeader = function (key) {
	    return c.del(key)
	  }
	  resp.headers = c.dict
	  return c
	}


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = ForeverAgent
	ForeverAgent.SSL = ForeverAgentSSL

	var util = __webpack_require__(27)
	  , Agent = __webpack_require__(53).Agent
	  , net = __webpack_require__(14)
	  , tls = __webpack_require__(14)
	  , AgentSSL = __webpack_require__(72).Agent
	  
	function getConnectionName(host, port) {  
	  var name = ''
	  if (typeof host === 'string') {
	    name = host + ':' + port
	  } else {
	    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
	    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')
	  }
	  return name
	}    

	function ForeverAgent(options) {
	  var self = this
	  self.options = options || {}
	  self.requests = {}
	  self.sockets = {}
	  self.freeSockets = {}
	  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
	  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
	  self.on('free', function(socket, host, port) {
	    var name = getConnectionName(host, port)

	    if (self.requests[name] && self.requests[name].length) {
	      self.requests[name].shift().onSocket(socket)
	    } else if (self.sockets[name].length < self.minSockets) {
	      if (!self.freeSockets[name]) self.freeSockets[name] = []
	      self.freeSockets[name].push(socket)
	      
	      // if an error happens while we don't use the socket anyway, meh, throw the socket away
	      var onIdleError = function() {
	        socket.destroy()
	      }
	      socket._onIdleError = onIdleError
	      socket.on('error', onIdleError)
	    } else {
	      // If there are no pending requests just destroy the
	      // socket and it will get removed from the pool. This
	      // gets us out of timeout issues and allows us to
	      // default to Connection:keep-alive.
	      socket.destroy()
	    }
	  })

	}
	util.inherits(ForeverAgent, Agent)

	ForeverAgent.defaultMinSockets = 5


	ForeverAgent.prototype.createConnection = net.createConnection
	ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
	ForeverAgent.prototype.addRequest = function(req, host, port) {
	  var name = getConnectionName(host, port)
	  
	  if (typeof host !== 'string') {
	    var options = host
	    port = options.port
	    host = options.host
	  }

	  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
	    var idleSocket = this.freeSockets[name].pop()
	    idleSocket.removeListener('error', idleSocket._onIdleError)
	    delete idleSocket._onIdleError
	    req._reusedSocket = true
	    req.onSocket(idleSocket)
	  } else {
	    this.addRequestNoreuse(req, host, port)
	  }
	}

	ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
	  if (this.sockets[name]) {
	    var index = this.sockets[name].indexOf(s)
	    if (index !== -1) {
	      this.sockets[name].splice(index, 1)
	    }
	  } else if (this.sockets[name] && this.sockets[name].length === 0) {
	    // don't leak
	    delete this.sockets[name]
	    delete this.requests[name]
	  }
	  
	  if (this.freeSockets[name]) {
	    var index = this.freeSockets[name].indexOf(s)
	    if (index !== -1) {
	      this.freeSockets[name].splice(index, 1)
	      if (this.freeSockets[name].length === 0) {
	        delete this.freeSockets[name]
	      }
	    }
	  }

	  if (this.requests[name] && this.requests[name].length) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createSocket(name, host, port).emit('free')
	  }
	}

	function ForeverAgentSSL (options) {
	  ForeverAgent.call(this, options)
	}
	util.inherits(ForeverAgentSSL, ForeverAgent)

	ForeverAgentSSL.prototype.createConnection = createConnectionSSL
	ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

	function createConnectionSSL (port, host, options) {
	  if (typeof port === 'object') {
	    options = port;
	  } else if (typeof host === 'object') {
	    options = host;
	  } else if (typeof options === 'object') {
	    options = options;
	  } else {
	    options = {};
	  }

	  if (typeof port === 'number') {
	    options.port = port;
	  }

	  if (typeof host === 'string') {
	    options.host = host;
	  }

	  return tls.connect(options);
	}


/***/ },
/* 117 */
/***/ function(module, exports) {

	/* eslint-env browser */
	module.exports = FormData;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict'

	function formatHostname(hostname) {
	  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
	  return hostname.replace(/^\.*/, '.').toLowerCase()
	}

	function parseNoProxyZone(zone) {
	  zone = zone.trim().toLowerCase()

	  var zoneParts = zone.split(':', 2)
	    , zoneHost = formatHostname(zoneParts[0])
	    , zonePort = zoneParts[1]
	    , hasPort = zone.indexOf(':') > -1

	  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}
	}

	function uriInNoProxy(uri, noProxy) {
	  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')
	    , hostname = formatHostname(uri.hostname)
	    , noProxyList = noProxy.split(',')

	  // iterate through the noProxyList until it finds a match.
	  return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {
	    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)
	      , hostnameMatched = (
	          isMatchedAt > -1 &&
	          (isMatchedAt === hostname.length - noProxyZone.hostname.length)
	        )

	    if (noProxyZone.hasPort) {
	      return (port === noProxyZone.port) && hostnameMatched
	    }

	    return hostnameMatched
	  })
	}

	function getProxyFromURI(uri) {
	  // Decide the proper request proxy to use based on the request URI object and the
	  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)
	  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)

	  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''

	  // if the noProxy is a wildcard then return null

	  if (noProxy === '*') {
	    return null
	  }

	  // if the noProxy is not empty and the uri is found return null

	  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {
	    return null
	  }

	  // Check for HTTP or HTTPS Proxy in environment Else default to null

	  if (uri.protocol === 'http:') {
	    return process.env.HTTP_PROXY ||
	           process.env.http_proxy || null
	  }

	  if (uri.protocol === 'https:') {
	    return process.env.HTTPS_PROXY ||
	           process.env.https_proxy ||
	           process.env.HTTP_PROXY  ||
	           process.env.http_proxy  || null
	  }

	  // if none of that works, return null
	  // (What uri protocol are you using then?)

	  return null
	}

	module.exports = getProxyFromURI

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var qs = __webpack_require__(120)
	  , querystring = __webpack_require__(18)


	function Querystring (request) {
	  this.request = request
	  this.lib = null
	  this.useQuerystring = null
	  this.parseOptions = null
	  this.stringifyOptions = null
	}

	Querystring.prototype.init = function (options) {
	  if (this.lib) {return}

	  this.useQuerystring = options.useQuerystring
	  this.lib = (this.useQuerystring ? querystring : qs)

	  this.parseOptions = options.qsParseOptions || {}
	  this.stringifyOptions = options.qsStringifyOptions || {}
	}

	Querystring.prototype.stringify = function (obj) {
	  return (this.useQuerystring)
	    ? this.rfc3986(this.lib.stringify(obj,
	      this.stringifyOptions.sep || null,
	      this.stringifyOptions.eq || null,
	      this.stringifyOptions))
	    : this.lib.stringify(obj, this.stringifyOptions)
	}

	Querystring.prototype.parse = function (str) {
	  return (this.useQuerystring)
	    ? this.lib.parse(str,
	      this.parseOptions.sep || null,
	      this.parseOptions.eq || null,
	      this.parseOptions)
	    : this.lib.parse(str, this.parseOptions)
	}

	Querystring.prototype.rfc3986 = function (str) {
	  return str.replace(/[!'()*]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}

	Querystring.prototype.unescape = querystring.unescape

	exports.Querystring = Querystring


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(121);


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Stringify = __webpack_require__(122);
	var Parse = __webpack_require__(124);


	// Declare internals

	var internals = {};


	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(123);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    arrayPrefixGenerators: {
	        brackets: function (prefix, key) {

	            return prefix + '[]';
	        },
	        indices: function (prefix, key) {

	            return prefix + '[' + key + ']';
	        },
	        repeat: function (prefix, key) {

	            return prefix;
	        }
	    },
	    strictNullHandling: false
	};


	internals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, filter) {

	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    }
	    else if (Utils.isBuffer(obj)) {
	        obj = obj.toString();
	    }
	    else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    }
	    else if (obj === null) {
	        if (strictNullHandling) {
	            return Utils.encode(prefix);
	        }

	        obj = '';
	    }

	    if (typeof obj === 'string' ||
	        typeof obj === 'number' ||
	        typeof obj === 'boolean') {

	        return [Utils.encode(prefix) + '=' + Utils.encode(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys = Array.isArray(filter) ? filter : Object.keys(obj);
	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];

	        if (Array.isArray(obj)) {
	            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, filter));
	        }
	        else {
	            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, filter));
	        }
	    }

	    return values;
	};


	module.exports = function (obj, options) {

	    options = options || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;
	    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;
	    var objKeys;
	    var filter;
	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    }
	    else if (Array.isArray(options.filter)) {
	        objKeys = filter = options.filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in internals.arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    }
	    else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    }
	    else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }
	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];
	        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, filter));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 123 */
/***/ function(module, exports) {

	// Load modules


	// Declare internals

	var internals = {};
	internals.hexTable = new Array(256);
	for (var i = 0; i < 256; ++i) {
	    internals.hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();
	}


	exports.arrayToObject = function (source) {

	    var obj = Object.create(null);
	    for (var i = 0, il = source.length; i < il; ++i) {
	        if (typeof source[i] !== 'undefined') {

	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};


	exports.merge = function (target, source) {

	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        }
	        else if (typeof target === 'object') {
	            target[source] = true;
	        }
	        else {
	            target = [target, source];
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        target = [target].concat(source);
	        return target;
	    }

	    if (Array.isArray(target) &&
	        !Array.isArray(source)) {

	        target = exports.arrayToObject(target);
	    }

	    var keys = Object.keys(source);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var value = source[key];

	        if (!target[key]) {
	            target[key] = value;
	        }
	        else {
	            target[key] = exports.merge(target[key], value);
	        }
	    }

	    return target;
	};


	exports.decode = function (str) {

	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};

	exports.encode = function (str) {

	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    if (typeof str !== 'string') {
	        str = '' + str;
	    }

	    var out = '';
	    for (var i = 0, il = str.length; i < il; ++i) {
	        var c = str.charCodeAt(i);

	        if (c === 0x2D || // -
	            c === 0x2E || // .
	            c === 0x5F || // _
	            c === 0x7E || // ~
	            (c >= 0x30 && c <= 0x39) || // 0-9
	            (c >= 0x41 && c <= 0x5A) || // a-z
	            (c >= 0x61 && c <= 0x7A)) { // A-Z

	            out += str[i];
	            continue;
	        }

	        if (c < 0x80) {
	            out += internals.hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
	            continue;
	        }

	        ++i;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));
	        out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	exports.compact = function (obj, refs) {

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return obj;
	    }

	    refs = refs || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0, il = obj.length; i < il; ++i) {
	            if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};


	exports.isRegExp = function (obj) {

	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};


	exports.isBuffer = function (obj) {

	    if (obj === null ||
	        typeof obj === 'undefined') {

	        return false;
	    }

	    return !!(obj.constructor &&
	              obj.constructor.isBuffer &&
	              obj.constructor.isBuffer(obj));
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(123);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000,
	    strictNullHandling: false
	};


	internals.parseValues = function (str, options) {

	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0, il = parts.length; i < il; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[Utils.decode(part)] = '';

	            if (options.strictNullHandling) {
	                obj[Utils.decode(part)] = null;
	            }
	        }
	        else {
	            var key = Utils.decode(part.slice(0, pos));
	            var val = Utils.decode(part.slice(pos + 1));

	            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = val;
	            }
	            else {
	                obj[key] = [].concat(obj[key]).concat(val);
	            }
	        }
	    }

	    return obj;
	};


	internals.parseObject = function (chain, val, options) {

	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj;
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(internals.parseObject(chain, val, options));
	    }
	    else {
	        obj = Object.create(null);
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        var indexString = '' + index;
	        if (!isNaN(index) &&
	            root !== cleanRoot &&
	            indexString === cleanRoot &&
	            index >= 0 &&
	            (options.parseArrays &&
	             index <= options.arrayLimit)) {

	            obj = [];
	            obj[index] = internals.parseObject(chain, val, options);
	        }
	        else {
	            obj[cleanRoot] = internals.parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};


	internals.parseKeys = function (key, val, options) {

	    if (!key) {
	        return;
	    }

	    // Transform dot notation to bracket notation

	    if (options.allowDots) {
	        key = key.replace(/\.([^\.\[]+)/g, '[$1]');
	    }

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {

	        ++i;
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return internals.parseObject(keys, val, options);
	};


	module.exports = function (str, options) {

	    if (str === '' ||
	        str === null ||
	        typeof str === 'undefined') {

	        return Object.create(null);
	    }

	    options = options || {};
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
	    options.parseArrays = options.parseArrays !== false;
	    options.allowDots = options.allowDots !== false;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;
	    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;


	    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
	    var obj = Object.create(null);

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        var newObj = internals.parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var fs = __webpack_require__(14)
	var qs = __webpack_require__(18)
	var validate = __webpack_require__(126)
	var util = __webpack_require__(27)

	function Har (request) {
	  this.request = request
	}

	Har.prototype.reducer = function (obj, pair) {
	  // new property ?
	  if (obj[pair.name] === undefined) {
	    obj[pair.name] = pair.value
	    return obj
	  }

	  // existing? convert to array
	  var arr = [
	    obj[pair.name],
	    pair.value
	  ]

	  obj[pair.name] = arr

	  return obj
	}

	Har.prototype.prep = function (data) {
	  // construct utility properties
	  data.queryObj = {}
	  data.headersObj = {}
	  data.postData.jsonObj = false
	  data.postData.paramsObj = false

	  // construct query objects
	  if (data.queryString && data.queryString.length) {
	    data.queryObj = data.queryString.reduce(this.reducer, {})
	  }

	  // construct headers objects
	  if (data.headers && data.headers.length) {
	    // loweCase header keys
	    data.headersObj = data.headers.reduceRight(function (headers, header) {
	      headers[header.name] = header.value
	      return headers
	    }, {})
	  }

	  // construct Cookie header
	  if (data.cookies && data.cookies.length) {
	    var cookies = data.cookies.map(function (cookie) {
	      return cookie.name + '=' + cookie.value
	    })

	    if (cookies.length) {
	      data.headersObj.cookie = cookies.join('; ')
	    }
	  }

	  // prep body
	  switch (data.postData.mimeType) {
	    case 'multipart/mixed':
	    case 'multipart/related':
	    case 'multipart/form-data':
	    case 'multipart/alternative':
	      // reset values
	      data.postData.mimeType = 'multipart/form-data'
	      break

	    case 'application/x-www-form-urlencoded':
	      if (!data.postData.params) {
	        data.postData.text = ''
	      } else {
	        data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})

	        // always overwrite
	        data.postData.text = qs.stringify(data.postData.paramsObj)
	      }
	      break

	    case 'text/json':
	    case 'text/x-json':
	    case 'application/json':
	    case 'application/x-json':
	      data.postData.mimeType = 'application/json'

	      if (data.postData.text) {
	        try {
	          data.postData.jsonObj = JSON.parse(data.postData.text)
	        } catch (e) {
	          this.request.debug(e)

	          // force back to text/plain
	          data.postData.mimeType = 'text/plain'
	        }
	      }
	      break
	  }

	  return data
	}

	Har.prototype.options = function (options) {
	  // skip if no har property defined
	  if (!options.har) {
	    return options
	  }

	  var har = util._extend({}, options.har)

	  // only process the first entry
	  if (har.log && har.log.entries) {
	    har = har.log.entries[0]
	  }

	  // add optional properties to make validation successful
	  har.url = har.url || options.url || options.uri || options.baseUrl || '/'
	  har.httpVersion = har.httpVersion || 'HTTP/1.1'
	  har.queryString = har.queryString || []
	  har.headers = har.headers || []
	  har.cookies = har.cookies || []
	  har.postData = har.postData || {}
	  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'

	  har.bodySize = 0
	  har.headersSize = 0
	  har.postData.size = 0

	  if (!validate.request(har)) {
	    return options
	  }

	  // clean up and get some utility properties
	  var req = this.prep(har)

	  // construct new options
	  if (req.url) {
	    options.url = req.url
	  }

	  if (req.method) {
	    options.method = req.method
	  }

	  if (Object.keys(req.queryObj).length) {
	    options.qs = req.queryObj
	  }

	  if (Object.keys(req.headersObj).length) {
	    options.headers = req.headersObj
	  }

	  switch (req.postData.mimeType) {
	    case 'application/x-www-form-urlencoded':
	      options.form = req.postData.paramsObj
	      break

	    case 'application/json':
	      if (req.postData.jsonObj) {
	        options.body = req.postData.jsonObj
	        options.json = true
	      }
	      break

	    case 'multipart/form-data':
	      options.formData = {}

	      req.postData.params.forEach(function (param) {
	        var attachment = {}

	        if (!param.fileName && !param.fileName && !param.contentType) {
	          options.formData[param.name] = param.value
	          return
	        }

	        // attempt to read from disk!
	        if (param.fileName && !param.value) {
	          attachment.value = fs.createReadStream(param.fileName)
	        } else if (param.value) {
	          attachment.value = param.value
	        }

	        if (param.fileName) {
	          attachment.options = {
	            filename: param.fileName,
	            contentType: param.contentType ? param.contentType : null
	          }
	        }

	        options.formData[param.name] = attachment
	      })
	      break

	    default:
	      if (req.postData.text) {
	        options.body = req.postData.text
	      }
	  }

	  return options
	}

	exports.Har = Har


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var schemas = __webpack_require__(127)
	var ValidationError = __webpack_require__(143)
	var validator = __webpack_require__(144)

	var runner = function (schema, data, cb) {
	  var validate = validator(schema, {
	    greedy: true,
	    verbose: true,
	    schemas: schemas
	  })

	  var valid = false

	  if (data !== undefined) {
	    // execute is-my-json-valid
	    valid = validate(data)
	  }

	  // callback?
	  if (!cb) {
	    return valid
	  } else {
	    return cb(validate.errors ? new ValidationError(validate.errors) : null, valid)
	  }

	  return valid
	}

	module.exports = function (data, cb) {
	  return runner(schemas.har, data, cb)
	}

	Object.keys(schemas).map(function (name) {
	  module.exports[name] = function (data, cb) {
	    return runner(schemas[name], data, cb)
	  }
	})


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var schemas = {
	  cache: __webpack_require__(128),
	  cacheEntry: __webpack_require__(129),
	  content: __webpack_require__(130),
	  cookie: __webpack_require__(131),
	  creator: __webpack_require__(132),
	  entry: __webpack_require__(133),
	  har: __webpack_require__(134),
	  log: __webpack_require__(135),
	  page: __webpack_require__(136),
	  pageTimings: __webpack_require__(137),
	  postData: __webpack_require__(138),
	  record: __webpack_require__(139),
	  request: __webpack_require__(140),
	  response: __webpack_require__(141),
	  timings: __webpack_require__(142)
	}

	// is-my-json-valid does not provide meaningful error messages for external schemas
	// this is a workaround
	schemas.cache.properties.beforeRequest = schemas.cacheEntry
	schemas.cache.properties.afterRequest = schemas.cacheEntry

	schemas.page.properties.pageTimings = schemas.pageTimings

	schemas.request.properties.cookies.items = schemas.cookie
	schemas.request.properties.headers.items = schemas.record
	schemas.request.properties.queryString.items = schemas.record
	schemas.request.properties.postData = schemas.postData

	schemas.response.properties.cookies.items = schemas.cookie
	schemas.response.properties.headers.items = schemas.record
	schemas.response.properties.content = schemas.content

	schemas.entry.properties.request = schemas.request
	schemas.entry.properties.response = schemas.response
	schemas.entry.properties.cache = schemas.cache
	schemas.entry.properties.timings = schemas.timings

	schemas.log.properties.creator = schemas.creator
	schemas.log.properties.browser = schemas.creator
	schemas.log.properties.pages.items = schemas.page
	schemas.log.properties.entries.items = schemas.entry

	schemas.har.properties.log = schemas.log

	module.exports = schemas


/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = {
		"properties": {
			"beforeRequest": {
				"$ref": "#cacheEntry"
			},
			"afterRequest": {
				"$ref": "#cacheEntry"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = {
		"oneOf": [
			{
				"type": "object",
				"optional": true,
				"required": [
					"lastAccess",
					"eTag",
					"hitCount"
				],
				"properties": {
					"expires": {
						"type": "string"
					},
					"lastAccess": {
						"type": "string"
					},
					"eTag": {
						"type": "string"
					},
					"hitCount": {
						"type": "integer"
					},
					"comment": {
						"type": "string"
					}
				}
			},
			{
				"type": null,
				"additionalProperties": false
			}
		]
	};

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"size",
			"mimeType"
		],
		"properties": {
			"size": {
				"type": "integer"
			},
			"compression": {
				"type": "integer"
			},
			"mimeType": {
				"type": "string"
			},
			"text": {
				"type": "string"
			},
			"encoding": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"name",
			"value"
		],
		"properties": {
			"name": {
				"type": "string"
			},
			"value": {
				"type": "string"
			},
			"path": {
				"type": "string"
			},
			"domain": {
				"type": "string"
			},
			"expires": {
				"type": [
					"string",
					"null"
				],
				"format": "date-time"
			},
			"httpOnly": {
				"type": "boolean"
			},
			"secure": {
				"type": "boolean"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"name",
			"version"
		],
		"properties": {
			"name": {
				"type": "string"
			},
			"version": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"optional": true,
		"required": [
			"startedDateTime",
			"time",
			"request",
			"response",
			"cache",
			"timings"
		],
		"properties": {
			"pageref": {
				"type": "string"
			},
			"startedDateTime": {
				"type": "string",
				"format": "date-time",
				"pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
			},
			"time": {
				"type": "number",
				"min": 0
			},
			"request": {
				"$ref": "#request"
			},
			"response": {
				"$ref": "#response"
			},
			"cache": {
				"$ref": "#cache"
			},
			"timings": {
				"$ref": "#timings"
			},
			"serverIPAddress": {
				"type": "string",
				"oneOf": [
					{
						"format": "ipv4"
					},
					{
						"format": "ipv6"
					}
				]
			},
			"connection": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"log"
		],
		"properties": {
			"log": {
				"$ref": "#log"
			}
		}
	};

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"version",
			"creator",
			"entries"
		],
		"properties": {
			"version": {
				"type": "string"
			},
			"creator": {
				"$ref": "#creator"
			},
			"browser": {
				"$ref": "#creator"
			},
			"pages": {
				"type": "array",
				"items": {
					"$ref": "#page"
				}
			},
			"entries": {
				"type": "array",
				"items": {
					"$ref": "#entry"
				}
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"optional": true,
		"required": [
			"startedDateTime",
			"id",
			"title",
			"pageTimings"
		],
		"properties": {
			"startedDateTime": {
				"type": "string",
				"format": "date-time",
				"pattern": "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
			},
			"id": {
				"type": "string",
				"unique": true
			},
			"title": {
				"type": "string"
			},
			"pageTimings": {
				"$ref": "#pageTimings"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"properties": {
			"onContentLoad": {
				"type": "number",
				"min": -1
			},
			"onLoad": {
				"type": "number",
				"min": -1
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"optional": true,
		"required": [
			"mimeType"
		],
		"properties": {
			"mimeType": {
				"type": "string"
			},
			"text": {
				"type": "string"
			},
			"params": {
				"type": "array",
				"required": [
					"name"
				],
				"properties": {
					"name": {
						"type": "string"
					},
					"value": {
						"type": "string"
					},
					"fileName": {
						"type": "string"
					},
					"contentType": {
						"type": "string"
					},
					"comment": {
						"type": "string"
					}
				}
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"name",
			"value"
		],
		"properties": {
			"name": {
				"type": "string"
			},
			"value": {
				"type": "string"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 140 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"method",
			"url",
			"httpVersion",
			"cookies",
			"headers",
			"queryString",
			"headersSize",
			"bodySize"
		],
		"properties": {
			"method": {
				"type": "string"
			},
			"url": {
				"type": "string",
				"format": "uri"
			},
			"httpVersion": {
				"type": "string"
			},
			"cookies": {
				"type": "array",
				"items": {
					"$ref": "#cookie"
				}
			},
			"headers": {
				"type": "array",
				"items": {
					"$ref": "#record"
				}
			},
			"queryString": {
				"type": "array",
				"items": {
					"$ref": "#record"
				}
			},
			"postData": {
				"$ref": "#postData"
			},
			"headersSize": {
				"type": "integer"
			},
			"bodySize": {
				"type": "integer"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 141 */
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"required": [
			"status",
			"statusText",
			"httpVersion",
			"cookies",
			"headers",
			"content",
			"redirectURL",
			"headersSize",
			"bodySize"
		],
		"properties": {
			"status": {
				"type": "integer"
			},
			"statusText": {
				"type": "string"
			},
			"httpVersion": {
				"type": "string"
			},
			"cookies": {
				"type": "array",
				"items": {
					"$ref": "#cookie"
				}
			},
			"headers": {
				"type": "array",
				"items": {
					"$ref": "#record"
				}
			},
			"content": {
				"$ref": "#content"
			},
			"redirectURL": {
				"type": "string"
			},
			"headersSize": {
				"type": "integer"
			},
			"bodySize": {
				"type": "integer"
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = {
		"required": [
			"send",
			"wait",
			"receive"
		],
		"properties": {
			"dns": {
				"type": "number",
				"min": -1
			},
			"connect": {
				"type": "number",
				"min": -1
			},
			"blocked": {
				"type": "number",
				"min": -1
			},
			"send": {
				"type": "number",
				"min": -1
			},
			"wait": {
				"type": "number",
				"min": -1
			},
			"receive": {
				"type": "number",
				"min": -1
			},
			"ssl": {
				"type": "number",
				"min": -1
			},
			"comment": {
				"type": "string"
			}
		}
	};

/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict'

	function ValidationError (errors) {
	  this.name = 'ValidationError'
	  this.errors = errors
	}

	ValidationError.prototype = Error.prototype

	module.exports = ValidationError


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var genobj = __webpack_require__(145)
	var genfun = __webpack_require__(147)
	var jsonpointer = __webpack_require__(148)
	var xtend = __webpack_require__(149)
	var formats = __webpack_require__(150)

	var get = function(obj, additionalSchemas, ptr) {

	  var visit = function(sub) {
	    if (sub && sub.id === ptr) return sub
	    if (typeof sub !== 'object' || !sub) return null
	    return Object.keys(sub).reduce(function(res, k) {
	      return res || visit(sub[k])
	    }, null)
	  }

	  var res = visit(obj)
	  if (res) return res

	  ptr = ptr.replace(/^#/, '')
	  ptr = ptr.replace(/\/$/, '')

	  try {
	    return jsonpointer.get(obj, decodeURI(ptr))
	  } catch (err) {
	    var end = ptr.indexOf('#')
	    var other
	    // external reference
	    if (end !== 0) {
	      // fragment doesn't exist.
	      if (end === -1) {
	        other = additionalSchemas[ptr]
	      } else {
	        var ext = ptr.slice(0, end)
	        other = additionalSchemas[ext]
	        var fragment = ptr.slice(end).replace(/^#/, '')
	        try {
	          return jsonpointer.get(other, fragment)
	        } catch (err) {}
	      }
	    } else {
	      other = additionalSchemas[ptr]
	    }
	    return other || null
	  }
	}

	var formatName = function(field) {
	  field = JSON.stringify(field)
	  var pattern = /\[([^\[\]"]+)\]/
	  while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
	  return field
	}

	var types = {}

	types.any = function() {
	  return 'true'
	}

	types.null = function(name) {
	  return name+' === null'
	}

	types.boolean = function(name) {
	  return 'typeof '+name+' === "boolean"'
	}

	types.array = function(name) {
	  return 'Array.isArray('+name+')'
	}

	types.object = function(name) {
	  return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
	}

	types.number = function(name) {
	  return 'typeof '+name+' === "number"'
	}

	types.integer = function(name) {
	  return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
	}

	types.string = function(name) {
	  return 'typeof '+name+' === "string"'
	}

	var unique = function(array) {
	  var list = []
	  for (var i = 0; i < array.length; i++) {
	    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
	  }
	  for (var i = 1; i < list.length; i++) {
	    if (list.indexOf(list[i]) !== i) return false
	  }
	  return true
	}

	var isMultipleOf = function(name, multipleOf) {
	  var res;
	  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1
	  if (factor > 1) {
	    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1
	    if (factorName > factor) res = true
	    else res = Math.round(factor * name) % (factor * multipleOf)
	  }
	  else res = name % multipleOf;
	  return !res;
	}

	var toType = function(node) {
	  return node.type
	}

	var compile = function(schema, cache, root, reporter, opts) {
	  var fmts = opts ? xtend(formats, opts.formats) : formats
	  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf}
	  var verbose = opts ? !!opts.verbose : false;
	  var greedy = opts && opts.greedy !== undefined ?
	    opts.greedy : false;

	  var syms = {}
	  var gensym = function(name) {
	    return name+(syms[name] = (syms[name] || 0)+1)
	  }

	  var reversePatterns = {}
	  var patterns = function(p) {
	    if (reversePatterns[p]) return reversePatterns[p]
	    var n = gensym('pattern')
	    scope[n] = new RegExp(p)
	    reversePatterns[p] = n
	    return n
	  }

	  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
	  var genloop = function() {
	    var v = vars.shift()
	    vars.push(v+v[0])
	    return v
	  }

	  var visit = function(name, node, reporter, filter) {
	    var properties = node.properties
	    var type = node.type
	    var tuple = false

	    if (Array.isArray(node.items)) { // tuple type
	      properties = {}
	      node.items.forEach(function(item, i) {
	        properties[i] = item
	      })
	      type = 'array'
	      tuple = true
	    }

	    var indent = 0
	    var error = function(msg, prop, value) {
	      validate('errors++')
	      if (reporter === true) {
	        validate('if (validate.errors === null) validate.errors = []')
	        if (verbose) {
	          validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type))
	        } else {
	          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
	        }
	      }
	    }

	    if (node.required === true) {
	      indent++
	      validate('if (%s === undefined) {', name)
	      error('is required')
	      validate('} else {')
	    } else {
	      indent++
	      validate('if (%s !== undefined) {', name)
	    }

	    var valid = [].concat(type)
	      .map(function(t) {
	        return types[t || 'any'](name)
	      })
	      .join(' || ') || 'true'

	    if (valid !== 'true') {
	      indent++
	      validate('if (!(%s)) {', valid)
	      error('is the wrong type')
	      validate('} else {')
	    }

	    if (tuple) {
	      if (node.additionalItems === false) {
	        validate('if (%s.length > %d) {', name, node.items.length)
	        error('has additional items')
	        validate('}')
	      } else if (node.additionalItems) {
	        var i = genloop()
	        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
	        visit(name+'['+i+']', node.additionalItems, reporter, filter)
	        validate('}')
	      }
	    }

	    if (node.format && fmts[node.format]) {
	      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
	      var n = gensym('format')
	      scope[n] = fmts[node.format]

	      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
	      else validate('if (!%s.test(%s)) {', n, name)
	      error('must be '+node.format+' format')
	      validate('}')
	      if (type !== 'string' && formats[node.format]) validate('}')
	    }

	    if (Array.isArray(node.required)) {
	      var isUndefined = function(req) {
	        return genobj(name, req) + ' === undefined'
	      }

	      var checkRequired = function (req) {
	        var prop = genobj(name, req);
	        validate('if (%s === undefined) {', prop)
	        error('is required', prop)
	        validate('missing++')
	        validate('}')
	      }
	      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
	      validate('var missing = 0')
	      node.required.map(checkRequired)
	      validate('}');
	      if (!greedy) {
	        validate('if (missing === 0) {')
	        indent++
	      }
	    }

	    if (node.uniqueItems) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	      validate('if (!(unique(%s))) {', name)
	      error('must be unique')
	      validate('}')
	      if (type !== 'array') validate('}')
	    }

	    if (node.enum) {
	      var complex = node.enum.some(function(e) {
	        return typeof e === 'object'
	      })

	      var compare = complex ?
	        function(e) {
	          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
	        } :
	        function(e) {
	          return name+' !== '+JSON.stringify(e)
	        }

	      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
	      error('must be an enum value')
	      validate('}')
	    }

	    if (node.dependencies) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))

	      Object.keys(node.dependencies).forEach(function(key) {
	        var deps = node.dependencies[key]
	        if (typeof deps === 'string') deps = [deps]

	        var exists = function(k) {
	          return genobj(name, k) + ' !== undefined'
	        }

	        if (Array.isArray(deps)) {
	          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
	          error('dependencies not set')
	          validate('}')
	        }
	        if (typeof deps === 'object') {
	          validate('if (%s !== undefined) {', genobj(name, key))
	          visit(name, deps, reporter, filter)
	          validate('}')
	        }
	      })

	      if (type !== 'object') validate('}')
	    }

	    if (node.additionalProperties || node.additionalProperties === false) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))

	      var i = genloop()
	      var keys = gensym('keys')

	      var toCompare = function(p) {
	        return keys+'['+i+'] !== '+JSON.stringify(p)
	      }

	      var toTest = function(p) {
	        return '!'+patterns(p)+'.test('+keys+'['+i+'])'
	      }

	      var additionalProp = Object.keys(properties || {}).map(toCompare)
	        .concat(Object.keys(node.patternProperties || {}).map(toTest))
	        .join(' && ') || 'true'

	      validate('var %s = Object.keys(%s)', keys, name)
	        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
	          ('if (%s) {', additionalProp)

	      if (node.additionalProperties === false) {
	        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
	        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
	      } else {
	        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
	      }

	      validate
	          ('}')
	        ('}')

	      if (type !== 'object') validate('}')
	    }

	    if (node.$ref) {
	      var sub = get(root, opts && opts.schemas || {}, node.$ref)
	      if (sub) {
	        var fn = cache[node.$ref]
	        if (!fn) {
	          cache[node.$ref] = function proxy(data) {
	            return fn(data)
	          }
	          fn = compile(sub, cache, root, false, opts)
	        }
	        var n = gensym('ref')
	        scope[n] = fn
	        validate('if (!(%s(%s))) {', n, name)
	        error('referenced schema does not match')
	        validate('}')
	      }
	    }

	    if (node.not) {
	      var prev = gensym('prev')
	      validate('var %s = errors', prev)
	      visit(name, node.not, false, filter)
	      validate('if (%s === errors) {', prev)
	      error('negative schema matches')
	      validate('} else {')
	        ('errors = %s', prev)
	      ('}')
	    }

	    if (node.items && !tuple) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))

	      var i = genloop()
	      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
	      visit(name+'['+i+']', node.items, reporter, filter)
	      validate('}')

	      if (type !== 'array') validate('}')
	    }

	    if (node.patternProperties) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	      var keys = gensym('keys')
	      var i = genloop()
	      validate
	        ('var %s = Object.keys(%s)', keys, name)
	        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)

	      Object.keys(node.patternProperties).forEach(function(key) {
	        var p = patterns(key)
	        validate('if (%s.test(%s)) {', p, keys+'['+i+']')
	        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
	        validate('}')
	      })

	      validate('}')
	      if (type !== 'object') validate('}')
	    }

	    if (node.pattern) {
	      var p = patterns(node.pattern)
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	      validate('if (!(%s.test(%s))) {', p, name)
	      error('pattern mismatch')
	      validate('}')
	      if (type !== 'string') validate('}')
	    }

	    if (node.allOf) {
	      node.allOf.forEach(function(sch) {
	        visit(name, sch, reporter, filter)
	      })
	    }

	    if (node.anyOf && node.anyOf.length) {
	      var prev = gensym('prev')

	      node.anyOf.forEach(function(sch, i) {
	        if (i === 0) {
	          validate('var %s = errors', prev)
	        } else {
	          validate('if (errors !== %s) {', prev)
	            ('errors = %s', prev)
	        }
	        visit(name, sch, false, false)
	      })
	      node.anyOf.forEach(function(sch, i) {
	        if (i) validate('}')
	      })
	      validate('if (%s !== errors) {', prev)
	      error('no schemas match')
	      validate('}')
	    }

	    if (node.oneOf && node.oneOf.length) {
	      var prev = gensym('prev')
	      var passes = gensym('passes')

	      validate
	        ('var %s = errors', prev)
	        ('var %s = 0', passes)

	      node.oneOf.forEach(function(sch, i) {
	        visit(name, sch, false, false)
	        validate('if (%s === errors) {', prev)
	          ('%s++', passes)
	        ('} else {')
	          ('errors = %s', prev)
	        ('}')
	      })

	      validate('if (%s !== 1) {', passes)
	      error('no (or more than one) schemas match')
	      validate('}')
	    }

	    if (node.multipleOf !== undefined) {
	      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))

	      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)

	      error('has a remainder')
	      validate('}')

	      if (type !== 'number' && type !== 'integer') validate('}')
	    }

	    if (node.maxProperties !== undefined) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))

	      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
	      error('has more properties than allowed')
	      validate('}')

	      if (type !== 'object') validate('}')
	    }

	    if (node.minProperties !== undefined) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))

	      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
	      error('has less properties than allowed')
	      validate('}')

	      if (type !== 'object') validate('}')
	    }

	    if (node.maxItems !== undefined) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))

	      validate('if (%s.length > %d) {', name, node.maxItems)
	      error('has more items than allowed')
	      validate('}')

	      if (type !== 'array') validate('}')
	    }

	    if (node.minItems !== undefined) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))

	      validate('if (%s.length < %d) {', name, node.minItems)
	      error('has less items than allowed')
	      validate('}')

	      if (type !== 'array') validate('}')
	    }

	    if (node.maxLength !== undefined) {
	      if (type !== 'string') validate('if (%s) {', types.string(name))

	      validate('if (%s.length > %d) {', name, node.maxLength)
	      error('has longer length than allowed')
	      validate('}')

	      if (type !== 'string') validate('}')
	    }

	    if (node.minLength !== undefined) {
	      if (type !== 'string') validate('if (%s) {', types.string(name))

	      validate('if (%s.length < %d) {', name, node.minLength)
	      error('has less length than allowed')
	      validate('}')

	      if (type !== 'string') validate('}')
	    }

	    if (node.minimum !== undefined) {
	      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
	      error('is less than minimum')
	      validate('}')
	    }

	    if (node.maximum !== undefined) {
	      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
	      error('is more than maximum')
	      validate('}')
	    }

	    if (properties) {
	      Object.keys(properties).forEach(function(p) {
	        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)

	        visit(genobj(name, p), properties[p], reporter, filter)

	        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
	      })
	    }

	    while (indent--) validate('}')
	  }

	  var validate = genfun
	    ('function validate(data) {')
	      ('validate.errors = null')
	      ('var errors = 0')

	  visit('data', schema, reporter, opts && opts.filter)

	  validate
	      ('return errors === 0')
	    ('}')

	  validate = validate.toFunction(scope)
	  validate.errors = null

	  if (Object.defineProperty) {
	    Object.defineProperty(validate, 'error', {
	      get: function() {
	        if (!validate.errors) return ''
	        return validate.errors.map(function(err) {
	          return err.field + ' ' + err.message;
	        }).join('\n')
	      }
	    })
	  }

	  validate.toJSON = function() {
	    return schema
	  }

	  return validate
	}

	module.exports = function(schema, opts) {
	  if (typeof schema === 'string') schema = JSON.parse(schema)
	  return compile(schema, {}, schema, true, opts)
	}

	module.exports.filter = function(schema, opts) {
	  var validate = module.exports(schema, xtend(opts, {filter: true}))
	  return function(sch) {
	    validate(sch)
	    return sch
	  }
	}


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var isProperty = __webpack_require__(146)

	var gen = function(obj, prop) {
	  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
	}

	gen.valid = isProperty
	gen.property = function (prop) {
	 return isProperty(prop) ? prop : JSON.stringify(prop)
	}

	module.exports = gen


/***/ },
/* 146 */
/***/ function(module, exports) {

	"use strict"
	function isProperty(str) {
	  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
	}
	module.exports = isProperty

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(27)

	var INDENT_START = /[\{\[]/
	var INDENT_END = /[\}\]]/

	module.exports = function() {
	  var lines = []
	  var indent = 0

	  var push = function(str) {
	    var spaces = ''
	    while (spaces.length < indent*2) spaces += '  '
	    lines.push(spaces+str)
	  }

	  var line = function(fmt) {
	    if (!fmt) return line

	    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_START.test(fmt[fmt.length-1])) {
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_END.test(fmt.trim()[0])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      return line
	    }

	    push(util.format.apply(util, arguments))
	    return line
	  }

	  line.toString = function() {
	    return lines.join('\n')
	  }

	  line.toFunction = function(scope) {
	    var src = 'return ('+line.toString()+')'

	    var keys = Object.keys(scope || {}).map(function(key) {
	      return key
	    })

	    var vals = keys.map(function(key) {
	      return scope[key]
	    })

	    return Function.apply(null, keys.concat(src)).apply(null, vals)
	  }

	  if (arguments.length) line.apply(null, arguments)

	  return line
	}


/***/ },
/* 148 */
/***/ function(module, exports) {

	var untilde = function(str) {
	  return str.replace(/~./g, function(m) {
	    switch (m) {
	      case "~0":
	        return "~";
	      case "~1":
	        return "/";
	    }
	    throw new Error("Invalid tilde escape: " + m);
	  });
	}

	var traverse = function(obj, pointer, value) {
	  // assert(isArray(pointer))
	  var part = untilde(pointer.shift());
	  if(!obj.hasOwnProperty(part)) {
	    return null;
	  }
	  if(pointer.length !== 0) { // keep traversin!
	    return traverse(obj[part], pointer, value);
	  }
	  // we're done
	  if(typeof value === "undefined") {
	    // just reading
	    return obj[part];
	  }
	  // set new value, return old value
	  var old_value = obj[part];
	  if(value === null) {
	    delete obj[part];
	  } else {
	    obj[part] = value;
	  }
	  return old_value;
	}

	var validate_input = function(obj, pointer) {
	  if(typeof obj !== "object") {
	    throw new Error("Invalid input object.");
	  }

	  if(pointer === "") {
	    return [];
	  }

	  if(!pointer) {
	    throw new Error("Invalid JSON pointer.");
	  }

	  pointer = pointer.split("/");
	  var first = pointer.shift();
	  if (first !== "") {
	    throw new Error("Invalid JSON pointer.");
	  }

	  return pointer;
	}

	var get = function(obj, pointer) {
	  pointer = validate_input(obj, pointer);
	  if (pointer.length === 0) {
	    return obj;
	  }
	  return traverse(obj, pointer);
	}

	var set = function(obj, pointer, value) {
	  pointer = validate_input(obj, pointer);
	  if (pointer.length === 0) {
	    throw new Error("Invalid JSON pointer for set.")
	  }
	  return traverse(obj, pointer, value);
	}

	exports.get = get
	exports.set = set


/***/ },
/* 149 */
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 150 */
/***/ function(module, exports) {

	exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
	exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
	exports['time'] = /^\d{2}:\d{2}:\d{2}$/
	exports['email'] = /^\S+@\S+$/
	exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
	exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
	exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
	exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
	exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
	exports['alpha'] = /^[a-zA-Z]+$/
	exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
	exports['style'] = /\s*(.+?):\s*([^;]+);?/g
	exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
	exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var caseless = __webpack_require__(115)
	  , uuid = __webpack_require__(152)
	  , helpers = __webpack_require__(31)

	var md5 = helpers.md5
	  , toBase64 = helpers.toBase64


	function Auth (request) {
	  // define all public properties here
	  this.request = request
	  this.hasAuth = false
	  this.sentAuth = false
	  this.bearerToken = null
	  this.user = null
	  this.pass = null
	}

	Auth.prototype.basic = function (user, pass, sendImmediately) {
	  var self = this
	  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
	    self.request.emit('error', new Error('auth() received invalid user or password'))
	  }
	  self.user = user
	  self.pass = pass
	  self.hasAuth = true
	  var header = user + ':' + (pass || '')
	  if (sendImmediately || typeof sendImmediately === 'undefined') {
	    var authHeader = 'Basic ' + toBase64(header)
	    self.sentAuth = true
	    return authHeader
	  }
	}

	Auth.prototype.bearer = function (bearer, sendImmediately) {
	  var self = this
	  self.bearerToken = bearer
	  self.hasAuth = true
	  if (sendImmediately || typeof sendImmediately === 'undefined') {
	    if (typeof bearer === 'function') {
	      bearer = bearer()
	    }
	    var authHeader = 'Bearer ' + (bearer || '')
	    self.sentAuth = true
	    return authHeader
	  }
	}

	Auth.prototype.digest = function (method, path, authHeader) {
	  // TODO: More complete implementation of RFC 2617.
	  //   - check challenge.algorithm
	  //   - support algorithm="MD5-sess"
	  //   - handle challenge.domain
	  //   - support qop="auth-int" only
	  //   - handle Authentication-Info (not necessarily?)
	  //   - check challenge.stale (not necessarily?)
	  //   - increase nc (not necessarily?)
	  // For reference:
	  // http://tools.ietf.org/html/rfc2617#section-3
	  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

	  var self = this

	  var challenge = {}
	  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
	  for (;;) {
	    var match = re.exec(authHeader)
	    if (!match) {
	      break
	    }
	    challenge[match[1]] = match[2] || match[3]
	  }

	  var ha1 = md5(self.user + ':' + challenge.realm + ':' + self.pass)
	  var ha2 = md5(method + ':' + path)
	  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth'
	  var nc = qop && '00000001'
	  var cnonce = qop && uuid().replace(/-/g, '')
	  var digestResponse = qop
	    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
	    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
	  var authValues = {
	    username: self.user,
	    realm: challenge.realm,
	    nonce: challenge.nonce,
	    uri: path,
	    qop: qop,
	    response: digestResponse,
	    nc: nc,
	    cnonce: cnonce,
	    algorithm: challenge.algorithm,
	    opaque: challenge.opaque
	  }

	  authHeader = []
	  for (var k in authValues) {
	    if (authValues[k]) {
	      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
	        authHeader.push(k + '=' + authValues[k])
	      } else {
	        authHeader.push(k + '="' + authValues[k] + '"')
	      }
	    }
	  }
	  authHeader = 'Digest ' + authHeader.join(', ')
	  self.sentAuth = true
	  return authHeader
	}

	Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
	  var self = this
	    , request = self.request

	  var authHeader
	  if (bearer === undefined && user === undefined) {
	    self.request.emit('error', new Error('no auth mechanism defined'))
	  } else if (bearer !== undefined) {
	    authHeader = self.bearer(bearer, sendImmediately)
	  } else {
	    authHeader = self.basic(user, pass, sendImmediately)
	  }
	  if (authHeader) {
	    request.setHeader('authorization', authHeader)
	  }
	}

	Auth.prototype.onResponse = function (response) {
	  var self = this
	    , request = self.request

	  if (!self.hasAuth || self.sentAuth) { return null }

	  var c = caseless(response.headers)

	  var authHeader = c.get('www-authenticate')
	  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()
	  request.debug('reauth', authVerb)

	  switch (authVerb) {
	    case 'basic':
	      return self.basic(self.user, self.pass, true)

	    case 'bearer':
	      return self.bearer(self.bearerToken, true)

	    case 'digest':
	      return self.digest(request.method, request.path, authHeader)
	  }
	}

	exports.Auth = Auth


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php

	/*global window, require, define */
	(function(_window) {
	  'use strict';

	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;

	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;

	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch(e) {}
	    }

	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var  _rnds = new Array(16);
	      _mathRNG = _rng = function() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }

	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }

	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(37).randomBytes;
	        _nodeRNG = _rng = _rb && function() {return _rb(16);};
	        _rng();
	      } catch(e) {}
	    }
	  }

	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }

	  // Buffer class to use
	  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;

	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }

	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = (buf && offset) || 0, ii = 0;

	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	      if (ii < 16) { // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });

	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }

	    return buf;
	  }

	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0, bth = _byteToHex;
	    return  bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] + '-' +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]] +
	            bth[buf[i++]] + bth[buf[i++]];
	  }

	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html

	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();

	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [
	    _seedBytes[0] | 0x01,
	    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	  ];

	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

	  // Previous uuid creation time
	  var _lastMSecs = 0, _lastNSecs = 0;

	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];

	    options = options || {};

	    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;

	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();

	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;

	    // Time since last uuid creation (in msecs)
	    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }

	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }

	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }

	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;

	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;

	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;

	    // `time_mid`
	    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;

	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;

	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;

	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;

	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }

	    return buf ? buf : unparse(b);
	  }

	  // **`v4()` - Generate random UUID**

	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;

	    if (typeof(options) === 'string') {
	      buf = (options === 'binary') ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};

	    var rnds = options.random || (options.rng || _rng)();

	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = (rnds[6] & 0x0f) | 0x40;
	    rnds[8] = (rnds[8] & 0x3f) | 0x80;

	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }

	    return buf || unparse(rnds);
	  }

	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;

	  if (('undefined' !== typeof module) && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {return uuid;}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;

	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function() {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };

	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'

	var url = __webpack_require__(15)
	  , qs = __webpack_require__(120)
	  , caseless = __webpack_require__(115)
	  , uuid = __webpack_require__(152)
	  , oauth = __webpack_require__(154)
	  , crypto = __webpack_require__(37)


	function OAuth (request) {
	  this.request = request
	  this.params = null
	}

	OAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {
	  var oa = {}
	  for (var i in _oauth) {
	    oa['oauth_' + i] = _oauth[i]
	  }
	  if (!oa.oauth_version) {
	    oa.oauth_version = '1.0'
	  }
	  if (!oa.oauth_timestamp) {
	    oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
	  }
	  if (!oa.oauth_nonce) {
	    oa.oauth_nonce = uuid().replace(/-/g, '')
	  }
	  if (!oa.oauth_signature_method) {
	    oa.oauth_signature_method = 'HMAC-SHA1'
	  }

	  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key
	  delete oa.oauth_consumer_secret
	  delete oa.oauth_private_key

	  var token_secret = oa.oauth_token_secret
	  delete oa.oauth_token_secret

	  var realm = oa.oauth_realm
	  delete oa.oauth_realm
	  delete oa.oauth_transport_method

	  var baseurl = uri.protocol + '//' + uri.host + uri.pathname
	  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))

	  oa.oauth_signature = oauth.sign(
	    oa.oauth_signature_method,
	    method,
	    baseurl,
	    params,
	    consumer_secret_or_private_key,
	    token_secret)

	  if (realm) {
	    oa.realm = realm
	  }

	  return oa
	}

	OAuth.prototype.buildBodyHash = function(_oauth, body) {
	  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {
	    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +
	      ' signature_method not supported with body_hash signing.'))
	  }

	  var shasum = crypto.createHash('sha1')
	  shasum.update(body || '')
	  var sha1 = shasum.digest('hex')

	  return new Buffer(sha1).toString('base64')
	}

	OAuth.prototype.concatParams = function (oa, sep, wrap) {
	  wrap = wrap || ''

	  var params = Object.keys(oa).filter(function (i) {
	    return i !== 'realm' && i !== 'oauth_signature'
	  }).sort()

	  if (oa.realm) {
	    params.splice(0, 1, 'realm')
	  }
	  params.push('oauth_signature')

	  return params.map(function (i) {
	    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap
	  }).join(sep)
	}

	OAuth.prototype.onRequest = function (_oauth) {
	  var self = this
	  self.params = _oauth

	  var uri = self.request.uri || {}
	    , method = self.request.method || ''
	    , headers = caseless(self.request.headers)
	    , body = self.request.body || ''
	    , qsLib = self.request.qsLib || qs

	  var form
	    , query
	    , contentType = headers.get('content-type') || ''
	    , formContentType = 'application/x-www-form-urlencoded'
	    , transport = _oauth.transport_method || 'header'

	  if (contentType.slice(0, formContentType.length) === formContentType) {
	    contentType = formContentType
	    form = body
	  }
	  if (uri.query) {
	    query = uri.query
	  }
	  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {
	    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +
	      'and content-type ' + formContentType))
	  }

	  if (!form && typeof _oauth.body_hash === 'boolean') {
	    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())
	  }

	  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)

	  switch (transport) {
	    case 'header':
	      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '"'))
	      break

	    case 'query':
	      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')
	      self.request.uri = url.parse(href)
	      self.request.path = self.request.uri.path
	      break

	    case 'body':
	      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')
	      break

	    default:
	      self.request.emit('error', new Error('oauth: transport_method invalid'))
	  }
	}

	exports.OAuth = OAuth

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var crypto = __webpack_require__(37)
	  , qs = __webpack_require__(18)
	  ;

	function sha1 (key, body) {
	  return crypto.createHmac('sha1', key).update(body).digest('base64')
	}

	function rsa (key, body) {
	  return crypto.createSign("RSA-SHA1").update(body).sign(key, 'base64');
	}

	function rfc3986 (str) {
	  return encodeURIComponent(str)
	    .replace(/!/g,'%21')
	    .replace(/\*/g,'%2A')
	    .replace(/\(/g,'%28')
	    .replace(/\)/g,'%29')
	    .replace(/'/g,'%27')
	    ;
	}

	// Maps object to bi-dimensional array
	// Converts { foo: 'A', bar: [ 'b', 'B' ]} to
	// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
	function map (obj) {
	  var key, val, arr = []
	  for (key in obj) {
	    val = obj[key]
	    if (Array.isArray(val))
	      for (var i = 0; i < val.length; i++)
	        arr.push([key, val[i]])
	    else if (typeof val === "object")
	      for (var prop in val)
	        arr.push([key + '[' + prop + ']', val[prop]]);
	    else
	      arr.push([key, val])
	  }
	  return arr
	}

	// Compare function for sort
	function compare (a, b) {
	  return a > b ? 1 : a < b ? -1 : 0
	}

	function generateBase (httpMethod, base_uri, params) {
	  // adapted from https://dev.twitter.com/docs/auth/oauth and 
	  // https://dev.twitter.com/docs/auth/creating-signature

	  // Parameter normalization
	  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
	  var normalized = map(params)
	  // 1.  First, the name and value of each parameter are encoded
	  .map(function (p) {
	    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
	  })
	  // 2.  The parameters are sorted by name, using ascending byte value
	  //     ordering.  If two or more parameters share the same name, they
	  //     are sorted by their value.
	  .sort(function (a, b) {
	    return compare(a[0], b[0]) || compare(a[1], b[1])
	  })
	  // 3.  The name of each parameter is concatenated to its corresponding
	  //     value using an "=" character (ASCII code 61) as a separator, even
	  //     if the value is empty.
	  .map(function (p) { return p.join('=') })
	   // 4.  The sorted name/value pairs are concatenated together into a
	   //     single string by using an "&" character (ASCII code 38) as
	   //     separator.
	  .join('&')

	  var base = [
	    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
	    rfc3986(base_uri),
	    rfc3986(normalized)
	  ].join('&')

	  return base
	}

	function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params)
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&')

	  return sha1(key, base)
	}

	function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
	  var base = generateBase(httpMethod, base_uri, params)
	  var key = private_key || ''

	  return rsa(key, base)
	}

	function plaintext (consumer_secret, token_secret) {
	  var key = [
	    consumer_secret || '',
	    token_secret || ''
	  ].map(rfc3986).join('&')

	  return key
	}

	function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
	  var method
	  var skipArgs = 1

	  switch (signMethod) {
	    case 'RSA-SHA1':
	      method = rsasign
	      break
	    case 'HMAC-SHA1':
	      method = hmacsign
	      break
	    case 'PLAINTEXT':
	      method = plaintext
	      skipArgs = 4
	      break
	    default:
	     throw new Error("Signature method not supported: " + signMethod)
	  }

	  return method.apply(null, [].slice.call(arguments, skipArgs))
	}

	exports.hmacsign = hmacsign
	exports.rsasign = rsasign
	exports.plaintext = plaintext
	exports.sign = sign
	exports.rfc3986 = rfc3986
	exports.generateBase = generateBase



/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict'

	var uuid = __webpack_require__(152)
	  , CombinedStream = __webpack_require__(156)
	  , isstream = __webpack_require__(158)


	function Multipart (request) {
	  this.request = request
	  this.boundary = uuid()
	  this.chunked = false
	  this.body = null
	}

	Multipart.prototype.isChunked = function (options) {
	  var self = this
	    , chunked = false
	    , parts = options.data || options

	  if (!parts.forEach) {
	    self.request.emit('error', new Error('Argument error, options.multipart.'))
	  }

	  if (options.chunked !== undefined) {
	    chunked = options.chunked
	  }

	  if (self.request.getHeader('transfer-encoding') === 'chunked') {
	    chunked = true
	  }

	  if (!chunked) {
	    parts.forEach(function (part) {
	      if (typeof part.body === 'undefined') {
	        self.request.emit('error', new Error('Body attribute missing in multipart.'))
	      }
	      if (isstream(part.body)) {
	        chunked = true
	      }
	    })
	  }

	  return chunked
	}

	Multipart.prototype.setHeaders = function (chunked) {
	  var self = this

	  if (chunked && !self.request.hasHeader('transfer-encoding')) {
	    self.request.setHeader('transfer-encoding', 'chunked')
	  }

	  var header = self.request.getHeader('content-type')

	  if (!header || header.indexOf('multipart') === -1) {
	    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)
	  } else {
	    if (header.indexOf('boundary') !== -1) {
	      self.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1')
	    } else {
	      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)
	    }
	  }
	}

	Multipart.prototype.build = function (parts, chunked) {
	  var self = this
	  var body = chunked ? new CombinedStream() : []

	  function add (part) {
	    return chunked ? body.append(part) : body.push(new Buffer(part))
	  }

	  if (self.request.preambleCRLF) {
	    add('\r\n')
	  }

	  parts.forEach(function (part) {
	    var preamble = '--' + self.boundary + '\r\n'
	    Object.keys(part).forEach(function (key) {
	      if (key === 'body') { return }
	      preamble += key + ': ' + part[key] + '\r\n'
	    })
	    preamble += '\r\n'
	    add(preamble)
	    add(part.body)
	    add('\r\n')
	  })
	  add('--' + self.boundary + '--')

	  if (self.request.postambleCRLF) {
	    add('\r\n')
	  }

	  return body
	}

	Multipart.prototype.onRequest = function (options) {
	  var self = this

	  var chunked = self.isChunked(options)
	    , parts = options.data || options

	  self.setHeaders(chunked)
	  self.chunked = chunked
	  self.body = self.build(parts, chunked)
	}

	exports.Multipart = Multipart

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(27);
	var Stream = __webpack_require__(56).Stream;
	var DelayedStream = __webpack_require__(157);

	module.exports = CombinedStream;
	function CombinedStream() {
	  this.writable = false;
	  this.readable = true;
	  this.dataSize = 0;
	  this.maxDataSize = 2 * 1024 * 1024;
	  this.pauseStreams = true;

	  this._released = false;
	  this._streams = [];
	  this._currentStream = null;
	}
	util.inherits(CombinedStream, Stream);

	CombinedStream.create = function(options) {
	  var combinedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    combinedStream[option] = options[option];
	  }

	  return combinedStream;
	};

	CombinedStream.isStreamLike = function(stream) {
	  return (typeof stream !== 'function')
	    && (typeof stream !== 'string')
	    && (typeof stream !== 'boolean')
	    && (typeof stream !== 'number')
	    && (!Buffer.isBuffer(stream));
	};

	CombinedStream.prototype.append = function(stream) {
	  var isStreamLike = CombinedStream.isStreamLike(stream);

	  if (isStreamLike) {
	    if (!(stream instanceof DelayedStream)) {
	      var newStream = DelayedStream.create(stream, {
	        maxDataSize: Infinity,
	        pauseStream: this.pauseStreams,
	      });
	      stream.on('data', this._checkDataSize.bind(this));
	      stream = newStream;
	    }

	    this._handleErrors(stream);

	    if (this.pauseStreams) {
	      stream.pause();
	    }
	  }

	  this._streams.push(stream);
	  return this;
	};

	CombinedStream.prototype.pipe = function(dest, options) {
	  Stream.prototype.pipe.call(this, dest, options);
	  this.resume();
	  return dest;
	};

	CombinedStream.prototype._getNext = function() {
	  this._currentStream = null;
	  var stream = this._streams.shift();


	  if (typeof stream == 'undefined') {
	    this.end();
	    return;
	  }

	  if (typeof stream !== 'function') {
	    this._pipeNext(stream);
	    return;
	  }

	  var getStream = stream;
	  getStream(function(stream) {
	    var isStreamLike = CombinedStream.isStreamLike(stream);
	    if (isStreamLike) {
	      stream.on('data', this._checkDataSize.bind(this));
	      this._handleErrors(stream);
	    }

	    this._pipeNext(stream);
	  }.bind(this));
	};

	CombinedStream.prototype._pipeNext = function(stream) {
	  this._currentStream = stream;

	  var isStreamLike = CombinedStream.isStreamLike(stream);
	  if (isStreamLike) {
	    stream.on('end', this._getNext.bind(this));
	    stream.pipe(this, {end: false});
	    return;
	  }

	  var value = stream;
	  this.write(value);
	  this._getNext();
	};

	CombinedStream.prototype._handleErrors = function(stream) {
	  var self = this;
	  stream.on('error', function(err) {
	    self._emitError(err);
	  });
	};

	CombinedStream.prototype.write = function(data) {
	  this.emit('data', data);
	};

	CombinedStream.prototype.pause = function() {
	  if (!this.pauseStreams) {
	    return;
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
	  this.emit('pause');
	};

	CombinedStream.prototype.resume = function() {
	  if (!this._released) {
	    this._released = true;
	    this.writable = true;
	    this._getNext();
	  }

	  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
	  this.emit('resume');
	};

	CombinedStream.prototype.end = function() {
	  this._reset();
	  this.emit('end');
	};

	CombinedStream.prototype.destroy = function() {
	  this._reset();
	  this.emit('close');
	};

	CombinedStream.prototype._reset = function() {
	  this.writable = false;
	  this._streams = [];
	  this._currentStream = null;
	};

	CombinedStream.prototype._checkDataSize = function() {
	  this._updateDataSize();
	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
	  this._emitError(new Error(message));
	};

	CombinedStream.prototype._updateDataSize = function() {
	  this.dataSize = 0;

	  var self = this;
	  this._streams.forEach(function(stream) {
	    if (!stream.dataSize) {
	      return;
	    }

	    self.dataSize += stream.dataSize;
	  });

	  if (this._currentStream && this._currentStream.dataSize) {
	    this.dataSize += this._currentStream.dataSize;
	  }
	};

	CombinedStream.prototype._emitError = function(err) {
	  this._reset();
	  this.emit('error', err);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer))

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(56).Stream;
	var util = __webpack_require__(27);

	module.exports = DelayedStream;
	function DelayedStream() {
	  this.source = null;
	  this.dataSize = 0;
	  this.maxDataSize = 1024 * 1024;
	  this.pauseStream = true;

	  this._maxDataSizeExceeded = false;
	  this._released = false;
	  this._bufferedEvents = [];
	}
	util.inherits(DelayedStream, Stream);

	DelayedStream.create = function(source, options) {
	  var delayedStream = new this();

	  options = options || {};
	  for (var option in options) {
	    delayedStream[option] = options[option];
	  }

	  delayedStream.source = source;

	  var realEmit = source.emit;
	  source.emit = function() {
	    delayedStream._handleEmit(arguments);
	    return realEmit.apply(source, arguments);
	  };

	  source.on('error', function() {});
	  if (delayedStream.pauseStream) {
	    source.pause();
	  }

	  return delayedStream;
	};

	Object.defineProperty(DelayedStream.prototype, 'readable', {
	  configurable: true,
	  enumerable: true,
	  get: function() {
	    return this.source.readable;
	  }
	});

	DelayedStream.prototype.setEncoding = function() {
	  return this.source.setEncoding.apply(this.source, arguments);
	};

	DelayedStream.prototype.resume = function() {
	  if (!this._released) {
	    this.release();
	  }

	  this.source.resume();
	};

	DelayedStream.prototype.pause = function() {
	  this.source.pause();
	};

	DelayedStream.prototype.release = function() {
	  this._released = true;

	  this._bufferedEvents.forEach(function(args) {
	    this.emit.apply(this, args);
	  }.bind(this));
	  this._bufferedEvents = [];
	};

	DelayedStream.prototype.pipe = function() {
	  var r = Stream.prototype.pipe.apply(this, arguments);
	  this.resume();
	  return r;
	};

	DelayedStream.prototype._handleEmit = function(args) {
	  if (this._released) {
	    this.emit.apply(this, args);
	    return;
	  }

	  if (args[0] === 'data') {
	    this.dataSize += args[1].length;
	    this._checkIfMaxDataSizeExceeded();
	  }

	  this._bufferedEvents.push(args);
	};

	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
	  if (this._maxDataSizeExceeded) {
	    return;
	  }

	  if (this.dataSize <= this.maxDataSize) {
	    return;
	  }

	  this._maxDataSizeExceeded = true;
	  var message =
	    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
	  this.emit('error', new Error(message));
	};


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var stream = __webpack_require__(56)


	function isStream (obj) {
	  return obj instanceof stream.Stream
	}


	function isReadable (obj) {
	  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
	}


	function isWritable (obj) {
	  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
	}


	function isDuplex (obj) {
	  return isReadable(obj) && isWritable(obj)
	}


	module.exports            = isStream
	module.exports.isReadable = isReadable
	module.exports.isWritable = isWritable
	module.exports.isDuplex   = isDuplex


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var url = __webpack_require__(15)
	var isUrl = /^https?:/

	function Redirect (request) {
	  this.request = request
	  this.followRedirect = true
	  this.followRedirects = true
	  this.followAllRedirects = false
	  this.allowRedirect = function () {return true}
	  this.maxRedirects = 10
	  this.redirects = []
	  this.redirectsFollowed = 0
	  this.removeRefererHeader = false
	}

	Redirect.prototype.onRequest = function (options) {
	  var self = this

	  if (options.maxRedirects !== undefined) {
	    self.maxRedirects = options.maxRedirects
	  }
	  if (typeof options.followRedirect === 'function') {
	    self.allowRedirect = options.followRedirect
	  }
	  if (options.followRedirect !== undefined) {
	    self.followRedirects = !!options.followRedirect
	  }
	  if (options.followAllRedirects !== undefined) {
	    self.followAllRedirects = options.followAllRedirects
	  }
	  if (self.followRedirects || self.followAllRedirects) {
	    self.redirects = self.redirects || []
	  }
	  if (options.removeRefererHeader !== undefined) {
	    self.removeRefererHeader = options.removeRefererHeader
	  }
	}

	Redirect.prototype.redirectTo = function (response) {
	  var self = this
	    , request = self.request

	  var redirectTo = null
	  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {
	    var location = response.caseless.get('location')
	    request.debug('redirect', location)

	    if (self.followAllRedirects) {
	      redirectTo = location
	    } else if (self.followRedirects) {
	      switch (request.method) {
	        case 'PATCH':
	        case 'PUT':
	        case 'POST':
	        case 'DELETE':
	          // Do not follow redirects
	          break
	        default:
	          redirectTo = location
	          break
	      }
	    }
	  } else if (response.statusCode === 401) {
	    var authHeader = request._auth.onResponse(response)
	    if (authHeader) {
	      request.setHeader('authorization', authHeader)
	      redirectTo = request.uri
	    }
	  }
	  return redirectTo
	}

	Redirect.prototype.onResponse = function (response) {
	  var self = this
	    , request = self.request

	  var redirectTo = self.redirectTo(response)
	  if (!redirectTo || !self.allowRedirect.call(request, response)) {
	    return false
	  }

	  request.debug('redirect to', redirectTo)

	  // ignore any potential response body.  it cannot possibly be useful
	  // to us at this point.
	  // response.resume should be defined, but check anyway before calling. Workaround for browserify.
	  if (response.resume) {
	    response.resume()
	  }

	  if (self.redirectsFollowed >= self.maxRedirects) {
	    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))
	    return false
	  }
	  self.redirectsFollowed += 1

	  if (!isUrl.test(redirectTo)) {
	    redirectTo = url.resolve(request.uri.href, redirectTo)
	  }

	  var uriPrev = request.uri
	  request.uri = url.parse(redirectTo)

	  // handle the case where we change protocol from https to http or vice versa
	  if (request.uri.protocol !== uriPrev.protocol) {
	    request._updateProtocol()
	  }

	  self.redirects.push(
	    { statusCode : response.statusCode
	    , redirectUri: redirectTo
	    }
	  )
	  if (self.followAllRedirects && response.statusCode !== 401 && response.statusCode !== 307) {
	    request.method = 'GET'
	  }
	  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215
	  delete request.src
	  delete request.req
	  delete request.agent
	  delete request._started
	  if (response.statusCode !== 401 && response.statusCode !== 307) {
	    // Remove parameters from the previous response, unless this is the second request
	    // for a server that requires digest authentication.
	    delete request.body
	    delete request._form
	    if (request.headers) {
	      request.removeHeader('host')
	      request.removeHeader('content-type')
	      request.removeHeader('content-length')
	      if (request.uri.hostname !== request.originalHost.split(':')[0]) {
	        // Remove authorization if changing hostnames (but not if just
	        // changing ports or protocols).  This matches the behavior of curl:
	        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
	        request.removeHeader('authorization')
	      }
	    }
	  }

	  if (!self.removeRefererHeader) {
	    request.setHeader('referer', request.uri.href)
	  }

	  request.emit('redirect')

	  request.init()

	  return true
	}

	exports.Redirect = Redirect


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'

	var url = __webpack_require__(15)
	  , tunnel = __webpack_require__(161)

	var defaultProxyHeaderWhiteList = [
	  'accept',
	  'accept-charset',
	  'accept-encoding',
	  'accept-language',
	  'accept-ranges',
	  'cache-control',
	  'content-encoding',
	  'content-language',
	  'content-length',
	  'content-location',
	  'content-md5',
	  'content-range',
	  'content-type',
	  'connection',
	  'date',
	  'expect',
	  'max-forwards',
	  'pragma',
	  'referer',
	  'te',
	  'transfer-encoding',
	  'user-agent',
	  'via'
	]

	var defaultProxyHeaderExclusiveList = [
	  'proxy-authorization'
	]

	function constructProxyHost(uriObject) {
	  var port = uriObject.portA
	    , protocol = uriObject.protocol
	    , proxyHost = uriObject.hostname + ':'

	  if (port) {
	    proxyHost += port
	  } else if (protocol === 'https:') {
	    proxyHost += '443'
	  } else {
	    proxyHost += '80'
	  }

	  return proxyHost
	}

	function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
	  var whiteList = proxyHeaderWhiteList
	    .reduce(function (set, header) {
	      set[header.toLowerCase()] = true
	      return set
	    }, {})

	  return Object.keys(headers)
	    .filter(function (header) {
	      return whiteList[header.toLowerCase()]
	    })
	    .reduce(function (set, header) {
	      set[header] = headers[header]
	      return set
	    }, {})
	}

	function constructTunnelOptions (request, proxyHeaders) {
	  var proxy = request.proxy

	  var tunnelOptions = {
	    proxy : {
	      host      : proxy.hostname,
	      port      : +proxy.port,
	      proxyAuth : proxy.auth,
	      headers   : proxyHeaders
	    },
	    headers            : request.headers,
	    ca                 : request.ca,
	    cert               : request.cert,
	    key                : request.key,
	    passphrase         : request.passphrase,
	    pfx                : request.pfx,
	    ciphers            : request.ciphers,
	    rejectUnauthorized : request.rejectUnauthorized,
	    secureOptions      : request.secureOptions,
	    secureProtocol     : request.secureProtocol
	  }

	  return tunnelOptions
	}

	function constructTunnelFnName(uri, proxy) {
	  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')
	  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')
	  return [uriProtocol, proxyProtocol].join('Over')
	}

	function getTunnelFn(request) {
	  var uri = request.uri
	  var proxy = request.proxy
	  var tunnelFnName = constructTunnelFnName(uri, proxy)
	  return tunnel[tunnelFnName]
	}


	function Tunnel (request) {
	  this.request = request
	  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList
	  this.proxyHeaderExclusiveList = []
	}

	Tunnel.prototype.isEnabled = function (options) {
	  var request = this.request
	  // Tunnel HTTPS by default, or if a previous request in the redirect chain
	  // was tunneled.  Allow the user to override this setting.

	  // If self.tunnel is already set (because this is a redirect), use the
	  // existing value.
	  if (typeof request.tunnel !== 'undefined') {
	    return request.tunnel
	  }

	  // If options.tunnel is set (the user specified a value), use it.
	  if (typeof options.tunnel !== 'undefined') {
	    return options.tunnel
	  }

	  // If the destination is HTTPS, tunnel.
	  if (request.uri.protocol === 'https:') {
	    return true
	  }

	  // Otherwise, leave tunnel unset, because if a later request in the redirect
	  // chain is HTTPS then that request (and any subsequent ones) should be
	  // tunneled.
	  return undefined
	}

	Tunnel.prototype.setup = function (options) {
	  var self = this
	    , request = self.request

	  options = options || {}

	  if (typeof request.proxy === 'string') {
	    request.proxy = url.parse(request.proxy)
	  }

	  if (!request.proxy || !request.tunnel) {
	    return false
	  }

	  // Setup Proxy Header Exclusive List and White List
	  if (options.proxyHeaderWhiteList) {
	    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList
	  }
	  if (options.proxyHeaderExclusiveList) {
	    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList
	  }

	  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)
	  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)

	  // Setup Proxy Headers and Proxy Headers Host
	  // Only send the Proxy White Listed Header names
	  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)
	  proxyHeaders.host = constructProxyHost(request.uri)

	  proxyHeaderExclusiveList.forEach(request.removeHeader, request)

	  // Set Agent from Tunnel Data
	  var tunnelFn = getTunnelFn(request)
	  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)
	  request.agent = tunnelFn(tunnelOptions)

	  return true
	}

	Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList
	Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList
	exports.Tunnel = Tunnel


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {'use strict'

	var net = __webpack_require__(14)
	  , tls = __webpack_require__(14)
	  , http = __webpack_require__(53)
	  , https = __webpack_require__(72)
	  , events = __webpack_require__(54)
	  , assert = __webpack_require__(92)
	  , util = __webpack_require__(27)
	  ;

	exports.httpOverHttp = httpOverHttp
	exports.httpsOverHttp = httpsOverHttp
	exports.httpOverHttps = httpOverHttps
	exports.httpsOverHttps = httpsOverHttps


	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = http.request
	  return agent
	}

	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = http.request
	  agent.createSocket = createSecureSocket
	  agent.defaultPort = 443
	  return agent
	}

	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = https.request
	  return agent
	}

	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options)
	  agent.request = https.request
	  agent.createSocket = createSecureSocket
	  agent.defaultPort = 443
	  return agent
	}


	function TunnelingAgent(options) {
	  var self = this
	  self.options = options || {}
	  self.proxyOptions = self.options.proxy || {}
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
	  self.requests = []
	  self.sockets = []

	  self.on('free', function onFree(socket, host, port) {
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i]
	      if (pending.host === host && pending.port === port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1)
	        pending.request.onSocket(socket)
	        return
	      }
	    }
	    socket.destroy()
	    self.removeSocket(socket)
	  })
	}
	util.inherits(TunnelingAgent, events.EventEmitter)

	TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
	  var self = this

	   // Legacy API: addRequest(req, host, port, path)
	  if (typeof options === 'string') {
	    options = {
	      host: options,
	      port: arguments[2],
	      path: arguments[3]
	    };
	  }

	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push({host: options.host, port: options.port, request: req})
	    return
	  }

	  // If we are under maxSockets create a new one.
	  self.createConnection({host: options.host, port: options.port, request: req})
	}

	TunnelingAgent.prototype.createConnection = function createConnection(pending) {
	  var self = this

	  self.createSocket(pending, function(socket) {
	    socket.on('free', onFree)
	    socket.on('close', onCloseOrRemove)
	    socket.on('agentRemove', onCloseOrRemove)
	    pending.request.onSocket(socket)

	    function onFree() {
	      self.emit('free', socket, pending.host, pending.port)
	    }

	    function onCloseOrRemove(err) {
	      self.removeSocket(socket)
	      socket.removeListener('free', onFree)
	      socket.removeListener('close', onCloseOrRemove)
	      socket.removeListener('agentRemove', onCloseOrRemove)
	    }
	  })
	}

	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this
	  var placeholder = {}
	  self.sockets.push(placeholder)

	  var connectOptions = mergeOptions({}, self.proxyOptions, 
	    { method: 'CONNECT'
	    , path: options.host + ':' + options.port
	    , agent: false
	    }
	  )
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {}
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        new Buffer(connectOptions.proxyAuth).toString('base64')
	  }

	  debug('making CONNECT request')
	  var connectReq = self.request(connectOptions)
	  connectReq.useChunkedEncodingByDefault = false // for v0.6
	  connectReq.once('response', onResponse) // for v0.6
	  connectReq.once('upgrade', onUpgrade)   // for v0.6
	  connectReq.once('connect', onConnect)   // for v0.7 or later
	  connectReq.once('error', onError)
	  connectReq.end()

	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true
	  }

	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head)
	    })
	  }

	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners()
	    socket.removeAllListeners()

	    if (res.statusCode === 200) {
	      assert.equal(head.length, 0)
	      debug('tunneling connection has established')
	      self.sockets[self.sockets.indexOf(placeholder)] = socket
	      cb(socket)
	    } else {
	      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
	      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
	      error.code = 'ECONNRESET'
	      options.request.emit('error', error)
	      self.removeSocket(placeholder)
	    }
	  }

	  function onError(cause) {
	    connectReq.removeAllListeners()

	    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
	    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
	    error.code = 'ECONNRESET'
	    options.request.emit('error', error)
	    self.removeSocket(placeholder)
	  }
	}

	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket)
	  if (pos === -1) return
	  
	  this.sockets.splice(pos, 1)

	  var pending = this.requests.shift()
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createConnection(pending)
	  }
	}

	function createSecureSocket(options, cb) {
	  var self = this
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
	      { servername: options.host
	      , socket: socket
	      }
	    ))
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket
	    cb(secureSocket)
	  })
	}


	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i]
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides)
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j]
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k]
	        }
	      }
	    }
	  }
	  return target
	}


	var debug
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments)
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0]
	    } else {
	      args.unshift('TUNNEL:')
	    }
	    console.error.apply(console, args)
	  }
	} else {
	  debug = function() {}
	}
	exports.debug = debug // for test

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32).Buffer, __webpack_require__(7)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	var config = {
	  baseURL: "https://app.ticketmaster.com"
	}

	module.exports = config;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var find = __webpack_require__(164);

	module.exports = function(apiKey, accessToken) {
	  return {
	    find: find(apiKey, accessToken)
	  }
	};

	module.exports.find = find;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(categoryId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v1/categories/' + categoryId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var all = __webpack_require__(166),
	    find = __webpack_require__(167);

	module.exports = function(apiKey, accessToken) {
	  return {
	    all: all(apiKey, accessToken),
	    find: find(apiKey, accessToken)
	  }
	};

	module.exports.all  = all;
	module.exports.find = find;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(options) {
	    options = options || {};
	    options.apikey = apiKey;

	    return requestAsync({
	      url: config.baseURL + '/discovery/v1/events/',
	      method: 'GET',
	      qs: options
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        var result = JSON.parse(body);
	        return result._embedded.events;
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(eventId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v1/events/' + eventId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var find = __webpack_require__(169);

	module.exports = function(apiKey, accessToken) {
	  return {
	    find: find(apiKey, accessToken)
	  }
	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(venueId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v1/venues/' + venueId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var attraction = __webpack_require__(171),
	    event      = __webpack_require__(174),
	    venue      = __webpack_require__(177);

	module.exports = function(apiKey, accessToken) {
	  return {
	    attraction: attraction(apiKey, accessToken),
	    event: event(apiKey, accessToken),
	    venue: venue(apiKey, accessToken)
	  };
	};

	module.exports.attraction = attraction;
	module.exports.event = event;
	module.exports.venue = venue;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var all = __webpack_require__(172),
	    find = __webpack_require__(173);

	module.exports = function(apiKey, accessToken) {
	  return {
	    all: all(apiKey, accessToken),
	    find: find(apiKey, accessToken)
	  }
	};

	module.exports.all = all;
	module.exports.find = find;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(options) {
	    options = options || {};
	    options.apikey = apiKey;

	    return requestAsync({
	      url: config.baseURL + '/discovery/v2/attractions/',
	      method: 'GET',
	      qs: options
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        var result = JSON.parse(body);
	        return result._embedded.attractions;
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(attractionId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v2/attractions/' + attractionId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var all = __webpack_require__(175),
	    find = __webpack_require__(176);

	module.exports = function(apiKey, accessToken) {
	  return {
	    all: all(apiKey, accessToken),
	    find: find(apiKey, accessToken)
	  }
	};

	module.exports.all  = all;
	module.exports.find = find;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(options) {
	    options = options || {};
	    options.apikey = apiKey;

	    return requestAsync({
	      url: config.baseURL + '/discovery/v2/events/',
	      method: 'GET',
	      qs: options
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        var result = JSON.parse(body);
	        return result._embedded ? result._embedded.events: Promise.reject(result);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(eventId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v2/events/' + eventId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var find = __webpack_require__(178);

	module.exports = function(apiKey, accessToken) {
	  return {
	    find: find(apiKey, accessToken)
	  }
	};


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(venueId) {
	    return requestAsync({
	      url: config.baseURL + '/discovery/v2/venues/' + venueId + '?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var v2 = __webpack_require__(180);

	module.exports = function(apiKey, accessToken) {
	  return { v2: v2(apiKey, accessToken) };
	};

	module.exports.v2 = v2;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var offer = __webpack_require__(181);

	module.exports = function(apiKey, accessToken) {
	  return { offer: offer(apiKey, accessToken) };
	};

	module.exports.offer = offer;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var find = __webpack_require__(182);

	module.exports = function(apiKey, accessToken) {
	  return { find: find(apiKey, accessToken) }
	};

	module.exports.find = find;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var Promise      = __webpack_require__(6);
	var requestAsync = __webpack_require__(9);
	var config       = __webpack_require__(162);

	module.exports = function(apiKey, accessToken) {
	  return function(eventId) {
	    return requestAsync({
	      url: config.baseURL + '/commerce/v2/events/' + eventId + '/offers?apikey=' + apiKey,
	      method: 'GET'
	    })
	    .spread(function (response, body) {
	      if(response.statusCode === 200) {
	        return JSON.parse(body);
	      } else {
	        parsedBody = JSON.parse(body);
	        return Promise.reject(parsedBody);
	      }
	    });
	  }
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGlja2V0bWFzdGVyLWNsaWVudC0wLjQuMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBmNDMzYzJmOGM0YzdjZTFmYTgwMiIsIndlYnBhY2s6Ly8vLi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjEvYXR0cmFjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9hdHRyYWN0aW9uL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYmx1ZWJpcmQvanMvYnJvd3Nlci9ibHVlYmlyZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2hlbHBlcnMvcmVxdWVzdF9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVxdWVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9leHRlbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVxdWVzdC9saWIvY29va2llcy5qcyIsIndlYnBhY2s6Ly8vLi4vfi90b3VnaC1jb29raWUvbGliL2Nvb2tpZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2VtcHR5LmpzIiwid2VicGFjazovLy8uLi9+L3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdXJsL34vcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovLy8uLi9+L3RvdWdoLWNvb2tpZS9saWIvcHVic3VmZml4LmpzIiwid2VicGFjazovLy8uLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uLi9+L3RvdWdoLWNvb2tpZS9saWIvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdG91Z2gtY29va2llL2xpYi9tZW1zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi90b3VnaC1jb29raWUvbGliL3Blcm11dGVEb21haW4uanMiLCJ3ZWJwYWNrOi8vLy4uL34vdG91Z2gtY29va2llL2xpYi9wYXRoTWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8uLi9+L3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi90b3VnaC1jb29raWUvcGFja2FnZS5qc29uIiwid2VicGFjazovLy8uLi9+L3JlcXVlc3QvbGliL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwid2VicGFjazovLy8uLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vYnVmZmVyL34vaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9qc29uLXN0cmluZ2lmeS1zYWZlL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4uL34vY3J5cHRvLWJyb3dzZXJpZnkvY3JlYXRlLWhhc2guanMiLCJ3ZWJwYWNrOi8vLy4uL34vc2hhLmpzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3NoYS5qcy9oYXNoLmpzIiwid2VicGFjazovLy8uLi9+L3NoYS5qcy9zaGExLmpzIiwid2VicGFjazovLy8uLi9+L3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4uL34vc2hhLmpzL3NoYTUxMi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yaXBlbWQxNjAvbGliL3JpcGVtZDE2MC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jcnlwdG8tYnJvd3NlcmlmeS9jcmVhdGUtaG1hYy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jcnlwdG8tYnJvd3NlcmlmeS9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGJrZGYyLWNvbXBhdC9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVxdWVzdC9yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtYnJvd3NlcmlmeS9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uLi9+L3N0cmluZ19kZWNvZGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid2VicGFjazovLy8uLi9+L3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtYnJvd3NlcmlmeS9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4uL34vQmFzZTY0L2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uLi9+L25vZGUtbGlicy1icm93c2VyL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy8uLi9+L25vZGUtbGlicy1icm93c2VyL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uLi9+L2Jyb3dzZXJpZnktemxpYi9zcmMvYmluZGluZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovLy8uLi9+L3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwid2VicGFjazovLy8uLi9+L3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uLi9+L3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwid2VicGFjazovLy8uLi9+L3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovLy8uLi9+L3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uLi9+L2Fzc2VydC9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYmwvYmwuanMiLCJ3ZWJwYWNrOi8vLy4uL34vaGF3ay9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hd3Mtc2lnbjIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vaHR0cC1zaWduYXR1cmUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtc2lnbmF0dXJlL2xpYi9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYXNzZXJ0LXBsdXMvYXNzZXJ0LmpzIiwid2VicGFjazovLy8uLi9+L2h0dHAtc2lnbmF0dXJlL2xpYi9zaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL34vaHR0cC1zaWduYXR1cmUvbGliL3ZlcmlmeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9odHRwLXNpZ25hdHVyZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hc24xL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hc24xL2xpYi9iZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vYXNuMS9saWIvYmVyL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hc24xL2xpYi9iZXIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vYXNuMS9saWIvYmVyL3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9hc24xL2xpYi9iZXIvd3JpdGVyLmpzIiwid2VicGFjazovLy8uLi9+L2N0eXBlL2N0eXBlLmpzIiwid2VicGFjazovLy8uLi9+L2N0eXBlL2N0Zi5qcyIsIndlYnBhY2s6Ly8vLi4vfi9jdHlwZS9jdGlvLmpzIiwid2VicGFjazovLy8uLi9+L21pbWUtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vbWltZS10eXBlcy9+L21pbWUtZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vbWltZS10eXBlcy9+L21pbWUtZGIvZGIuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9zdHJpbmdzdHJlYW0vc3RyaW5nc3RyZWFtLmpzIiwid2VicGFjazovLy8uLi9+L2Nhc2VsZXNzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2ZvcmV2ZXItYWdlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9+L3JlcXVlc3QvbGliL2dldFByb3h5RnJvbVVSSS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZXF1ZXN0L2xpYi9xdWVyeXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vcXMvbGliL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9xcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uLi9+L3JlcXVlc3QvbGliL2hhci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvY2FjaGUuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2NhY2hlRW50cnkuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2NvbnRlbnQuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2Nvb2tpZS5qc29uIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvY3JlYXRvci5qc29uIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvZW50cnkuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2hhci5qc29uIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvbG9nLmpzb24iLCJ3ZWJwYWNrOi8vLy4uL34vaGFyLXZhbGlkYXRvci9saWIvc2NoZW1hcy9wYWdlLmpzb24iLCJ3ZWJwYWNrOi8vLy4uL34vaGFyLXZhbGlkYXRvci9saWIvc2NoZW1hcy9wYWdlVGltaW5ncy5qc29uIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvcG9zdERhdGEuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL3JlY29yZC5qc29uIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvcmVxdWVzdC5qc29uIiwid2VicGFjazovLy8uLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvcmVzcG9uc2UuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL3RpbWluZ3MuanNvbiIsIndlYnBhY2s6Ly8vLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi4vfi9pcy1teS1qc29uLXZhbGlkL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L2dlbmVyYXRlLW9iamVjdC1wcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9pcy1wcm9wZXJ0eS9pcy1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vfi9nZW5lcmF0ZS1mdW5jdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9qc29ucG9pbnRlci9qc29ucG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi4vfi94dGVuZC9pbW11dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL34vaXMtbXktanNvbi12YWxpZC9mb3JtYXRzLmpzIiwid2VicGFjazovLy8uLi9+L3JlcXVlc3QvbGliL2F1dGguanMiLCJ3ZWJwYWNrOi8vLy4uL34vbm9kZS11dWlkL3V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vcmVxdWVzdC9saWIvb2F1dGguanMiLCJ3ZWJwYWNrOi8vLy4uL34vb2F1dGgtc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi9yZXF1ZXN0L2xpYi9tdWx0aXBhcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vY29tYmluZWQtc3RyZWFtL2xpYi9jb21iaW5lZF9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4uL34vZGVsYXllZC1zdHJlYW0vbGliL2RlbGF5ZWRfc3RyZWFtLmpzIiwid2VicGFjazovLy8uLi9+L2lzc3RyZWFtL2lzc3RyZWFtLmpzIiwid2VicGFjazovLy8uLi9+L3JlcXVlc3QvbGliL3JlZGlyZWN0LmpzIiwid2VicGFjazovLy8uLi9+L3JlcXVlc3QvbGliL3R1bm5lbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90dW5uZWwtYWdlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9jYXRlZ29yeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9jYXRlZ29yeS9maW5kLmpzIiwid2VicGFjazovLy8uLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL2V2ZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL2V2ZW50L2FsbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9ldmVudC9maW5kLmpzIiwid2VicGFjazovLy8uLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL3ZlbnVlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL3ZlbnVlL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvYXR0cmFjdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92Mi9hdHRyYWN0aW9uL2FsbC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92Mi9hdHRyYWN0aW9uL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvZXZlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvZXZlbnQvYWxsLmpzIiwid2VicGFjazovLy8uLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YyL2V2ZW50L2ZpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvdmVudWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvdmVudWUvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2NvbW1lcmNlL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9+L3RpY2tldG1hc3Rlci9saWIvY29tbWVyY2UvdjIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL34vdGlja2V0bWFzdGVyL2xpYi9jb21tZXJjZS92Mi9vZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vfi90aWNrZXRtYXN0ZXIvbGliL2NvbW1lcmNlL3YyL29mZmVyL2ZpbmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBmNDMzYzJmOGM0YzdjZTFmYTgwMlxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgndGlja2V0bWFzdGVyJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRpc2NvdmVyeSA9IHJlcXVpcmUoJy4vbGliL2Rpc2NvdmVyeScpO1xudmFyIGNvbW1lcmNlID0gcmVxdWlyZSgnLi9saWIvY29tbWVyY2UnKTtcblxudmFyIEFQSSA9IGZ1bmN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pIHtcbiAgcmV0dXJuIHtcbiAgICBhcGlLZXk6IGFwaUtleSxcbiAgICBhY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW4sXG4gICAgZGlzY292ZXJ5OiBkaXNjb3ZlcnkoYXBpS2V5LCBhY2Nlc3NUb2tlbiksXG4gICAgY29tbWVyY2U6IGNvbW1lcmNlKGFwaUtleSwgYWNjZXNzVG9rZW4pXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gQVBJKGFwaUtleSwgYWNjZXNzVG9rZW4pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZGlzY292ZXJ5ID0gZGlzY292ZXJ5O1xubW9kdWxlLmV4cG9ydHMuY29tbWVyY2UgPSBjb21tZXJjZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHYxID0gcmVxdWlyZSgnLi92MScpLFxuICAgIHYyID0gcmVxdWlyZSgnLi92MicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pIHtcbiAgcmV0dXJuIHtcbiAgICB2MTogdjEoYXBpS2V5LCBhY2Nlc3NUb2tlbiksXG4gICAgdjI6IHYyKGFwaUtleSwgYWNjZXNzVG9rZW4pXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cy52MSA9IHYxO1xubW9kdWxlLmV4cG9ydHMudjIgPSB2MjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhdHRyYWN0aW9uID0gcmVxdWlyZSgnLi9hdHRyYWN0aW9uJyksXG4gICAgY2F0ZWdvcnkgICA9IHJlcXVpcmUoJy4vY2F0ZWdvcnknKSxcbiAgICBldmVudCAgICAgID0gcmVxdWlyZSgnLi9ldmVudCcpLFxuICAgIHZlbnVlICAgICAgPSByZXF1aXJlKCcuL3ZlbnVlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4ge1xuICAgIGF0dHJhY3Rpb246IGF0dHJhY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbiksXG4gICAgY2F0ZWdvcnk6IGNhdGVnb3J5KGFwaUtleSwgYWNjZXNzVG9rZW4pLFxuICAgIGV2ZW50OiBldmVudChhcGlLZXksIGFjY2Vzc1Rva2VuKSxcbiAgICB2ZW51ZTogdmVudWUoYXBpS2V5LCBhY2Nlc3NUb2tlbilcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmF0dHJhY3Rpb24gPSBhdHRyYWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbm1vZHVsZS5leHBvcnRzLmV2ZW50ID0gZXZlbnQ7XG5tb2R1bGUuZXhwb3J0cy52ZW51ZSA9IHZlbnVlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGZpbmQgPSByZXF1aXJlKCcuL2ZpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiB7XG4gICAgZmluZDogZmluZChhcGlLZXksIGFjY2Vzc1Rva2VuKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kID0gZmluZDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9hdHRyYWN0aW9uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFByb21pc2UgICAgICA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgcmVxdWVzdEFzeW5jID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9yZXF1ZXN0X2hlbHBlcicpO1xudmFyIGNvbmZpZyAgICAgICA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJhY3Rpb25JZCkge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoe1xuICAgICAgdXJsOiBjb25maWcuYmFzZVVSTCArICcvZGlzY292ZXJ5L3YxL2F0dHJhY3Rpb25zLycgKyBhdHRyYWN0aW9uSWQgKyAnP2FwaWtleT0nICsgYXBpS2V5LFxuICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgIH0pXG4gICAgLnNwcmVhZChmdW5jdGlvbiAocmVzcG9uc2UsIGJvZHkpIHtcbiAgICAgIGlmKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGFyc2VkQm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjEvYXR0cmFjdGlvbi9maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogQHByZXNlcnZlXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE0IFBldGthIEFudG9ub3ZcbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOjwvcD5cbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKiBcbiAqL1xuLyoqXG4gKiBibHVlYmlyZCBidWlsZCB2ZXJzaW9uIDIuOS4zMFxuICogRmVhdHVyZXMgZW5hYmxlZDogY29yZSwgcmFjZSwgY2FsbF9nZXQsIGdlbmVyYXRvcnMsIG1hcCwgbm9kZWlmeSwgcHJvbWlzaWZ5LCBwcm9wcywgcmVkdWNlLCBzZXR0bGUsIHNvbWUsIGNhbmNlbCwgdXNpbmcsIGZpbHRlciwgYW55LCBlYWNoLCB0aW1lcnNcbiovXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5Qcm9taXNlPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiBfZGVyZXFfPT1cImZ1bmN0aW9uXCImJl9kZXJlcV87aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIF9kZXJlcV89PVwiZnVuY3Rpb25cIiYmX2RlcmVxXztmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciBTb21lUHJvbWlzZUFycmF5ID0gUHJvbWlzZS5fU29tZVByb21pc2VBcnJheTtcbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KDEpO1xuICAgIHJldC5zZXRVbndyYXAoKTtcbiAgICByZXQuaW5pdCgpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLmFueSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBhbnkocHJvbWlzZXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbnkodGhpcyk7XG59O1xuXG59O1xuXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGZpcnN0TGluZUVycm9yO1xudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge2ZpcnN0TGluZUVycm9yID0gZTt9XG52YXIgc2NoZWR1bGUgPSBfZGVyZXFfKFwiLi9zY2hlZHVsZS5qc1wiKTtcbnZhciBRdWV1ZSA9IF9kZXJlcV8oXCIuL3F1ZXVlLmpzXCIpO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xuXG5mdW5jdGlvbiBBc3luYygpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZSA9IG5ldyBRdWV1ZSgxNik7XG4gICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9kcmFpblF1ZXVlcygpO1xuICAgIH07XG4gICAgdGhpcy5fc2NoZWR1bGUgPVxuICAgICAgICBzY2hlZHVsZS5pc1N0YXRpYyA/IHNjaGVkdWxlKHRoaXMuZHJhaW5RdWV1ZXMpIDogc2NoZWR1bGU7XG59XG5cbkFzeW5jLnByb3RvdHlwZS5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZW5hYmxlVHJhbXBvbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ub3JtYWxRdWV1ZS5sZW5ndGgoKSA+IDA7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUudGhyb3dMYXRlciA9IGZ1bmN0aW9uKGZuLCBhcmcpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBhcmcgPSBmbjtcbiAgICAgICAgZm4gPSBmdW5jdGlvbiAoKSB7IHRocm93IGFyZzsgfTtcbiAgICB9XG4gICAgdmFyIGRvbWFpbiA9IHRoaXMuX2dldERvbWFpbigpO1xuICAgIGlmIChkb21haW4gIT09IHVuZGVmaW5lZCkgZm4gPSBkb21haW4uYmluZChmbik7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbihhcmcpO1xuICAgICAgICB9LCAwKTtcbiAgICB9IGVsc2UgdHJ5IHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmbihhcmcpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9tM09UWGtcXHUwMDBhXCIpO1xuICAgIH1cbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKCF0cnVlKSB7XG5pZiAodXRpbC5pc05vZGUpIHtcbiAgICB2YXIgRXZlbnRzTW9kdWxlID0gX2RlcmVxXyhcImV2ZW50c1wiKTtcblxuICAgIHZhciBkb21haW5HZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvbWFpbiA9IHByb2Nlc3MuZG9tYWluO1xuICAgICAgICBpZiAoZG9tYWluID09PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgIH07XG5cbiAgICBpZiAoRXZlbnRzTW9kdWxlLnVzaW5nRG9tYWlucykge1xuICAgICAgICBBc3luYy5wcm90b3R5cGUuX2dldERvbWFpbiA9IGRvbWFpbkdldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV2ZW50c01vZHVsZSwgXCJ1c2luZ0RvbWFpbnNcIik7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGlmICghZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm9uKFwiZG9tYWluc0FjdGl2YXRlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgQXN5bmMucHJvdG90eXBlLl9nZXREb21haW4gPSBkb21haW5HZXR0ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB1c2luZ0RvbWFpbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRzTW9kdWxlLCBcInVzaW5nRG9tYWluc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNpbmdEb21haW5zO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNpbmdEb21haW5zIHx8ICF2YWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNpbmdEb21haW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzeW5jLnByb3RvdHlwZS5fZ2V0RG9tYWluID0gZG9tYWluR2V0dGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwiZG9tYWluc0FjdGl2YXRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZUxhdGVyKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdmFyIGRvbWFpbiA9IHRoaXMuX2dldERvbWFpbigpO1xuICAgIGlmIChkb21haW4gIT09IHVuZGVmaW5lZCkgZm4gPSBkb21haW4uYmluZChmbik7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZShmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBkb21haW4gPSB0aGlzLl9nZXREb21haW4oKTtcbiAgICBpZiAoZG9tYWluICE9PSB1bmRlZmluZWQpIGZuID0gZG9tYWluLmJpbmQoZm4pO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY1NldHRsZVByb21pc2VzKHByb21pc2UpIHtcbiAgICB2YXIgZG9tYWluID0gdGhpcy5fZ2V0RG9tYWluKCk7XG4gICAgaWYgKGRvbWFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmbiA9IGRvbWFpbi5iaW5kKHByb21pc2UuX3NldHRsZVByb21pc2VzKTtcbiAgICAgICAgdGhpcy5fbm9ybWFsUXVldWUucHVzaChmbiwgcHJvbWlzZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB9XG4gICAgdGhpcy5fcXVldWVUaWNrKCk7XG59XG5cbmlmICghdXRpbC5oYXNEZXZUb29scykge1xuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2VMYXRlciA9IEFzeW5jSW52b2tlTGF0ZXI7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IEFzeW5jSW52b2tlO1xuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IEFzeW5jU2V0dGxlUHJvbWlzZXM7XG59IGVsc2Uge1xuICAgIGlmIChzY2hlZHVsZS5pc1N0YXRpYykge1xuICAgICAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uKGZuKSB7IHNldFRpbWVvdXQoZm4sIDApOyB9O1xuICAgIH1cbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlTGF0ZXIgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZUxhdGVyLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgICAgICBpZiAodGhpcy5fdHJhbXBvbGluZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIEFzeW5jSW52b2tlLmNhbGwodGhpcywgZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5zZXR0bGVQcm9taXNlcyA9IGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY1NldHRsZVByb21pc2VzLmNhbGwodGhpcywgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5Bc3luYy5wcm90b3R5cGUuaW52b2tlRmlyc3QgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICB2YXIgZG9tYWluID0gdGhpcy5fZ2V0RG9tYWluKCk7XG4gICAgaWYgKGRvbWFpbiAhPT0gdW5kZWZpbmVkKSBmbiA9IGRvbWFpbi5iaW5kKGZuKTtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS51bnNoaWZ0KGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCgpID4gMCkge1xuICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuLl9zZXR0bGVQcm9taXNlcygpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGFyZyA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpblF1ZXVlKHRoaXMuX25vcm1hbFF1ZXVlKTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBBc3luYygpO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcblxufSx7XCIuL3F1ZXVlLmpzXCI6MjgsXCIuL3NjaGVkdWxlLmpzXCI6MzEsXCIuL3V0aWwuanNcIjozOCxcImV2ZW50c1wiOjM5fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UpIHtcbnZhciByZWplY3RUaGlzID0gZnVuY3Rpb24oXywgZSkge1xuICAgIHRoaXMuX3JlamVjdChlKTtcbn07XG5cbnZhciB0YXJnZXRSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnByb21pc2VSZWplY3Rpb25RdWV1ZWQgPSB0cnVlO1xuICAgIGNvbnRleHQuYmluZGluZ1Byb21pc2UuX3RoZW4ocmVqZWN0VGhpcywgcmVqZWN0VGhpcywgbnVsbCwgdGhpcywgZSk7XG59O1xuXG52YXIgYmluZGluZ1Jlc29sdmVkID0gZnVuY3Rpb24odGhpc0FyZywgY29udGV4dCkge1xuICAgIHRoaXMuX3NldEJvdW5kVG8odGhpc0FyZyk7XG4gICAgaWYgKHRoaXMuX2lzUGVuZGluZygpKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVDYWxsYmFjayhjb250ZXh0LnRhcmdldCk7XG4gICAgfVxufTtcblxudmFyIGJpbmRpbmdSZWplY3RlZCA9IGZ1bmN0aW9uKGUsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbnRleHQucHJvbWlzZVJlamVjdGlvblF1ZXVlZCkgdGhpcy5fcmVqZWN0KGUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpc0FyZyk7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXQuX3Byb3BhZ2F0ZUZyb20odGhpcywgMSk7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgcHJvbWlzZVJlamVjdGlvblF1ZXVlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm9taXNlOiByZXQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGJpbmRpbmdQcm9taXNlOiBtYXliZVByb21pc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0Ll90aGVuKElOVEVSTkFMLCB0YXJnZXRSZWplY3RlZCwgcmV0Ll9wcm9ncmVzcywgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgYmluZGluZ1Jlc29sdmVkLCBiaW5kaW5nUmVqZWN0ZWQsIHJldC5fcHJvZ3Jlc3MsIHJldCwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Ll9zZXRCb3VuZFRvKHRoaXNBcmcpO1xuICAgICAgICByZXQuX3Jlc29sdmVDYWxsYmFjayh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEJvdW5kVG8gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzEwNzI7XG4gICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MTMxMDcyKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTMxMDcyKSA9PT0gMTMxMDcyO1xufTtcblxuUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhpc0FyZyk7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcblxuICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihmdW5jdGlvbih0aGlzQXJnKSB7XG4gICAgICAgICAgICByZXQuX3NldEJvdW5kVG8odGhpc0FyZyk7XG4gICAgICAgICAgICByZXQuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIH0sIHJldC5fcmVqZWN0LCByZXQuX3Byb2dyZXNzLCByZXQsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fc2V0Qm91bmRUbyh0aGlzQXJnKTtcbiAgICAgICAgcmV0Ll9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcbn07XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2xkO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB0cnkgeyBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7IH1cbiAgICBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gYmx1ZWJpcmQ7XG59XG52YXIgYmx1ZWJpcmQgPSBfZGVyZXFfKFwiLi9wcm9taXNlLmpzXCIpKCk7XG5ibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbm1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG5cbn0se1wiLi9wcm9taXNlLmpzXCI6MjN9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGNyID0gT2JqZWN0LmNyZWF0ZTtcbmlmIChjcikge1xuICAgIHZhciBjYWxsZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgIHZhciBnZXR0ZXJDYWNoZSA9IGNyKG51bGwpO1xuICAgIGNhbGxlckNhY2hlW1wiIHNpemVcIl0gPSBnZXR0ZXJDYWNoZVtcIiBzaXplXCJdID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIGlzSWRlbnRpZmllciA9IHV0aWwuaXNJZGVudGlmaWVyO1xuXG52YXIgZ2V0TWV0aG9kQ2FsbGVyO1xudmFyIGdldEdldHRlcjtcbmlmICghdHJ1ZSkge1xudmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xufTtcblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59O1xuXG52YXIgZ2V0Q29tcGlsZWQgPSBmdW5jdGlvbihuYW1lLCBjb21waWxlciwgY2FjaGUpIHtcbiAgICB2YXIgcmV0ID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY29tcGlsZXIobmFtZSk7XG4gICAgICAgIGNhY2hlW25hbWVdID0gcmV0O1xuICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgIGlmIChjYWNoZVtcIiBzaXplXCJdID4gNTEyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZ2V0TWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlTWV0aG9kQ2FsbGVyLCBjYWxsZXJDYWNoZSk7XG59O1xuXG5nZXRHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VHZXR0ZXIsIGdldHRlckNhY2hlKTtcbn07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm47XG4gICAgaWYgKG9iaiAhPSBudWxsKSBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk9iamVjdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcob2JqKSArIFwiIGhhcyBubyBtZXRob2QgJ1wiICtcbiAgICAgICAgICAgIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNhbGxlcihvYmopIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgdmFyIGZuID0gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgdGhpcyk7XG59XG5Qcm9taXNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KCRfbGVuIC0gMSk7IGZvcih2YXIgJF9pID0gMTsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2kgLSAxXSA9IGFyZ3VtZW50c1skX2ldO31cbiAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVDYWxsZXIgPSBnZXRNZXRob2RDYWxsZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVDYWxsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihjYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xufTtcblxuZnVuY3Rpb24gbmFtZWRHZXR0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialt0aGlzXTtcbn1cbmZ1bmN0aW9uIGluZGV4ZWRHZXR0ZXIob2JqKSB7XG4gICAgdmFyIGluZGV4ID0gK3RoaXM7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBNYXRoLm1heCgwLCBpbmRleCArIG9iai5sZW5ndGgpO1xuICAgIHJldHVybiBvYmpbaW5kZXhdO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBpc0luZGV4ID0gKHR5cGVvZiBwcm9wZXJ0eU5hbWUgPT09IFwibnVtYmVyXCIpO1xuICAgIHZhciBnZXR0ZXI7XG4gICAgaWYgKCFpc0luZGV4KSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlR2V0dGVyID0gZ2V0R2V0dGVyKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBnZXR0ZXIgPSBtYXliZUdldHRlciAhPT0gbnVsbCA/IG1heWJlR2V0dGVyIDogbmFtZWRHZXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBuYW1lZEdldHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGluZGV4ZWRHZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGdldHRlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5TmFtZSwgdW5kZWZpbmVkKTtcbn07XG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIGVycm9ycyA9IF9kZXJlcV8oXCIuL2Vycm9ycy5qc1wiKTtcbnZhciBhc3luYyA9IF9kZXJlcV8oXCIuL2FzeW5jLmpzXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gZXJyb3JzLkNhbmNlbGxhdGlvbkVycm9yO1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5pc0NhbmNlbGxhYmxlKCkpIHJldHVybiB0aGlzO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgdmFyIHByb21pc2VUb1JlamVjdCA9IHRoaXM7XG4gICAgd2hpbGUgKChwYXJlbnQgPSBwcm9taXNlVG9SZWplY3QuX2NhbmNlbGxhdGlvblBhcmVudCkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBwYXJlbnQuaXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHByb21pc2VUb1JlamVjdCA9IHBhcmVudDtcbiAgICB9XG4gICAgdGhpcy5fdW5zZXRDYW5jZWxsYWJsZSgpO1xuICAgIHByb21pc2VUb1JlamVjdC5fdGFyZ2V0KCkuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgZmFsc2UsIHRydWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5pc0NhbmNlbGxhYmxlKCkpIHJldHVybiB0aGlzO1xuICAgIGlmIChyZWFzb24gPT09IHVuZGVmaW5lZCkgcmVhc29uID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgYXN5bmMuaW52b2tlTGF0ZXIodGhpcy5fY2FuY2VsLCB0aGlzLCByZWFzb24pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2NhbmNlbGxhYmxlKCkpIHJldHVybiB0aGlzO1xuICAgIGFzeW5jLmVuYWJsZVRyYW1wb2xpbmUoKTtcbiAgICB0aGlzLl9zZXRDYW5jZWxsYWJsZSgpO1xuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblByb21pc2UucHJvdG90eXBlLnVuY2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMudGhlbigpO1xuICAgIHJldC5fdW5zZXRDYW5jZWxsYWJsZSgpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy5fdGhlbihkaWRGdWxmaWxsLCBkaWRSZWplY3QsIGRpZFByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcblxuICAgIHJldC5fc2V0Q2FuY2VsbGFibGUoKTtcbiAgICByZXQuX2NhbmNlbGxhdGlvblBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmV0O1xufTtcbn07XG5cbn0se1wiLi9hc3luYy5qc1wiOjIsXCIuL2Vycm9ycy5qc1wiOjEzfV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgYXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luYy5qc1wiKTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciBibHVlYmlyZEZyYW1lUGF0dGVybiA9XG4gICAgL1tcXFxcXFwvXWJsdWViaXJkW1xcXFxcXC9danNbXFxcXFxcL10obWFpbnxkZWJ1Z3x6YWxnb3xpbnN0cnVtZW50ZWQpLztcbnZhciBzdGFja0ZyYW1lUGF0dGVybiA9IG51bGw7XG52YXIgZm9ybWF0U3RhY2sgPSBudWxsO1xudmFyIGluZGVudFN0YWNrRnJhbWVzID0gZmFsc2U7XG52YXIgd2FybjtcblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IDEgKyAocGFyZW50ID09PSB1bmRlZmluZWQgPyAwIDogcGFyZW50Ll9sZW5ndGgpO1xuICAgIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENhcHR1cmVkVHJhY2UpO1xuICAgIGlmIChsZW5ndGggPiAzMikgdGhpcy51bmN5Y2xlKCk7XG59XG51dGlsLmluaGVyaXRzKENhcHR1cmVkVHJhY2UsIEVycm9yKTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUudW5jeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbm9kZSA9IHRoaXM7IG5vZGUgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IGk7XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2tUb0luZGV4W3N0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2tUb0luZGV4W2N1cnJlbnRTdGFja107XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc1tpXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB2YXIgY3ljbGVFZGdlTm9kZSA9IGkgPiAwID8gbm9kZXNbaSAtIDFdIDogdGhpcztcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50LnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDI7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQ7XG59O1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS5oYXNQYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50ICE9PSB1bmRlZmluZWQ7XG59O1xuXG5DYXB0dXJlZFRyYWNlLnByb3RvdHlwZS5hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuX19zdGFja0NsZWFuZWRfXykgcmV0dXJuO1xuICAgIHRoaXMudW5jeWNsZSgpO1xuICAgIHZhciBwYXJzZWQgPSBDYXB0dXJlZFRyYWNlLnBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgIHZhciBzdGFja3MgPSBbcGFyc2VkLnN0YWNrXTtcblxuICAgIHZhciB0cmFjZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goY2xlYW5TdGFjayh0cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKSkpO1xuICAgICAgICB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcyk7XG4gICAgcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcyk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlY29uc3RydWN0U3RhY2sobWVzc2FnZSwgc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHN0YWNrc1tpXS5wdXNoKFwiRnJvbSBwcmV2aW91cyBldmVudDpcIik7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IHN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2tzW2ldID0gc3RhY2tzW2ldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrcy5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVPckVtcHR5SnVtcHMoc3RhY2tzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHN0YWNrc1tpXS5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgICgoaSArIDEgPCBzdGFja3MubGVuZ3RoKSAmJiBzdGFja3NbaV1bMF0gPT09IHN0YWNrc1tpKzFdWzBdKSkge1xuICAgICAgICAgICAgc3RhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ29tbW9uUm9vdHMoc3RhY2tzKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFja3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzdGFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHByZXYgPSBzdGFja3NbaV07XG4gICAgICAgIHZhciBjdXJyZW50TGFzdEluZGV4ID0gY3VycmVudC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgY3VycmVudExhc3RMaW5lID0gY3VycmVudFtjdXJyZW50TGFzdEluZGV4XTtcbiAgICAgICAgdmFyIGNvbW1vblJvb3RNZWV0UG9pbnQgPSAtMTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcHJldi5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgaWYgKHByZXZbal0gPT09IGN1cnJlbnRMYXN0TGluZSkge1xuICAgICAgICAgICAgICAgIGNvbW1vblJvb3RNZWV0UG9pbnQgPSBqO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbW1vblJvb3RNZWV0UG9pbnQ7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHByZXZbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFtjdXJyZW50TGFzdEluZGV4XSA9PT0gbGluZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExhc3RJbmRleC0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gcHJldjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuU3RhY2soc3RhY2spIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHN0YWNrW2ldO1xuICAgICAgICB2YXIgaXNUcmFjZUxpbmUgPSBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpIHx8XG4gICAgICAgICAgICBcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmU7XG4gICAgICAgIHZhciBpc0ludGVybmFsRnJhbWUgPSBpc1RyYWNlTGluZSAmJiBzaG91bGRJZ25vcmUobGluZSk7XG4gICAgICAgIGlmIChpc1RyYWNlTGluZSAmJiAhaXNJbnRlcm5hbEZyYW1lKSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50U3RhY2tGcmFtZXMgJiYgbGluZS5jaGFyQXQoMCkgIT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IFwiICAgIFwiICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHN0YWNrRnJhbWVzQXNBcnJheShlcnJvcikge1xuICAgIHZhciBzdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xccyskL2csIFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKFwiICAgIChObyBzdGFjayB0cmFjZSlcIiA9PT0gbGluZSB8fCBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuXG5DYXB0dXJlZFRyYWNlLnBhcnNlU3RhY2tBbmRNZXNzYWdlID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgc3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSA6IFtcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBjbGVhblN0YWNrKHN0YWNrKVxuICAgIH07XG59O1xuXG5DYXB0dXJlZFRyYWNlLmZvcm1hdEFuZExvZ0Vycm9yID0gZnVuY3Rpb24oZXJyb3IsIHRpdGxlKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIGZvcm1hdFN0YWNrKHN0YWNrLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBTdHJpbmcoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2FybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB3YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ2FwdHVyZWRUcmFjZS51bmhhbmRsZWRSZWplY3Rpb24gPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgQ2FwdHVyZWRUcmFjZS5mb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiXi0tLSBXaXRoIGFkZGl0aW9uYWwgc3RhY2sgdHJhY2U6IFwiKTtcbn07XG5cbkNhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuQ2FwdHVyZWRUcmFjZS5maXJlUmVqZWN0aW9uRXZlbnQgPVxuZnVuY3Rpb24obmFtZSwgbG9jYWxIYW5kbGVyLCByZWFzb24sIHByb21pc2UpIHtcbiAgICB2YXIgbG9jYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9jYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInJlamVjdGlvbkhhbmRsZWRcIikge1xuICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgfVxuXG4gICAgdmFyIGdsb2JhbEV2ZW50RmlyZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gZmlyZUdsb2JhbEV2ZW50KG5hbWUsIHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBnbG9iYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIGlmIChmaXJlRG9tRXZlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvbUV2ZW50RmlyZWQgPSBmaXJlRG9tRXZlbnQobmFtZS50b0xvd2VyQ2FzZSgpLCB7XG4gICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRvbUV2ZW50RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZ2xvYmFsRXZlbnRGaXJlZCAmJiAhbG9jYWxFdmVudEZpcmVkICYmICFkb21FdmVudEZpcmVkICYmXG4gICAgICAgIG5hbWUgPT09IFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpIHtcbiAgICAgICAgQ2FwdHVyZWRUcmFjZS5mb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiVW5oYW5kbGVkIHJlamVjdGlvbiBcIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0Tm9uRXJyb3Iob2JqKSB7XG4gICAgdmFyIHN0cjtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHN0ciA9IFwiW2Z1bmN0aW9uIFwiICtcbiAgICAgICAgICAgIChvYmoubmFtZSB8fCBcImFub255bW91c1wiKSArXG4gICAgICAgICAgICBcIl1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBvYmoudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHJ1c2VsZXNzVG9TdHJpbmcgPSAvXFxbb2JqZWN0IFthLXpBLVowLTkkX10rXFxdLztcbiAgICAgICAgaWYgKHJ1c2VsZXNzVG9TdHJpbmcudGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgICAgICAgICAgICAgIHN0ciA9IG5ld1N0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdHIgPSBcIihlbXB0eSBhcnJheSlcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFwiKDxcIiArIHNuaXAoc3RyKSArIFwiPiwgbm8gc3RhY2sgdHJhY2UpXCIpO1xufVxuXG5mdW5jdGlvbiBzbmlwKHN0cikge1xuICAgIHZhciBtYXhDaGFycyA9IDQxO1xuICAgIGlmIChzdHIubGVuZ3RoIDwgbWF4Q2hhcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbWF4Q2hhcnMgLSAzKSArIFwiLi4uXCI7XG59XG5cbnZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIHBhcnNlTGluZUluZm9SZWdleCA9IC9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87XG5mdW5jdGlvbiBwYXJzZUxpbmVJbmZvKGxpbmUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBsaW5lOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9XG59XG5DYXB0dXJlZFRyYWNlLnNldEJvdW5kcyA9IGZ1bmN0aW9uKGZpcnN0TGluZUVycm9yLCBsYXN0TGluZUVycm9yKSB7XG4gICAgaWYgKCFDYXB0dXJlZFRyYWNlLmlzU3VwcG9ydGVkKCkpIHJldHVybjtcbiAgICB2YXIgZmlyc3RTdGFja0xpbmVzID0gZmlyc3RMaW5lRXJyb3Iuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgdmFyIGxhc3RTdGFja0xpbmVzID0gbGFzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZmlyc3RJbmRleCA9IC0xO1xuICAgIHZhciBsYXN0SW5kZXggPSAtMTtcbiAgICB2YXIgZmlyc3RGaWxlTmFtZTtcbiAgICB2YXIgbGFzdEZpbGVOYW1lO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3RTdGFja0xpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUxpbmVJbmZvKGZpcnN0U3RhY2tMaW5lc1tpXSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGZpcnN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gcmVzdWx0LmxpbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RTdGFja0xpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUxpbmVJbmZvKGxhc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbGFzdEZpbGVOYW1lID0gcmVzdWx0LmZpbGVOYW1lO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gcmVzdWx0LmxpbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3RJbmRleCA8IDAgfHwgbGFzdEluZGV4IDwgMCB8fCAhZmlyc3RGaWxlTmFtZSB8fCAhbGFzdEZpbGVOYW1lIHx8XG4gICAgICAgIGZpcnN0RmlsZU5hbWUgIT09IGxhc3RGaWxlTmFtZSB8fCBmaXJzdEluZGV4ID49IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2hvdWxkSWdub3JlID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgICBpZiAoYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBpbmZvID0gcGFyc2VMaW5lSW5mbyhsaW5lKTtcbiAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmZpbGVOYW1lID09PSBmaXJzdEZpbGVOYW1lICYmXG4gICAgICAgICAgICAgICAgKGZpcnN0SW5kZXggPD0gaW5mby5saW5lICYmIGluZm8ubGluZSA8PSBsYXN0SW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59O1xuXG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSAoZnVuY3Rpb24gc3RhY2tEZXRlY3Rpb24oKSB7XG4gICAgdmFyIHY4c3RhY2tGcmFtZVBhdHRlcm4gPSAvXlxccyphdFxccyovO1xuICAgIHZhciB2OHN0YWNrRm9ybWF0dGVyID0gZnVuY3Rpb24oc3RhY2ssIGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIpIHJldHVybiBzdGFjaztcblxuICAgICAgICBpZiAoZXJyb3IubmFtZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXROb25FcnJvcihlcnJvcik7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdCArIDY7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICsgNjtcbiAgICAgICAgICAgIGNhcHR1cmVTdGFja1RyYWNlKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCk7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQgLSA2O1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG5cbiAgICBpZiAodHlwZW9mIGVyci5zdGFjayA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBlcnIuc3RhY2suc3BsaXQoXCJcXG5cIilbMF0uaW5kZXhPZihcInN0YWNrRGV0ZWN0aW9uQFwiKSA+PSAwKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gL0AvO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIGluZGVudFN0YWNrRnJhbWVzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlKG8pIHtcbiAgICAgICAgICAgIG8uc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaGFzU3RhY2tBZnRlclRocm93O1xuICAgIHRyeSB7IHRocm93IG5ldyBFcnJvcigpOyB9XG4gICAgY2F0Y2goZSkge1xuICAgICAgICBoYXNTdGFja0FmdGVyVGhyb3cgPSAoXCJzdGFja1wiIGluIGUpO1xuICAgIH1cbiAgICBpZiAoIShcInN0YWNrXCIgaW4gZXJyKSAmJiBoYXNTdGFja0FmdGVyVGhyb3cpIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSB2OHN0YWNrRnJhbWVQYXR0ZXJuO1xuICAgICAgICBmb3JtYXRTdGFjayA9IHY4c3RhY2tGb3JtYXR0ZXI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjYXB0dXJlU3RhY2tUcmFjZShvKSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQgKyA2O1xuICAgICAgICAgICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICAgICAgICAgIGNhdGNoKGUpIHsgby5zdGFjayA9IGUuc3RhY2s7IH1cbiAgICAgICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdCAtIDY7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcblxufSkoW10pO1xuXG52YXIgZmlyZURvbUV2ZW50O1xudmFyIGZpcmVHbG9iYWxFdmVudCA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicmVqZWN0aW9uSGFuZGxlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdChuYW1lLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW1pdChuYW1lLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXN0b21FdmVudFdvcmtzID0gZmFsc2U7XG4gICAgICAgIHZhciBhbnlFdmVudFdvcmtzID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBldiA9IG5ldyBzZWxmLkN1c3RvbUV2ZW50KFwidGVzdFwiKTtcbiAgICAgICAgICAgIGN1c3RvbUV2ZW50V29ya3MgPSBldiBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50O1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICBpZiAoIWN1c3RvbUV2ZW50V29ya3MpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoXCJ0ZXN0aW5ndGhlZXZlbnRcIiwgZmFsc2UsIHRydWUsIHt9KTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGFueUV2ZW50V29ya3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55RXZlbnRXb3Jrcykge1xuICAgICAgICAgICAgZmlyZURvbUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgZGV0YWlsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21FdmVudFdvcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gbmV3IHNlbGYuQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgZmFsc2UsIHRydWUsIGRldGFpbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50ID8gIXNlbGYuZGlzcGF0Y2hFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9XaW5kb3dNZXRob2ROYW1lTWFwID0ge307XG4gICAgICAgIHRvV2luZG93TWV0aG9kTmFtZU1hcFtcInVuaGFuZGxlZFJlamVjdGlvblwiXSA9IChcIm9uXCIgK1xuICAgICAgICAgICAgXCJ1bmhhbmRsZWRSZWplY3Rpb25cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdG9XaW5kb3dNZXRob2ROYW1lTWFwW1wicmVqZWN0aW9uSGFuZGxlZFwiXSA9IChcIm9uXCIgK1xuICAgICAgICAgICAgXCJyZWplY3Rpb25IYW5kbGVkXCIpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSB0b1dpbmRvd01ldGhvZE5hbWVNYXBbbmFtZV07XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gc2VsZlttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJyZWplY3Rpb25IYW5kbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbChzZWxmLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoc2VsZiwgcmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbn0pKCk7XG5cbmlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS53YXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9O1xuICAgIGlmICh1dGlsLmlzTm9kZSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICB3YXJuID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoXCJcXHUwMDFiWzMxbVwiICsgbWVzc2FnZSArIFwiXFx1MDAxYlszOW1cXG5cIik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUgJiYgdHlwZW9mIChuZXcgRXJyb3IoKS5zdGFjaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgd2FybiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIiVjXCIgKyBtZXNzYWdlLCBcImNvbG9yOiByZWRcIik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5yZXR1cm4gQ2FwdHVyZWRUcmFjZTtcbn07XG5cbn0se1wiLi9hc3luYy5qc1wiOjIsXCIuL3V0aWwuanNcIjozOH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5FWFRfRklMVEVSKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzLmpzXCIpO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIga2V5cyA9IF9kZXJlcV8oXCIuL2VzNS5qc1wiKS5rZXlzO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5cbmZ1bmN0aW9uIENhdGNoRmlsdGVyKGluc3RhbmNlcywgY2FsbGJhY2ssIHByb21pc2UpIHtcbiAgICB0aGlzLl9pbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2FmZVByZWRpY2F0ZShwcmVkaWNhdGUsIGUpIHtcbiAgICB2YXIgc2FmZU9iamVjdCA9IHt9O1xuICAgIHZhciByZXRmaWx0ZXIgPSB0cnlDYXRjaChwcmVkaWNhdGUpLmNhbGwoc2FmZU9iamVjdCwgZSk7XG5cbiAgICBpZiAocmV0ZmlsdGVyID09PSBlcnJvck9iaikgcmV0dXJuIHJldGZpbHRlcjtcblxuICAgIHZhciBzYWZlS2V5cyA9IGtleXMoc2FmZU9iamVjdCk7XG4gICAgaWYgKHNhZmVLZXlzLmxlbmd0aCkge1xuICAgICAgICBlcnJvck9iai5lID0gbmV3IFR5cGVFcnJvcihcIkNhdGNoIGZpbHRlciBtdXN0IGluaGVyaXQgZnJvbSBFcnJvciBvciBiZSBhIHNpbXBsZSBwcmVkaWNhdGUgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9vODRvNjhcXHUwMDBhXCIpO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxuICAgIHJldHVybiByZXRmaWx0ZXI7XG59XG5cbkNhdGNoRmlsdGVyLnByb3RvdHlwZS5kb0ZpbHRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGNiID0gdGhpcy5fY2FsbGJhY2s7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgIHZhciBib3VuZFRvID0gcHJvbWlzZS5fYm91bmRUbztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5faW5zdGFuY2VzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5faW5zdGFuY2VzW2ldO1xuICAgICAgICB2YXIgaXRlbUlzRXJyb3JUeXBlID0gaXRlbSA9PT0gRXJyb3IgfHxcbiAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcik7XG5cbiAgICAgICAgaWYgKGl0ZW1Jc0Vycm9yVHlwZSAmJiBlIGluc3RhbmNlb2YgaXRlbSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBORVhUX0ZJTFRFUi5lID0gcmV0LmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiICYmICFpdGVtSXNFcnJvclR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRIYW5kbGUgPSBzYWZlUHJlZGljYXRlKGl0ZW0sIGUpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEhhbmRsZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBlID0gZXJyb3JPYmouZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIE5FWFRfRklMVEVSLmUgPSByZXQuZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE5FWFRfRklMVEVSLmUgPSBlO1xuICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbn07XG5cbnJldHVybiBDYXRjaEZpbHRlcjtcbn07XG5cbn0se1wiLi9lcnJvcnMuanNcIjoxMyxcIi4vZXM1LmpzXCI6MTQsXCIuL3V0aWwuanNcIjozOH1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIENhcHR1cmVkVHJhY2UsIGlzRGVidWdnaW5nKSB7XG52YXIgY29udGV4dFN0YWNrID0gW107XG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENhcHR1cmVkVHJhY2UocGVla0NvbnRleHQoKSk7XG59XG5Db250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0RlYnVnZ2luZygpKSByZXR1cm47XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dFN0YWNrLnB1c2godGhpcy5fdHJhY2UpO1xuICAgIH1cbn07XG5cbkNvbnRleHQucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNEZWJ1Z2dpbmcoKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLl90cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHRTdGFjay5wb3AoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KCkge1xuICAgIGlmIChpc0RlYnVnZ2luZygpKSByZXR1cm4gbmV3IENvbnRleHQoKTtcbn1cblxuZnVuY3Rpb24gcGVla0NvbnRleHQoKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IGNvbnRleHRTdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dFN0YWNrW2xhc3RJbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IHBlZWtDb250ZXh0O1xuUHJvbWlzZS5wcm90b3R5cGUuX3B1c2hDb250ZXh0ID0gQ29udGV4dC5wcm90b3R5cGUuX3B1c2hDb250ZXh0O1xuUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dDtcblxucmV0dXJuIGNyZWF0ZUNvbnRleHQ7XG59O1xuXG59LHt9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgQ2FwdHVyZWRUcmFjZSkge1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgV2FybmluZyA9IF9kZXJlcV8oXCIuL2Vycm9ycy5qc1wiKS5XYXJuaW5nO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGNhbkF0dGFjaFRyYWNlID0gdXRpbC5jYW5BdHRhY2hUcmFjZTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkO1xudmFyIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uO1xudmFyIGRlYnVnZ2luZyA9IGZhbHNlIHx8ICh1dGlsLmlzTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAoISFwcm9jZXNzLmVudltcIkJMVUVCSVJEX0RFQlVHXCJdIHx8XG4gICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudltcIk5PREVfRU5WXCJdID09PSBcImRldmVsb3BtZW50XCIpKTtcblxuaWYgKGRlYnVnZ2luZykge1xuICAgIGFzeW5jLmRpc2FibGVUcmFtcG9saW5lSWZOZWNlc3NhcnkoKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX2lnbm9yZVJlamVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDE2Nzc3MjE2O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vuc3VyZVBvc3NpYmxlUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICBhc3luYy5pbnZva2VMYXRlcih0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb24sIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIENhcHR1cmVkVHJhY2UuZmlyZVJlamVjdGlvbkV2ZW50KFwicmVqZWN0aW9uSGFuZGxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbkhhbmRsZWQsIHVuZGVmaW5lZCwgdGhpcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1JlamVjdGlvblVuaGFuZGxlZCgpKSB7XG4gICAgICAgIHZhciByZWFzb24gPSB0aGlzLl9nZXRDYXJyaWVkU3RhY2tUcmFjZSgpIHx8IHRoaXMuX3NldHRsZWRWYWx1ZTtcbiAgICAgICAgdGhpcy5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICBDYXB0dXJlZFRyYWNlLmZpcmVSZWplY3Rpb25FdmVudChcInVuaGFuZGxlZFJlamVjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiwgcmVhc29uLCB0aGlzKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNTI0Mjg4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH41MjQyODgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUyNDI4OCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJlamVjdGlvbklzVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyMDk3MTUyO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjA5NzE1Mik7XG4gICAgaWYgKHRoaXMuX2lzVW5oYW5kbGVkUmVqZWN0aW9uTm90aWZpZWQoKSkge1xuICAgICAgICB0aGlzLl91bnNldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVqZWN0aW9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyMDk3MTUyKSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Q2FycmllZFN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoY2FwdHVyZWRUcmFjZSkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMDQ4NTc2O1xuICAgIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAgPSBjYXB0dXJlZFRyYWNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FycnlpbmdTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMDQ4NTc2KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZ2V0Q2FycmllZFN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ2FycnlpbmdTdGFja1RyYWNlKClcbiAgICAgICAgPyB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwXG4gICAgICAgIDogdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZWJ1Z2dpbmcpIHtcbiAgICAgICAgdGhpcy5fdHJhY2UgPSBuZXcgQ2FwdHVyZWRUcmFjZSh0aGlzLl9wZWVrQ29udGV4dCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGZ1bmN0aW9uIChlcnJvciwgaWdub3JlU2VsZikge1xuICAgIGlmIChkZWJ1Z2dpbmcgJiYgY2FuQXR0YWNoVHJhY2UoZXJyb3IpKSB7XG4gICAgICAgIHZhciB0cmFjZSA9IHRoaXMuX3RyYWNlO1xuICAgICAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlnbm9yZVNlbGYpIHRyYWNlID0gdHJhY2UuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhY2UuYXR0YWNoRXh0cmFUcmFjZShlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVycm9yLl9fc3RhY2tDbGVhbmVkX18pIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBDYXB0dXJlZFRyYWNlLnBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fd2FybiA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB2YXIgd2FybmluZyA9IG5ldyBXYXJuaW5nKG1lc3NhZ2UpO1xuICAgIHZhciBjdHggPSB0aGlzLl9wZWVrQ29udGV4dCgpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmF0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IENhcHR1cmVkVHJhY2UucGFyc2VTdGFja0FuZE1lc3NhZ2Uod2FybmluZyk7XG4gICAgICAgIHdhcm5pbmcuc3RhY2sgPSBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgQ2FwdHVyZWRUcmFjZS5mb3JtYXRBbmRMb2dFcnJvcih3YXJuaW5nLCBcIlwiKTtcbn07XG5cblByb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uID0gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyBmbiA6IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2Uub25VbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gZm4gOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLmxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkgJiZcbiAgICAgICAgZGVidWdnaW5nID09PSBmYWxzZVxuICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9EVDFxeUdcXHUwMDBhXCIpO1xuICAgIH1cbiAgICBkZWJ1Z2dpbmcgPSBDYXB0dXJlZFRyYWNlLmlzU3VwcG9ydGVkKCk7XG4gICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICBhc3luYy5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5KCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5oYXNMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRlYnVnZ2luZyAmJiBDYXB0dXJlZFRyYWNlLmlzU3VwcG9ydGVkKCk7XG59O1xuXG5pZiAoIUNhcHR1cmVkVHJhY2UuaXNTdXBwb3J0ZWQoKSkge1xuICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKXt9O1xuICAgIGRlYnVnZ2luZyA9IGZhbHNlO1xufVxuXG5yZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlYnVnZ2luZztcbn07XG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi9lcnJvcnMuanNcIjoxMyxcIi4vdXRpbC5qc1wiOjM4fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgaXNQcmltaXRpdmUgPSB1dGlsLmlzUHJpbWl0aXZlO1xudmFyIHdyYXBzUHJpbWl0aXZlUmVjZWl2ZXIgPSB1dGlsLndyYXBzUHJpbWl0aXZlUmVjZWl2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIHJldHVybmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xufTtcbnZhciB0aHJvd2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IHRoaXM7XG59O1xudmFyIHJldHVyblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge307XG52YXIgdGhyb3dVbmRlZmluZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyB1bmRlZmluZWQ7XG59O1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uICh2YWx1ZSwgYWN0aW9uKSB7XG4gICAgaWYgKGFjdGlvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChhY3Rpb24gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cblByb21pc2UucHJvdG90eXBlW1wicmV0dXJuXCJdID1cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXR1cm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMudGhlbihyZXR1cm5VbmRlZmluZWQpO1xuXG4gICAgaWYgKHdyYXBzUHJpbWl0aXZlUmVjZWl2ZXIgJiYgaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgd3JhcHBlcih2YWx1ZSwgMiksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZXR1cm5lciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHZhbHVlLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGVbXCJ0aHJvd1wiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKHJlYXNvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy50aGVuKHRocm93VW5kZWZpbmVkKTtcblxuICAgIGlmICh3cmFwc1ByaW1pdGl2ZVJlY2VpdmVyICYmIGlzUHJpbWl0aXZlKHJlYXNvbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgICAgICB3cmFwcGVyKHJlYXNvbiwgMSksXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGhlbih0aHJvd2VyLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcmVhc29uLCB1bmRlZmluZWQpO1xufTtcbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlUmVkdWNlID0gUHJvbWlzZS5yZWR1Y2U7XG5cblByb21pc2UucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gUHJvbWlzZVJlZHVjZSh0aGlzLCBmbiwgbnVsbCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgbnVsbCwgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNS5qc1wiKTtcbnZhciBPYmplY3RmcmVlemUgPSBlczUuZnJlZXplO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGluaGVyaXRzID0gdXRpbC5pbmhlcml0cztcbnZhciBub3RFbnVtZXJhYmxlUHJvcCA9IHV0aWwubm90RW51bWVyYWJsZVByb3A7XG5cbmZ1bmN0aW9uIHN1YkVycm9yKG5hbWVQcm9wZXJ0eSwgZGVmYXVsdE1lc3NhZ2UpIHtcbiAgICBmdW5jdGlvbiBTdWJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdWJFcnJvcikpIHJldHVybiBuZXcgU3ViRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogZGVmYXVsdE1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm5hbWVcIiwgbmFtZVByb3BlcnR5KTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5oZXJpdHMoU3ViRXJyb3IsIEVycm9yKTtcbiAgICByZXR1cm4gU3ViRXJyb3I7XG59XG5cbnZhciBfVHlwZUVycm9yLCBfUmFuZ2VFcnJvcjtcbnZhciBXYXJuaW5nID0gc3ViRXJyb3IoXCJXYXJuaW5nXCIsIFwid2FybmluZ1wiKTtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IHN1YkVycm9yKFwiQ2FuY2VsbGF0aW9uRXJyb3JcIiwgXCJjYW5jZWxsYXRpb24gZXJyb3JcIik7XG52YXIgVGltZW91dEVycm9yID0gc3ViRXJyb3IoXCJUaW1lb3V0RXJyb3JcIiwgXCJ0aW1lb3V0IGVycm9yXCIpO1xudmFyIEFnZ3JlZ2F0ZUVycm9yID0gc3ViRXJyb3IoXCJBZ2dyZWdhdGVFcnJvclwiLCBcImFnZ3JlZ2F0ZSBlcnJvclwiKTtcbnRyeSB7XG4gICAgX1R5cGVFcnJvciA9IFR5cGVFcnJvcjtcbiAgICBfUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG59IGNhdGNoKGUpIHtcbiAgICBfVHlwZUVycm9yID0gc3ViRXJyb3IoXCJUeXBlRXJyb3JcIiwgXCJ0eXBlIGVycm9yXCIpO1xuICAgIF9SYW5nZUVycm9yID0gc3ViRXJyb3IoXCJSYW5nZUVycm9yXCIsIFwicmFuZ2UgZXJyb3JcIik7XG59XG5cbnZhciBtZXRob2RzID0gKFwiam9pbiBwb3AgcHVzaCBzaGlmdCB1bnNoaWZ0IHNsaWNlIGZpbHRlciBmb3JFYWNoIHNvbWUgXCIgK1xuICAgIFwiZXZlcnkgbWFwIGluZGV4T2YgbGFzdEluZGV4T2YgcmVkdWNlIHJlZHVjZVJpZ2h0IHNvcnQgcmV2ZXJzZVwiKS5zcGxpdChcIiBcIik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlW21ldGhvZHNbaV1dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW21ldGhvZHNbaV1dID0gQXJyYXkucHJvdG90eXBlW21ldGhvZHNbaV1dO1xuICAgIH1cbn1cblxuZXM1LmRlZmluZVByb3BlcnR5KEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgIHZhbHVlOiAwLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGVbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcbnZhciBsZXZlbCA9IDA7XG5BZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZW50ID0gQXJyYXkobGV2ZWwgKiA0ICsgMSkuam9pbihcIiBcIik7XG4gICAgdmFyIHJldCA9IFwiXFxuXCIgKyBpbmRlbnQgKyBcIkFnZ3JlZ2F0ZUVycm9yIG9mOlwiICsgXCJcXG5cIjtcbiAgICBsZXZlbCsrO1xuICAgIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3RyID0gdGhpc1tpXSA9PT0gdGhpcyA/IFwiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiIDogdGhpc1tpXSArIFwiXCI7XG4gICAgICAgIHZhciBsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgbGluZXNbal0gPSBpbmRlbnQgKyBsaW5lc1tqXTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICByZXQgKz0gc3RyICsgXCJcXG5cIjtcbiAgICB9XG4gICAgbGV2ZWwtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gT3BlcmF0aW9uYWxFcnJvcihtZXNzYWdlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE9wZXJhdGlvbmFsRXJyb3IpKVxuICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSk7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIFwiT3BlcmF0aW9uYWxFcnJvclwiKTtcbiAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgdGhpcy5jYXVzZSA9IG1lc3NhZ2U7XG4gICAgdGhpc1tcImlzT3BlcmF0aW9uYWxcIl0gPSB0cnVlO1xuXG4gICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIiwgbWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJzdGFja1wiLCBtZXNzYWdlLnN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cblxufVxuaW5oZXJpdHMoT3BlcmF0aW9uYWxFcnJvciwgRXJyb3IpO1xuXG52YXIgZXJyb3JUeXBlcyA9IEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXTtcbmlmICghZXJyb3JUeXBlcykge1xuICAgIGVycm9yVHlwZXMgPSBPYmplY3RmcmVlemUoe1xuICAgICAgICBDYW5jZWxsYXRpb25FcnJvcjogQ2FuY2VsbGF0aW9uRXJyb3IsXG4gICAgICAgIFRpbWVvdXRFcnJvcjogVGltZW91dEVycm9yLFxuICAgICAgICBPcGVyYXRpb25hbEVycm9yOiBPcGVyYXRpb25hbEVycm9yLFxuICAgICAgICBSZWplY3Rpb25FcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgQWdncmVnYXRlRXJyb3I6IEFnZ3JlZ2F0ZUVycm9yXG4gICAgfSk7XG4gICAgbm90RW51bWVyYWJsZVByb3AoRXJyb3IsIFwiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiLCBlcnJvclR5cGVzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuXG59LHtcIi4vZXM1LmpzXCI6MTQsXCIuL3V0aWwuanNcIjozOH1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0VTNSA9IChmdW5jdGlvbigpe1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHJldHVybiB0aGlzID09PSB1bmRlZmluZWQ7XG59KSgpO1xuXG5pZiAoaXNFUzUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgZnJlZXplOiBPYmplY3QuZnJlZXplLFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0LmRlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgICAgICBnZXRQcm90b3R5cGVPZjogT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICAgICAgICAgIHJldHVybiAhISghZGVzY3JpcHRvciB8fCBkZXNjcmlwdG9yLndyaXRhYmxlIHx8IGRlc2NyaXB0b3Iuc2V0KTtcbiAgICAgICAgfVxuICAgIH07XG59IGVsc2Uge1xuICAgIHZhciBoYXMgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbiAgICB2YXIgc3RyID0ge30udG9TdHJpbmc7XG4gICAgdmFyIHByb3RvID0ge30uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gICAgdmFyIE9iamVjdEtleXMgPSBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobywga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldERlc2NyaXB0b3IgPSBmdW5jdGlvbihvLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHt2YWx1ZTogb1trZXldfTtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG8sIGtleSwgZGVzYykge1xuICAgICAgICBvW2tleV0gPSBkZXNjLnZhbHVlO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEZyZWV6ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgdmFyIE9iamVjdEdldFByb3RvdHlwZU9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChvYmopLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBBcnJheUlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgaXNBcnJheTogQXJyYXlJc0FycmF5LFxuICAgICAgICBrZXlzOiBPYmplY3RLZXlzLFxuICAgICAgICBuYW1lczogT2JqZWN0S2V5cyxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICAgICAgICBnZXREZXNjcmlwdG9yOiBPYmplY3RHZXREZXNjcmlwdG9yLFxuICAgICAgICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdEdldFByb3RvdHlwZU9mLFxuICAgICAgICBpc0VTNTogaXNFUzUsXG4gICAgICAgIHByb3BlcnR5SXNXcml0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbn0se31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VNYXAgPSBQcm9taXNlLm1hcDtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIFByb21pc2VNYXAodGhpcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG5cblByb21pc2UuZmlsdGVyID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgSU5URVJOQUwpO1xufTtcbn07XG5cbn0se31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBORVhUX0ZJTFRFUiwgdHJ5Q29udmVydFRvUHJvbWlzZSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIHdyYXBzUHJpbWl0aXZlUmVjZWl2ZXIgPSB1dGlsLndyYXBzUHJpbWl0aXZlUmVjZWl2ZXI7XG52YXIgaXNQcmltaXRpdmUgPSB1dGlsLmlzUHJpbWl0aXZlO1xudmFyIHRocm93ZXIgPSB1dGlsLnRocm93ZXI7XG5cbmZ1bmN0aW9uIHJldHVyblRoaXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiB0aHJvd1RoaXMoKSB7XG4gICAgdGhyb3cgdGhpcztcbn1cbmZ1bmN0aW9uIHJldHVybiQocikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRocm93JChyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyByO1xuICAgIH07XG59XG5mdW5jdGlvbiBwcm9taXNlZEZpbmFsbHkocmV0LCByZWFzb25PclZhbHVlLCBpc0Z1bGZpbGxlZCkge1xuICAgIHZhciB0aGVuO1xuICAgIGlmICh3cmFwc1ByaW1pdGl2ZVJlY2VpdmVyICYmIGlzUHJpbWl0aXZlKHJlYXNvbk9yVmFsdWUpKSB7XG4gICAgICAgIHRoZW4gPSBpc0Z1bGZpbGxlZCA/IHJldHVybiQocmVhc29uT3JWYWx1ZSkgOiB0aHJvdyQocmVhc29uT3JWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhlbiA9IGlzRnVsZmlsbGVkID8gcmV0dXJuVGhpcyA6IHRocm93VGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHJldC5fdGhlbih0aGVuLCB0aHJvd2VyLCB1bmRlZmluZWQsIHJlYXNvbk9yVmFsdWUsIHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGZpbmFsbHlIYW5kbGVyKHJlYXNvbk9yVmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcblxuICAgIHZhciByZXQgPSBwcm9taXNlLl9pc0JvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRUbylcbiAgICAgICAgICAgICAgICAgICAgOiBoYW5kbGVyKCk7XG5cbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCBwcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZWRGaW5hbGx5KG1heWJlUHJvbWlzZSwgcmVhc29uT3JWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuaXNGdWxmaWxsZWQoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZS5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgTkVYVF9GSUxURVIuZSA9IHJlYXNvbk9yVmFsdWU7XG4gICAgICAgIHJldHVybiBORVhUX0ZJTFRFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVhc29uT3JWYWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRhcEhhbmRsZXIodmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcjtcblxuICAgIHZhciByZXQgPSBwcm9taXNlLl9pc0JvdW5kKClcbiAgICAgICAgICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRUbywgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaGFuZGxlcih2YWx1ZSk7XG5cbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCBwcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZWRGaW5hbGx5KG1heWJlUHJvbWlzZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuX3Bhc3NUaHJvdWdoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyLCBpc0ZpbmFsbHkpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMudGhlbigpO1xuXG4gICAgdmFyIHByb21pc2VBbmRIYW5kbGVyID0ge1xuICAgICAgICBwcm9taXNlOiB0aGlzLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgaXNGaW5hbGx5ID8gZmluYWxseUhhbmRsZXIgOiB0YXBIYW5kbGVyLFxuICAgICAgICAgICAgaXNGaW5hbGx5ID8gZmluYWxseUhhbmRsZXIgOiB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByb21pc2VBbmRIYW5kbGVyLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubGFzdGx5ID1cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoSGFuZGxlcihoYW5kbGVyLCB0cnVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRhcCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoSGFuZGxlcihoYW5kbGVyLCBmYWxzZSk7XG59O1xufTtcblxufSx7XCIuL3V0aWwuanNcIjozOH1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlKSB7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzLmpzXCIpO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKHZhbHVlLCB5aWVsZEhhbmRsZXJzLCB0cmFjZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeWllbGRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHlpZWxkSGFuZGxlcnNbaV0pKHZhbHVlKTtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCByZWNlaXZlciwgeWllbGRIYW5kbGVyLCBzdGFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX3N0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSBnZW5lcmF0b3JGdW5jdGlvbjtcbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl95aWVsZEhhbmRsZXJzID0gdHlwZW9mIHlpZWxkSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gW3lpZWxkSGFuZGxlcl0uY29uY2F0KHlpZWxkSGFuZGxlcnMpXG4gICAgICAgIDogeWllbGRIYW5kbGVycztcbn1cblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fcnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2dlbmVyYXRvciA9IHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uLmNhbGwodGhpcy5fcmVjZWl2ZXIpO1xuICAgIHRoaXMuX3JlY2VpdmVyID1cbiAgICAgICAgdGhpcy5fZ2VuZXJhdG9yRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbmV4dCh1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZVNwYXduLnByb3RvdHlwZS5fY29udGludWUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKCEobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgcHJvbWlzZUZyb21ZaWVsZEhhbmRsZXIobWF5YmVQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3coXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkEgdmFsdWUgJXMgd2FzIHlpZWxkZWQgdGhhdCBjb3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC80WTRwRGtcXHUwMDBhXFx1MDAwYVwiLnJlcGxhY2UoXCIlc1wiLCB2YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGcm9tIGNvcm91dGluZTpcXHUwMDBhXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhY2suc3BsaXQoXCJcXG5cIikuc2xpY2UoMSwgLTcpLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgIHRoaXMuX25leHQsXG4gICAgICAgICAgICB0aGlzLl90aHJvdyxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlU3Bhd24ucHJvdG90eXBlLl90aHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pXG4gICAgICAgIC5jYWxsKHRoaXMuX2dlbmVyYXRvciwgcmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lID0gZnVuY3Rpb24gKGdlbmVyYXRvckZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBnZW5lcmF0b3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJnZW5lcmF0b3JGdW5jdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC82VnFobTBcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB2YXIgeWllbGRIYW5kbGVyID0gT2JqZWN0KG9wdGlvbnMpLnlpZWxkSGFuZGxlcjtcbiAgICB2YXIgUHJvbWlzZVNwYXduJCA9IFByb21pc2VTcGF3bjtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3biQodW5kZWZpbmVkLCB1bmRlZmluZWQsIHlpZWxkSGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2spO1xuICAgICAgICBzcGF3bi5fZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICBzcGF3bi5fbmV4dCh1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gc3Bhd24ucHJvbWlzZSgpO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmNvcm91dGluZS5hZGRZaWVsZEhhbmRsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgeWllbGRIYW5kbGVycy5wdXNoKGZuKTtcbn07XG5cblByb21pc2Uuc3Bhd24gPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzZWcWhtMFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciBzcGF3biA9IG5ldyBQcm9taXNlU3Bhd24oZ2VuZXJhdG9yRnVuY3Rpb24sIHRoaXMpO1xuICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgc3Bhd24uX3J1bihQcm9taXNlLnNwYXduKTtcbiAgICByZXR1cm4gcmV0O1xufTtcbn07XG5cbn0se1wiLi9lcnJvcnMuanNcIjoxMyxcIi4vdXRpbC5qc1wiOjM4fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgcmVqZWN0O1xuXG5pZiAoIXRydWUpIHtcbmlmIChjYW5FdmFsdWF0ZSkge1xuICAgIHZhciB0aGVuQ2FsbGJhY2sgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ2YWx1ZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5wSW5kZXggPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5jaGVja0Z1bGZpbGxtZW50KHRoaXMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFwiLnJlcGxhY2UoL0luZGV4L2csIGkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbGxlciA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY291bnQ7ICsraSkgdmFsdWVzLnB1c2goXCJob2xkZXIucFwiICsgaSk7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJob2xkZXJcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBob2xkZXIuZm47ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWVzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBcIi5yZXBsYWNlKC92YWx1ZXMvZywgdmFsdWVzLmpvaW4oXCIsIFwiKSkpO1xuICAgIH07XG4gICAgdmFyIHRoZW5DYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgY2FsbGVycyA9IFt1bmRlZmluZWRdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDU7ICsraSkge1xuICAgICAgICB0aGVuQ2FsbGJhY2tzLnB1c2godGhlbkNhbGxiYWNrKGkpKTtcbiAgICAgICAgY2FsbGVycy5wdXNoKGNhbGxlcihpKSk7XG4gICAgfVxuXG4gICAgdmFyIEhvbGRlciA9IGZ1bmN0aW9uKHRvdGFsLCBmbikge1xuICAgICAgICB0aGlzLnAxID0gdGhpcy5wMiA9IHRoaXMucDMgPSB0aGlzLnA0ID0gdGhpcy5wNSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLm5vdyA9IDA7XG4gICAgfTtcblxuICAgIEhvbGRlci5wcm90b3R5cGUuY2FsbGVycyA9IGNhbGxlcnM7XG4gICAgSG9sZGVyLnByb3RvdHlwZS5jaGVja0Z1bGZpbGxtZW50ID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgbm93ID0gdGhpcy5ub3c7XG4gICAgICAgIG5vdysrO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICBpZiAobm93ID49IHRvdGFsKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuY2FsbGVyc1t0b3RhbF07XG4gICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGhhbmRsZXIpKHRoaXMpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZXQuZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2socmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIH07XG59XG59XG5cblByb21pc2Uuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGFzdCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBmbjtcbiAgICBpZiAobGFzdCA+IDAgJiYgdHlwZW9mIGFyZ3VtZW50c1tsYXN0XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZuID0gYXJndW1lbnRzW2xhc3RdO1xuICAgICAgICBpZiAoIXRydWUpIHtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgNiAmJiBjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgIHZhciBob2xkZXIgPSBuZXcgSG9sZGVyKGxhc3QsIGZuKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhlbkNhbGxiYWNrcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Q7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShhcmd1bWVudHNbaV0sIHJldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3RoZW4oY2FsbGJhY2tzW2ldLCByZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0LCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXliZVByb21pc2UuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl92YWx1ZSgpLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKHJldCwgbWF5YmVQcm9taXNlLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheSgkX2xlbik7IGZvcih2YXIgJF9pID0gMDsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2ldID0gYXJndW1lbnRzWyRfaV07fVxuICAgIGlmIChmbikgYXJncy5wb3AoKTtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VBcnJheShhcmdzKS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyByZXQuc3ByZWFkKGZuKSA6IHJldDtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKSB7XG52YXIgYXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luYy5qc1wiKTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIFBFTkRJTkcgPSB7fTtcbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xuXG5mdW5jdGlvbiBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGZuO1xuICAgIHRoaXMuX3ByZXNlcnZlZFZhbHVlcyA9IF9maWx0ZXIgPT09IElOVEVSTkFMXG4gICAgICAgID8gbmV3IEFycmF5KHRoaXMubGVuZ3RoKCkpXG4gICAgICAgIDogbnVsbDtcbiAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgIHRoaXMuX2luRmxpZ2h0ID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IGxpbWl0ID49IDEgPyBbXSA6IEVNUFRZX0FSUkFZO1xuICAgIGFzeW5jLmludm9rZShpbml0LCB0aGlzLCB1bmRlZmluZWQpO1xufVxudXRpbC5pbmhlcml0cyhNYXBwaW5nUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuZnVuY3Rpb24gaW5pdCgpIHt0aGlzLl9pbml0JCh1bmRlZmluZWQsIC0yKTt9XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9saW1pdDtcbiAgICBpZiAodmFsdWVzW2luZGV4XSA9PT0gUEVORElORykge1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pbkZsaWdodC0tO1xuICAgICAgICAgICAgdGhpcy5fZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbWl0ID49IDEgJiYgdGhpcy5faW5GbGlnaHQgPj0gbGltaXQpIHtcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwpIHByZXNlcnZlZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcHJvbWlzZS5fYm91bmRUbztcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGNhbGxiYWNrKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHJldHVybiB0aGlzLl9yZWplY3QocmV0LmUpO1xuXG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHJldCwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGltaXQgPj0gMSkgdGhpcy5faW5GbGlnaHQrKztcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gUEVORElORztcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl9wcm94eVByb21pc2VBcnJheSh0aGlzLCBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG1heWJlUHJvbWlzZS5fdmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChtYXliZVByb21pc2UuX3JlYXNvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gcmV0O1xuICAgIH1cbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyKHZhbHVlcywgcHJlc2VydmVkVmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgfVxufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9pbkZsaWdodCA8IGxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodmFsdWVzW2luZGV4XSwgaW5kZXgpO1xuICAgIH1cbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9maWx0ZXIgPSBmdW5jdGlvbiAoYm9vbGVhbnMsIHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZiAoYm9vbGVhbnNbaV0pIHJldFtqKytdID0gdmFsdWVzW2ldO1xuICAgIH1cbiAgICByZXQubGVuZ3RoID0gajtcbiAgICB0aGlzLl9yZXNvbHZlKHJldCk7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcmVzZXJ2ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbn07XG5cbmZ1bmN0aW9uIG1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIF9maWx0ZXIpIHtcbiAgICB2YXIgbGltaXQgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsXG4gICAgICAgID8gb3B0aW9ucy5jb25jdXJyZW5jeVxuICAgICAgICA6IDA7XG4gICAgbGltaXQgPSB0eXBlb2YgbGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgaXNGaW5pdGUobGltaXQpICYmIGxpbWl0ID49IDEgPyBsaW1pdCA6IDA7XG4gICAgcmV0dXJuIG5ldyBNYXBwaW5nUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgbGltaXQsIF9maWx0ZXIpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBhcGlSZWplY3Rpb24oXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuXG4gICAgcmV0dXJuIG1hcCh0aGlzLCBmbiwgb3B0aW9ucywgbnVsbCkucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5tYXAgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZm4gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOTE2bEpKXFx1MDAwYVwiKTtcbiAgICByZXR1cm4gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikucHJvbWlzZSgpO1xufTtcblxuXG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi91dGlsLmpzXCI6Mzh9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cblByb21pc2UubWV0aG9kID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQcm9taXNlLlR5cGVFcnJvcihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgcmV0Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0cnlDYXRjaChmbikuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIHJldC5fcmVzb2x2ZUZyb21TeW5jVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59O1xuXG5Qcm9taXNlLmF0dGVtcHQgPSBQcm9taXNlW1widHJ5XCJdID0gZnVuY3Rpb24gKGZuLCBhcmdzLCBjdHgpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgdmFsdWUgPSB1dGlsLmlzQXJyYXkoYXJncylcbiAgICAgICAgPyB0cnlDYXRjaChmbikuYXBwbHkoY3R4LCBhcmdzKVxuICAgICAgICA6IHRyeUNhdGNoKGZuKS5jYWxsKGN0eCwgYXJncyk7XG4gICAgcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlRnJvbVN5bmNWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdXRpbC5lcnJvck9iaikge1xuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayh2YWx1ZS5lLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlLCB0cnVlKTtcbiAgICB9XG59O1xufTtcblxufSx7XCIuL3V0aWwuanNcIjozOH1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgYXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luYy5qc1wiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBzcHJlYWRBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsKSkgcmV0dXJuIHN1Y2Nlc3NBZGFwdGVyLmNhbGwocHJvbWlzZSwgdmFsLCBub2RlYmFjayk7XG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKG5vZGViYWNrKS5hcHBseShwcm9taXNlLl9ib3VuZFRvLCBbbnVsbF0uY29uY2F0KHZhbCkpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3VjY2Vzc0FkYXB0ZXIodmFsLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgcmVjZWl2ZXIgPSBwcm9taXNlLl9ib3VuZFRvO1xuICAgIHZhciByZXQgPSB2YWwgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHJlY2VpdmVyLCBudWxsKVxuICAgICAgICA6IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHJlY2VpdmVyLCBudWxsLCB2YWwpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yQWRhcHRlcihyZWFzb24sIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBwcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIG5ld1JlYXNvbiA9IHRhcmdldC5fZ2V0Q2FycmllZFN0YWNrVHJhY2UoKTtcbiAgICAgICAgbmV3UmVhc29uLmNhdXNlID0gcmVhc29uO1xuICAgICAgICByZWFzb24gPSBuZXdSZWFzb247XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYXRjaChub2RlYmFjaykuY2FsbChwcm9taXNlLl9ib3VuZFRvLCByZWFzb24pO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIocmV0LmUpO1xuICAgIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYXNDYWxsYmFjayA9IFxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gc3VjY2Vzc0FkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0KG9wdGlvbnMpLnNwcmVhZCkge1xuICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICBlcnJvckFkYXB0ZXIsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbm9kZWJhY2tcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xufTtcblxufSx7XCIuL2FzeW5jLmpzXCI6MixcIi4vdXRpbC5qc1wiOjM4fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIFByb21pc2VBcnJheSkge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3NlZCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4odW5kZWZpbmVkLCB1bmRlZmluZWQsIGhhbmRsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc1ZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkpIHJldHVybjtcbiAgICB0aGlzLl90YXJnZXQoKS5fcHJvZ3Jlc3NVbmNoZWNrZWQocHJvZ3Jlc3NWYWx1ZSk7XG5cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzc0hhbmRsZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3Byb2dyZXNzSGFuZGxlcjBcbiAgICAgICAgOiB0aGlzWyhpbmRleCA8PCAyKSArIGluZGV4IC0gNSArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvUHJvZ3Jlc3NXaXRoID0gZnVuY3Rpb24gKHByb2dyZXNzaW9uKSB7XG4gICAgdmFyIHByb2dyZXNzVmFsdWUgPSBwcm9ncmVzc2lvbi52YWx1ZTtcbiAgICB2YXIgaGFuZGxlciA9IHByb2dyZXNzaW9uLmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBwcm9ncmVzc2lvbi5wcm9taXNlO1xuICAgIHZhciByZWNlaXZlciA9IHByb2dyZXNzaW9uLnJlY2VpdmVyO1xuXG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHByb2dyZXNzVmFsdWUpO1xuICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIGlmIChyZXQuZSAhPSBudWxsICYmXG4gICAgICAgICAgICByZXQuZS5uYW1lICE9PSBcIlN0b3BQcm9ncmVzc1Byb3BhZ2F0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciB0cmFjZSA9IHV0aWwuY2FuQXR0YWNoVHJhY2UocmV0LmUpXG4gICAgICAgICAgICAgICAgPyByZXQuZSA6IG5ldyBFcnJvcih1dGlsLnRvU3RyaW5nKHJldC5lKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHRyYWNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX3Byb2dyZXNzKHJldC5lKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3RoZW4ocHJvbWlzZS5fcHJvZ3Jlc3MsIG51bGwsIG51bGwsIHByb21pc2UsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZS5fcHJvZ3Jlc3MocmV0KTtcbiAgICB9XG59O1xuXG5cblByb21pc2UucHJvdG90eXBlLl9wcm9ncmVzc1VuY2hlY2tlZCA9IGZ1bmN0aW9uIChwcm9ncmVzc1ZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aCgpO1xuICAgIHZhciBwcm9ncmVzcyA9IHRoaXMuX3Byb2dyZXNzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9wcm9ncmVzc0hhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCBwcm9ncmVzc1ZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQcm9taXNlQXJyYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZVByb2dyZXNzZWQocHJvZ3Jlc3NWYWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhc3luYy5pbnZva2UodGhpcy5fZG9Qcm9ncmVzc1dpdGgsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZXI6IHRoaXMuX3JlY2VpdmVyQXQoaSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuaW52b2tlKHByb2dyZXNzLCBwcm9taXNlLCBwcm9ncmVzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG59O1xuXG59LHtcIi4vYXN5bmMuanNcIjoyLFwiLi91dGlsLmpzXCI6Mzh9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG52YXIgbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciBwcm9taXNlIHJlc29sdXRpb24gY2hhaW5cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9MaEZwbzBcXHUwMDBhXCIpO1xufTtcbnZhciByZWZsZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGFzeW5jID0gX2RlcmVxXyhcIi4vYXN5bmMuanNcIik7XG52YXIgZXJyb3JzID0gX2RlcmVxXyhcIi4vZXJyb3JzLmpzXCIpO1xudmFyIFR5cGVFcnJvciA9IFByb21pc2UuVHlwZUVycm9yID0gZXJyb3JzLlR5cGVFcnJvcjtcblByb21pc2UuUmFuZ2VFcnJvciA9IGVycm9ycy5SYW5nZUVycm9yO1xuUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvciA9IGVycm9ycy5DYW5jZWxsYXRpb25FcnJvcjtcblByb21pc2UuVGltZW91dEVycm9yID0gZXJyb3JzLlRpbWVvdXRFcnJvcjtcblByb21pc2UuT3BlcmF0aW9uYWxFcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xuUHJvbWlzZS5SZWplY3Rpb25FcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xuUHJvbWlzZS5BZ2dyZWdhdGVFcnJvciA9IGVycm9ycy5BZ2dyZWdhdGVFcnJvcjtcbnZhciBJTlRFUk5BTCA9IGZ1bmN0aW9uKCl7fTtcbnZhciBBUFBMWSA9IHt9O1xudmFyIE5FWFRfRklMVEVSID0ge2U6IG51bGx9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSBfZGVyZXFfKFwiLi90aGVuYWJsZXMuanNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgX2RlcmVxXyhcIi4vcHJvbWlzZV9hcnJheS5qc1wiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG52YXIgQ2FwdHVyZWRUcmFjZSA9IF9kZXJlcV8oXCIuL2NhcHR1cmVkX3RyYWNlLmpzXCIpKCk7XG52YXIgaXNEZWJ1Z2dpbmcgPSBfZGVyZXFfKFwiLi9kZWJ1Z2dhYmlsaXR5LmpzXCIpKFByb21pc2UsIENhcHR1cmVkVHJhY2UpO1xuIC8qanNoaW50IHVudXNlZDpmYWxzZSovXG52YXIgY3JlYXRlQ29udGV4dCA9XG4gICAgX2RlcmVxXyhcIi4vY29udGV4dC5qc1wiKShQcm9taXNlLCBDYXB0dXJlZFRyYWNlLCBpc0RlYnVnZ2luZyk7XG52YXIgQ2F0Y2hGaWx0ZXIgPSBfZGVyZXFfKFwiLi9jYXRjaF9maWx0ZXIuanNcIikoTkVYVF9GSUxURVIpO1xudmFyIFByb21pc2VSZXNvbHZlciA9IF9kZXJlcV8oXCIuL3Byb21pc2VfcmVzb2x2ZXIuanNcIik7XG52YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gUHJvbWlzZVJlc29sdmVyLl9ub2RlYmFja0ZvclByb21pc2U7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgcmVzb2x2ZXIgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9FQzIyWW5cXHUwMDBhXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHByb21pc2UgY29uc3RydWN0b3IgY2Fubm90IGJlIGludm9rZWQgZGlyZWN0bHlcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9Lc0lsZ2VcXHUwMDBhXCIpO1xuICAgIH1cbiAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zZXR0bGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkgdGhpcy5fcmVzb2x2ZUZyb21SZXNvbHZlcihyZXNvbHZlcik7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmNhdWdodCA9IFByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgICB2YXIgY2F0Y2hJbnN0YW5jZXMgPSBuZXcgQXJyYXkobGVuIC0gMSksXG4gICAgICAgICAgICBqID0gMCwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNhdGNoSW5zdGFuY2VzW2orK10gPSBpdGVtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUeXBlRXJyb3IoXCJDYXRjaCBmaWx0ZXIgbXVzdCBpbmhlcml0IGZyb20gRXJyb3Igb3IgYmUgYSBzaW1wbGUgcHJlZGljYXRlIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvbzg0bzY4XFx1MDAwYVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgZm4gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHZhciBjYXRjaEZpbHRlciA9IG5ldyBDYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgZm4sIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyLmRvRmlsdGVyLCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYXRjaEZpbHRlciwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4odW5kZWZpbmVkLCBmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWZsZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVuKHJlZmxlY3QsIHJlZmxlY3QsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcykge1xuICAgIGlmIChpc0RlYnVnZ2luZygpICYmIGFyZ3VtZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBkaWRGdWxmaWxsICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIGRpZFJlamVjdCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIi50aGVuKCkgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBidXQgd2FzIHBhc3NlZDogXCIgK1xuICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcoZGlkRnVsZmlsbCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbXNnICs9IFwiLCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZGlkUmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93YXJuKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgZGlkUHJvZ3Jlc3MsXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBkaWRQcm9ncmVzcykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fdGhlbihkaWRGdWxmaWxsLCBkaWRSZWplY3QsIGRpZFByb2dyZXNzLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCkge1xuICAgIHJldHVybiB0aGlzLmFsbCgpLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCBBUFBMWSwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzUmVzb2x2ZWQoKSAmJlxuICAgICAgICB0aGlzLl9jYW5jZWxsYWJsZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZUFycmF5KHRoaXMpLnByb21pc2UoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHV0aWwub3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sIGZuKTtcbn07XG5cblByb21pc2UuaXMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIFByb21pc2U7XG59O1xuXG5Qcm9taXNlLmZyb21Ob2RlID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCkpO1xuICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5kZWZlciA9IFByb21pc2UucGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2VSZXNvbHZlcihwcm9taXNlKTtcbn07XG5cblByb21pc2UuY2FzdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmV0ID0gdHJ5Q29udmVydFRvUHJvbWlzZShvYmopO1xuICAgIGlmICghKHJldCBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgIHZhciB2YWwgPSByZXQ7XG4gICAgICAgIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcmV0Ll9mdWxmaWxsVW5jaGVja2VkKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgdmFyIHByZXYgPSBhc3luYy5fc2NoZWR1bGU7XG4gICAgYXN5bmMuX3NjaGVkdWxlID0gZm47XG4gICAgcmV0dXJuIHByZXY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBkaWRQcm9ncmVzcyxcbiAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHJldCA9IGhhdmVJbnRlcm5hbERhdGEgPyBpbnRlcm5hbERhdGEgOiBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG5cbiAgICBpZiAoIWhhdmVJbnRlcm5hbERhdGEpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDQgfCAxKTtcbiAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICBpZiAodGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkKSByZWNlaXZlciA9IHRoaXMuX2JvdW5kVG87XG4gICAgICAgIGlmICghaGF2ZUludGVybmFsRGF0YSkgcmV0Ll9zZXRJc01pZ3JhdGVkKCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrSW5kZXggPVxuICAgICAgICB0YXJnZXQuX2FkZENhbGxiYWNrcyhkaWRGdWxmaWxsLCBkaWRSZWplY3QsIGRpZFByb2dyZXNzLCByZXQsIHJlY2VpdmVyKTtcblxuICAgIGlmICh0YXJnZXQuX2lzUmVzb2x2ZWQoKSAmJiAhdGFyZ2V0Ll9pc1NldHRsZVByb21pc2VzUXVldWVkKCkpIHtcbiAgICAgICAgYXN5bmMuaW52b2tlKFxuICAgICAgICAgICAgdGFyZ2V0Ll9zZXR0bGVQcm9taXNlQXRQb3N0UmVzb2x1dGlvbiwgdGFyZ2V0LCBjYWxsYmFja0luZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VBdFBvc3RSZXNvbHV0aW9uID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKHRoaXMuX2lzUmVqZWN0aW9uVW5oYW5kbGVkKCkpIHRoaXMuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICB0aGlzLl9zZXR0bGVQcm9taXNlQXQoaW5kZXgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2xlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0RmllbGQgJiAxMzEwNzE7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGb2xsb3dpbmdPckZ1bGZpbGxlZE9yUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDkzOTUyNDA5NikgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA1MzY4NzA5MTIpID09PSA1MzY4NzA5MTI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0TGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gKHRoaXMuX2JpdEZpZWxkICYgLTEzMTA3MikgfFxuICAgICAgICAobGVuICYgMTMxMDcxKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2ODQzNTQ1Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTM0MjE3NzI4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNTM2ODcwOTEyO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDMzNTU0NDMyO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDMzNTU0NDMyKSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDY3MTA4ODY0KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Q2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjcxMDg4NjQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzTWlncmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRJc01pZ3JhdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjQxOTQzMDQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzTWlncmF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDQxOTQzMDQpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWNlaXZlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHJldCA9IGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5fcmVjZWl2ZXIwXG4gICAgICAgIDogdGhpc1tcbiAgICAgICAgICAgIGluZGV4ICogNSAtIDUgKyA0XTtcbiAgICBpZiAocmV0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5faXNCb3VuZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZFRvO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA9PT0gMFxuICAgICAgICA/IHRoaXMuX3Byb21pc2UwXG4gICAgICAgIDogdGhpc1tpbmRleCAqIDUgLSA1ICsgM107XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZnVsZmlsbG1lbnRIYW5kbGVyQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IDBcbiAgICAgICAgPyB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwXG4gICAgICAgIDogdGhpc1tpbmRleCAqIDUgLSA1ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjBcbiAgICAgICAgOiB0aGlzW2luZGV4ICogNSAtIDUgKyAxXTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGZvbGxvd2VyLCBpbmRleCkge1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcmVqZWN0ID0gZm9sbG93ZXIuX3JlamVjdGlvbkhhbmRsZXJBdChpbmRleCk7XG4gICAgdmFyIHByb2dyZXNzID0gZm9sbG93ZXIuX3Byb2dyZXNzSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHByb21pc2UuX3NldElzTWlncmF0ZWQoKTtcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9ncmVzcywgcHJvbWlzZSwgcmVjZWl2ZXIpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2FkZENhbGxiYWNrcyA9IGZ1bmN0aW9uIChcbiAgICBmdWxmaWxsLFxuICAgIHJlamVjdCxcbiAgICBwcm9ncmVzcyxcbiAgICBwcm9taXNlLFxuICAgIHJlY2VpdmVyXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSAxMzEwNzEgLSA1KSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2U7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gdW5kZWZpbmVkKSB0aGlzLl9yZWNlaXZlcjAgPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIgJiYgIXRoaXMuX2lzQ2FycnlpbmdTdGFja1RyYWNlKCkpXG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gZnVsZmlsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPSByZWplY3Q7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5fcHJvZ3Jlc3NIYW5kbGVyMCA9IHByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA1IC0gNTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSBwcm9taXNlO1xuICAgICAgICB0aGlzW2Jhc2UgKyA0XSA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAodHlwZW9mIGZ1bGZpbGwgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID0gZnVsZmlsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDFdID0gcmVqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIHByb2dyZXNzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB0aGlzW2Jhc2UgKyAyXSA9IHByb2dyZXNzO1xuICAgIH1cbiAgICB0aGlzLl9zZXRMZW5ndGgoaW5kZXggKyAxKTtcbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UHJveHlIYW5kbGVycyA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJvbWlzZVNsb3RWYWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2xlbmd0aCgpO1xuXG4gICAgaWYgKGluZGV4ID49IDEzMTA3MSAtIDUpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHByb21pc2VTbG90VmFsdWU7XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyMCA9IHJlY2VpdmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiYXNlID0gaW5kZXggKiA1IC0gNTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSBwcm9taXNlU2xvdFZhbHVlO1xuICAgICAgICB0aGlzW2Jhc2UgKyA0XSA9IHJlY2VpdmVyO1xuICAgIH1cbiAgICB0aGlzLl9zZXRMZW5ndGgoaW5kZXggKyAxKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9wcm94eVByb21pc2VBcnJheSA9IGZ1bmN0aW9uIChwcm9taXNlQXJyYXksIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0UHJveHlIYW5kbGVycyhwcm9taXNlQXJyYXksIGluZGV4KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXNvbHZlQ2FsbGJhY2sgPSBmdW5jdGlvbih2YWx1ZSwgc2hvdWxkQmluZCkge1xuICAgIGlmICh0aGlzLl9pc0ZvbGxvd2luZ09yRnVsZmlsbGVkT3JSZWplY3RlZCgpKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UsIHRydWUpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgdmFyIHByb3BhZ2F0aW9uRmxhZ3MgPSAxIHwgKHNob3VsZEJpbmQgPyA0IDogMCk7XG4gICAgdGhpcy5fcHJvcGFnYXRlRnJvbShtYXliZVByb21pc2UsIHByb3BhZ2F0aW9uRmxhZ3MpO1xuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICBpZiAocHJvbWlzZS5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tzKHRoaXMsIGkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEZvbGxvd2luZygpO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgICAgIHRoaXMuX3NldEZvbGxvd2VlKHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAocHJvbWlzZS5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9mdWxmaWxsVW5jaGVja2VkKHByb21pc2UuX3ZhbHVlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlamVjdFVuY2hlY2tlZChwcm9taXNlLl9yZWFzb24oKSxcbiAgICAgICAgICAgIHByb21pc2UuX2dldENhcnJpZWRTdGFja1RyYWNlKCkpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWplY3RDYWxsYmFjayA9XG5mdW5jdGlvbihyZWFzb24sIHN5bmNocm9ub3VzLCBzaG91bGROb3RNYXJrT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKSB7XG4gICAgaWYgKCFzaG91bGROb3RNYXJrT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKSB7XG4gICAgICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKHJlYXNvbik7XG4gICAgfVxuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbiwgaGFzU3RhY2sgPyB1bmRlZmluZWQgOiB0cmFjZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21SZXNvbHZlciA9IGZ1bmN0aW9uIChyZXNvbHZlcikge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB0aGlzLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB2YXIgciA9IHRyeUNhdGNoKHJlc29sdmVyKShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9KTtcbiAgICBzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgIHRoaXMuX3BvcENvbnRleHQoKTtcblxuICAgIGlmIChyICE9PSB1bmRlZmluZWQgJiYgciA9PT0gZXJyb3JPYmogJiYgcHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyLmUsIHRydWUsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyID0gZnVuY3Rpb24gKFxuICAgIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZVxuKSB7XG4gICAgaWYgKHByb21pc2UuX2lzUmVqZWN0ZWQoKSkgcmV0dXJuO1xuICAgIHByb21pc2UuX3B1c2hDb250ZXh0KCk7XG4gICAgdmFyIHg7XG4gICAgaWYgKHJlY2VpdmVyID09PSBBUFBMWSAmJiAhdGhpcy5faXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHggPSB0cnlDYXRjaChoYW5kbGVyKS5hcHBseSh0aGlzLl9ib3VuZFRvLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuXG4gICAgaWYgKHggPT09IGVycm9yT2JqIHx8IHggPT09IHByb21pc2UgfHwgeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgdmFyIGVyciA9IHggPT09IHByb21pc2UgPyBtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpIDogeC5lO1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhlcnIsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhblZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fY2FuY2VsbGFibGUoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3BhZ2F0ZUZyb20gPSBmdW5jdGlvbiAocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAxKSA+IDAgJiYgcGFyZW50Ll9jYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX3NldENhbmNlbGxhYmxlKCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgaWYgKChmbGFncyAmIDQpID4gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5faXNGb2xsb3dpbmdPckZ1bGZpbGxlZE9yUmVqZWN0ZWQoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2Z1bGZpbGxVbmNoZWNrZWQodmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24sIGNhcnJpZWRTdGFja1RyYWNlKSB7XG4gICAgaWYgKHRoaXMuX2lzRm9sbG93aW5nT3JGdWxmaWxsZWRPclJlamVjdGVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9yZWplY3RVbmNoZWNrZWQocmVhc29uLCBjYXJyaWVkU3RhY2tUcmFjZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciBpc1Byb21pc2UgPSBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZTtcblxuICAgIGlmIChpc1Byb21pc2UgJiYgcHJvbWlzZS5faXNNaWdyYXRlZCgpKSB7XG4gICAgICAgIHByb21pc2UuX3Vuc2V0SXNNaWdyYXRlZCgpO1xuICAgICAgICByZXR1cm4gYXN5bmMuaW52b2tlKHRoaXMuX3NldHRsZVByb21pc2VBdCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2lzRnVsZmlsbGVkKClcbiAgICAgICAgPyB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJBdChpbmRleClcbiAgICAgICAgOiB0aGlzLl9yZWplY3Rpb25IYW5kbGVyQXQoaW5kZXgpO1xuXG4gICAgdmFyIGNhcnJpZWRTdGFja1RyYWNlID1cbiAgICAgICAgdGhpcy5faXNDYXJyeWluZ1N0YWNrVHJhY2UoKSA/IHRoaXMuX2dldENhcnJpZWRTdGFja1RyYWNlKCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5fc2V0dGxlZFZhbHVlO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaW5kZXgpO1xuXG5cbiAgICB0aGlzLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFpc1Byb21pc2UpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChyZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZUZyb21IYW5kbGVyKGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJvbWlzZUFycmF5KSB7XG4gICAgICAgIGlmICghcmVjZWl2ZXIuX2lzUmVzb2x2ZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUZ1bGZpbGxlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZVJlamVjdGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSwgY2FycmllZFN0YWNrVHJhY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IDQgJiYgKGluZGV4ICYgMzEpID09PSA0KVxuICAgICAgICBhc3luYy5pbnZva2VMYXRlcih0aGlzLl9zZXRMZW5ndGgsIHRoaXMsIDApO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNDYXJyeWluZ1N0YWNrVHJhY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzSGFuZGxlcjAgPVxuICAgICAgICB0aGlzLl9yZWNlaXZlcjAgPVxuICAgICAgICB0aGlzLl9wcm9taXNlMCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNSAtIDU7XG4gICAgICAgIHRoaXNbYmFzZSArIDNdID1cbiAgICAgICAgdGhpc1tiYXNlICsgNF0gPVxuICAgICAgICB0aGlzW2Jhc2UgKyAwXSA9XG4gICAgICAgIHRoaXNbYmFzZSArIDFdID1cbiAgICAgICAgdGhpc1tiYXNlICsgMl0gPSB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzU2V0dGxlUHJvbWlzZXNRdWV1ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmXG4gICAgICAgICAgICAtMTA3Mzc0MTgyNCkgPT09IC0xMDczNzQxODI0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFNldHRsZVByb21pc2VzUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAtMTA3Mzc0MTgyNDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl91bnNldFNldHRsZVByb21pc2VzUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofi0xMDczNzQxODI0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9xdWV1ZVNldHRsZVByb21pc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgdGhpcy5fc2V0U2V0dGxlUHJvbWlzZXNRdWV1ZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsVW5jaGVja2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKSB7XG4gICAgICAgIHZhciBlcnIgPSBtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKGVycik7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWplY3RVbmNoZWNrZWQoZXJyLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9zZXR0bGVkVmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9jbGVhblZhbHVlcygpO1xuXG4gICAgaWYgKHRoaXMuX2xlbmd0aCgpID4gMCkge1xuICAgICAgICB0aGlzLl9xdWV1ZVNldHRsZVByb21pc2VzKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFVuY2hlY2tlZENoZWNrRXJyb3IgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdmFyIHRyYWNlID0gdXRpbC5lbnN1cmVFcnJvck9iamVjdChyZWFzb24pO1xuICAgIHRoaXMuX3JlamVjdFVuY2hlY2tlZChyZWFzb24sIHRyYWNlID09PSByZWFzb24gPyB1bmRlZmluZWQgOiB0cmFjZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0VW5jaGVja2VkID0gZnVuY3Rpb24gKHJlYXNvbiwgdHJhY2UpIHtcbiAgICBpZiAocmVhc29uID09PSB0aGlzKSB7XG4gICAgICAgIHZhciBlcnIgPSBtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpO1xuICAgICAgICB0aGlzLl9hdHRhY2hFeHRyYVRyYWNlKGVycik7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWplY3RVbmNoZWNrZWQoZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UmVqZWN0ZWQoKTtcbiAgICB0aGlzLl9zZXR0bGVkVmFsdWUgPSByZWFzb247XG4gICAgdGhpcy5fY2xlYW5WYWx1ZXMoKTtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoXCJzdGFja1wiIGluIGUpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5pbnZva2VGaXJzdChcbiAgICAgICAgICAgICAgICAgICAgQ2FwdHVyZWRUcmFjZS51bmhhbmRsZWRSZWplY3Rpb24sIHVuZGVmaW5lZCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LCB0cmFjZSA9PT0gdW5kZWZpbmVkID8gcmVhc29uIDogdHJhY2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRyYWNlICE9PSB1bmRlZmluZWQgJiYgdHJhY2UgIT09IHJlYXNvbikge1xuICAgICAgICB0aGlzLl9zZXRDYXJyaWVkU3RhY2tUcmFjZSh0cmFjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlbmd0aCgpID4gMCkge1xuICAgICAgICB0aGlzLl9xdWV1ZVNldHRsZVByb21pc2VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldHRsZVByb21pc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vuc2V0U2V0dGxlUHJvbWlzZXNRdWV1ZWQoKTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlQXQoaSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5fbWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IgPSBtYWtlU2VsZlJlc29sdXRpb25FcnJvcjtcbl9kZXJlcV8oXCIuL3Byb2dyZXNzLmpzXCIpKFByb21pc2UsIFByb21pc2VBcnJheSk7XG5fZGVyZXFfKFwiLi9tZXRob2QuanNcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5fZGVyZXFfKFwiLi9iaW5kLmpzXCIpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlKTtcbl9kZXJlcV8oXCIuL2ZpbmFsbHkuanNcIikoUHJvbWlzZSwgTkVYVF9GSUxURVIsIHRyeUNvbnZlcnRUb1Byb21pc2UpO1xuX2RlcmVxXyhcIi4vZGlyZWN0X3Jlc29sdmUuanNcIikoUHJvbWlzZSk7XG5fZGVyZXFfKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzXCIpKFByb21pc2UpO1xuX2RlcmVxXyhcIi4vam9pbi5qc1wiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5fZGVyZXFfKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2NhbmNlbC5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCk7XG5fZGVyZXFfKCcuL2dlbmVyYXRvcnMuanMnKShQcm9taXNlLCBhcGlSZWplY3Rpb24sIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlKTtcbl9kZXJlcV8oJy4vbm9kZWlmeS5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi9wcm9wcy5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbl9kZXJlcV8oJy4vcmFjZS5qcycpKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9yZWR1Y2UuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgSU5URVJOQUwpO1xuX2RlcmVxXygnLi9zZXR0bGUuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXkpO1xuX2RlcmVxXygnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xuX2RlcmVxXygnLi9wcm9taXNpZnkuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2FueS5qcycpKFByb21pc2UpO1xuX2RlcmVxXygnLi9lYWNoLmpzJykoUHJvbWlzZSwgSU5URVJOQUwpO1xuX2RlcmVxXygnLi90aW1lcnMuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5fZGVyZXFfKCcuL2ZpbHRlci5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMoUHJvbWlzZS5wcm90b3R5cGUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZnVuY3Rpb24gZmlsbFR5cGVzKHZhbHVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3JlamVjdGlvbkhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9wcm9ncmVzc0hhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcHJvbWlzZTAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3JlY2VpdmVyMCA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9zZXR0bGVkVmFsdWUgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIENhcHR1cmVkVHJhY2Uuc2V0Qm91bmRzKGFzeW5jLmZpcnN0TGluZUVycm9yLCB1dGlsLmxhc3RMaW5lRXJyb3IpOyAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG5cbn0se1wiLi9hbnkuanNcIjoxLFwiLi9hc3luYy5qc1wiOjIsXCIuL2JpbmQuanNcIjozLFwiLi9jYWxsX2dldC5qc1wiOjUsXCIuL2NhbmNlbC5qc1wiOjYsXCIuL2NhcHR1cmVkX3RyYWNlLmpzXCI6NyxcIi4vY2F0Y2hfZmlsdGVyLmpzXCI6OCxcIi4vY29udGV4dC5qc1wiOjksXCIuL2RlYnVnZ2FiaWxpdHkuanNcIjoxMCxcIi4vZGlyZWN0X3Jlc29sdmUuanNcIjoxMSxcIi4vZWFjaC5qc1wiOjEyLFwiLi9lcnJvcnMuanNcIjoxMyxcIi4vZmlsdGVyLmpzXCI6MTUsXCIuL2ZpbmFsbHkuanNcIjoxNixcIi4vZ2VuZXJhdG9ycy5qc1wiOjE3LFwiLi9qb2luLmpzXCI6MTgsXCIuL21hcC5qc1wiOjE5LFwiLi9tZXRob2QuanNcIjoyMCxcIi4vbm9kZWlmeS5qc1wiOjIxLFwiLi9wcm9ncmVzcy5qc1wiOjIyLFwiLi9wcm9taXNlX2FycmF5LmpzXCI6MjQsXCIuL3Byb21pc2VfcmVzb2x2ZXIuanNcIjoyNSxcIi4vcHJvbWlzaWZ5LmpzXCI6MjYsXCIuL3Byb3BzLmpzXCI6MjcsXCIuL3JhY2UuanNcIjoyOSxcIi4vcmVkdWNlLmpzXCI6MzAsXCIuL3NldHRsZS5qc1wiOjMyLFwiLi9zb21lLmpzXCI6MzMsXCIuL3N5bmNocm9ub3VzX2luc3BlY3Rpb24uanNcIjozNCxcIi4vdGhlbmFibGVzLmpzXCI6MzUsXCIuL3RpbWVycy5qc1wiOjM2LFwiLi91c2luZy5qc1wiOjM3LFwiLi91dGlsLmpzXCI6Mzh9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcblxuZnVuY3Rpb24gdG9SZXNvbHV0aW9uVmFsdWUodmFsKSB7XG4gICAgc3dpdGNoKHZhbCkge1xuICAgIGNhc2UgLTI6IHJldHVybiBbXTtcbiAgICBjYXNlIC0zOiByZXR1cm4ge307XG4gICAgfVxufVxuXG5mdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcGFyZW50ID0gdmFsdWVzO1xuICAgICAgICBwcm9taXNlLl9wcm9wYWdhdGVGcm9tKHBhcmVudCwgMSB8IDQpO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl90b3RhbFJlc29sdmVkID0gMDtcbiAgICB0aGlzLl9pbml0KHVuZGVmaW5lZCwgLTIpO1xufVxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KF8sIHJlc29sdmVWYWx1ZUlmRW1wdHkpIHtcbiAgICB2YXIgdmFsdWVzID0gdHJ5Q29udmVydFRvUHJvbWlzZSh0aGlzLl92YWx1ZXMsIHRoaXMuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlcy5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLl92YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IFByb21pc2UuVHlwZUVycm9yKFwiZXhwZWN0aW5nIGFuIGFycmF5LCBhIHByb21pc2Ugb3IgYSB0aGVuYWJsZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3M4TU1oY1xcdTAwMGFcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhcmRSZWplY3RfXyhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXMuX2lzUGVuZGluZygpKSB7XG4gICAgICAgICAgICB2YWx1ZXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlSWZFbXB0eVxuICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KHZhbHVlcy5fcmVhc29uKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3JlamVjdChhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYW4gYXJyYXksIGEgcHJvbWlzZSBvciBhIHRoZW5hYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvczhNTWhjXFx1MDAwYVwiKS5fcmVhc29uKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKHJlc29sdmVWYWx1ZUlmRW1wdHkgPT09IC01KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRW1wdHlBcnJheSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0b1Jlc29sdXRpb25WYWx1ZShyZXNvbHZlVmFsdWVJZkVtcHR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGVuID0gdGhpcy5nZXRBY3R1YWxMZW5ndGgodmFsdWVzLmxlbmd0aCk7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuc2hvdWxkQ29weVZhbHVlcygpID8gbmV3IEFycmF5KGxlbikgOiB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGlzUmVzb2x2ZWQgPSB0aGlzLl9pc1Jlc29sdmVkKCk7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlc1tpXSwgcHJvbWlzZSk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICAgICAgaWYgKGlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2lnbm9yZVJlamVjdGlvbnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHlQcm9taXNlQXJyYXkodGhpcywgaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLl92YWx1ZSgpLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkKG1heWJlUHJvbWlzZS5fcmVhc29uKCksIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlRnVsZmlsbGVkKG1heWJlUHJvbWlzZSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX19oYXJkUmVqZWN0X18gPVxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBmYWxzZSwgdHJ1ZSk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUHJvZ3Jlc3NlZCA9IGZ1bmN0aW9uIChwcm9ncmVzc1ZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3Byb21pc2UuX3Byb2dyZXNzKHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICB2YWx1ZTogcHJvZ3Jlc3NWYWx1ZVxuICAgIH0pO1xufTtcblxuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24sIGluZGV4KSB7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCsrO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbjtcbn07XG5cbnJldHVybiBQcm9taXNlQXJyYXk7XG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBlcnJvcnMgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIik7XG52YXIgVGltZW91dEVycm9yID0gZXJyb3JzLlRpbWVvdXRFcnJvcjtcbnZhciBPcGVyYXRpb25hbEVycm9yID0gZXJyb3JzLk9wZXJhdGlvbmFsRXJyb3I7XG52YXIgaGF2ZUdldHRlcnMgPSB1dGlsLmhhdmVHZXR0ZXJzO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNS5qc1wiKTtcblxuZnVuY3Rpb24gaXNVbnR5cGVkRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVzNS5nZXRQcm90b3R5cGVPZihvYmopID09PSBFcnJvci5wcm90b3R5cGU7XG59XG5cbnZhciByRXJyb3JLZXkgPSAvXig/Om5hbWV8bWVzc2FnZXxzdGFja3xjYXVzZSkkLztcbmZ1bmN0aW9uIHdyYXBBc09wZXJhdGlvbmFsRXJyb3Iob2JqKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoaXNVbnR5cGVkRXJyb3Iob2JqKSkge1xuICAgICAgICByZXQgPSBuZXcgT3BlcmF0aW9uYWxFcnJvcihvYmopO1xuICAgICAgICByZXQubmFtZSA9IG9iai5uYW1lO1xuICAgICAgICByZXQubWVzc2FnZSA9IG9iai5tZXNzYWdlO1xuICAgICAgICByZXQuc3RhY2sgPSBvYmouc3RhY2s7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghckVycm9yS2V5LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdXRpbC5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9taXNlID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG1heWJlV3JhcEFzRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdyYXBwZWQpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHdyYXBwZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KCRfbGVuIC0gMSk7IGZvcih2YXIgJF9pID0gMTsgJF9pIDwgJF9sZW47ICsrJF9pKSB7YXJnc1skX2kgLSAxXSA9IGFyZ3VtZW50c1skX2ldO31cbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH07XG59XG5cblxudmFyIFByb21pc2VSZXNvbHZlcjtcbmlmICghaGF2ZUdldHRlcnMpIHtcbiAgICBQcm9taXNlUmVzb2x2ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLmFzQ2FsbGJhY2sgPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB0aGlzLmFzQ2FsbGJhY2s7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIFByb21pc2VSZXNvbHZlciA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgfTtcbn1cbmlmIChoYXZlR2V0dGVycykge1xuICAgIHZhciBwcm9wID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGViYWNrRm9yUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZSwgXCJhc0NhbGxiYWNrXCIsIHByb3ApO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShQcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLCBcImNhbGxiYWNrXCIsIHByb3ApO1xufVxuXG5Qcm9taXNlUmVzb2x2ZXIuX25vZGViYWNrRm9yUHJvbWlzZSA9IG5vZGViYWNrRm9yUHJvbWlzZTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VSZXNvbHZlcl1cIjtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9XG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZVJlc29sdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBpbnZvY2F0aW9uLCByZXNvbHZlciByZXNvbHZlL3JlamVjdCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYSByZXNvbHZlciBjb250ZXh0LiBDb25zaWRlciB1c2luZyB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLlxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL3Nka1hMOVxcdTAwMGFcIik7XG4gICAgfVxuICAgIHRoaXMucHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHZhbHVlKTtcbn07XG5cblByb21pc2VSZXNvbHZlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUmVzb2x2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb24sIHJlc29sdmVyIHJlc29sdmUvcmVqZWN0IG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhIHJlc29sdmVyIGNvbnRleHQuIENvbnNpZGVyIHVzaW5nIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGluc3RlYWQuXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvc2RrWEw5XFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24pO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlUmVzb2x2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGludm9jYXRpb24sIHJlc29sdmVyIHJlc29sdmUvcmVqZWN0IG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhIHJlc29sdmVyIGNvbnRleHQuIENvbnNpZGVyIHVzaW5nIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGluc3RlYWQuXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvc2RrWEw5XFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdGhpcy5wcm9taXNlLl9wcm9ncmVzcyh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB0aGlzLnByb21pc2UuY2FuY2VsKGVycik7XG59O1xuXG5Qcm9taXNlUmVzb2x2ZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWplY3QobmV3IFRpbWVvdXRFcnJvcihcInRpbWVvdXRcIikpO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnByb21pc2UuaXNSZXNvbHZlZCgpO1xufTtcblxuUHJvbWlzZVJlc29sdmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZS50b0pTT04oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVJlc29sdmVyO1xuXG59LHtcIi4vZXJyb3JzLmpzXCI6MTMsXCIuL2VzNS5qc1wiOjE0LFwiLi91dGlsLmpzXCI6Mzh9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBUSElTID0ge307XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gX2RlcmVxXyhcIi4vcHJvbWlzZV9yZXNvbHZlci5qc1wiKVxuICAgIC5fbm9kZWJhY2tGb3JQcm9taXNlO1xudmFyIHdpdGhBcHBlbmRlZCA9IHV0aWwud2l0aEFwcGVuZGVkO1xudmFyIG1heWJlV3JhcEFzRXJyb3IgPSB1dGlsLm1heWJlV3JhcEFzRXJyb3I7XG52YXIgY2FuRXZhbHVhdGUgPSB1dGlsLmNhbkV2YWx1YXRlO1xudmFyIFR5cGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9yc1wiKS5UeXBlRXJyb3I7XG52YXIgZGVmYXVsdFN1ZmZpeCA9IFwiQXN5bmNcIjtcbnZhciBkZWZhdWx0UHJvbWlzaWZpZWQgPSB7X19pc1Byb21pc2lmaWVkX186IHRydWV9O1xudmFyIG5vQ29weVByb3BzUGF0dGVybiA9XG4gICAgL14oPzpsZW5ndGh8bmFtZXxhcmd1bWVudHN8Y2FsbGVyfGNhbGxlZXxwcm90b3R5cGV8X19pc1Byb21pc2lmaWVkX18pJC87XG52YXIgZGVmYXVsdEZpbHRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdXRpbC5pc0lkZW50aWZpZXIobmFtZSkgJiZcbiAgICAgICAgbmFtZS5jaGFyQXQoMCkgIT09IFwiX1wiICYmXG4gICAgICAgIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbn07XG5cbmZ1bmN0aW9uIHByb3BzRmlsdGVyKGtleSkge1xuICAgIHJldHVybiAhbm9Db3B5UHJvcHNQYXR0ZXJuLnRlc3Qoa2V5KTtcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNpZmllZChmbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbi5fX2lzUHJvbWlzaWZpZWRfXyA9PT0gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkge1xuICAgIHZhciB2YWwgPSB1dGlsLmdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdChvYmosIGtleSArIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21pc2lmaWVkKTtcbiAgICByZXR1cm4gdmFsID8gaXNQcm9taXNpZmllZCh2YWwpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIga2V5ID0gcmV0W2ldO1xuICAgICAgICBpZiAoc3VmZml4UmVnZXhwLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgdmFyIGtleVdpdGhvdXRBc3luY1N1ZmZpeCA9IGtleS5yZXBsYWNlKHN1ZmZpeFJlZ2V4cCwgXCJcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJldC5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRbal0gPT09IGtleVdpdGhvdXRBc3luY1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHByb21pc2lmeSBhbiBBUEkgdGhhdCBoYXMgbm9ybWFsIG1ldGhvZHMgd2l0aCAnJXMnLXN1ZmZpeFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL2lXclpid1xcdTAwMGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXCIlc1wiLCBzdWZmaXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByb21pc2lmaWFibGVNZXRob2RzKG9iaiwgc3VmZml4LCBzdWZmaXhSZWdleHAsIGZpbHRlcikge1xuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyhvYmopO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICB2YXIgcGFzc2VzRGVmYXVsdEZpbHRlciA9IGZpbHRlciA9PT0gZGVmYXVsdEZpbHRlclxuICAgICAgICAgICAgPyB0cnVlIDogZGVmYXVsdEZpbHRlcihrZXksIHZhbHVlLCBvYmopO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICF1dGlsLmlzTmF0aXZlRnVuY3Rpb25NZXRob2QodmFsdWUpICYmXG4gICAgICAgICAgICAhaXNQcm9taXNpZmllZCh2YWx1ZSkgJiZcbiAgICAgICAgICAgICFoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSAmJlxuICAgICAgICAgICAgZmlsdGVyKGtleSwgdmFsdWUsIG9iaiwgcGFzc2VzRGVmYXVsdEZpbHRlcikpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxudmFyIGVzY2FwZUlkZW50UmVnZXggPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbJF0pLywgXCJcXFxcJFwiKTtcbn07XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkRXZhbDtcbmlmICghdHJ1ZSkge1xudmFyIHN3aXRjaENhc2VBcmd1bWVudE9yZGVyID0gZnVuY3Rpb24obGlrZWx5QXJndW1lbnRDb3VudCkge1xuICAgIHZhciByZXQgPSBbbGlrZWx5QXJndW1lbnRDb3VudF07XG4gICAgdmFyIG1pbiA9IE1hdGgubWF4KDAsIGxpa2VseUFyZ3VtZW50Q291bnQgLSAxIC0gMyk7XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCAtIDE7IGkgPj0gbWluOyAtLWkpIHtcbiAgICAgICAgcmV0LnB1c2goaSk7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IGxpa2VseUFyZ3VtZW50Q291bnQgKyAxOyBpIDw9IDM7ICsraSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbnZhciBhcmd1bWVudFNlcXVlbmNlID0gZnVuY3Rpb24oYXJndW1lbnRDb3VudCkge1xuICAgIHJldHVybiB1dGlsLmZpbGxlZFJhbmdlKGFyZ3VtZW50Q291bnQsIFwiX2FyZ1wiLCBcIlwiKTtcbn07XG5cbnZhciBwYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uKHBhcmFtZXRlckNvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoXG4gICAgICAgIE1hdGgubWF4KHBhcmFtZXRlckNvdW50LCAzKSwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckNvdW50ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZm4ubGVuZ3RoLCAxMDIzICsgMSksIDApO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5cbm1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsID1cbmZ1bmN0aW9uKGNhbGxiYWNrLCByZWNlaXZlciwgb3JpZ2luYWxOYW1lLCBmbikge1xuICAgIHZhciBuZXdQYXJhbWV0ZXJDb3VudCA9IE1hdGgubWF4KDAsIHBhcmFtZXRlckNvdW50KGZuKSAtIDEpO1xuICAgIHZhciBhcmd1bWVudE9yZGVyID0gc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIobmV3UGFyYW1ldGVyQ291bnQpO1xuICAgIHZhciBzaG91bGRQcm94eVRoaXMgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCIgfHwgcmVjZWl2ZXIgPT09IFRISVM7XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNhbGxGb3JBcmd1bWVudENvdW50KGNvdW50KSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRTZXF1ZW5jZShjb3VudCkuam9pbihcIiwgXCIpO1xuICAgICAgICB2YXIgY29tbWEgPSBjb3VudCA+IDAgPyBcIiwgXCIgOiBcIlwiO1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBpZiAoc2hvdWxkUHJveHlUaGlzKSB7XG4gICAgICAgICAgICByZXQgPSBcInJldCA9IGNhbGxiYWNrLmNhbGwodGhpcywge3thcmdzfX0sIG5vZGViYWNrKTsgYnJlYWs7XFxuXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSByZWNlaXZlciA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBcInJldCA9IGNhbGxiYWNrKHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiXG4gICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmNhbGwocmVjZWl2ZXIsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZShcInt7YXJnc319XCIsIGFyZ3MpLnJlcGxhY2UoXCIsIFwiLCBjb21tYSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50T3JkZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJldCArPSBcImNhc2UgXCIgKyBhcmd1bWVudE9yZGVyW2ldICtcIjpcIiArXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChhcmd1bWVudE9yZGVyW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCArPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBkZWZhdWx0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGkgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYXJnc1tpXSA9IG5vZGViYWNrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgW0NvZGVGb3JDYWxsXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgYnJlYWs7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKFwiW0NvZGVGb3JDYWxsXVwiLCAoc2hvdWxkUHJveHlUaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwicmV0ID0gY2FsbGJhY2suYXBwbHkocmVjZWl2ZXIsIGFyZ3MpO1xcblwiKSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIGdldEZ1bmN0aW9uQ29kZSA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcInRoaXMgIT0gbnVsbCA/IHRoaXNbJ1wiK2NhbGxiYWNrK1wiJ10gOiBmblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiZm5cIjtcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlY2VpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpdGhBcHBlbmRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXliZVdyYXBBc0Vycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vZGViYWNrRm9yUHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cnlDYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJlcnJvck9ialwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJub3RFbnVtZXJhYmxlUHJvcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJJTlRFUk5BTFwiLFwiJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB2YXIgcmV0ID0gZnVuY3Rpb24gKFBhcmFtZXRlcnMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIG5vZGViYWNrID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdHJ5Q2F0Y2goW0dldEZ1bmN0aW9uQ29kZV0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIFtDb2RlRm9yU3dpdGNoQ2FzZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKG1heWJlV3JhcEFzRXJyb3IocmV0LmUpLCB0cnVlLCB0cnVlKTtcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChyZXQsICdfX2lzUHJvbWlzaWZpZWRfXycsIHRydWUpOyAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIlxuICAgICAgICAucmVwbGFjZShcIlBhcmFtZXRlcnNcIiwgcGFyYW1ldGVyRGVjbGFyYXRpb24obmV3UGFyYW1ldGVyQ291bnQpKVxuICAgICAgICAucmVwbGFjZShcIltDb2RlRm9yU3dpdGNoQ2FzZV1cIiwgZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoXCJbR2V0RnVuY3Rpb25Db2RlXVwiLCBnZXRGdW5jdGlvbkNvZGUpKShcbiAgICAgICAgICAgIFByb21pc2UsXG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIHJlY2VpdmVyLFxuICAgICAgICAgICAgd2l0aEFwcGVuZGVkLFxuICAgICAgICAgICAgbWF5YmVXcmFwQXNFcnJvcixcbiAgICAgICAgICAgIG5vZGViYWNrRm9yUHJvbWlzZSxcbiAgICAgICAgICAgIHV0aWwudHJ5Q2F0Y2gsXG4gICAgICAgICAgICB1dGlsLmVycm9yT2JqLFxuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcCxcbiAgICAgICAgICAgIElOVEVSTkFMXG4gICAgICAgICk7XG59O1xufVxuXG5mdW5jdGlvbiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZShjYWxsYmFjaywgcmVjZWl2ZXIsIF8sIGZuKSB7XG4gICAgdmFyIGRlZmF1bHRUaGlzID0gKGZ1bmN0aW9uKCkge3JldHVybiB0aGlzO30pKCk7XG4gICAgdmFyIG1ldGhvZCA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb21pc2lmaWVkKCkge1xuICAgICAgICB2YXIgX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gVEhJUykgX3JlY2VpdmVyID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHZhciBjYiA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgdGhpcyAhPT0gZGVmYXVsdFRoaXNcbiAgICAgICAgICAgID8gdGhpc1ttZXRob2RdIDogY2FsbGJhY2s7XG4gICAgICAgIHZhciBmbiA9IG5vZGViYWNrRm9yUHJvbWlzZShwcm9taXNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiLmFwcGx5KF9yZWNlaXZlciwgd2l0aEFwcGVuZGVkKGFyZ3VtZW50cywgZm4pKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKGUpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICByZXR1cm4gcHJvbWlzaWZpZWQ7XG59XG5cbnZhciBtYWtlTm9kZVByb21pc2lmaWVkID0gY2FuRXZhbHVhdGVcbiAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWRFdmFsXG4gICAgOiBtYWtlTm9kZVByb21pc2lmaWVkQ2xvc3VyZTtcblxuZnVuY3Rpb24gcHJvbWlzaWZ5QWxsKG9iaiwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyKSB7XG4gICAgdmFyIHN1ZmZpeFJlZ2V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlSWRlbnRSZWdleChzdWZmaXgpICsgXCIkXCIpO1xuICAgIHZhciBtZXRob2RzID1cbiAgICAgICAgcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ldGhvZHNbaV07XG4gICAgICAgIHZhciBmbiA9IG1ldGhvZHNbaSsxXTtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkS2V5ID0ga2V5ICsgc3VmZml4O1xuICAgICAgICBvYmpbcHJvbWlzaWZpZWRLZXldID0gcHJvbWlzaWZpZXIgPT09IG1ha2VOb2RlUHJvbWlzaWZpZWRcbiAgICAgICAgICAgICAgICA/IG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksIGZuLCBzdWZmaXgpXG4gICAgICAgICAgICAgICAgOiBwcm9taXNpZmllcihmbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGtleSwgVEhJUywga2V5LCBmbiwgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KGNhbGxiYWNrLCByZWNlaXZlcikge1xuICAgIHJldHVybiBtYWtlTm9kZVByb21pc2lmaWVkKGNhbGxiYWNrLCByZWNlaXZlciwgdW5kZWZpbmVkLCBjYWxsYmFjayk7XG59XG5cblByb21pc2UucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZm4gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOTE2bEpKXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKGlzUHJvbWlzaWZpZWQoZm4pKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHByb21pc2lmeShmbiwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBUSElTIDogcmVjZWl2ZXIpO1xuICAgIHV0aWwuY29weURlc2NyaXB0b3JzKGZuLCByZXQsIHByb3BzRmlsdGVyKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm9taXNpZnlBbGwgPSBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgdGFyZ2V0IG9mIHByb21pc2lmeUFsbCBtdXN0IGJlIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvOUlUbFYwXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IE9iamVjdChvcHRpb25zKTtcbiAgICB2YXIgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXg7XG4gICAgaWYgKHR5cGVvZiBzdWZmaXggIT09IFwic3RyaW5nXCIpIHN1ZmZpeCA9IGRlZmF1bHRTdWZmaXg7XG4gICAgdmFyIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXI7XG4gICAgdmFyIHByb21pc2lmaWVyID0gb3B0aW9ucy5wcm9taXNpZmllcjtcbiAgICBpZiAodHlwZW9mIHByb21pc2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHByb21pc2lmaWVyID0gbWFrZU5vZGVQcm9taXNpZmllZDtcblxuICAgIGlmICghdXRpbC5pc0lkZW50aWZpZXIoc3VmZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInN1ZmZpeCBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzhGWm81VlxcdTAwMGFcIik7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKHRhcmdldCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhcmdldFtrZXlzW2ldXTtcbiAgICAgICAgaWYgKGtleXNbaV0gIT09IFwiY29uc3RydWN0b3JcIiAmJlxuICAgICAgICAgICAgdXRpbC5pc0NsYXNzKHZhbHVlKSkge1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLnByb3RvdHlwZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyKTtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZSwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNpZnlBbGwodGFyZ2V0LCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIpO1xufTtcbn07XG5cblxufSx7XCIuL2Vycm9yc1wiOjEzLFwiLi9wcm9taXNlX3Jlc29sdmVyLmpzXCI6MjUsXCIuL3V0aWwuanNcIjozOH1dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbnZhciBlczUgPSBfZGVyZXFfKFwiLi9lczUuanNcIik7XG5cbmZ1bmN0aW9uIFByb3BlcnRpZXNQcm9taXNlQXJyYXkob2JqKSB7XG4gICAgdmFyIGtleXMgPSBlczUua2V5cyhvYmopO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXldO1xuICAgICAgICB2YWx1ZXNbaSArIGxlbl0gPSBrZXk7XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFByb3BlcnRpZXNQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTMpIDtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbCA9IHt9O1xuICAgICAgICB2YXIga2V5T2Zmc2V0ID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFsW3RoaXMuX3ZhbHVlc1tpICsga2V5T2Zmc2V0XV0gPSB0aGlzLl92YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWwpO1xuICAgIH1cbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUHJvZ3Jlc3NlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl9wcm9taXNlLl9wcm9ncmVzcyh7XG4gICAgICAgIGtleTogdGhpcy5fdmFsdWVzW2luZGV4ICsgdGhpcy5sZW5ndGgoKV0sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5nZXRBY3R1YWxMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgcmV0dXJuIGxlbiA+PiAxO1xufTtcblxuZnVuY3Rpb24gcHJvcHMocHJvbWlzZXMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBjYXN0VmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHByb21pc2VzKTtcblxuICAgIGlmICghaXNPYmplY3QoY2FzdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiY2Fubm90IGF3YWl0IHByb3BlcnRpZXMgb2YgYSBub24tb2JqZWN0XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvT3NGS0M4XFx1MDAwYVwiKTtcbiAgICB9IGVsc2UgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0ID0gY2FzdFZhbHVlLl90aGVuKFxuICAgICAgICAgICAgUHJvbWlzZS5wcm9wcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBuZXcgUHJvcGVydGllc1Byb21pc2VBcnJheShjYXN0VmFsdWUpLnByb21pc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoY2FzdFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20oY2FzdFZhbHVlLCA0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb3BzKHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm9wcyA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiBwcm9wcyhwcm9taXNlcyk7XG59O1xufTtcblxufSx7XCIuL2VzNS5qc1wiOjE0LFwiLi91dGlsLmpzXCI6Mzh9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGFycmF5TW92ZShzcmMsIHNyY0luZGV4LCBkc3QsIGRzdEluZGV4LCBsZW4pIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICAgIGRzdFtqICsgZHN0SW5kZXhdID0gc3JjW2ogKyBzcmNJbmRleF07XG4gICAgICAgIHNyY1tqICsgc3JjSW5kZXhdID0gdm9pZCAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUXVldWUoY2FwYWNpdHkpIHtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fZnJvbnQgPSAwO1xufVxuXG5RdWV1ZS5wcm90b3R5cGUuX3dpbGxCZU92ZXJDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFjaXR5IDwgc2l6ZTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcHVzaE9uZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCArIDEpO1xuICAgIHZhciBpID0gKHRoaXMuX2Zyb250ICsgbGVuZ3RoKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXNbaV0gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoICsgMTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fdW5zaGlmdE9uZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGNhcGFjaXR5ID0gdGhpcy5fY2FwYWNpdHk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eSh0aGlzLmxlbmd0aCgpICsgMSk7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgdmFyIGkgPSAoKCgoIGZyb250IC0gMSApICZcbiAgICAgICAgICAgICAgICAgICAgKCBjYXBhY2l0eSAtIDEpICkgXiBjYXBhY2l0eSApIC0gY2FwYWNpdHkgKTtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gICAgdGhpcy5fZnJvbnQgPSBpO1xuICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMubGVuZ3RoKCkgKyAxO1xufTtcblxuUXVldWUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX3Vuc2hpZnRPbmUoYXJnKTtcbiAgICB0aGlzLl91bnNoaWZ0T25lKHJlY2VpdmVyKTtcbiAgICB0aGlzLl91bnNoaWZ0T25lKGZuKTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCkgKyAzO1xuICAgIGlmICh0aGlzLl93aWxsQmVPdmVyQ2FwYWNpdHkobGVuZ3RoKSkge1xuICAgICAgICB0aGlzLl9wdXNoT25lKGZuKTtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShyZWNlaXZlcik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUoYXJnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaiA9IHRoaXMuX2Zyb250ICsgbGVuZ3RoIC0gMztcbiAgICB0aGlzLl9jaGVja0NhcGFjaXR5KGxlbmd0aCk7XG4gICAgdmFyIHdyYXBNYXNrID0gdGhpcy5fY2FwYWNpdHkgLSAxO1xuICAgIHRoaXNbKGogKyAwKSAmIHdyYXBNYXNrXSA9IGZuO1xuICAgIHRoaXNbKGogKyAxKSAmIHdyYXBNYXNrXSA9IHJlY2VpdmVyO1xuICAgIHRoaXNbKGogKyAyKSAmIHdyYXBNYXNrXSA9IGFyZztcbiAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQsXG4gICAgICAgIHJldCA9IHRoaXNbZnJvbnRdO1xuXG4gICAgdGhpc1tmcm9udF0gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnJvbnQgPSAoZnJvbnQgKyAxKSAmICh0aGlzLl9jYXBhY2l0eSAtIDEpO1xuICAgIHRoaXMuX2xlbmd0aC0tO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX2NoZWNrQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIGlmICh0aGlzLl9jYXBhY2l0eSA8IHNpemUpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplVG8odGhpcy5fY2FwYWNpdHkgPDwgMSk7XG4gICAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLl9yZXNpemVUbyA9IGZ1bmN0aW9uIChjYXBhY2l0eSkge1xuICAgIHZhciBvbGRDYXBhY2l0eSA9IHRoaXMuX2NhcGFjaXR5O1xuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuX2xlbmd0aDtcbiAgICB2YXIgbW92ZUl0ZW1zQ291bnQgPSAoZnJvbnQgKyBsZW5ndGgpICYgKG9sZENhcGFjaXR5IC0gMSk7XG4gICAgYXJyYXlNb3ZlKHRoaXMsIDAsIHRoaXMsIG9sZENhcGFjaXR5LCBtb3ZlSXRlbXNDb3VudCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXVlO1xuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oXG4gICAgUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbikge1xudmFyIGlzQXJyYXkgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpLmlzQXJyYXk7XG5cbnZhciByYWNlTGF0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhY2UoYXJyYXksIHByb21pc2UpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gcmFjZShwcm9taXNlcywgcGFyZW50KSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocHJvbWlzZXMpO1xuXG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJhY2VMYXRlcihtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYW4gYXJyYXksIGEgcHJvbWlzZSBvciBhIHRoZW5hYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvczhNTWhjXFx1MDAwYVwiKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20ocGFyZW50LCA0IHwgMSk7XG4gICAgfVxuICAgIHZhciBmdWxmaWxsID0gcmV0Ll9mdWxmaWxsO1xuICAgIHZhciByZWplY3QgPSByZXQuX3JlamVjdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvbWlzZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbCA9IHByb21pc2VzW2ldO1xuXG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuY2FzdCh2YWwpLl90aGVuKGZ1bGZpbGwsIHJlamVjdCwgdW5kZWZpbmVkLCByZXQsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcmFjZShwcm9taXNlcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJhY2UodGhpcywgdW5kZWZpbmVkKTtcbn07XG5cbn07XG5cbn0se1wiLi91dGlsLmpzXCI6Mzh9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMKSB7XG52YXIgYXN5bmMgPSBfZGVyZXFfKFwiLi9hc3luYy5qc1wiKTtcbnZhciB1dGlsID0gX2RlcmVxXyhcIi4vdXRpbC5qc1wiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuZnVuY3Rpb24gUmVkdWN0aW9uUHJvbWlzZUFycmF5KHByb21pc2VzLCBmbiwgYWNjdW0sIF9lYWNoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQocHJvbWlzZXMpO1xuICAgIHRoaXMuX3Byb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgdGhpcy5fcHJlc2VydmVkVmFsdWVzID0gX2VhY2ggPT09IElOVEVSTkFMID8gW10gOiBudWxsO1xuICAgIHRoaXMuX3plcm90aElzQWNjdW0gPSAoYWNjdW0gPT09IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5fZ290QWNjdW0gPSBmYWxzZTtcbiAgICB0aGlzLl9yZWR1Y2luZ0luZGV4ID0gKHRoaXMuX3plcm90aElzQWNjdW0gPyAxIDogMCk7XG4gICAgdGhpcy5fdmFsdWVzUGhhc2UgPSB1bmRlZmluZWQ7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UoYWNjdW0sIHRoaXMuX3Byb21pc2UpO1xuICAgIHZhciByZWplY3RlZCA9IGZhbHNlO1xuICAgIHZhciBpc1Byb21pc2UgPSBtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNQZW5kaW5nKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHlQcm9taXNlQXJyYXkodGhpcywgLTEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5faXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgYWNjdW0gPSBtYXliZVByb21pc2UuX3ZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLl9nb3RBY2N1bSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICByZWplY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEoaXNQcm9taXNlIHx8IHRoaXMuX3plcm90aElzQWNjdW0pKSB0aGlzLl9nb3RBY2N1bSA9IHRydWU7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBmbjtcbiAgICB0aGlzLl9hY2N1bSA9IGFjY3VtO1xuICAgIGlmICghcmVqZWN0ZWQpIGFzeW5jLmludm9rZShpbml0LCB0aGlzLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC01KTtcbn1cbnV0aWwuaW5oZXJpdHMoUmVkdWN0aW9uUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9nb3RBY2N1bSB8fCB0aGlzLl96ZXJvdGhJc0FjY3VtKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcy5fcHJlc2VydmVkVmFsdWVzICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdIDogdGhpcy5fYWNjdW0pO1xuICAgIH1cbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuX3ZhbHVlcztcbiAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICB2YXIgaXNFYWNoID0gcHJlc2VydmVkVmFsdWVzICE9PSBudWxsO1xuICAgIHZhciBnb3RBY2N1bSA9IHRoaXMuX2dvdEFjY3VtO1xuICAgIHZhciB2YWx1ZXNQaGFzZSA9IHRoaXMuX3ZhbHVlc1BoYXNlO1xuICAgIHZhciB2YWx1ZXNQaGFzZUluZGV4O1xuICAgIGlmICghdmFsdWVzUGhhc2UpIHtcbiAgICAgICAgdmFsdWVzUGhhc2UgPSB0aGlzLl92YWx1ZXNQaGFzZSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhbHVlc1BoYXNlSW5kZXg9MDsgdmFsdWVzUGhhc2VJbmRleDxsZW5ndGg7ICsrdmFsdWVzUGhhc2VJbmRleCkge1xuICAgICAgICAgICAgdmFsdWVzUGhhc2VbdmFsdWVzUGhhc2VJbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbHVlc1BoYXNlSW5kZXggPSB2YWx1ZXNQaGFzZVtpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5femVyb3RoSXNBY2N1bSkge1xuICAgICAgICB0aGlzLl9hY2N1bSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9nb3RBY2N1bSA9IGdvdEFjY3VtID0gdHJ1ZTtcbiAgICAgICAgdmFsdWVzUGhhc2VbaW5kZXhdID0gKCh2YWx1ZXNQaGFzZUluZGV4ID09PSAwKVxuICAgICAgICAgICAgPyAxIDogMik7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fYWNjdW0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZ290QWNjdW0gPSBnb3RBY2N1bSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlc1BoYXNlSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlc1BoYXNlW2luZGV4XSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXNQaGFzZVtpbmRleF0gPSAyO1xuICAgICAgICAgICAgdGhpcy5fYWNjdW0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdvdEFjY3VtKSByZXR1cm47XG5cbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLl9wcm9taXNlLl9ib3VuZFRvO1xuICAgIHZhciByZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5fcmVkdWNpbmdJbmRleDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhbHVlc1BoYXNlSW5kZXggPSB2YWx1ZXNQaGFzZVtpXTtcbiAgICAgICAgaWYgKHZhbHVlc1BoYXNlSW5kZXggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZHVjaW5nSW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXNQaGFzZUluZGV4ICE9PSAxKSByZXR1cm47XG4gICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICBpZiAoaXNFYWNoKSB7XG4gICAgICAgICAgICBwcmVzZXJ2ZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXQgPSB0cnlDYXRjaChjYWxsYmFjaykuY2FsbChyZWNlaXZlciwgdmFsdWUsIGksIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB0cnlDYXRjaChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2FsbChyZWNlaXZlciwgdGhpcy5fYWNjdW0sIHZhbHVlLCBpLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3BvcENvbnRleHQoKTtcblxuICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgcmV0dXJuIHRoaXMuX3JlamVjdChyZXQuZSk7XG5cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmV0LCB0aGlzLl9wcm9taXNlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlLl9pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1BoYXNlW2ldID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl9wcm94eVByb21pc2VBcnJheSh0aGlzLCBpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF5YmVQcm9taXNlLl9pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbWF5YmVQcm9taXNlLl92YWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVkdWNpbmdJbmRleCA9IGkgKyAxO1xuICAgICAgICB0aGlzLl9hY2N1bSA9IHJldDtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNvbHZlKGlzRWFjaCA/IHByZXNlcnZlZFZhbHVlcyA6IHRoaXMuX2FjY3VtKTtcbn07XG5cbmZ1bmN0aW9uIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBhcGlSZWplY3Rpb24oXCJmbiBtdXN0IGJlIGEgZnVuY3Rpb25cXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC85MTZsSkpcXHUwMDBhXCIpO1xuICAgIHZhciBhcnJheSA9IG5ldyBSZWR1Y3Rpb25Qcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKTtcbiAgICByZXR1cm4gYXJyYXkucHJvbWlzZSgpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiByZWR1Y2UodGhpcywgZm4sIGluaXRpYWxWYWx1ZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnJlZHVjZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICByZXR1cm4gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCk7XG59O1xufTtcblxufSx7XCIuL2FzeW5jLmpzXCI6MixcIi4vdXRpbC5qc1wiOjM4fV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgc2NoZWR1bGU7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWxcIik7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9tM09UWGtcXHUwMDBhXCIpO1xufTtcbmlmICh1dGlsLmlzTm9kZSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBHbG9iYWxTZXRJbW1lZGlhdGUgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBQcm9jZXNzTmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIHNjaGVkdWxlID0gdXRpbC5pc1JlY2VudE5vZGVcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGZuKSB7IEdsb2JhbFNldEltbWVkaWF0ZS5jYWxsKGdsb2JhbCwgZm4pOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbihmbikgeyBQcm9jZXNzTmV4dFRpY2suY2FsbChwcm9jZXNzLCBmbik7IH07XG59IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZm4pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGRpdiwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTsgfTtcbiAgICB9O1xuICAgIHNjaGVkdWxlLmlzU3RhdGljID0gdHJ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHNjaGVkdWxlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHNldFRpbWVvdXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBzY2hlZHVsZSA9IG5vQXN5bmNTY2hlZHVsZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNjaGVkdWxlO1xuXG59LHtcIi4vdXRpbFwiOjM4fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG4gICAgZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5KSB7XG52YXIgUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uO1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xuXG5mdW5jdGlvbiBTZXR0bGVkUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFNldHRsZWRQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVzb2x2ZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGluc3BlY3Rpb24pIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgIH1cbn07XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMjY4NDM1NDU2O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5fcHJvbWlzZVJlc29sdmVkKGluZGV4LCByZXQpO1xufTtcblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uLCBpbmRleCkge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICByZXQuX2JpdEZpZWxkID0gMTM0MjE3NzI4O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlID0gcmVhc29uO1xuICAgIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5cblByb21pc2Uuc2V0dGxlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHRoaXMpLnByb21pc2UoKTtcbn07XG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbikge1xudmFyIHV0aWwgPSBfZGVyZXFfKFwiLi91dGlsLmpzXCIpO1xudmFyIFJhbmdlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIikuUmFuZ2VFcnJvcjtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IF9kZXJlcV8oXCIuL2Vycm9ycy5qc1wiKS5BZ2dyZWdhdGVFcnJvcjtcbnZhciBpc0FycmF5ID0gdXRpbC5pc0FycmF5O1xuXG5cbmZ1bmN0aW9uIFNvbWVQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciQodmFsdWVzKTtcbiAgICB0aGlzLl9ob3dNYW55ID0gMDtcbiAgICB0aGlzLl91bndyYXAgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhTb21lUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2hvd01hbnkgPT09IDApIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZShbXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCAtNSk7XG4gICAgdmFyIGlzQXJyYXlSZXNvbHZlZCA9IGlzQXJyYXkodGhpcy5fdmFsdWVzKTtcbiAgICBpZiAoIXRoaXMuX2lzUmVzb2x2ZWQoKSAmJlxuICAgICAgICBpc0FycmF5UmVzb2x2ZWQgJiZcbiAgICAgICAgdGhpcy5faG93TWFueSA+IHRoaXMuX2NhblBvc3NpYmx5RnVsZmlsbCgpKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKHRoaXMubGVuZ3RoKCkpKTtcbiAgICB9XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pbml0KCk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zZXRVbndyYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdW53cmFwID0gdHJ1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLmhvd01hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvd01hbnk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zZXRIb3dNYW55ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdGhpcy5faG93TWFueSA9IGNvdW50O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLl9hZGRGdWxmaWxsZWQodmFsdWUpO1xuICAgIGlmICh0aGlzLl9mdWxmaWxsZWQoKSA9PT0gdGhpcy5ob3dNYW55KCkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IHRoaXMuaG93TWFueSgpO1xuICAgICAgICBpZiAodGhpcy5ob3dNYW55KCkgPT09IDEgJiYgdGhpcy5fdW53cmFwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgaWYgKHRoaXMuaG93TWFueSgpID4gdGhpcy5fY2FuUG9zc2libHlGdWxmaWxsKCkpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgQWdncmVnYXRlRXJyb3IoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoKCk7IGkgPCB0aGlzLl92YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGUucHVzaCh0aGlzLl92YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlamVjdChlKTtcbiAgICB9XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl90b3RhbFJlc29sdmVkO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gdGhpcy5sZW5ndGgoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hZGRSZWplY3RlZCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLl92YWx1ZXMucHVzaChyZWFzb24pO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3ZhbHVlc1t0aGlzLl90b3RhbFJlc29sdmVkKytdID0gdmFsdWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fY2FuUG9zc2libHlGdWxmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCgpIC0gdGhpcy5fcmVqZWN0ZWQoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9nZXRSYW5nZUVycm9yID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBcIklucHV0IGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBcIiArXG4gICAgICAgICAgICB0aGlzLl9ob3dNYW55ICsgXCIgaXRlbXMgYnV0IGNvbnRhaW5zIG9ubHkgXCIgKyBjb3VudCArIFwiIGl0ZW1zXCI7XG4gICAgcmV0dXJuIG5ldyBSYW5nZUVycm9yKG1lc3NhZ2UpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlamVjdCh0aGlzLl9nZXRSYW5nZUVycm9yKDApKTtcbn07XG5cbmZ1bmN0aW9uIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpIHtcbiAgICBpZiAoKGhvd01hbnkgfCAwKSAhPT0gaG93TWFueSB8fCBob3dNYW55IDwgMCkge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzF3QW1IeFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgU29tZVByb21pc2VBcnJheShwcm9taXNlcyk7XG4gICAgdmFyIHByb21pc2UgPSByZXQucHJvbWlzZSgpO1xuICAgIHJldC5zZXRIb3dNYW55KGhvd01hbnkpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2Uuc29tZSA9IGZ1bmN0aW9uIChwcm9taXNlcywgaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHByb21pc2VzLCBob3dNYW55KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoaG93TWFueSkge1xuICAgIHJldHVybiBzb21lKHRoaXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5fU29tZVByb21pc2VBcnJheSA9IFNvbWVQcm9taXNlQXJyYXk7XG59O1xuXG59LHtcIi4vZXJyb3JzLmpzXCI6MTMsXCIuL3V0aWwuanNcIjozOH1dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZSA9IHByb21pc2UuX3NldHRsZWRWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICAgICAgdGhpcy5fc2V0dGxlZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IGZ1bGZpbGxtZW50IHZhbHVlIG9mIGEgbm9uLWZ1bGZpbGxlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaGMxRExqXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5lcnJvciA9XG5Qcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUucmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgcmVqZWN0aW9uIHJlYXNvbiBvZiBhIG5vbi1yZWplY3RlZCBwcm9taXNlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvaFB1aXdCXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5faXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2ODQzNTQ1NikgPiAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVqZWN0ZWQgPVxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEzNDIxNzcyOCkgPiAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUGVuZGluZyA9XG5Qcm9taXNlLnByb3RvdHlwZS5faXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA0MDI2NTMxODQpID09PSAwO1xufTtcblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPVxuUHJvbWlzZS5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDQwMjY1MzE4NCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9pc1BlbmRpbmcoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0KCkuX2lzUmVqZWN0ZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldCgpLl9pc0Z1bGZpbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5faXNSZXNvbHZlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldCgpO1xuICAgIGlmICghdGFyZ2V0LmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9oYzFETGpcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0Ll9zZXR0bGVkVmFsdWU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0KCk7XG4gICAgaWYgKCF0YXJnZXQuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgZ2V0IHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL2hQdWl3QlxcdTAwMGFcIik7XG4gICAgfVxuICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgIHJldHVybiB0YXJnZXQuX3NldHRsZWRWYWx1ZTtcbn07XG5cblxuUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xufTtcblxufSx7fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcblxuZnVuY3Rpb24gdHJ5Q29udmVydFRvUHJvbWlzZShvYmosIGNvbnRleHQpIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FueUJsdWViaXJkUHJvbWlzZShvYmopKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgb2JqLl90aGVuKFxuICAgICAgICAgICAgICAgIHJldC5fZnVsZmlsbFVuY2hlY2tlZCxcbiAgICAgICAgICAgICAgICByZXQuX3JlamVjdFVuY2hlY2tlZENoZWNrRXJyb3IsXG4gICAgICAgICAgICAgICAgcmV0Ll9wcm9ncmVzc1VuY2hlY2tlZCxcbiAgICAgICAgICAgICAgICByZXQsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoZW4gPSB1dGlsLnRyeUNhdGNoKGdldFRoZW4pKG9iaik7XG4gICAgICAgIGlmICh0aGVuID09PSBlcnJvck9iaikge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgcmV0ID0gUHJvbWlzZS5yZWplY3QodGhlbi5lKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb1RoZW5hYmxlKG9iaiwgdGhlbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG59XG5cbnZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc0FueUJsdWViaXJkUHJvbWlzZShvYmopIHtcbiAgICByZXR1cm4gaGFzUHJvcC5jYWxsKG9iaiwgXCJfcHJvbWlzZTBcIik7XG59XG5cbmZ1bmN0aW9uIGRvVGhlbmFibGUoeCwgdGhlbiwgY29udGV4dCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciByZXQgPSBwcm9taXNlO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wdXNoQ29udGV4dCgpO1xuICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICB2YXIgc3luY2hyb25vdXMgPSB0cnVlO1xuICAgIHZhciByZXN1bHQgPSB1dGlsLnRyeUNhdGNoKHRoZW4pLmNhbGwoeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlRnJvbVRoZW5hYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEZyb21UaGVuYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0Zyb21UaGVuYWJsZSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICBpZiAocHJvbWlzZSAmJiByZXN1bHQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlc3VsdC5lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZyb21UaGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgaWYgKHggPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhcbiAgICAgICAgICAgICAgICBQcm9taXNlLl9tYWtlU2VsZlJlc29sdXRpb25FcnJvcigpLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdEZyb21UaGVuYWJsZShyZWFzb24pIHtcbiAgICAgICAgaWYgKCFwcm9taXNlKSByZXR1cm47XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHJlYXNvbiwgc3luY2hyb25vdXMsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9ncmVzc0Zyb21UaGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXByb21pc2UpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9taXNlLl9wcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9wcm9ncmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxucmV0dXJuIHRyeUNvbnZlcnRUb1Byb21pc2U7XG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMKSB7XG52YXIgdXRpbCA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIik7XG52YXIgVGltZW91dEVycm9yID0gUHJvbWlzZS5UaW1lb3V0RXJyb3I7XG5cbnZhciBhZnRlclRpbWVvdXQgPSBmdW5jdGlvbiAocHJvbWlzZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJvbWlzZS5pc1BlbmRpbmcoKSkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gXCJvcGVyYXRpb24gdGltZWQgb3V0XCI7XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIHV0aWwubWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGVycik7XG4gICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShlcnIpO1xuICAgIHByb21pc2UuX2NhbmNlbChlcnIpO1xufTtcblxudmFyIGFmdGVyVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gZGVsYXkoK3RoaXMpLnRoZW5SZXR1cm4odmFsdWUpOyB9O1xudmFyIGRlbGF5ID0gUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uICh2YWx1ZSwgbXMpIHtcbiAgICBpZiAobXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtcyA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgcmV0Ll9mdWxmaWxsKCk7IH0sIG1zKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbXMgPSArbXM7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChtcykge1xuICAgIHJldHVybiBkZWxheSh0aGlzLCBtcyk7XG59O1xuXG5mdW5jdGlvbiBzdWNjZXNzQ2xlYXIodmFsdWUpIHtcbiAgICB2YXIgaGFuZGxlID0gdGhpcztcbiAgICBpZiAoaGFuZGxlIGluc3RhbmNlb2YgTnVtYmVyKSBoYW5kbGUgPSAraGFuZGxlO1xuICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZmFpbHVyZUNsZWFyKHJlYXNvbikge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzO1xuICAgIGlmIChoYW5kbGUgaW5zdGFuY2VvZiBOdW1iZXIpIGhhbmRsZSA9ICtoYW5kbGU7XG4gICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgdGhyb3cgcmVhc29uO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgbXMgPSArbXM7XG4gICAgdmFyIHJldCA9IHRoaXMudGhlbigpLmNhbmNlbGxhYmxlKCk7XG4gICAgcmV0Ll9jYW5jZWxsYXRpb25QYXJlbnQgPSB0aGlzO1xuICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXRUaW1lb3V0KCkge1xuICAgICAgICBhZnRlclRpbWVvdXQocmV0LCBtZXNzYWdlKTtcbiAgICB9LCBtcyk7XG4gICAgcmV0dXJuIHJldC5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhciwgdW5kZWZpbmVkLCBoYW5kbGUsIHVuZGVmaW5lZCk7XG59O1xuXG59O1xuXG59LHtcIi4vdXRpbC5qc1wiOjM4fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgY3JlYXRlQ29udGV4dCkge1xuICAgIHZhciBUeXBlRXJyb3IgPSBfZGVyZXFfKFwiLi9lcnJvcnMuanNcIikuVHlwZUVycm9yO1xuICAgIHZhciBpbmhlcml0cyA9IF9kZXJlcV8oXCIuL3V0aWwuanNcIikuaW5oZXJpdHM7XG4gICAgdmFyIFByb21pc2VJbnNwZWN0aW9uID0gUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbjtcblxuICAgIGZ1bmN0aW9uIGluc3BlY3Rpb25NYXBwZXIoaW5zcGVjdGlvbnMpIHtcbiAgICAgICAgdmFyIGxlbiA9IGluc3BlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBpbnNwZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0aW9uLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChpbnNwZWN0aW9uLmVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zcGVjdGlvbnNbaV0gPSBpbnNwZWN0aW9uLl9zZXR0bGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3BlY3Rpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm93ZXIoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZTt9LCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYXN0UHJlc2VydmluZ0Rpc3Bvc2FibGUodGhlbmFibGUpIHtcbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UodGhlbmFibGUpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlICE9PSB0aGVuYWJsZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9pc0Rpc3Bvc2FibGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoZW5hYmxlLl9nZXREaXNwb3NlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0aGVuYWJsZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fc2V0RGlzcG9zYWJsZSh0aGVuYWJsZS5fZ2V0RGlzcG9zZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcG9zZShyZXNvdXJjZXMsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcmVzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldCA9IFByb21pc2UuZGVmZXIoKTtcbiAgICAgICAgZnVuY3Rpb24gaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHJldHVybiByZXQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGNhc3RQcmVzZXJ2aW5nRGlzcG9zYWJsZShyZXNvdXJjZXNbaSsrXSk7XG4gICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5faXNEaXNwb3NhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9nZXREaXNwb3NlcigpLnRyeURpc3Bvc2UoaW5zcGVjdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dlcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihpdGVyYXRvciwgdGhyb3dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRvcigpO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiByZXQucHJvbWlzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwb3NlclN1Y2Nlc3ModmFsdWUpIHtcbiAgICAgICAgdmFyIGluc3BlY3Rpb24gPSBuZXcgUHJvbWlzZUluc3BlY3Rpb24oKTtcbiAgICAgICAgaW5zcGVjdGlvbi5fc2V0dGxlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGluc3BlY3Rpb24uX2JpdEZpZWxkID0gMjY4NDM1NDU2O1xuICAgICAgICByZXR1cm4gZGlzcG9zZSh0aGlzLCBpbnNwZWN0aW9uKS50aGVuUmV0dXJuKHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXNwb3NlckZhaWwocmVhc29uKSB7XG4gICAgICAgIHZhciBpbnNwZWN0aW9uID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgICAgIGluc3BlY3Rpb24uX3NldHRsZWRWYWx1ZSA9IHJlYXNvbjtcbiAgICAgICAgaW5zcGVjdGlvbi5fYml0RmllbGQgPSAxMzQyMTc3Mjg7XG4gICAgICAgIHJldHVybiBkaXNwb3NlKHRoaXMsIGluc3BlY3Rpb24pLnRoZW5UaHJvdyhyZWFzb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERpc3Bvc2VyKGRhdGEsIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLnJlc291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlKCkuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS50cnlEaXNwb3NlID0gZnVuY3Rpb24oaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHJlc291cmNlICE9PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMuZG9EaXNwb3NlKHJlc291cmNlLCBpbnNwZWN0aW9uKSA6IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fdW5zZXREaXNwb3NhYmxlKCk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5pc0Rpc3Bvc2VyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIChkICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZC5yZXNvdXJjZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQudHJ5RGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25EaXNwb3NlcihmbiwgcHJvbWlzZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yJChmbiwgcHJvbWlzZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGluaGVyaXRzKEZ1bmN0aW9uRGlzcG9zZXIsIERpc3Bvc2VyKTtcblxuICAgIEZ1bmN0aW9uRGlzcG9zZXIucHJvdG90eXBlLmRvRGlzcG9zZSA9IGZ1bmN0aW9uIChyZXNvdXJjZSwgaW5zcGVjdGlvbikge1xuICAgICAgICB2YXIgZm4gPSB0aGlzLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwocmVzb3VyY2UsIHJlc291cmNlLCBpbnNwZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWF5YmVVbndyYXBEaXNwb3Nlcih2YWx1ZSkge1xuICAgICAgICBpZiAoRGlzcG9zZXIuaXNEaXNwb3Nlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzW3RoaXMuaW5kZXhdLl9zZXREaXNwb3NhYmxlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5wcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIFByb21pc2UudXNpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgMikgcmV0dXJuIGFwaVJlamVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieW91IG11c3QgcGFzcyBhdCBsZWFzdCAyIGFyZ3VtZW50cyB0byBQcm9taXNlLnVzaW5nXCIpO1xuICAgICAgICB2YXIgZm4gPSBhcmd1bWVudHNbbGVuIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGFwaVJlamVjdGlvbihcImZuIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsLzkxNmxKSlxcdTAwMGFcIik7XG4gICAgICAgIGxlbi0tO1xuICAgICAgICB2YXIgcmVzb3VyY2VzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChEaXNwb3Nlci5pc0Rpc3Bvc2VyKHJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNwb3NlciA9IHJlc291cmNlO1xuICAgICAgICAgICAgICAgIHJlc291cmNlID0gcmVzb3VyY2UucHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJlc291cmNlLl9zZXREaXNwb3NhYmxlKGRpc3Bvc2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fdGhlbihtYXliZVVud3JhcERpc3Bvc2VyLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvdXJjZXNbaV0gPSByZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5zZXR0bGUocmVzb3VyY2VzKVxuICAgICAgICAgICAgLnRoZW4oaW5zcGVjdGlvbk1hcHBlcilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uYXBwbHkodW5kZWZpbmVkLCB2YWxzKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLl90aGVuKFxuICAgICAgICAgICAgICAgIGRpc3Bvc2VyU3VjY2VzcywgZGlzcG9zZXJGYWlsLCB1bmRlZmluZWQsIHJlc291cmNlcywgdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzb3VyY2VzLnByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3NldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2MjE0NDtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSBkaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2lzRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDI2MjE0NCkgPiAwO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5fZ2V0RGlzcG9zZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlcjtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0RGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjYyMTQ0KTtcbiAgICAgICAgdGhpcy5fZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLmRpc3Bvc2VyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkRpc3Bvc2VyKGZuLCB0aGlzLCBjcmVhdGVDb250ZXh0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9O1xuXG59O1xuXG59LHtcIi4vZXJyb3JzLmpzXCI6MTMsXCIuL3V0aWwuanNcIjozOH1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IF9kZXJlcV8oXCIuL2VzNS5qc1wiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBoYXZlR2V0dGVycyA9IChmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvID0ge307XG4gICAgICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShvLCBcImZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gby5mID09PSAzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KSgpO1xuXG52YXIgZXJyb3JPYmogPSB7ZToge319O1xudmFyIHRyeUNhdGNoVGFyZ2V0O1xuZnVuY3Rpb24gdHJ5Q2F0Y2hlcigpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHJ5Q2F0Y2hUYXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqLmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJ5Q2F0Y2goZm4pIHtcbiAgICB0cnlDYXRjaFRhcmdldCA9IGZuO1xuICAgIHJldHVybiB0cnlDYXRjaGVyO1xufVxuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbihDaGlsZCwgUGFyZW50KSB7XG4gICAgdmFyIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIFQoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBDaGlsZDtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQgPSBQYXJlbnQ7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBQYXJlbnQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKFBhcmVudC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSkgJiZcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUuY2hhckF0KHByb3BlcnR5TmFtZS5sZW5ndGgtMSkgIT09IFwiJFwiXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lICsgXCIkXCJdID0gUGFyZW50LnByb3RvdHlwZVtwcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFQucHJvdG90eXBlID0gUGFyZW50LnByb3RvdHlwZTtcbiAgICBDaGlsZC5wcm90b3R5cGUgPSBuZXcgVCgpO1xuICAgIHJldHVybiBDaGlsZC5wcm90b3R5cGU7XG59O1xuXG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fFxuICAgICAgICB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCI7XG5cbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gIWlzUHJpbWl0aXZlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0ID09IG51bGwgJiYgZGVzYy5zZXQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IGRlc2MudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vdEVudW1lcmFibGVQcm9wKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqKSkgcmV0dXJuIG9iajtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH07XG4gICAgZXM1LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG52YXIgd3JhcHNQcmltaXRpdmVSZWNlaXZlciA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcyAhPT0gXCJzdHJpbmdcIjtcbn0pLmNhbGwoXCJzdHJpbmdcIik7XG5cbmZ1bmN0aW9uIHRocm93ZXIocikge1xuICAgIHRocm93IHI7XG59XG5cbnZhciBpbmhlcml0ZWREYXRhS2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBvUHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuICAgICAgICB2YXIgZ2V0S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICB2YXIgdmlzaXRlZEtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgd2hpbGUgKG9iaiAhPSBudWxsICYmIG9iaiAhPT0gb1Byb3RvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IGdldEtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRLZXlzW2tleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCAmJiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gZXM1LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSgpO1xuXG52YXIgdGhpc0Fzc2lnbm1lbnRQYXR0ZXJuID0gL3RoaXNcXHMqXFwuXFxzKlxcUytcXHMqPS87XG5mdW5jdGlvbiBpc0NsYXNzKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmbi5wcm90b3R5cGUpO1xuICAgICAgICAgICAgaWYgKCgoZXM1LmlzRVM1ICYmIGtleXMubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICAoa2V5cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgIShrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSBcImNvbnN0cnVjdG9yXCIpKSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzQXNzaWdubWVudFBhdHRlcm4udGVzdChmbiArIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNywtVzA1NSwtVzAzMSovXG4gICAgZnVuY3Rpb24gZigpIHt9XG4gICAgZi5wcm90b3R5cGUgPSBvYmo7XG4gICAgdmFyIGwgPSA4O1xuICAgIHdoaWxlIChsLS0pIG5ldyBmKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AoZSwgXCJpc09wZXJhdGlvbmFsXCIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaChpZ25vcmUpIHt9XG59XG5cbmZ1bmN0aW9uIG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICBpZiAoZSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICgoZSBpbnN0YW5jZW9mIEVycm9yW1wiX19CbHVlYmlyZEVycm9yVHlwZXNfX1wiXS5PcGVyYXRpb25hbEVycm9yKSB8fFxuICAgICAgICBlW1wiaXNPcGVyYXRpb25hbFwiXSA9PT0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNhbkF0dGFjaFRyYWNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBFcnJvciAmJiBlczUucHJvcGVydHlJc1dyaXRhYmxlKG9iaiwgXCJzdGFja1wiKTtcbn1cblxudmFyIGVuc3VyZUVycm9yT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBuZXcgRXJyb3IoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB0cnkge3Rocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTt9XG4gICAgICAgICAgICBjYXRjaChlcnIpIHtyZXR1cm4gZXJyO31cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gY29weURlc2NyaXB0b3JzKGZyb20sIHRvLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmcm9tKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChmaWx0ZXIoa2V5KSkge1xuICAgICAgICAgICAgZXM1LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIGVzNS5nZXREZXNjcmlwdG9yKGZyb20sIGtleSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc05hdGl2ZUZ1bmN0aW9uTWV0aG9kKGZuKSB7XG4gICAgcmV0dXJuIGZuID09PSBmbi5jYWxsIHx8XG4gICAgICAgICAgIGZuID09PSBmbi50b1N0cmluZyB8fFxuICAgICAgICAgICBmbiA9PT0gZm4uYmluZCB8fFxuICAgICAgICAgICBmbiA9PT0gZm4uYXBwbHk7XG59XG5cbnZhciByZXQgPSB7XG4gICAgaXNDbGFzczogaXNDbGFzcyxcbiAgICBpc0lkZW50aWZpZXI6IGlzSWRlbnRpZmllcixcbiAgICBpbmhlcml0ZWREYXRhS2V5czogaW5oZXJpdGVkRGF0YUtleXMsXG4gICAgZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0OiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQsXG4gICAgdGhyb3dlcjogdGhyb3dlcixcbiAgICBpc0FycmF5OiBlczUuaXNBcnJheSxcbiAgICBoYXZlR2V0dGVyczogaGF2ZUdldHRlcnMsXG4gICAgbm90RW51bWVyYWJsZVByb3A6IG5vdEVudW1lcmFibGVQcm9wLFxuICAgIGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgY2FuRXZhbHVhdGU6IGNhbkV2YWx1YXRlLFxuICAgIGVycm9yT2JqOiBlcnJvck9iaixcbiAgICB0cnlDYXRjaDogdHJ5Q2F0Y2gsXG4gICAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICAgIHdpdGhBcHBlbmRlZDogd2l0aEFwcGVuZGVkLFxuICAgIG1heWJlV3JhcEFzRXJyb3I6IG1heWJlV3JhcEFzRXJyb3IsXG4gICAgd3JhcHNQcmltaXRpdmVSZWNlaXZlcjogd3JhcHNQcmltaXRpdmVSZWNlaXZlcixcbiAgICB0b0Zhc3RQcm9wZXJ0aWVzOiB0b0Zhc3RQcm9wZXJ0aWVzLFxuICAgIGZpbGxlZFJhbmdlOiBmaWxsZWRSYW5nZSxcbiAgICB0b1N0cmluZzogc2FmZVRvU3RyaW5nLFxuICAgIGNhbkF0dGFjaFRyYWNlOiBjYW5BdHRhY2hUcmFjZSxcbiAgICBlbnN1cmVFcnJvck9iamVjdDogZW5zdXJlRXJyb3JPYmplY3QsXG4gICAgb3JpZ2luYXRlc0Zyb21SZWplY3Rpb246IG9yaWdpbmF0ZXNGcm9tUmVqZWN0aW9uLFxuICAgIG1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbjogbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uLFxuICAgIGNsYXNzU3RyaW5nOiBjbGFzc1N0cmluZyxcbiAgICBjb3B5RGVzY3JpcHRvcnM6IGNvcHlEZXNjcmlwdG9ycyxcbiAgICBoYXNEZXZUb29sczogdHlwZW9mIGNocm9tZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjaHJvbWUgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIGNocm9tZS5sb2FkVGltZXMgPT09IFwiZnVuY3Rpb25cIixcbiAgICBpc05vZGU6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIGNsYXNzU3RyaW5nKHByb2Nlc3MpLnRvTG93ZXJDYXNlKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiLFxuICAgIGlzTmF0aXZlRnVuY3Rpb25NZXRob2Q6IGlzTmF0aXZlRnVuY3Rpb25NZXRob2Rcbn07XG5yZXQuaXNSZWNlbnROb2RlID0gcmV0LmlzTm9kZSAmJiAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoXCIuXCIpLm1hcChOdW1iZXIpO1xuICAgIHJldHVybiAodmVyc2lvblswXSA9PT0gMCAmJiB2ZXJzaW9uWzFdID4gMTApIHx8ICh2ZXJzaW9uWzBdID4gMCk7XG59KSgpO1xudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge3JldC5sYXN0TGluZUVycm9yID0gZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHJldDtcblxufSx7XCIuL2VzNS5qc1wiOjE0fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG59LHt9XX0se30sWzRdKSg0KVxufSk7ICAgICAgICAgICAgICAgICAgICA7aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAhPT0gbnVsbCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuUCA9IHdpbmRvdy5Qcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiAhPT0gbnVsbCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5QID0gc2VsZi5Qcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vYmx1ZWJpcmQvanMvYnJvd3Nlci9ibHVlYmlyZC5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbn0gKCkpXG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBjYWNoZWRTZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdyZXF1ZXN0Jyk7XG5cbnZhciByZXF1ZXN0QXN5bmMgPSBQcm9taXNlLnByb21pc2lmeShyZXF1ZXN0LmRlZmF1bHRzKHtcbiAgaGVhZGVyczoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgfSxcbiAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgdGltZW91dDogMzAwMDBcbn0pKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0QXN5bmM7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IDIwMTAtMjAxMiBNaWtlYWwgUm9nZXJzXG4vL1xuLy8gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4ndXNlIHN0cmljdCdcblxudmFyIGV4dGVuZCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2V4dGVuZCcpXG4gICwgY29va2llcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvY29va2llcycpXG4gICwgaGVscGVycyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvaGVscGVycycpXG5cbnZhciBpc0Z1bmN0aW9uICAgICAgICAgICAgPSBoZWxwZXJzLmlzRnVuY3Rpb25cbiAgLCBwYXJhbXNIYXZlUmVxdWVzdEJvZHkgPSBoZWxwZXJzLnBhcmFtc0hhdmVSZXF1ZXN0Qm9keVxuXG5cbi8vIG9yZ2FuaXplIHBhcmFtcyBmb3IgcGF0Y2gsIHBvc3QsIHB1dCwgaGVhZCwgZGVsXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gIH1cblxuICB2YXIgcGFyYW1zID0ge31cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIGV4dGVuZChwYXJhbXMsIG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICBleHRlbmQocGFyYW1zLCB7dXJpOiB1cml9KVxuICB9IGVsc2Uge1xuICAgIGV4dGVuZChwYXJhbXMsIHVyaSlcbiAgfVxuXG4gIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIHJldHVybiBwYXJhbXNcbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCB1cmkgb3Igb3B0aW9ucyBvYmplY3QuJylcbiAgfVxuXG4gIHZhciBwYXJhbXMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG5cbiAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdIRUFEJyAmJiBwYXJhbXNIYXZlUmVxdWVzdEJvZHkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBIRUFEIHJlcXVlc3RzIE1VU1QgTk9UIGluY2x1ZGUgYSByZXF1ZXN0IGJvZHkuJylcbiAgfVxuXG4gIHJldHVybiBuZXcgcmVxdWVzdC5SZXF1ZXN0KHBhcmFtcylcbn1cblxuZnVuY3Rpb24gdmVyYkZ1bmMgKHZlcmIpIHtcbiAgdmFyIG1ldGhvZCA9IHZlcmIgPT09ICdkZWwnID8gJ0RFTEVURScgOiB2ZXJiLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIGZ1bmN0aW9uICh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICBwYXJhbXMubWV0aG9kID0gbWV0aG9kXG4gICAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLCBwYXJhbXMuY2FsbGJhY2spXG4gIH1cbn1cblxuLy8gZGVmaW5lIGxpa2UgdGhpcyB0byBwbGVhc2UgY29kZWludGVsL2ludGVsbGlzZW5zZSBJREVzXG5yZXF1ZXN0LmdldCA9IHZlcmJGdW5jKCdnZXQnKVxucmVxdWVzdC5oZWFkID0gdmVyYkZ1bmMoJ2hlYWQnKVxucmVxdWVzdC5wb3N0ID0gdmVyYkZ1bmMoJ3Bvc3QnKVxucmVxdWVzdC5wdXQgPSB2ZXJiRnVuYygncHV0JylcbnJlcXVlc3QucGF0Y2ggPSB2ZXJiRnVuYygncGF0Y2gnKVxucmVxdWVzdC5kZWwgPSB2ZXJiRnVuYygnZGVsJylcblxucmVxdWVzdC5qYXIgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIGNvb2tpZXMuamFyKHN0b3JlKVxufVxuXG5yZXF1ZXN0LmNvb2tpZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIGNvb2tpZXMucGFyc2Uoc3RyKVxufVxuXG5mdW5jdGlvbiB3cmFwUmVxdWVzdE1ldGhvZCAobWV0aG9kLCBvcHRpb25zLCByZXF1ZXN0ZXIsIHZlcmIpIHtcblxuICByZXR1cm4gZnVuY3Rpb24gKHVyaSwgb3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdHMsIGNhbGxiYWNrKVxuXG4gICAgdmFyIHRhcmdldCA9IHt9XG4gICAgZXh0ZW5kKHRydWUsIHRhcmdldCwgb3B0aW9ucywgcGFyYW1zKVxuXG4gICAgaWYgKHZlcmIpIHtcbiAgICAgIHRhcmdldC5tZXRob2QgPSAodmVyYiA9PT0gJ2RlbCcgPyAnREVMRVRFJyA6IHZlcmIudG9VcHBlckNhc2UoKSlcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0ZXIpKSB7XG4gICAgICBtZXRob2QgPSByZXF1ZXN0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0aG9kKHRhcmdldCwgdGFyZ2V0LmNhbGxiYWNrKVxuICB9XG59XG5cbnJlcXVlc3QuZGVmYXVsdHMgPSBmdW5jdGlvbiAob3B0aW9ucywgcmVxdWVzdGVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlcXVlc3RlciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHZhciBkZWZhdWx0cyAgICAgID0gd3JhcFJlcXVlc3RNZXRob2Qoc2VsZiwgb3B0aW9ucywgcmVxdWVzdGVyKVxuXG4gIHZhciB2ZXJicyA9IFsnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnZGVsJ11cbiAgdmVyYnMuZm9yRWFjaChmdW5jdGlvbih2ZXJiKSB7XG4gICAgZGVmYXVsdHNbdmVyYl0gID0gd3JhcFJlcXVlc3RNZXRob2Qoc2VsZlt2ZXJiXSwgb3B0aW9ucywgcmVxdWVzdGVyLCB2ZXJiKVxuICB9KVxuXG4gIGRlZmF1bHRzLmNvb2tpZSAgID0gd3JhcFJlcXVlc3RNZXRob2Qoc2VsZi5jb29raWUsIG9wdGlvbnMsIHJlcXVlc3RlcilcbiAgZGVmYXVsdHMuamFyICAgICAgPSBzZWxmLmphclxuICBkZWZhdWx0cy5kZWZhdWx0cyA9IHNlbGYuZGVmYXVsdHNcbiAgcmV0dXJuIGRlZmF1bHRzXG59XG5cbnJlcXVlc3QuZm9yZXZlciA9IGZ1bmN0aW9uIChhZ2VudE9wdGlvbnMsIG9wdGlvbnNBcmcpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fVxuICBpZiAob3B0aW9uc0FyZykge1xuICAgIGV4dGVuZChvcHRpb25zLCBvcHRpb25zQXJnKVxuICB9XG4gIGlmIChhZ2VudE9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmFnZW50T3B0aW9ucyA9IGFnZW50T3B0aW9uc1xuICB9XG5cbiAgb3B0aW9ucy5mb3JldmVyID0gdHJ1ZVxuICByZXR1cm4gcmVxdWVzdC5kZWZhdWx0cyhvcHRpb25zKVxufVxuXG4vLyBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdFxucmVxdWVzdC5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0JylcbnJlcXVlc3QuaW5pdFBhcmFtcyA9IGluaXRQYXJhbXNcblxuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHJlcXVlc3QuZGVidWdcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCAnZGVidWcnLCB7XG4gIGVudW1lcmFibGUgOiB0cnVlLFxuICBnZXQgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5SZXF1ZXN0LmRlYnVnXG4gIH0sXG4gIHNldCA6IGZ1bmN0aW9uKGRlYnVnKSB7XG4gICAgcmVxdWVzdC5SZXF1ZXN0LmRlYnVnID0gZGVidWdcbiAgfVxufSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZXF1ZXN0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB1bmRlZmluZWQ7XG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcblx0aWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcblx0fVxuXG5cdHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0aWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBoYXNfb3duX2NvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcblx0dmFyIGhhc19pc19wcm9wZXJ0eV9vZl9tZXRob2QgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSAmJiBoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuXHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc19vd25fY29uc3RydWN0b3IgJiYgIWhhc19pc19wcm9wZXJ0eV9vZl9tZXRob2QpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iaikge31cblxuXHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicpIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0aSA9IDI7XG5cdH0gZWxzZSBpZiAoKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHx8IHRhcmdldCA9PSBudWxsKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0W25hbWVdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICh0YXJnZXQgPT09IGNvcHkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGlzQXJyYXkoY29weSkpKSkge1xuXHRcdFx0XHRcdGlmIChjb3B5SXNBcnJheSkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBleHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9leHRlbmQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciB0b3VnaCA9IHJlcXVpcmUoJ3RvdWdoLWNvb2tpZScpXG5cbnZhciBDb29raWUgPSB0b3VnaC5Db29raWVcbiAgLCBDb29raWVKYXIgPSB0b3VnaC5Db29raWVKYXJcblxuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmIChzdHIgJiYgc3RyLnVyaSkge1xuICAgIHN0ciA9IHN0ci51cmlcbiAgfVxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjb29raWUgZnVuY3Rpb24gb25seSBhY2NlcHRzIFNUUklORyBhcyBwYXJhbScpXG4gIH1cbiAgcmV0dXJuIENvb2tpZS5wYXJzZShzdHIpXG59XG5cbi8vIEFkYXB0IHRoZSBzb21ldGltZXMtQXN5bmMgYXBpIG9mIHRvdWdoLkNvb2tpZUphciB0byBvdXIgcmVxdWlyZW1lbnRzXG5mdW5jdGlvbiBSZXF1ZXN0SmFyKHN0b3JlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9qYXIgPSBuZXcgQ29va2llSmFyKHN0b3JlKVxufVxuUmVxdWVzdEphci5wcm90b3R5cGUuc2V0Q29va2llID0gZnVuY3Rpb24oY29va2llT3JTdHIsIHVyaSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX2phci5zZXRDb29raWVTeW5jKGNvb2tpZU9yU3RyLCB1cmksIG9wdGlvbnMgfHwge30pXG59XG5SZXF1ZXN0SmFyLnByb3RvdHlwZS5nZXRDb29raWVTdHJpbmcgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBzZWxmLl9qYXIuZ2V0Q29va2llU3RyaW5nU3luYyh1cmkpXG59XG5SZXF1ZXN0SmFyLnByb3RvdHlwZS5nZXRDb29raWVzID0gZnVuY3Rpb24odXJpKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gc2VsZi5famFyLmdldENvb2tpZXNTeW5jKHVyaSlcbn1cblxuZXhwb3J0cy5qYXIgPSBmdW5jdGlvbihzdG9yZSkge1xuICByZXR1cm4gbmV3IFJlcXVlc3RKYXIoc3RvcmUpXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVxdWVzdC9saWIvY29va2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbnZhciB1cmxQYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xudmFyIHB1YnN1ZmZpeCA9IHJlcXVpcmUoJy4vcHVic3VmZml4Jyk7XG52YXIgU3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlJykuU3RvcmU7XG52YXIgTWVtb3J5Q29va2llU3RvcmUgPSByZXF1aXJlKCcuL21lbXN0b3JlJykuTWVtb3J5Q29va2llU3RvcmU7XG52YXIgcGF0aE1hdGNoID0gcmVxdWlyZSgnLi9wYXRoTWF0Y2gnKS5wYXRoTWF0Y2g7XG52YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cbnZhciBwdW55Y29kZTtcbnRyeSB7XG4gIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbn0gY2F0Y2goZSkge1xuICBjb25zb2xlLndhcm4oXCJjb29raWU6IGNhbid0IGxvYWQgcHVueWNvZGU7IHdvbid0IHVzZSBwdW55Y29kZSBmb3IgZG9tYWluIG5vcm1hbGl6YXRpb25cIik7XG59XG5cbnZhciBEQVRFX0RFTElNID0gL1tcXHgwOVxceDIwLVxceDJGXFx4M0ItXFx4NDBcXHg1Qi1cXHg2MFxceDdCLVxceDdFXS87XG5cbi8vIEZyb20gUkZDNjI2NSBTNC4xLjFcbi8vIG5vdGUgdGhhdCBpdCBleGNsdWRlcyBcXHgzQiBcIjtcIlxudmFyIENPT0tJRV9PQ1RFVCAgPSAvW1xceDIxXFx4MjMtXFx4MkJcXHgyRC1cXHgzQVxceDNDLVxceDVCXFx4NUQtXFx4N0VdLztcbnZhciBDT09LSUVfT0NURVRTID0gbmV3IFJlZ0V4cCgnXicrQ09PS0lFX09DVEVULnNvdXJjZSsnKyQnKTtcblxudmFyIENPTlRST0xfQ0hBUlMgPSAvW1xceDAwLVxceDFGXS87XG5cbi8vIERvdWJsZSBxdW90ZXMgYXJlIHBhcnQgb2YgdGhlIHZhbHVlIChzZWU6IFM0LjEuMSkuXG4vLyAnXFxyJywgJ1xcbicgYW5kICdcXDAnIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgdGVybWluYXRvciBpbiB0aGUgXCJyZWxheGVkXCIgbW9kZVxuLy8gKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0Nocm9taXVtV2ViQXBwcy9jaHJvbWl1bS9ibG9iL2IzZDNiNGRhOGJiOTRjMWIyZTA2MTYwMGRmMTA2ZDU5MGZkYTM2MjAvbmV0L2Nvb2tpZXMvcGFyc2VkX2Nvb2tpZS5jYyNMNjApXG4vLyAnPScgYW5kICc7JyBhcmUgYXR0cmlidXRlL3ZhbHVlcyBzZXBhcmF0b3JzXG4vLyAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vQ2hyb21pdW1XZWJBcHBzL2Nocm9taXVtL2Jsb2IvYjNkM2I0ZGE4YmI5NGMxYjJlMDYxNjAwZGYxMDZkNTkwZmRhMzYyMC9uZXQvY29va2llcy9wYXJzZWRfY29va2llLmNjI0w2NClcbnZhciBDT09LSUVfUEFJUiA9IC9eKChbXj07XSspKVxccyo9XFxzKihbXlxcblxcclxcMF0qKS87XG5cbi8vIFVzZWQgdG8gcGFyc2Ugbm9uLVJGQy1jb21wbGlhbnQgY29va2llcyBsaWtlICc9YWJjJyB3aGVuIGdpdmVuIHRoZSBgbG9vc2VgXG4vLyBvcHRpb24gaW4gQ29va2llLnBhcnNlOlxudmFyIExPT1NFX0NPT0tJRV9QQUlSID0gL14oKD86PSk/KFtePTtdKilcXHMqPVxccyopPyhbXlxcblxcclxcMF0qKS87XG5cbi8vIFJGQzYyNjUgUzQuMS4xIGRlZmluZXMgcGF0aCB2YWx1ZSBhcyAnYW55IENIQVIgZXhjZXB0IENUTHMgb3IgXCI7XCInXG4vLyBOb3RlICc7JyBpcyBcXHgzQlxudmFyIFBBVEhfVkFMVUUgPSAvW1xceDIwLVxceDNBXFx4M0MtXFx4N0VdKy87XG5cbi8vIFVzZWQgZm9yIGNoZWNraW5nIHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIGEgdHJhaWxpbmcgc2VtaS1jb2xvblxudmFyIFRSQUlMSU5HX1NFTUlDT0xPTiA9IC87KyQvO1xuXG52YXIgREFZX09GX01PTlRIID0gL14oXFxkezEsMn0pW15cXGRdKiQvO1xudmFyIFRJTUUgPSAvXihcXGR7MSwyfSlbXlxcZF0qOihcXGR7MSwyfSlbXlxcZF0qOihcXGR7MSwyfSlbXlxcZF0qJC87XG52YXIgTU9OVEggPSAvXihKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykvaTtcblxudmFyIE1PTlRIX1RPX05VTSA9IHtcbiAgamFuOjAsIGZlYjoxLCBtYXI6MiwgYXByOjMsIG1heTo0LCBqdW46NSxcbiAganVsOjYsIGF1Zzo3LCBzZXA6OCwgb2N0OjksIG5vdjoxMCwgZGVjOjExXG59O1xudmFyIE5VTV9UT19NT05USCA9IFtcbiAgJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01heScsJ0p1bicsJ0p1bCcsJ0F1ZycsJ1NlcCcsJ09jdCcsJ05vdicsJ0RlYydcbl07XG52YXIgTlVNX1RPX0RBWSA9IFtcbiAgJ1N1bicsJ01vbicsJ1R1ZScsJ1dlZCcsJ1RodScsJ0ZyaScsJ1NhdCdcbl07XG5cbnZhciBZRUFSID0gL14oXFxkezJ9fFxcZHs0fSkkLzsgLy8gMiB0byA0IGRpZ2l0c1xuXG52YXIgTUFYX1RJTUUgPSAyMTQ3NDgzNjQ3MDAwOyAvLyAzMS1iaXQgbWF4XG52YXIgTUlOX1RJTUUgPSAwOyAvLyAzMS1iaXQgbWluXG5cblxuLy8gUkZDNjI2NSBTNS4xLjEgZGF0ZSBwYXJzZXI6XG5mdW5jdGlvbiBwYXJzZURhdGUoc3RyKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogUkZDNjI2NSBTNS4xLjE6XG4gICAqIDIuIFByb2Nlc3MgZWFjaCBkYXRlLXRva2VuIHNlcXVlbnRpYWxseSBpbiB0aGUgb3JkZXIgdGhlIGRhdGUtdG9rZW5zXG4gICAqIGFwcGVhciBpbiB0aGUgY29va2llLWRhdGVcbiAgICovXG4gIHZhciB0b2tlbnMgPSBzdHIuc3BsaXQoREFURV9ERUxJTSk7XG4gIGlmICghdG9rZW5zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGhvdXIgPSBudWxsO1xuICB2YXIgbWludXRlcyA9IG51bGw7XG4gIHZhciBzZWNvbmRzID0gbnVsbDtcbiAgdmFyIGRheSA9IG51bGw7XG4gIHZhciBtb250aCA9IG51bGw7XG4gIHZhciB5ZWFyID0gbnVsbDtcblxuICBmb3IgKHZhciBpPTA7IGk8dG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldLnRyaW0oKTtcbiAgICBpZiAoIXRva2VuLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8qIDIuMS4gSWYgdGhlIGZvdW5kLXRpbWUgZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgdG9rZW4gbWF0Y2hlcyB0aGUgdGltZVxuICAgICAqIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtdGltZSBmbGFnIGFuZCBzZXQgdGhlIGhvdXItIHZhbHVlLFxuICAgICAqIG1pbnV0ZS12YWx1ZSwgYW5kIHNlY29uZC12YWx1ZSB0byB0aGUgbnVtYmVycyBkZW5vdGVkIGJ5IHRoZSBkaWdpdHMgaW5cbiAgICAgKiB0aGUgZGF0ZS10b2tlbiwgcmVzcGVjdGl2ZWx5LiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmQgY29udGludWVcbiAgICAgKiB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmIChzZWNvbmRzID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBUSU1FLmV4ZWModG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQocmVzdWx0WzFdLCAxMCk7XG4gICAgICAgIG1pbnV0ZXMgPSBwYXJzZUludChyZXN1bHRbMl0sIDEwKTtcbiAgICAgICAgc2Vjb25kcyA9IHBhcnNlSW50KHJlc3VsdFszXSwgMTApO1xuICAgICAgICAvKiBSRkM2MjY1IFM1LjEuMS41OlxuICAgICAgICAgKiBbZmFpbCBpZl1cbiAgICAgICAgICogKiAgdGhlIGhvdXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDIzLFxuICAgICAgICAgKiAqICB0aGUgbWludXRlLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiA1OSwgb3JcbiAgICAgICAgICogKiAgdGhlIHNlY29uZC12YWx1ZSBpcyBncmVhdGVyIHRoYW4gNTkuXG4gICAgICAgICAqL1xuICAgICAgICBpZihob3VyID4gMjMgfHwgbWludXRlcyA+IDU5IHx8IHNlY29uZHMgPiA1OSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIDIuMi4gSWYgdGhlIGZvdW5kLWRheS1vZi1tb250aCBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBkYXRlLXRva2VuIG1hdGNoZXNcbiAgICAgKiB0aGUgZGF5LW9mLW1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtZGF5LW9mLSBtb250aCBmbGFnIGFuZCBzZXRcbiAgICAgKiB0aGUgZGF5LW9mLW1vbnRoLXZhbHVlIHRvIHRoZSBudW1iZXIgZGVub3RlZCBieSB0aGUgZGF0ZS10b2tlbi4gIFNraXBcbiAgICAgKiB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmQgY29udGludWUgdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgKi9cbiAgICBpZiAoZGF5ID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBEQVlfT0ZfTU9OVEguZXhlYyh0b2tlbik7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGRheSA9IHBhcnNlSW50KHJlc3VsdCwgMTApO1xuICAgICAgICAvKiBSRkM2MjY1IFM1LjEuMS41OlxuICAgICAgICAgKiBbZmFpbCBpZl0gdGhlIGRheS1vZi1tb250aC12YWx1ZSBpcyBsZXNzIHRoYW4gMSBvciBncmVhdGVyIHRoYW4gMzFcbiAgICAgICAgICovXG4gICAgICAgIGlmKGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi4zLiBJZiB0aGUgZm91bmQtbW9udGggZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0ZS10b2tlbiBtYXRjaGVzIHRoZVxuICAgICAqIG1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtbW9udGggZmxhZyBhbmQgc2V0IHRoZSBtb250aC12YWx1ZSB0b1xuICAgICAqIHRoZSBtb250aCBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmRcbiAgICAgKiBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmIChtb250aCA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gTU9OVEguZXhlYyh0b2tlbik7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIG1vbnRoID0gTU9OVEhfVE9fTlVNW3Jlc3VsdFsxXS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi40LiBJZiB0aGUgZm91bmQteWVhciBmbGFnIGlzIG5vdCBzZXQgYW5kIHRoZSBkYXRlLXRva2VuIG1hdGNoZXMgdGhlIHllYXJcbiAgICAgKiBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLXllYXIgZmxhZyBhbmQgc2V0IHRoZSB5ZWFyLXZhbHVlIHRvIHRoZSBudW1iZXJcbiAgICAgKiBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmQgY29udGludWUgdG9cbiAgICAgKiB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmICh5ZWFyID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBZRUFSLmV4ZWModG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB5ZWFyID0gcGFyc2VJbnQocmVzdWx0WzBdLCAxMCk7XG4gICAgICAgIC8qIEZyb20gUzUuMS4xOlxuICAgICAgICAgKiAzLiAgSWYgdGhlIHllYXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDcwIGFuZCBsZXNzXG4gICAgICAgICAqIHRoYW4gb3IgZXF1YWwgdG8gOTksIGluY3JlbWVudCB0aGUgeWVhci12YWx1ZSBieSAxOTAwLlxuICAgICAgICAgKiA0LiAgSWYgdGhlIHllYXItdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgYW5kIGxlc3NcbiAgICAgICAgICogdGhhbiBvciBlcXVhbCB0byA2OSwgaW5jcmVtZW50IHRoZSB5ZWFyLXZhbHVlIGJ5IDIwMDAuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoNzAgPD0geWVhciAmJiB5ZWFyIDw9IDk5KSB7XG4gICAgICAgICAgeWVhciArPSAxOTAwO1xuICAgICAgICB9IGVsc2UgaWYgKDAgPD0geWVhciAmJiB5ZWFyIDw9IDY5KSB7XG4gICAgICAgICAgeWVhciArPSAyMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHllYXIgPCAxNjAxKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyA1LiAuLi4gdGhlIHllYXItdmFsdWUgaXMgbGVzcyB0aGFuIDE2MDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWNvbmRzID09PSBudWxsIHx8IGRheSA9PT0gbnVsbCB8fCBtb250aCA9PT0gbnVsbCB8fCB5ZWFyID09PSBudWxsKSB7XG4gICAgcmV0dXJuOyAvLyA1LiAuLi4gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb3VuZC1kYXktb2YtbW9udGgsIGZvdW5kLW1vbnRoLCBmb3VuZC1cbiAgICAgICAgICAgIC8vIHllYXIsIG9yIGZvdW5kLXRpbWUgZmxhZ3MgaXMgbm90IHNldCxcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGVzLCBzZWNvbmRzKSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICB2YXIgZCA9IGRhdGUuZ2V0VVRDRGF0ZSgpOyBkID0gZCA+PSAxMCA/IGQgOiAnMCcrZDtcbiAgdmFyIGggPSBkYXRlLmdldFVUQ0hvdXJzKCk7IGggPSBoID49IDEwID8gaCA6ICcwJytoO1xuICB2YXIgbSA9IGRhdGUuZ2V0VVRDTWludXRlcygpOyBtID0gbSA+PSAxMCA/IG0gOiAnMCcrbTtcbiAgdmFyIHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKTsgcyA9IHMgPj0gMTAgPyBzIDogJzAnK3M7XG4gIHJldHVybiBOVU1fVE9fREFZW2RhdGUuZ2V0VVRDRGF5KCldICsgJywgJyArXG4gICAgZCsnICcrIE5VTV9UT19NT05USFtkYXRlLmdldFVUQ01vbnRoKCldICsnICcrIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArJyAnK1xuICAgIGgrJzonK20rJzonK3MrJyBHTVQnO1xufVxuXG4vLyBTNS4xLjIgQ2Fub25pY2FsaXplZCBIb3N0IE5hbWVzXG5mdW5jdGlvbiBjYW5vbmljYWxEb21haW4oc3RyKSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXlxcLi8sJycpOyAvLyBTNC4xLjIuMyAmIFM1LjIuMzogaWdub3JlIGxlYWRpbmcgLlxuXG4gIC8vIGNvbnZlcnQgdG8gSUROIGlmIGFueSBub24tQVNDSUkgY2hhcmFjdGVyc1xuICBpZiAocHVueWNvZGUgJiYgL1teXFx1MDAwMS1cXHUwMDdmXS8udGVzdChzdHIpKSB7XG4gICAgc3RyID0gcHVueWNvZGUudG9BU0NJSShzdHIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xufVxuXG4vLyBTNS4xLjMgRG9tYWluIE1hdGNoaW5nXG5mdW5jdGlvbiBkb21haW5NYXRjaChzdHIsIGRvbVN0ciwgY2Fub25pY2FsaXplKSB7XG4gIGlmIChzdHIgPT0gbnVsbCB8fCBkb21TdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjYW5vbmljYWxpemUgIT09IGZhbHNlKSB7XG4gICAgc3RyID0gY2Fub25pY2FsRG9tYWluKHN0cik7XG4gICAgZG9tU3RyID0gY2Fub25pY2FsRG9tYWluKGRvbVN0cik7XG4gIH1cblxuICAvKlxuICAgKiBcIlRoZSBkb21haW4gc3RyaW5nIGFuZCB0aGUgc3RyaW5nIGFyZSBpZGVudGljYWwuIChOb3RlIHRoYXQgYm90aCB0aGVcbiAgICogZG9tYWluIHN0cmluZyBhbmQgdGhlIHN0cmluZyB3aWxsIGhhdmUgYmVlbiBjYW5vbmljYWxpemVkIHRvIGxvd2VyIGNhc2UgYXRcbiAgICogdGhpcyBwb2ludClcIlxuICAgKi9cbiAgaWYgKHN0ciA9PSBkb21TdHIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qIFwiQWxsIG9mIHRoZSBmb2xsb3dpbmcgW3RocmVlXSBjb25kaXRpb25zIGhvbGQ6XCIgKG9yZGVyIGFkanVzdGVkIGZyb20gdGhlIFJGQykgKi9cblxuICAvKiBcIiogVGhlIHN0cmluZyBpcyBhIGhvc3QgbmFtZSAoaS5lLiwgbm90IGFuIElQIGFkZHJlc3MpLlwiICovXG4gIGlmIChuZXQuaXNJUChzdHIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyogXCIqIFRoZSBkb21haW4gc3RyaW5nIGlzIGEgc3VmZml4IG9mIHRoZSBzdHJpbmdcIiAqL1xuICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoZG9tU3RyKTtcbiAgaWYgKGlkeCA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBpdCdzIGEgbm9uLW1hdGNoICgtMSkgb3IgcHJlZml4ICgwKVxuICB9XG5cbiAgLy8gZS5nIFwiYS5iLmNcIi5pbmRleE9mKFwiYi5jXCIpID09PSAyXG4gIC8vIDUgPT09IDMrMlxuICBpZiAoc3RyLmxlbmd0aCAhPT0gZG9tU3RyLmxlbmd0aCArIGlkeCkgeyAvLyBpdCdzIG5vdCBhIHN1ZmZpeFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qIFwiKiBUaGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyB0aGF0IGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgZG9tYWluXG4gICogc3RyaW5nIGlzIGEgJXgyRSAoXCIuXCIpIGNoYXJhY3Rlci5cIiAqL1xuICBpZiAoc3RyLnN1YnN0cihpZHgtMSwxKSAhPT0gJy4nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLy8gUkZDNjI2NSBTNS4xLjQgUGF0aHMgYW5kIFBhdGgtTWF0Y2hcblxuLypcbiAqIFwiVGhlIHVzZXIgYWdlbnQgTVVTVCB1c2UgYW4gYWxnb3JpdGhtIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZyBhbGdvcml0aG1cbiAqIHRvIGNvbXB1dGUgdGhlIGRlZmF1bHQtcGF0aCBvZiBhIGNvb2tpZTpcIlxuICpcbiAqIEFzc3VtcHRpb246IHRoZSBwYXRoIChhbmQgbm90IHF1ZXJ5IHBhcnQgb3IgYWJzb2x1dGUgdXJpKSBpcyBwYXNzZWQgaW4uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQYXRoKHBhdGgpIHtcbiAgLy8gXCIyLiBJZiB0aGUgdXJpLXBhdGggaXMgZW1wdHkgb3IgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgdXJpLXBhdGggaXMgbm90XG4gIC8vIGEgJXgyRiAoXCIvXCIpIGNoYXJhY3Rlciwgb3V0cHV0ICV4MkYgKFwiL1wiKSBhbmQgc2tpcCB0aGUgcmVtYWluaW5nIHN0ZXBzLlxuICBpZiAoIXBhdGggfHwgcGF0aC5zdWJzdHIoMCwxKSAhPT0gXCIvXCIpIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH1cblxuICAvLyBcIjMuIElmIHRoZSB1cmktcGF0aCBjb250YWlucyBubyBtb3JlIHRoYW4gb25lICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIsIG91dHB1dFxuICAvLyAleDJGIChcIi9cIikgYW5kIHNraXAgdGhlIHJlbWFpbmluZyBzdGVwLlwiXG4gIGlmIChwYXRoID09PSBcIi9cIikge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgdmFyIHJpZ2h0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgaWYgKHJpZ2h0U2xhc2ggPT09IDApIHtcbiAgICByZXR1cm4gXCIvXCI7XG4gIH1cblxuICAvLyBcIjQuIE91dHB1dCB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdXJpLXBhdGggZnJvbSB0aGUgZmlyc3QgY2hhcmFjdGVyIHVwIHRvLFxuICAvLyBidXQgbm90IGluY2x1ZGluZywgdGhlIHJpZ2h0LW1vc3QgJXgyRiAoXCIvXCIpLlwiXG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIHJpZ2h0U2xhc2gpO1xufVxuXG5cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHN0ciA9IHN0ci50cmltKCk7XG5cbiAgLy8gUzQuMS4xIFRyYWlsaW5nIHNlbWktY29sb25zIGFyZSBub3QgcGFydCBvZiB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgdmFyIHNlbWlDb2xvbkNoZWNrID0gVFJBSUxJTkdfU0VNSUNPTE9OLmV4ZWMoc3RyKTtcbiAgaWYgKHNlbWlDb2xvbkNoZWNrKSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDAsIHNlbWlDb2xvbkNoZWNrLmluZGV4KTtcbiAgfVxuXG4gIC8vIFdlIHVzZSBhIHJlZ2V4IHRvIHBhcnNlIHRoZSBcIm5hbWUtdmFsdWUtcGFpclwiIHBhcnQgb2YgUzUuMlxuICB2YXIgZmlyc3RTZW1pID0gc3RyLmluZGV4T2YoJzsnKTsgLy8gUzUuMiBzdGVwIDFcbiAgdmFyIHBhaXJSZSA9IG9wdGlvbnMubG9vc2UgPyBMT09TRV9DT09LSUVfUEFJUiA6IENPT0tJRV9QQUlSO1xuICB2YXIgcmVzdWx0ID0gcGFpclJlLmV4ZWMoZmlyc3RTZW1pID09PSAtMSA/IHN0ciA6IHN0ci5zdWJzdHIoMCxmaXJzdFNlbWkpKTtcblxuICAvLyBSeCBzYXRpc2ZpZXMgdGhlIFwidGhlIG5hbWUgc3RyaW5nIGlzIGVtcHR5XCIgYW5kIFwibGFja3MgYSAleDNEIChcIj1cIilcIlxuICAvLyBjb25zdHJhaW50cyBhcyB3ZWxsIGFzIHRyaW1taW5nIGFueSB3aGl0ZXNwYWNlLlxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gbmV3IENvb2tpZSgpO1xuICBpZiAocmVzdWx0WzFdKSB7XG4gICAgYy5rZXkgPSByZXN1bHRbMl0udHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIGMua2V5ID0gJyc7XG4gIH1cbiAgYy52YWx1ZSA9IHJlc3VsdFszXS50cmltKCk7XG4gIGlmIChDT05UUk9MX0NIQVJTLnRlc3QoYy5rZXkpIHx8IENPTlRST0xfQ0hBUlMudGVzdChjLnZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmaXJzdFNlbWkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvLyBTNS4yLjMgXCJ1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnNpc3Qgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmdcbiAgLy8gKGluY2x1ZGluZyB0aGUgJXgzQiAoXCI7XCIpIGluIHF1ZXN0aW9uKS5cIiBwbHVzIGxhdGVyIG9uIGluIHRoZSBzYW1lIHNlY3Rpb25cbiAgLy8gXCJkaXNjYXJkIHRoZSBmaXJzdCBcIjtcIiBhbmQgdHJpbVwiLlxuICB2YXIgdW5wYXJzZWQgPSBzdHIuc2xpY2UoZmlyc3RTZW1pKS5yZXBsYWNlKC9eXFxzKjtcXHMqLywnJykudHJpbSgpO1xuXG4gIC8vIFwiSWYgdGhlIHVucGFyc2VkLWF0dHJpYnV0ZXMgc3RyaW5nIGlzIGVtcHR5LCBza2lwIHRoZSByZXN0IG9mIHRoZXNlXG4gIC8vIHN0ZXBzLlwiXG4gIGlmICh1bnBhcnNlZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qXG4gICAqIFM1LjIgc2F5cyB0aGF0IHdoZW4gbG9vcGluZyBvdmVyIHRoZSBpdGVtcyBcIltwXXJvY2VzcyB0aGUgYXR0cmlidXRlLW5hbWVcbiAgICogYW5kIGF0dHJpYnV0ZS12YWx1ZSBhY2NvcmRpbmcgdG8gdGhlIHJlcXVpcmVtZW50cyBpbiB0aGUgZm9sbG93aW5nXG4gICAqIHN1YnNlY3Rpb25zXCIgZm9yIGV2ZXJ5IGl0ZW0uICBQbHVzLCBmb3IgbWFueSBvZiB0aGUgaW5kaXZpZHVhbCBhdHRyaWJ1dGVzXG4gICAqIGluIFM1LjMgaXQgc2F5cyB0byB1c2UgdGhlIFwiYXR0cmlidXRlLXZhbHVlIG9mIHRoZSBsYXN0IGF0dHJpYnV0ZSBpbiB0aGVcbiAgICogY29va2llLWF0dHJpYnV0ZS1saXN0XCIuICBUaGVyZWZvcmUsIGluIHRoaXMgaW1wbGVtZW50YXRpb24sIHdlIG92ZXJ3cml0ZVxuICAgKiB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICB2YXIgY29va2llX2F2cyA9IHVucGFyc2VkLnNwbGl0KC9cXHMqO1xccyovKTtcbiAgd2hpbGUgKGNvb2tpZV9hdnMubGVuZ3RoKSB7XG4gICAgdmFyIGF2ID0gY29va2llX2F2cy5zaGlmdCgpO1xuICAgIHZhciBhdl9zZXAgPSBhdi5pbmRleE9mKCc9Jyk7XG4gICAgdmFyIGF2X2tleSwgYXZfdmFsdWU7XG5cbiAgICBpZiAoYXZfc2VwID09PSAtMSkge1xuICAgICAgYXZfa2V5ID0gYXY7XG4gICAgICBhdl92YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF2X2tleSA9IGF2LnN1YnN0cigwLGF2X3NlcCk7XG4gICAgICBhdl92YWx1ZSA9IGF2LnN1YnN0cihhdl9zZXArMSk7XG4gICAgfVxuXG4gICAgYXZfa2V5ID0gYXZfa2V5LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICBhdl92YWx1ZSA9IGF2X3ZhbHVlLnRyaW0oKTtcbiAgICB9XG5cbiAgICBzd2l0Y2goYXZfa2V5KSB7XG4gICAgY2FzZSAnZXhwaXJlcyc6IC8vIFM1LjIuMVxuICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgIHZhciBleHAgPSBwYXJzZURhdGUoYXZfdmFsdWUpO1xuICAgICAgICAvLyBcIklmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgZmFpbGVkIHRvIHBhcnNlIGFzIGEgY29va2llIGRhdGUsIGlnbm9yZSB0aGVcbiAgICAgICAgLy8gY29va2llLWF2LlwiXG4gICAgICAgIGlmIChleHApIHtcbiAgICAgICAgICAvLyBvdmVyIGFuZCB1bmRlcmZsb3cgbm90IHJlYWxpc3RpY2FsbHkgYSBjb25jZXJuOiBWOCdzIGdldFRpbWUoKSBzZWVtcyB0b1xuICAgICAgICAgIC8vIHN0b3JlIHNvbWV0aGluZyBsYXJnZXIgdGhhbiBhIDMyLWJpdCB0aW1lX3QgKGV2ZW4gd2l0aCAzMi1iaXQgbm9kZSlcbiAgICAgICAgICBjLmV4cGlyZXMgPSBleHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWF4LWFnZSc6IC8vIFM1LjIuMlxuICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgIC8vIFwiSWYgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCBhIERJR0lUIG9yIGEgXCItXCJcbiAgICAgICAgLy8gY2hhcmFjdGVyIC4uLltvcl0uLi4gSWYgdGhlIHJlbWFpbmRlciBvZiBhdHRyaWJ1dGUtdmFsdWUgY29udGFpbnMgYVxuICAgICAgICAvLyBub24tRElHSVQgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cIlxuICAgICAgICBpZiAoL14tP1swLTldKyQvLnRlc3QoYXZfdmFsdWUpKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gcGFyc2VJbnQoYXZfdmFsdWUsIDEwKTtcbiAgICAgICAgICAvLyBcIklmIGRlbHRhLXNlY29uZHMgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gKDApLCBsZXQgZXhwaXJ5LXRpbWVcbiAgICAgICAgICAvLyBiZSB0aGUgZWFybGllc3QgcmVwcmVzZW50YWJsZSBkYXRlIGFuZCB0aW1lLlwiXG4gICAgICAgICAgYy5zZXRNYXhBZ2UoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RvbWFpbic6IC8vIFM1LjIuM1xuICAgICAgLy8gXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5LCB0aGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkLiAgSG93ZXZlcixcbiAgICAgIC8vIHRoZSB1c2VyIGFnZW50IFNIT1VMRCBpZ25vcmUgdGhlIGNvb2tpZS1hdiBlbnRpcmVseS5cIlxuICAgICAgaWYgKGF2X3ZhbHVlKSB7XG4gICAgICAgIC8vIFM1LjIuMyBcIkxldCBjb29raWUtZG9tYWluIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUgd2l0aG91dCB0aGUgbGVhZGluZyAleDJFXG4gICAgICAgIC8vIChcIi5cIikgY2hhcmFjdGVyLlwiXG4gICAgICAgIHZhciBkb21haW4gPSBhdl92YWx1ZS50cmltKCkucmVwbGFjZSgvXlxcLi8sICcnKTtcbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgIC8vIFwiQ29udmVydCB0aGUgY29va2llLWRvbWFpbiB0byBsb3dlciBjYXNlLlwiXG4gICAgICAgICAgYy5kb21haW4gPSBkb21haW4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRoJzogLy8gUzUuMi40XG4gICAgICAvKlxuICAgICAgICogXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgICAgKiBhdHRyaWJ1dGUtdmFsdWUgaXMgbm90ICV4MkYgKFwiL1wiKTpcbiAgICAgICAqICAgTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBkZWZhdWx0LXBhdGguXG4gICAgICAgKiBPdGhlcndpc2U6XG4gICAgICAgKiAgIExldCBjb29raWUtcGF0aCBiZSB0aGUgYXR0cmlidXRlLXZhbHVlLlwiXG4gICAgICAgKlxuICAgICAgICogV2UnbGwgcmVwcmVzZW50IHRoZSBkZWZhdWx0LXBhdGggYXMgbnVsbCBzaW5jZSBpdCBkZXBlbmRzIG9uIHRoZVxuICAgICAgICogY29udGV4dCBvZiB0aGUgcGFyc2luZy5cbiAgICAgICAqL1xuICAgICAgYy5wYXRoID0gYXZfdmFsdWUgJiYgYXZfdmFsdWVbMF0gPT09IFwiL1wiID8gYXZfdmFsdWUgOiBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWN1cmUnOiAvLyBTNS4yLjVcbiAgICAgIC8qXG4gICAgICAgKiBcIklmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiU2VjdXJlXCIsXG4gICAgICAgKiB0aGUgdXNlciBhZ2VudCBNVVNUIGFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdFxuICAgICAgICogd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBTZWN1cmUgYW5kIGFuIGVtcHR5IGF0dHJpYnV0ZS12YWx1ZS5cIlxuICAgICAgICovXG4gICAgICBjLnNlY3VyZSA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2h0dHBvbmx5JzogLy8gUzUuMi42IC0tIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzICdzZWN1cmUnXG4gICAgICBjLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGMuZXh0ZW5zaW9ucyA9IGMuZXh0ZW5zaW9ucyB8fCBbXTtcbiAgICAgIGMuZXh0ZW5zaW9ucy5wdXNoKGF2KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG4vLyBhdm9pZCB0aGUgVjggZGVvcHRpbWl6YXRpb24gbW9uc3RlciFcbmZ1bmN0aW9uIGpzb25QYXJzZShzdHIpIHtcbiAgdmFyIG9iajtcbiAgdHJ5IHtcbiAgICBvYmogPSBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBmcm9tSlNPTihzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBvYmo7XG4gIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgIG9iaiA9IGpzb25QYXJzZShzdHIpO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGFzc3VtZSBpdCdzIGFuIE9iamVjdFxuICAgIG9iaiA9IHN0cjtcbiAgfVxuXG4gIHZhciBjID0gbmV3IENvb2tpZSgpO1xuICBmb3IgKHZhciBpPTA7IGk8Q29va2llLnNlcmlhbGl6YWJsZVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzW2ldO1xuICAgIGlmIChvYmpbcHJvcF0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBvYmpbcHJvcF0gPT09IENvb2tpZS5wcm90b3R5cGVbcHJvcF0pXG4gICAge1xuICAgICAgY29udGludWU7IC8vIGxlYXZlIGFzIHByb3RvdHlwZSBkZWZhdWx0XG4gICAgfVxuXG4gICAgaWYgKHByb3AgPT09ICdleHBpcmVzJyB8fFxuICAgICAgICBwcm9wID09PSAnY3JlYXRpb24nIHx8XG4gICAgICAgIHByb3AgPT09ICdsYXN0QWNjZXNzZWQnKVxuICAgIHtcbiAgICAgIGlmIChvYmpbcHJvcF0gPT09IG51bGwpIHtcbiAgICAgICAgY1twcm9wXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjW3Byb3BdID0gb2JqW3Byb3BdID09IFwiSW5maW5pdHlcIiA/XG4gICAgICAgICAgXCJJbmZpbml0eVwiIDogbmV3IERhdGUob2JqW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY1twcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuLyogU2VjdGlvbiA1LjQgcGFydCAyOlxuICogXCIqICBDb29raWVzIHdpdGggbG9uZ2VyIHBhdGhzIGFyZSBsaXN0ZWQgYmVmb3JlIGNvb2tpZXMgd2l0aFxuICogICAgIHNob3J0ZXIgcGF0aHMuXG4gKlxuICogICogIEFtb25nIGNvb2tpZXMgdGhhdCBoYXZlIGVxdWFsLWxlbmd0aCBwYXRoIGZpZWxkcywgY29va2llcyB3aXRoXG4gKiAgICAgZWFybGllciBjcmVhdGlvbi10aW1lcyBhcmUgbGlzdGVkIGJlZm9yZSBjb29raWVzIHdpdGggbGF0ZXJcbiAqICAgICBjcmVhdGlvbi10aW1lcy5cIlxuICovXG5cbmZ1bmN0aW9uIGNvb2tpZUNvbXBhcmUoYSxiKSB7XG4gIHZhciBjbXAgPSAwO1xuXG4gIC8vIGRlc2NlbmRpbmcgZm9yIGxlbmd0aDogYiBDTVAgYVxuICB2YXIgYVBhdGhMZW4gPSBhLnBhdGggPyBhLnBhdGgubGVuZ3RoIDogMDtcbiAgdmFyIGJQYXRoTGVuID0gYi5wYXRoID8gYi5wYXRoLmxlbmd0aCA6IDA7XG4gIGNtcCA9IGJQYXRoTGVuIC0gYVBhdGhMZW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgLy8gYXNjZW5kaW5nIGZvciB0aW1lOiBhIENNUCBiXG4gIHZhciBhVGltZSA9IGEuY3JlYXRpb24gPyBhLmNyZWF0aW9uLmdldFRpbWUoKSA6IE1BWF9USU1FO1xuICB2YXIgYlRpbWUgPSBiLmNyZWF0aW9uID8gYi5jcmVhdGlvbi5nZXRUaW1lKCkgOiBNQVhfVElNRTtcbiAgY21wID0gYVRpbWUgLSBiVGltZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICAvLyBicmVhayB0aWVzIGZvciB0aGUgc2FtZSBtaWxsaXNlY29uZCAocHJlY2lzaW9uIG9mIEphdmFTY3JpcHQncyBjbG9jaylcbiAgY21wID0gYS5jcmVhdGlvbkluZGV4IC0gYi5jcmVhdGlvbkluZGV4O1xuXG4gIHJldHVybiBjbXA7XG59XG5cbi8vIEdpdmVzIHRoZSBwZXJtdXRhdGlvbiBvZiBhbGwgcG9zc2libGUgcGF0aE1hdGNoKCllcyBvZiBhIGdpdmVuIHBhdGguIFRoZVxuLy8gYXJyYXkgaXMgaW4gbG9uZ2VzdC10by1zaG9ydGVzdCBvcmRlci4gIEhhbmR5IGZvciBpbmRleGluZy5cbmZ1bmN0aW9uIHBlcm11dGVQYXRoKHBhdGgpIHtcbiAgaWYgKHBhdGggPT09ICcvJykge1xuICAgIHJldHVybiBbJy8nXTtcbiAgfVxuICBpZiAocGF0aC5sYXN0SW5kZXhPZignLycpID09PSBwYXRoLmxlbmd0aC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKDAscGF0aC5sZW5ndGgtMSk7XG4gIH1cbiAgdmFyIHBlcm11dGF0aW9ucyA9IFtwYXRoXTtcbiAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIHZhciBsaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgaWYgKGxpbmRleCA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLGxpbmRleCk7XG4gICAgcGVybXV0YXRpb25zLnB1c2gocGF0aCk7XG4gIH1cbiAgcGVybXV0YXRpb25zLnB1c2goJy8nKTtcbiAgcmV0dXJuIHBlcm11dGF0aW9ucztcbn1cblxuZnVuY3Rpb24gZ2V0Q29va2llQ29udGV4dCh1cmwpIHtcbiAgaWYgKHVybCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgLy8gTk9URTogZGVjb2RlVVJJIHdpbGwgdGhyb3cgb24gbWFsZm9ybWVkIFVSSXMgKHNlZSBHSC0zMikuXG4gIC8vIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IHNraXAgZGVjb2RpbmcgZm9yIHN1Y2ggVVJJcy5cbiAgdHJ5IHtcbiAgICB1cmwgPSBkZWNvZGVVUkkodXJsKTtcbiAgfVxuICBjYXRjaChlcnIpIHtcbiAgICAvLyBTaWxlbnRseSBzd2FsbG93IGVycm9yXG4gIH1cblxuICByZXR1cm4gdXJsUGFyc2UodXJsKTtcbn1cblxuZnVuY3Rpb24gQ29va2llKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgaWYgKENvb2tpZS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiZcbiAgICAgICAgQ29va2llLnByb3RvdHlwZVtwcm9wXSAhPT0gb3B0aW9uc1twcm9wXSAmJlxuICAgICAgICBwcm9wLnN1YnN0cigwLDEpICE9PSAnXycpXG4gICAge1xuICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICB0aGlzLmNyZWF0aW9uID0gdGhpcy5jcmVhdGlvbiB8fCBuZXcgRGF0ZSgpO1xuXG4gIC8vIHVzZWQgdG8gYnJlYWsgY3JlYXRpb24gdGllcyBpbiBjb29raWVDb21wYXJlKCk6XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY3JlYXRpb25JbmRleCcsIHtcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLCAvLyBpbXBvcnRhbnQgZm9yIGFzc2VydC5kZWVwRXF1YWwgY2hlY2tzXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6ICsrQ29va2llLmNvb2tpZXNDcmVhdGVkXG4gIH0pO1xufVxuXG5Db29raWUuY29va2llc0NyZWF0ZWQgPSAwOyAvLyBpbmNyZW1lbnRlZCBlYWNoIHRpbWUgYSBjb29raWUgaXMgY3JlYXRlZFxuXG5Db29raWUucGFyc2UgPSBwYXJzZTtcbkNvb2tpZS5mcm9tSlNPTiA9IGZyb21KU09OO1xuXG5Db29raWUucHJvdG90eXBlLmtleSA9IFwiXCI7XG5Db29raWUucHJvdG90eXBlLnZhbHVlID0gXCJcIjtcblxuLy8gdGhlIG9yZGVyIGluIHdoaWNoIHRoZSBSRkMgaGFzIHRoZW06XG5Db29raWUucHJvdG90eXBlLmV4cGlyZXMgPSBcIkluZmluaXR5XCI7IC8vIGNvZXJjZXMgdG8gbGl0ZXJhbCBJbmZpbml0eVxuQ29va2llLnByb3RvdHlwZS5tYXhBZ2UgPSBudWxsOyAvLyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgZXhwaXJlcyBmb3IgVFRMXG5Db29raWUucHJvdG90eXBlLmRvbWFpbiA9IG51bGw7XG5Db29raWUucHJvdG90eXBlLnBhdGggPSBudWxsO1xuQ29va2llLnByb3RvdHlwZS5zZWN1cmUgPSBmYWxzZTtcbkNvb2tpZS5wcm90b3R5cGUuaHR0cE9ubHkgPSBmYWxzZTtcbkNvb2tpZS5wcm90b3R5cGUuZXh0ZW5zaW9ucyA9IG51bGw7XG5cbi8vIHNldCBieSB0aGUgQ29va2llSmFyOlxuQ29va2llLnByb3RvdHlwZS5ob3N0T25seSA9IG51bGw7IC8vIGJvb2xlYW4gd2hlbiBzZXRcbkNvb2tpZS5wcm90b3R5cGUucGF0aElzRGVmYXVsdCA9IG51bGw7IC8vIGJvb2xlYW4gd2hlbiBzZXRcbkNvb2tpZS5wcm90b3R5cGUuY3JlYXRpb24gPSBudWxsOyAvLyBEYXRlIHdoZW4gc2V0OyBkZWZhdWx0ZWQgYnkgQ29va2llLnBhcnNlXG5Db29raWUucHJvdG90eXBlLmxhc3RBY2Nlc3NlZCA9IG51bGw7IC8vIERhdGUgd2hlbiBzZXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb29raWUucHJvdG90eXBlLCAnY3JlYXRpb25JbmRleCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiAwXG59KTtcblxuQ29va2llLnNlcmlhbGl6YWJsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhDb29raWUucHJvdG90eXBlKVxuICAuZmlsdGVyKGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gIShcbiAgICAgIENvb2tpZS5wcm90b3R5cGVbcHJvcF0gaW5zdGFuY2VvZiBGdW5jdGlvbiB8fFxuICAgICAgcHJvcCA9PT0gJ2NyZWF0aW9uSW5kZXgnIHx8XG4gICAgICBwcm9wLnN1YnN0cigwLDEpID09PSAnXydcbiAgICApO1xuICB9KTtcblxuQ29va2llLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gIHJldHVybiAnQ29va2llPVwiJyt0aGlzLnRvU3RyaW5nKCkgK1xuICAgICc7IGhvc3RPbmx5PScrKHRoaXMuaG9zdE9ubHkgIT0gbnVsbCA/IHRoaXMuaG9zdE9ubHkgOiAnPycpICtcbiAgICAnOyBhQWdlPScrKHRoaXMubGFzdEFjY2Vzc2VkID8gKG5vdy10aGlzLmxhc3RBY2Nlc3NlZC5nZXRUaW1lKCkpKydtcycgOiAnPycpICtcbiAgICAnOyBjQWdlPScrKHRoaXMuY3JlYXRpb24gPyAobm93LXRoaXMuY3JlYXRpb24uZ2V0VGltZSgpKSsnbXMnIDogJz8nKSArXG4gICAgJ1wiJztcbn07XG5cbkNvb2tpZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvYmogPSB7fTtcblxuICB2YXIgcHJvcHMgPSBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllcztcbiAgZm9yICh2YXIgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICBpZiAodGhpc1twcm9wXSA9PT0gQ29va2llLnByb3RvdHlwZVtwcm9wXSkge1xuICAgICAgY29udGludWU7IC8vIGxlYXZlIGFzIHByb3RvdHlwZSBkZWZhdWx0XG4gICAgfVxuXG4gICAgaWYgKHByb3AgPT09ICdleHBpcmVzJyB8fFxuICAgICAgICBwcm9wID09PSAnY3JlYXRpb24nIHx8XG4gICAgICAgIHByb3AgPT09ICdsYXN0QWNjZXNzZWQnKVxuICAgIHtcbiAgICAgIGlmICh0aGlzW3Byb3BdID09PSBudWxsKSB7XG4gICAgICAgIG9ialtwcm9wXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdID09IFwiSW5maW5pdHlcIiA/IC8vIGludGVudGlvbmFsbHkgbm90ID09PVxuICAgICAgICAgIFwiSW5maW5pdHlcIiA6IHRoaXNbcHJvcF0udG9JU09TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdtYXhBZ2UnKSB7XG4gICAgICBpZiAodGhpc1twcm9wXSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBhZ2FpbiwgaW50ZW50aW9uYWxseSBub3QgPT09XG4gICAgICAgIG9ialtwcm9wXSA9ICh0aGlzW3Byb3BdID09IEluZmluaXR5IHx8IHRoaXNbcHJvcF0gPT0gLUluZmluaXR5KSA/XG4gICAgICAgICAgdGhpc1twcm9wXS50b1N0cmluZygpIDogdGhpc1twcm9wXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IENvb2tpZS5wcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuQ29va2llLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnJvbUpTT04odGhpcy50b0pTT04oKSk7XG59O1xuXG5Db29raWUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIGlmICghQ09PS0lFX09DVEVUUy50ZXN0KHRoaXMudmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLmV4cGlyZXMgIT0gSW5maW5pdHkgJiYgISh0aGlzLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSAmJiAhcGFyc2VEYXRlKHRoaXMuZXhwaXJlcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwgJiYgdGhpcy5tYXhBZ2UgPD0gMCkge1xuICAgIHJldHVybiBmYWxzZTsgLy8gXCJNYXgtQWdlPVwiIG5vbi16ZXJvLWRpZ2l0ICpESUdJVFxuICB9XG4gIGlmICh0aGlzLnBhdGggIT0gbnVsbCAmJiAhUEFUSF9WQUxVRS50ZXN0KHRoaXMucGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2RvbWFpbiA9IHRoaXMuY2RvbWFpbigpO1xuICBpZiAoY2RvbWFpbikge1xuICAgIGlmIChjZG9tYWluLm1hdGNoKC9cXC4kLykpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gUzQuMS4yLjMgc3VnZ2VzdHMgdGhhdCB0aGlzIGlzIGJhZC4gZG9tYWluTWF0Y2goKSB0ZXN0cyBjb25maXJtIHRoaXNcbiAgICB9XG4gICAgdmFyIHN1ZmZpeCA9IHB1YnN1ZmZpeC5nZXRQdWJsaWNTdWZmaXgoY2RvbWFpbik7XG4gICAgaWYgKHN1ZmZpeCA9PSBudWxsKSB7IC8vIGl0J3MgYSBwdWJsaWMgc3VmZml4XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29va2llLnByb3RvdHlwZS5zZXRFeHBpcmVzID0gZnVuY3Rpb24gc2V0RXhwaXJlcyhleHApIHtcbiAgaWYgKGV4cCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICB0aGlzLmV4cGlyZXMgPSBleHA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5leHBpcmVzID0gcGFyc2VEYXRlKGV4cCkgfHwgXCJJbmZpbml0eVwiO1xuICB9XG59O1xuXG5Db29raWUucHJvdG90eXBlLnNldE1heEFnZSA9IGZ1bmN0aW9uIHNldE1heEFnZShhZ2UpIHtcbiAgaWYgKGFnZSA9PT0gSW5maW5pdHkgfHwgYWdlID09PSAtSW5maW5pdHkpIHtcbiAgICB0aGlzLm1heEFnZSA9IGFnZS50b1N0cmluZygpOyAvLyBzbyBKU09OLnN0cmluZ2lmeSgpIHdvcmtzXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tYXhBZ2UgPSBhZ2U7XG4gIH1cbn07XG5cbi8vIGdpdmVzIENvb2tpZSBoZWFkZXIgZm9ybWF0XG5Db29raWUucHJvdG90eXBlLmNvb2tpZVN0cmluZyA9IGZ1bmN0aW9uIGNvb2tpZVN0cmluZygpIHtcbiAgdmFyIHZhbCA9IHRoaXMudmFsdWU7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHZhbCA9ICcnO1xuICB9XG4gIGlmICh0aGlzLmtleSA9PT0gJycpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHJldHVybiB0aGlzLmtleSsnPScrdmFsO1xufTtcblxuLy8gZ2l2ZXMgU2V0LUNvb2tpZSBoZWFkZXIgZm9ybWF0XG5Db29raWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSB0aGlzLmNvb2tpZVN0cmluZygpO1xuXG4gIGlmICh0aGlzLmV4cGlyZXMgIT0gSW5maW5pdHkpIHtcbiAgICBpZiAodGhpcy5leHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgc3RyICs9ICc7IEV4cGlyZXM9Jytmb3JtYXREYXRlKHRoaXMuZXhwaXJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnOyBFeHBpcmVzPScrdGhpcy5leHBpcmVzO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm1heEFnZSAhPSBudWxsICYmIHRoaXMubWF4QWdlICE9IEluZmluaXR5KSB7XG4gICAgc3RyICs9ICc7IE1heC1BZ2U9Jyt0aGlzLm1heEFnZTtcbiAgfVxuXG4gIGlmICh0aGlzLmRvbWFpbiAmJiAhdGhpcy5ob3N0T25seSkge1xuICAgIHN0ciArPSAnOyBEb21haW49Jyt0aGlzLmRvbWFpbjtcbiAgfVxuICBpZiAodGhpcy5wYXRoKSB7XG4gICAgc3RyICs9ICc7IFBhdGg9Jyt0aGlzLnBhdGg7XG4gIH1cblxuICBpZiAodGhpcy5zZWN1cmUpIHtcbiAgICBzdHIgKz0gJzsgU2VjdXJlJztcbiAgfVxuICBpZiAodGhpcy5odHRwT25seSkge1xuICAgIHN0ciArPSAnOyBIdHRwT25seSc7XG4gIH1cbiAgaWYgKHRoaXMuZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgc3RyICs9ICc7ICcrZXh0O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8vIFRUTCgpIHBhcnRpYWxseSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuLy8gZWxzZXdoZXJlKVxuLy8gUzUuMyBzYXlzIHRvIGdpdmUgdGhlIFwibGF0ZXN0IHJlcHJlc2VudGFibGUgZGF0ZVwiIGZvciB3aGljaCB3ZSB1c2UgSW5maW5pdHlcbi8vIEZvciBcImV4cGlyZWRcIiB3ZSB1c2UgMFxuQ29va2llLnByb3RvdHlwZS5UVEwgPSBmdW5jdGlvbiBUVEwobm93KSB7XG4gIC8qIFJGQzYyNjUgUzQuMS4yLjIgSWYgYSBjb29raWUgaGFzIGJvdGggdGhlIE1heC1BZ2UgYW5kIHRoZSBFeHBpcmVzXG4gICAqIGF0dHJpYnV0ZSwgdGhlIE1heC1BZ2UgYXR0cmlidXRlIGhhcyBwcmVjZWRlbmNlIGFuZCBjb250cm9scyB0aGVcbiAgICogZXhwaXJhdGlvbiBkYXRlIG9mIHRoZSBjb29raWUuXG4gICAqIChDb25jdXJzIHdpdGggUzUuMyBzdGVwIDMpXG4gICAqL1xuICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLm1heEFnZTw9MCA/IDAgOiB0aGlzLm1heEFnZSoxMDAwO1xuICB9XG5cbiAgdmFyIGV4cGlyZXMgPSB0aGlzLmV4cGlyZXM7XG4gIGlmIChleHBpcmVzICE9IEluZmluaXR5KSB7XG4gICAgaWYgKCEoZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICBleHBpcmVzID0gcGFyc2VEYXRlKGV4cGlyZXMpIHx8IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmIChleHBpcmVzID09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGlyZXMuZ2V0VGltZSgpIC0gKG5vdyB8fCBEYXRlLm5vdygpKTtcbiAgfVxuXG4gIHJldHVybiBJbmZpbml0eTtcbn07XG5cbi8vIGV4cGlyeVRpbWUoKSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuLy8gZWxzZXdoZXJlKVxuQ29va2llLnByb3RvdHlwZS5leHBpcnlUaW1lID0gZnVuY3Rpb24gZXhwaXJ5VGltZShub3cpIHtcbiAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwpIHtcbiAgICB2YXIgcmVsYXRpdmVUbyA9IG5vdyB8fCB0aGlzLmNyZWF0aW9uIHx8IG5ldyBEYXRlKCk7XG4gICAgdmFyIGFnZSA9ICh0aGlzLm1heEFnZSA8PSAwKSA/IC1JbmZpbml0eSA6IHRoaXMubWF4QWdlKjEwMDA7XG4gICAgcmV0dXJuIHJlbGF0aXZlVG8uZ2V0VGltZSgpICsgYWdlO1xuICB9XG5cbiAgaWYgKHRoaXMuZXhwaXJlcyA9PSBJbmZpbml0eSkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICByZXR1cm4gdGhpcy5leHBpcmVzLmdldFRpbWUoKTtcbn07XG5cbi8vIGV4cGlyeURhdGUoKSByZXBsYWNlcyB0aGUgXCJleHBpcnktdGltZVwiIHBhcnRzIG9mIFM1LjMgc3RlcCAzIChzZXRDb29raWUoKVxuLy8gZWxzZXdoZXJlKSwgZXhjZXB0IGl0IHJldHVybnMgYSBEYXRlXG5Db29raWUucHJvdG90eXBlLmV4cGlyeURhdGUgPSBmdW5jdGlvbiBleHBpcnlEYXRlKG5vdykge1xuICB2YXIgbWlsbGlzZWMgPSB0aGlzLmV4cGlyeVRpbWUobm93KTtcbiAgaWYgKG1pbGxpc2VjID09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1BWF9USU1FKTtcbiAgfSBlbHNlIGlmIChtaWxsaXNlYyA9PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTUlOX1RJTUUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZShtaWxsaXNlYyk7XG4gIH1cbn07XG5cbi8vIFRoaXMgcmVwbGFjZXMgdGhlIFwicGVyc2lzdGVudC1mbGFnXCIgcGFydHMgb2YgUzUuMyBzdGVwIDNcbkNvb2tpZS5wcm90b3R5cGUuaXNQZXJzaXN0ZW50ID0gZnVuY3Rpb24gaXNQZXJzaXN0ZW50KCkge1xuICByZXR1cm4gKHRoaXMubWF4QWdlICE9IG51bGwgfHwgdGhpcy5leHBpcmVzICE9IEluZmluaXR5KTtcbn07XG5cbi8vIE1vc3RseSBTNS4xLjIgYW5kIFM1LjIuMzpcbkNvb2tpZS5wcm90b3R5cGUuY2RvbWFpbiA9XG5Db29raWUucHJvdG90eXBlLmNhbm9uaWNhbGl6ZWREb21haW4gPSBmdW5jdGlvbiBjYW5vbmljYWxpemVkRG9tYWluKCkge1xuICBpZiAodGhpcy5kb21haW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjYW5vbmljYWxEb21haW4odGhpcy5kb21haW4pO1xufTtcblxuZnVuY3Rpb24gQ29va2llSmFyKHN0b3JlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBvcHRpb25zID0ge3JlamVjdFB1YmxpY1N1ZmZpeGVzOiBvcHRpb25zfTtcbiAgfSBlbHNlIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVqZWN0UHVibGljU3VmZml4ZXMgIT0gbnVsbCkge1xuICAgIHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgPSBvcHRpb25zLnJlamVjdFB1YmxpY1N1ZmZpeGVzO1xuICB9XG4gIGlmIChvcHRpb25zLmxvb3NlTW9kZSAhPSBudWxsKSB7XG4gICAgdGhpcy5lbmFibGVMb29zZU1vZGUgPSBvcHRpb25zLmxvb3NlTW9kZTtcbiAgfVxuXG4gIGlmICghc3RvcmUpIHtcbiAgICBzdG9yZSA9IG5ldyBNZW1vcnlDb29raWVTdG9yZSgpO1xuICB9XG4gIHRoaXMuc3RvcmUgPSBzdG9yZTtcbn1cbkNvb2tpZUphci5wcm90b3R5cGUuc3RvcmUgPSBudWxsO1xuQ29va2llSmFyLnByb3RvdHlwZS5yZWplY3RQdWJsaWNTdWZmaXhlcyA9IHRydWU7XG5Db29raWVKYXIucHJvdG90eXBlLmVuYWJsZUxvb3NlTW9kZSA9IGZhbHNlO1xudmFyIENBTl9CRV9TWU5DID0gW107XG5cbkNBTl9CRV9TWU5DLnB1c2goJ3NldENvb2tpZScpO1xuQ29va2llSmFyLnByb3RvdHlwZS5zZXRDb29raWUgPSBmdW5jdGlvbihjb29raWUsIHVybCwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIGVycjtcbiAgdmFyIGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBjYiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGhvc3QgPSBjYW5vbmljYWxEb21haW4oY29udGV4dC5ob3N0bmFtZSk7XG4gIHZhciBsb29zZSA9IHRoaXMuZW5hYmxlTG9vc2VNb2RlO1xuICBpZiAob3B0aW9ucy5sb29zZSAhPSBudWxsKSB7XG4gICAgbG9vc2UgPSBvcHRpb25zLmxvb3NlO1xuICB9XG5cbiAgLy8gUzUuMyBzdGVwIDFcbiAgaWYgKCEoY29va2llIGluc3RhbmNlb2YgQ29va2llKSkge1xuICAgIGNvb2tpZSA9IENvb2tpZS5wYXJzZShjb29raWUsIHsgbG9vc2U6IGxvb3NlIH0pO1xuICB9XG4gIGlmICghY29va2llKSB7XG4gICAgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGZhaWxlZCB0byBwYXJzZVwiKTtcbiAgICByZXR1cm4gY2Iob3B0aW9ucy5pZ25vcmVFcnJvciA/IG51bGwgOiBlcnIpO1xuICB9XG5cbiAgLy8gUzUuMyBzdGVwIDJcbiAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IG5ldyBEYXRlKCk7IC8vIHdpbGwgYXNzaWduIGxhdGVyIHRvIHNhdmUgZWZmb3J0IGluIHRoZSBmYWNlIG9mIGVycm9yc1xuXG4gIC8vIFM1LjMgc3RlcCAzOiBOT09QOyBwZXJzaXN0ZW50LWZsYWcgYW5kIGV4cGlyeS10aW1lIGlzIGhhbmRsZWQgYnkgZ2V0Q29va2llKClcblxuICAvLyBTNS4zIHN0ZXAgNDogTk9PUDsgZG9tYWluIGlzIG51bGwgYnkgZGVmYXVsdFxuXG4gIC8vIFM1LjMgc3RlcCA1OiBwdWJsaWMgc3VmZml4ZXNcbiAgaWYgKHRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMgJiYgY29va2llLmRvbWFpbikge1xuICAgIHZhciBzdWZmaXggPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4KGNvb2tpZS5jZG9tYWluKCkpO1xuICAgIGlmIChzdWZmaXggPT0gbnVsbCkgeyAvLyBlLmcuIFwiY29tXCJcbiAgICAgIGVyciA9IG5ldyBFcnJvcihcIkNvb2tpZSBoYXMgZG9tYWluIHNldCB0byBhIHB1YmxpYyBzdWZmaXhcIik7XG4gICAgICByZXR1cm4gY2Iob3B0aW9ucy5pZ25vcmVFcnJvciA/IG51bGwgOiBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFM1LjMgc3RlcCA2OlxuICBpZiAoY29va2llLmRvbWFpbikge1xuICAgIGlmICghZG9tYWluTWF0Y2goaG9zdCwgY29va2llLmNkb21haW4oKSwgZmFsc2UpKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgbm90IGluIHRoaXMgaG9zdCdzIGRvbWFpbi4gQ29va2llOlwiK2Nvb2tpZS5jZG9tYWluKCkrXCIgUmVxdWVzdDpcIitob3N0KTtcbiAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgfVxuXG4gICAgaWYgKGNvb2tpZS5ob3N0T25seSA9PSBudWxsKSB7IC8vIGRvbid0IHJlc2V0IGlmIGFscmVhZHkgc2V0XG4gICAgICBjb29raWUuaG9zdE9ubHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICBjb29raWUuaG9zdE9ubHkgPSB0cnVlO1xuICAgIGNvb2tpZS5kb21haW4gPSBob3N0O1xuICB9XG5cbiAgLy9TNS4yLjQgSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAvL2F0dHJpYnV0ZS12YWx1ZSBpcyBub3QgJXgyRiAoXCIvXCIpOlxuICAvL0xldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICBpZiAoIWNvb2tpZS5wYXRoIHx8IGNvb2tpZS5wYXRoWzBdICE9PSAnLycpIHtcbiAgICBjb29raWUucGF0aCA9IGRlZmF1bHRQYXRoKGNvbnRleHQucGF0aG5hbWUpO1xuICAgIGNvb2tpZS5wYXRoSXNEZWZhdWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFM1LjMgc3RlcCA4OiBOT09QOyBzZWN1cmUgYXR0cmlidXRlXG4gIC8vIFM1LjMgc3RlcCA5OiBOT09QOyBodHRwT25seSBhdHRyaWJ1dGVcblxuICAvLyBTNS4zIHN0ZXAgMTBcbiAgaWYgKG9wdGlvbnMuaHR0cCA9PT0gZmFsc2UgJiYgY29va2llLmh0dHBPbmx5KSB7XG4gICAgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGlzIEh0dHBPbmx5IGFuZCB0aGlzIGlzbid0IGFuIEhUVFAgQVBJXCIpO1xuICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gIH1cblxuICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gIGlmICghc3RvcmUudXBkYXRlQ29va2llKSB7XG4gICAgc3RvcmUudXBkYXRlQ29va2llID0gZnVuY3Rpb24ob2xkQ29va2llLCBuZXdDb29raWUsIGNiKSB7XG4gICAgICB0aGlzLnB1dENvb2tpZShuZXdDb29raWUsIGNiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aENvb2tpZShlcnIsIG9sZENvb2tpZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgY29va2llKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9sZENvb2tpZSkge1xuICAgICAgLy8gUzUuMyBzdGVwIDExIC0gXCJJZiB0aGUgY29va2llIHN0b3JlIGNvbnRhaW5zIGEgY29va2llIHdpdGggdGhlIHNhbWUgbmFtZSxcbiAgICAgIC8vIGRvbWFpbiwgYW5kIHBhdGggYXMgdGhlIG5ld2x5IGNyZWF0ZWQgY29va2llOlwiXG4gICAgICBpZiAob3B0aW9ucy5odHRwID09PSBmYWxzZSAmJiBvbGRDb29raWUuaHR0cE9ubHkpIHsgLy8gc3RlcCAxMS4yXG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihcIm9sZCBDb29raWUgaXMgSHR0cE9ubHkgYW5kIHRoaXMgaXNuJ3QgYW4gSFRUUCBBUElcIik7XG4gICAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgICB9XG4gICAgICBjb29raWUuY3JlYXRpb24gPSBvbGRDb29raWUuY3JlYXRpb247IC8vIHN0ZXAgMTEuM1xuICAgICAgY29va2llLmNyZWF0aW9uSW5kZXggPSBvbGRDb29raWUuY3JlYXRpb25JbmRleDsgLy8gcHJlc2VydmUgdGllLWJyZWFrZXJcbiAgICAgIGNvb2tpZS5sYXN0QWNjZXNzZWQgPSBub3c7XG4gICAgICAvLyBTdGVwIDExLjQgKGRlbGV0ZSBjb29raWUpIGlzIGltcGxpZWQgYnkganVzdCBzZXR0aW5nIHRoZSBuZXcgb25lOlxuICAgICAgc3RvcmUudXBkYXRlQ29va2llKG9sZENvb2tpZSwgY29va2llLCBuZXh0KTsgLy8gc3RlcCAxMlxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb2tpZS5jcmVhdGlvbiA9IGNvb2tpZS5sYXN0QWNjZXNzZWQgPSBub3c7XG4gICAgICBzdG9yZS5wdXRDb29raWUoY29va2llLCBuZXh0KTsgLy8gc3RlcCAxMlxuICAgIH1cbiAgfVxuXG4gIHN0b3JlLmZpbmRDb29raWUoY29va2llLmRvbWFpbiwgY29va2llLnBhdGgsIGNvb2tpZS5rZXksIHdpdGhDb29raWUpO1xufTtcblxuLy8gUkZDNjM2NSBTNS40XG5DQU5fQkVfU1lOQy5wdXNoKCdnZXRDb29raWVzJyk7XG5Db29raWVKYXIucHJvdG90eXBlLmdldENvb2tpZXMgPSBmdW5jdGlvbih1cmwsIG9wdGlvbnMsIGNiKSB7XG4gIHZhciBjb250ZXh0ID0gZ2V0Q29va2llQ29udGV4dCh1cmwpO1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgY2IgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBob3N0ID0gY2Fub25pY2FsRG9tYWluKGNvbnRleHQuaG9zdG5hbWUpO1xuICB2YXIgcGF0aCA9IGNvbnRleHQucGF0aG5hbWUgfHwgJy8nO1xuXG4gIHZhciBzZWN1cmUgPSBvcHRpb25zLnNlY3VyZTtcbiAgaWYgKHNlY3VyZSA9PSBudWxsICYmIGNvbnRleHQucHJvdG9jb2wgJiZcbiAgICAgIChjb250ZXh0LnByb3RvY29sID09ICdodHRwczonIHx8IGNvbnRleHQucHJvdG9jb2wgPT0gJ3dzczonKSlcbiAge1xuICAgIHNlY3VyZSA9IHRydWU7XG4gIH1cblxuICB2YXIgaHR0cCA9IG9wdGlvbnMuaHR0cDtcbiAgaWYgKGh0dHAgPT0gbnVsbCkge1xuICAgIGh0dHAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5vdyA9IG9wdGlvbnMubm93IHx8IERhdGUubm93KCk7XG4gIHZhciBleHBpcmVDaGVjayA9IG9wdGlvbnMuZXhwaXJlICE9PSBmYWxzZTtcbiAgdmFyIGFsbFBhdGhzID0gISFvcHRpb25zLmFsbFBhdGhzO1xuICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gIGZ1bmN0aW9uIG1hdGNoaW5nQ29va2llKGMpIHtcbiAgICAvLyBcIkVpdGhlcjpcbiAgICAvLyAgIFRoZSBjb29raWUncyBob3N0LW9ubHktZmxhZyBpcyB0cnVlIGFuZCB0aGUgY2Fub25pY2FsaXplZFxuICAgIC8vICAgcmVxdWVzdC1ob3N0IGlzIGlkZW50aWNhbCB0byB0aGUgY29va2llJ3MgZG9tYWluLlxuICAgIC8vIE9yOlxuICAgIC8vICAgVGhlIGNvb2tpZSdzIGhvc3Qtb25seS1mbGFnIGlzIGZhbHNlIGFuZCB0aGUgY2Fub25pY2FsaXplZFxuICAgIC8vICAgcmVxdWVzdC1ob3N0IGRvbWFpbi1tYXRjaGVzIHRoZSBjb29raWUncyBkb21haW4uXCJcbiAgICBpZiAoYy5ob3N0T25seSkge1xuICAgICAgaWYgKGMuZG9tYWluICE9IGhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWRvbWFpbk1hdGNoKGhvc3QsIGMuZG9tYWluLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFwiVGhlIHJlcXVlc3QtdXJpJ3MgcGF0aCBwYXRoLW1hdGNoZXMgdGhlIGNvb2tpZSdzIHBhdGguXCJcbiAgICBpZiAoIWFsbFBhdGhzICYmICFwYXRoTWF0Y2gocGF0aCwgYy5wYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFwiSWYgdGhlIGNvb2tpZSdzIHNlY3VyZS1vbmx5LWZsYWcgaXMgdHJ1ZSwgdGhlbiB0aGUgcmVxdWVzdC11cmknc1xuICAgIC8vIHNjaGVtZSBtdXN0IGRlbm90ZSBhIFwic2VjdXJlXCIgcHJvdG9jb2xcIlxuICAgIGlmIChjLnNlY3VyZSAmJiAhc2VjdXJlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gXCJJZiB0aGUgY29va2llJ3MgaHR0cC1vbmx5LWZsYWcgaXMgdHJ1ZSwgdGhlbiBleGNsdWRlIHRoZSBjb29raWUgaWYgdGhlXG4gICAgLy8gY29va2llLXN0cmluZyBpcyBiZWluZyBnZW5lcmF0ZWQgZm9yIGEgXCJub24tSFRUUFwiIEFQSVwiXG4gICAgaWYgKGMuaHR0cE9ubHkgJiYgIWh0dHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBkZWZlcnJlZCBmcm9tIFM1LjNcbiAgICAvLyBub24tUkZDOiBhbGxvdyByZXRlbnRpb24gb2YgZXhwaXJlZCBjb29raWVzIGJ5IGNob2ljZVxuICAgIGlmIChleHBpcmVDaGVjayAmJiBjLmV4cGlyeVRpbWUoKSA8PSBub3cpIHtcbiAgICAgIHN0b3JlLnJlbW92ZUNvb2tpZShjLmRvbWFpbiwgYy5wYXRoLCBjLmtleSwgZnVuY3Rpb24oKXt9KTsgLy8gcmVzdWx0IGlnbm9yZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0b3JlLmZpbmRDb29raWVzKGhvc3QsIGFsbFBhdGhzID8gbnVsbCA6IHBhdGgsIGZ1bmN0aW9uKGVycixjb29raWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgY29va2llcyA9IGNvb2tpZXMuZmlsdGVyKG1hdGNoaW5nQ29va2llKTtcblxuICAgIC8vIHNvcnRpbmcgb2YgUzUuNCBwYXJ0IDJcbiAgICBpZiAob3B0aW9ucy5zb3J0ICE9PSBmYWxzZSkge1xuICAgICAgY29va2llcyA9IGNvb2tpZXMuc29ydChjb29raWVDb21wYXJlKTtcbiAgICB9XG5cbiAgICAvLyBTNS40IHBhcnQgM1xuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvb2tpZXMuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBjLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICB9KTtcbiAgICAvLyBUT0RPIHBlcnNpc3QgbGFzdEFjY2Vzc2VkXG5cbiAgICBjYihudWxsLGNvb2tpZXMpO1xuICB9KTtcbn07XG5cbkNBTl9CRV9TWU5DLnB1c2goJ2dldENvb2tpZVN0cmluZycpO1xuQ29va2llSmFyLnByb3RvdHlwZS5nZXRDb29raWVTdHJpbmcgPSBmdW5jdGlvbigvKi4uLiwgY2IqLykge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtcbiAgdmFyIGNiID0gYXJncy5wb3AoKTtcbiAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIsY29va2llcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNiKG51bGwsIGNvb2tpZXNcbiAgICAgICAgLnNvcnQoY29va2llQ29tcGFyZSlcbiAgICAgICAgLm1hcChmdW5jdGlvbihjKXtcbiAgICAgICAgICByZXR1cm4gYy5jb29raWVTdHJpbmcoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgfTtcbiAgYXJncy5wdXNoKG5leHQpO1xuICB0aGlzLmdldENvb2tpZXMuYXBwbHkodGhpcyxhcmdzKTtcbn07XG5cbkNBTl9CRV9TWU5DLnB1c2goJ2dldFNldENvb2tpZVN0cmluZ3MnKTtcbkNvb2tpZUphci5wcm90b3R5cGUuZ2V0U2V0Q29va2llU3RyaW5ncyA9IGZ1bmN0aW9uKC8qLi4uLCBjYiovKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO1xuICB2YXIgY2IgPSBhcmdzLnBvcCgpO1xuICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVycixjb29raWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgY29va2llcy5tYXAoZnVuY3Rpb24oYyl7XG4gICAgICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICBhcmdzLnB1c2gobmV4dCk7XG4gIHRoaXMuZ2V0Q29va2llcy5hcHBseSh0aGlzLGFyZ3MpO1xufTtcblxuQ0FOX0JFX1NZTkMucHVzaCgnc2VyaWFsaXplJyk7XG5Db29raWVKYXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciB0eXBlID0gdGhpcy5zdG9yZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB0eXBlID0gbnVsbDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBSRUFETUUubWQgXCJTZXJpYWxpemF0aW9uIEZvcm1hdFwiIGlmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIVxuICB2YXIgc2VyaWFsaXplZCA9IHtcbiAgICAvLyBUaGUgdmVyc2lvbiBvZiB0b3VnaC1jb29raWUgdGhhdCBzZXJpYWxpemVkIHRoaXMgamFyLiBHZW5lcmFsbHkgYSBnb29kXG4gICAgLy8gcHJhY3RpY2Ugc2luY2UgZnV0dXJlIHZlcnNpb25zIGNhbiBtYWtlIGRhdGEgaW1wb3J0IGRlY2lzaW9ucyBiYXNlZCBvblxuICAgIC8vIGtub3duIHBhc3QgYmVoYXZpb3IuIFdoZW4vaWYgdGhpcyBtYXR0ZXJzLCB1c2UgYHNlbXZlcmAuXG4gICAgdmVyc2lvbjogJ3RvdWdoLWNvb2tpZUAnK1ZFUlNJT04sXG5cbiAgICAvLyBhZGQgdGhlIHN0b3JlIHR5cGUsIHRvIG1ha2UgaHVtYW5zIGhhcHB5OlxuICAgIHN0b3JlVHlwZTogdHlwZSxcblxuICAgIC8vIENvb2tpZUphciBjb25maWd1cmF0aW9uOlxuICAgIHJlamVjdFB1YmxpY1N1ZmZpeGVzOiAhIXRoaXMucmVqZWN0UHVibGljU3VmZml4ZXMsXG5cbiAgICAvLyB0aGlzIGdldHMgZmlsbGVkIGZyb20gZ2V0QWxsQ29va2llczpcbiAgICBjb29raWVzOiBbXVxuICB9O1xuXG4gIGlmICghKHRoaXMuc3RvcmUuZ2V0QWxsQ29va2llcyAmJlxuICAgICAgICB0eXBlb2YgdGhpcy5zdG9yZS5nZXRBbGxDb29raWVzID09PSAnZnVuY3Rpb24nKSlcbiAge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ3N0b3JlIGRvZXMgbm90IHN1cHBvcnQgZ2V0QWxsQ29va2llcyBhbmQgY2Fubm90IGJlIHNlcmlhbGl6ZWQnKSk7XG4gIH1cblxuICB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMoZnVuY3Rpb24oZXJyLGNvb2tpZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG5cbiAgICBzZXJpYWxpemVkLmNvb2tpZXMgPSBjb29raWVzLm1hcChmdW5jdGlvbihjb29raWUpIHtcbiAgICAgIC8vIGNvbnZlcnQgdG8gc2VyaWFsaXplZCAncmF3JyBjb29raWVzXG4gICAgICBjb29raWUgPSAoY29va2llIGluc3RhbmNlb2YgQ29va2llKSA/IGNvb2tpZS50b0pTT04oKSA6IGNvb2tpZTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBpbmRleCBzbyBuZXcgb25lcyBnZXQgYXNzaWduZWQgZHVyaW5nIGRlc2VyaWFsaXphdGlvblxuICAgICAgZGVsZXRlIGNvb2tpZS5jcmVhdGlvbkluZGV4O1xuXG4gICAgICByZXR1cm4gY29va2llO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNiKG51bGwsIHNlcmlhbGl6ZWQpO1xuICB9KTtcbn07XG5cbi8vIHdlbGwta25vd24gbmFtZSB0aGF0IEpTT04uc3RyaW5naWZ5IGNhbGxzXG5Db29raWVKYXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zZXJpYWxpemVTeW5jKCk7XG59O1xuXG4vLyB1c2UgdGhlIGNsYXNzIG1ldGhvZCBDb29raWVKYXIuZGVzZXJpYWxpemUgaW5zdGVhZCBvZiBjYWxsaW5nIHRoaXMgZGlyZWN0bHlcbkNBTl9CRV9TWU5DLnB1c2goJ19pbXBvcnRDb29raWVzJyk7XG5Db29raWVKYXIucHJvdG90eXBlLl9pbXBvcnRDb29raWVzID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgY2IpIHtcbiAgdmFyIGphciA9IHRoaXM7XG4gIHZhciBjb29raWVzID0gc2VyaWFsaXplZC5jb29raWVzO1xuICBpZiAoIWNvb2tpZXMgfHwgIUFycmF5LmlzQXJyYXkoY29va2llcykpIHtcbiAgICByZXR1cm4gY2IobmV3IEVycm9yKCdzZXJpYWxpemVkIGphciBoYXMgbm8gY29va2llcyBhcnJheScpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1dE5leHQoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgaWYgKCFjb29raWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNiKGVyciwgamFyKTtcbiAgICB9XG5cbiAgICB2YXIgY29va2llO1xuICAgIHRyeSB7XG4gICAgICBjb29raWUgPSBmcm9tSlNPTihjb29raWVzLnNoaWZ0KCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBjYihlKTtcbiAgICB9XG5cbiAgICBpZiAoY29va2llID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcHV0TmV4dChudWxsKTsgLy8gc2tpcCB0aGlzIGNvb2tpZVxuICAgIH1cblxuICAgIGphci5zdG9yZS5wdXRDb29raWUoY29va2llLCBwdXROZXh0KTtcbiAgfVxuXG4gIHB1dE5leHQoKTtcbn07XG5cbkNvb2tpZUphci5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHN0ck9yT2JqLCBzdG9yZSwgY2IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAvLyBzdG9yZSBpcyBvcHRpb25hbFxuICAgIGNiID0gc3RvcmU7XG4gICAgc3RvcmUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWQ7XG4gIGlmICh0eXBlb2Ygc3RyT3JPYmogPT09ICdzdHJpbmcnKSB7XG4gICAgc2VyaWFsaXplZCA9IGpzb25QYXJzZShzdHJPck9iaik7XG4gICAgaWYgKHNlcmlhbGl6ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGNiKHNlcmlhbGl6ZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXJpYWxpemVkID0gc3RyT3JPYmo7XG4gIH1cblxuICB2YXIgamFyID0gbmV3IENvb2tpZUphcihzdG9yZSwgc2VyaWFsaXplZC5yZWplY3RQdWJsaWNTdWZmaXhlcyk7XG4gIGphci5faW1wb3J0Q29va2llcyhzZXJpYWxpemVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG4gICAgY2IobnVsbCwgamFyKTtcbiAgfSk7XG59O1xuXG5Db29raWVKYXIuZGVzZXJpYWxpemVTeW5jID0gZnVuY3Rpb24oc3RyT3JPYmosIHN0b3JlKSB7XG4gIHZhciBzZXJpYWxpemVkID0gdHlwZW9mIHN0ck9yT2JqID09PSAnc3RyaW5nJyA/XG4gICAgSlNPTi5wYXJzZShzdHJPck9iaikgOiBzdHJPck9iajtcbiAgdmFyIGphciA9IG5ldyBDb29raWVKYXIoc3RvcmUsIHNlcmlhbGl6ZWQucmVqZWN0UHVibGljU3VmZml4ZXMpO1xuXG4gIC8vIGNhdGNoIHRoaXMgbWlzdGFrZSBlYXJseTpcbiAgaWYgKCFqYXIuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvb2tpZUphciBzdG9yZSBpcyBub3Qgc3luY2hyb25vdXM7IHVzZSBhc3luYyBBUEkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIGphci5faW1wb3J0Q29va2llc1N5bmMoc2VyaWFsaXplZCk7XG4gIHJldHVybiBqYXI7XG59O1xuQ29va2llSmFyLmZyb21KU09OID0gQ29va2llSmFyLmRlc2VyaWFsaXplU3luYztcblxuQ0FOX0JFX1NZTkMucHVzaCgnY2xvbmUnKTtcbkNvb2tpZUphci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihuZXdTdG9yZSwgY2IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBjYiA9IG5ld1N0b3JlO1xuICAgIG5ld1N0b3JlID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuc2VyaWFsaXplKGZ1bmN0aW9uKGVycixzZXJpYWxpemVkKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuICAgIENvb2tpZUphci5kZXNlcmlhbGl6ZShuZXdTdG9yZSwgc2VyaWFsaXplZCwgY2IpO1xuICB9KTtcbn07XG5cbi8vIFVzZSBhIGNsb3N1cmUgdG8gcHJvdmlkZSBhIHRydWUgaW1wZXJhdGl2ZSBBUEkgZm9yIHN5bmNocm9ub3VzIHN0b3Jlcy5cbmZ1bmN0aW9uIHN5bmNXcmFwKG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnN0b3JlLnN5bmNocm9ub3VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvb2tpZUphciBzdG9yZSBpcyBub3Qgc3luY2hyb25vdXM7IHVzZSBhc3luYyBBUEkgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHN5bmNFcnIsIHN5bmNSZXN1bHQ7XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIHN5bmNDYihlcnIsIHJlc3VsdCkge1xuICAgICAgc3luY0VyciA9IGVycjtcbiAgICAgIHN5bmNSZXN1bHQgPSByZXN1bHQ7XG4gICAgfSk7XG4gICAgdGhpc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgaWYgKHN5bmNFcnIpIHtcbiAgICAgIHRocm93IHN5bmNFcnI7XG4gICAgfVxuICAgIHJldHVybiBzeW5jUmVzdWx0O1xuICB9O1xufVxuXG4vLyB3cmFwIGFsbCBkZWNsYXJlZCBDQU5fQkVfU1lOQyBtZXRob2RzIGluIHRoZSBzeW5jIHdyYXBwZXJcbkNBTl9CRV9TWU5DLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIENvb2tpZUphci5wcm90b3R5cGVbbWV0aG9kKydTeW5jJ10gPSBzeW5jV3JhcChtZXRob2QpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb29raWVKYXI6IENvb2tpZUphcixcbiAgQ29va2llOiBDb29raWUsXG4gIFN0b3JlOiBTdG9yZSxcbiAgTWVtb3J5Q29va2llU3RvcmU6IE1lbW9yeUNvb2tpZVN0b3JlLFxuICBwYXJzZURhdGU6IHBhcnNlRGF0ZSxcbiAgZm9ybWF0RGF0ZTogZm9ybWF0RGF0ZSxcbiAgcGFyc2U6IHBhcnNlLFxuICBmcm9tSlNPTjogZnJvbUpTT04sXG4gIGRvbWFpbk1hdGNoOiBkb21haW5NYXRjaCxcbiAgZGVmYXVsdFBhdGg6IGRlZmF1bHRQYXRoLFxuICBwYXRoTWF0Y2g6IHBhdGhNYXRjaCxcbiAgZ2V0UHVibGljU3VmZml4OiBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4LFxuICBjb29raWVDb21wYXJlOiBjb29raWVDb21wYXJlLFxuICBwZXJtdXRlRG9tYWluOiByZXF1aXJlKCcuL3Blcm11dGVEb21haW4nKS5wZXJtdXRlRG9tYWluLFxuICBwZXJtdXRlUGF0aDogcGVybXV0ZVBhdGgsXG4gIGNhbm9uaWNhbERvbWFpbjogY2Fub25pY2FsRG9tYWluXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RvdWdoLWNvb2tpZS9saWIvY29va2llLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2VtcHR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3VybC91cmwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdXJsL34vcHVueWNvZGUvcHVueWNvZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vd2VicGFjay9idWlsZGluL21vZHVsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9xdWVyeXN0cmluZy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcXVlcnlzdHJpbmcvZGVjb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcXVlcnlzdHJpbmcvZW5jb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBBVVRPTUFUSUNBTExZIEdFTkVSQVRFRCBieSBnZW5lcmF0ZS1wdWJzdWZmaXguanMgKlxuICogICAgICAgICAgICAgICAgICBETyBOT1QgRURJVCEgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxubW9kdWxlLmV4cG9ydHMuZ2V0UHVibGljU3VmZml4ID0gZnVuY3Rpb24gZ2V0UHVibGljU3VmZml4KGRvbWFpbikge1xuICAvKiFcbiAgICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgKlxuICAgKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAqXG4gICAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICpcbiAgICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gICAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICAgKlxuICAgKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIFNhbGVzZm9yY2UuY29tIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbiAgICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICAgKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gICAqXG4gICAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gICAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICAgKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gICAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gICAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICAgKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICAgKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICAgKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICAgKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgICovXG4gIGlmICghZG9tYWluKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGRvbWFpbi5tYXRjaCgvXlxcLi8pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGFzY2lpRG9tYWluID0gcHVueWNvZGUudG9BU0NJSShkb21haW4pO1xuICB2YXIgY29udmVydGVkID0gZmFsc2U7XG4gIGlmIChhc2NpaURvbWFpbiAhPT0gZG9tYWluKSB7XG4gICAgZG9tYWluID0gYXNjaWlEb21haW47XG4gICAgY29udmVydGVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaW5kZXhbZG9tYWluXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZG9tYWluID0gZG9tYWluLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBwYXJ0cyA9IGRvbWFpbi5zcGxpdCgnLicpLnJldmVyc2UoKTtcblxuICB2YXIgc3VmZml4ID0gJyc7XG4gIHZhciBzdWZmaXhMZW4gPSAwO1xuICBmb3IgKHZhciBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgIHZhciBzdGFyc3RyID0gJyonK3N1ZmZpeDtcbiAgICB2YXIgcGFydHN0ciA9IHBhcnQrc3VmZml4O1xuXG4gICAgaWYgKGluZGV4W3N0YXJzdHJdKSB7IC8vIHN0YXIgcnVsZSBtYXRjaGVzXG4gICAgICBzdWZmaXhMZW4gPSBpKzE7XG4gICAgICBpZiAoaW5kZXhbcGFydHN0cl0gPT09IGZhbHNlKSB7IC8vIGV4Y2VwdGlvbiBydWxlIG1hdGNoZXMgKE5COiBmYWxzZSwgbm90IHVuZGVmaW5lZClcbiAgICAgICAgc3VmZml4TGVuLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleFtwYXJ0c3RyXSkgeyAvLyBleGFjdCBtYXRjaCwgbm90IGV4Y2VwdGlvblxuICAgICAgc3VmZml4TGVuID0gaSsxO1xuICAgIH1cblxuICAgIHN1ZmZpeCA9ICcuJytwYXJ0c3RyO1xuICB9XG5cbiAgaWYgKGluZGV4WycqJytzdWZmaXhdKSB7IC8vICouZG9tYWluIGV4aXN0cyAoZS5nLiAqLmt5b3RvLmpwIGZvciBkb21haW49J2t5b3RvLmpwJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzdWZmaXhMZW4gPSBzdWZmaXhMZW4gfHwgMTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IHN1ZmZpeExlbikge1xuICAgIHZhciBwdWJsaWNTdWZmaXggPSBwYXJ0cy5zbGljZSgwLHN1ZmZpeExlbisxKS5yZXZlcnNlKCkuam9pbignLicpO1xuICAgIHJldHVybiBjb252ZXJ0ZWQgPyBwdW55Y29kZS50b1VuaWNvZGUocHVibGljU3VmZml4KSA6IHB1YmxpY1N1ZmZpeDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLy8gVGhlIGZvbGxvd2luZyBnZW5lcmF0ZWQgc3RydWN0dXJlIGlzIHVzZWQgdW5kZXIgdGhlIE1QTCB2ZXJzaW9uIDIuMFxuLy8gU2VlIHB1YmxpYy1zdWZmaXgudHh0IGZvciBtb3JlIGluZm9ybWF0aW9uXG5cbnZhciBpbmRleCA9IG1vZHVsZS5leHBvcnRzLmluZGV4ID0gT2JqZWN0LmZyZWV6ZShcbntcImFjXCI6dHJ1ZSxcImNvbS5hY1wiOnRydWUsXCJlZHUuYWNcIjp0cnVlLFwiZ292LmFjXCI6dHJ1ZSxcIm5ldC5hY1wiOnRydWUsXCJtaWwuYWNcIjp0cnVlLFwib3JnLmFjXCI6dHJ1ZSxcImFkXCI6dHJ1ZSxcIm5vbS5hZFwiOnRydWUsXCJhZVwiOnRydWUsXCJjby5hZVwiOnRydWUsXCJuZXQuYWVcIjp0cnVlLFwib3JnLmFlXCI6dHJ1ZSxcInNjaC5hZVwiOnRydWUsXCJhYy5hZVwiOnRydWUsXCJnb3YuYWVcIjp0cnVlLFwibWlsLmFlXCI6dHJ1ZSxcImFlcm9cIjp0cnVlLFwiYWNjaWRlbnQtaW52ZXN0aWdhdGlvbi5hZXJvXCI6dHJ1ZSxcImFjY2lkZW50LXByZXZlbnRpb24uYWVyb1wiOnRydWUsXCJhZXJvYmF0aWMuYWVyb1wiOnRydWUsXCJhZXJvY2x1Yi5hZXJvXCI6dHJ1ZSxcImFlcm9kcm9tZS5hZXJvXCI6dHJ1ZSxcImFnZW50cy5hZXJvXCI6dHJ1ZSxcImFpcmNyYWZ0LmFlcm9cIjp0cnVlLFwiYWlybGluZS5hZXJvXCI6dHJ1ZSxcImFpcnBvcnQuYWVyb1wiOnRydWUsXCJhaXItc3VydmVpbGxhbmNlLmFlcm9cIjp0cnVlLFwiYWlydHJhZmZpYy5hZXJvXCI6dHJ1ZSxcImFpci10cmFmZmljLWNvbnRyb2wuYWVyb1wiOnRydWUsXCJhbWJ1bGFuY2UuYWVyb1wiOnRydWUsXCJhbXVzZW1lbnQuYWVyb1wiOnRydWUsXCJhc3NvY2lhdGlvbi5hZXJvXCI6dHJ1ZSxcImF1dGhvci5hZXJvXCI6dHJ1ZSxcImJhbGxvb25pbmcuYWVyb1wiOnRydWUsXCJicm9rZXIuYWVyb1wiOnRydWUsXCJjYWEuYWVyb1wiOnRydWUsXCJjYXJnby5hZXJvXCI6dHJ1ZSxcImNhdGVyaW5nLmFlcm9cIjp0cnVlLFwiY2VydGlmaWNhdGlvbi5hZXJvXCI6dHJ1ZSxcImNoYW1waW9uc2hpcC5hZXJvXCI6dHJ1ZSxcImNoYXJ0ZXIuYWVyb1wiOnRydWUsXCJjaXZpbGF2aWF0aW9uLmFlcm9cIjp0cnVlLFwiY2x1Yi5hZXJvXCI6dHJ1ZSxcImNvbmZlcmVuY2UuYWVyb1wiOnRydWUsXCJjb25zdWx0YW50LmFlcm9cIjp0cnVlLFwiY29uc3VsdGluZy5hZXJvXCI6dHJ1ZSxcImNvbnRyb2wuYWVyb1wiOnRydWUsXCJjb3VuY2lsLmFlcm9cIjp0cnVlLFwiY3Jldy5hZXJvXCI6dHJ1ZSxcImRlc2lnbi5hZXJvXCI6dHJ1ZSxcImRnY2EuYWVyb1wiOnRydWUsXCJlZHVjYXRvci5hZXJvXCI6dHJ1ZSxcImVtZXJnZW5jeS5hZXJvXCI6dHJ1ZSxcImVuZ2luZS5hZXJvXCI6dHJ1ZSxcImVuZ2luZWVyLmFlcm9cIjp0cnVlLFwiZW50ZXJ0YWlubWVudC5hZXJvXCI6dHJ1ZSxcImVxdWlwbWVudC5hZXJvXCI6dHJ1ZSxcImV4Y2hhbmdlLmFlcm9cIjp0cnVlLFwiZXhwcmVzcy5hZXJvXCI6dHJ1ZSxcImZlZGVyYXRpb24uYWVyb1wiOnRydWUsXCJmbGlnaHQuYWVyb1wiOnRydWUsXCJmcmVpZ2h0LmFlcm9cIjp0cnVlLFwiZnVlbC5hZXJvXCI6dHJ1ZSxcImdsaWRpbmcuYWVyb1wiOnRydWUsXCJnb3Zlcm5tZW50LmFlcm9cIjp0cnVlLFwiZ3JvdW5kaGFuZGxpbmcuYWVyb1wiOnRydWUsXCJncm91cC5hZXJvXCI6dHJ1ZSxcImhhbmdnbGlkaW5nLmFlcm9cIjp0cnVlLFwiaG9tZWJ1aWx0LmFlcm9cIjp0cnVlLFwiaW5zdXJhbmNlLmFlcm9cIjp0cnVlLFwiam91cm5hbC5hZXJvXCI6dHJ1ZSxcImpvdXJuYWxpc3QuYWVyb1wiOnRydWUsXCJsZWFzaW5nLmFlcm9cIjp0cnVlLFwibG9naXN0aWNzLmFlcm9cIjp0cnVlLFwibWFnYXppbmUuYWVyb1wiOnRydWUsXCJtYWludGVuYW5jZS5hZXJvXCI6dHJ1ZSxcIm1hcmtldHBsYWNlLmFlcm9cIjp0cnVlLFwibWVkaWEuYWVyb1wiOnRydWUsXCJtaWNyb2xpZ2h0LmFlcm9cIjp0cnVlLFwibW9kZWxsaW5nLmFlcm9cIjp0cnVlLFwibmF2aWdhdGlvbi5hZXJvXCI6dHJ1ZSxcInBhcmFjaHV0aW5nLmFlcm9cIjp0cnVlLFwicGFyYWdsaWRpbmcuYWVyb1wiOnRydWUsXCJwYXNzZW5nZXItYXNzb2NpYXRpb24uYWVyb1wiOnRydWUsXCJwaWxvdC5hZXJvXCI6dHJ1ZSxcInByZXNzLmFlcm9cIjp0cnVlLFwicHJvZHVjdGlvbi5hZXJvXCI6dHJ1ZSxcInJlY3JlYXRpb24uYWVyb1wiOnRydWUsXCJyZXBib2R5LmFlcm9cIjp0cnVlLFwicmVzLmFlcm9cIjp0cnVlLFwicmVzZWFyY2guYWVyb1wiOnRydWUsXCJyb3RvcmNyYWZ0LmFlcm9cIjp0cnVlLFwic2FmZXR5LmFlcm9cIjp0cnVlLFwic2NpZW50aXN0LmFlcm9cIjp0cnVlLFwic2VydmljZXMuYWVyb1wiOnRydWUsXCJzaG93LmFlcm9cIjp0cnVlLFwic2t5ZGl2aW5nLmFlcm9cIjp0cnVlLFwic29mdHdhcmUuYWVyb1wiOnRydWUsXCJzdHVkZW50LmFlcm9cIjp0cnVlLFwidGF4aS5hZXJvXCI6dHJ1ZSxcInRyYWRlci5hZXJvXCI6dHJ1ZSxcInRyYWRpbmcuYWVyb1wiOnRydWUsXCJ0cmFpbmVyLmFlcm9cIjp0cnVlLFwidW5pb24uYWVyb1wiOnRydWUsXCJ3b3JraW5nZ3JvdXAuYWVyb1wiOnRydWUsXCJ3b3Jrcy5hZXJvXCI6dHJ1ZSxcImFmXCI6dHJ1ZSxcImdvdi5hZlwiOnRydWUsXCJjb20uYWZcIjp0cnVlLFwib3JnLmFmXCI6dHJ1ZSxcIm5ldC5hZlwiOnRydWUsXCJlZHUuYWZcIjp0cnVlLFwiYWdcIjp0cnVlLFwiY29tLmFnXCI6dHJ1ZSxcIm9yZy5hZ1wiOnRydWUsXCJuZXQuYWdcIjp0cnVlLFwiY28uYWdcIjp0cnVlLFwibm9tLmFnXCI6dHJ1ZSxcImFpXCI6dHJ1ZSxcIm9mZi5haVwiOnRydWUsXCJjb20uYWlcIjp0cnVlLFwibmV0LmFpXCI6dHJ1ZSxcIm9yZy5haVwiOnRydWUsXCJhbFwiOnRydWUsXCJjb20uYWxcIjp0cnVlLFwiZWR1LmFsXCI6dHJ1ZSxcImdvdi5hbFwiOnRydWUsXCJtaWwuYWxcIjp0cnVlLFwibmV0LmFsXCI6dHJ1ZSxcIm9yZy5hbFwiOnRydWUsXCJhbVwiOnRydWUsXCJhblwiOnRydWUsXCJjb20uYW5cIjp0cnVlLFwibmV0LmFuXCI6dHJ1ZSxcIm9yZy5hblwiOnRydWUsXCJlZHUuYW5cIjp0cnVlLFwiYW9cIjp0cnVlLFwiZWQuYW9cIjp0cnVlLFwiZ3YuYW9cIjp0cnVlLFwib2cuYW9cIjp0cnVlLFwiY28uYW9cIjp0cnVlLFwicGIuYW9cIjp0cnVlLFwiaXQuYW9cIjp0cnVlLFwiYXFcIjp0cnVlLFwiYXJcIjp0cnVlLFwiY29tLmFyXCI6dHJ1ZSxcImVkdS5hclwiOnRydWUsXCJnb2IuYXJcIjp0cnVlLFwiZ292LmFyXCI6dHJ1ZSxcImludC5hclwiOnRydWUsXCJtaWwuYXJcIjp0cnVlLFwibmV0LmFyXCI6dHJ1ZSxcIm9yZy5hclwiOnRydWUsXCJ0dXIuYXJcIjp0cnVlLFwiYXJwYVwiOnRydWUsXCJlMTY0LmFycGFcIjp0cnVlLFwiaW4tYWRkci5hcnBhXCI6dHJ1ZSxcImlwNi5hcnBhXCI6dHJ1ZSxcImlyaXMuYXJwYVwiOnRydWUsXCJ1cmkuYXJwYVwiOnRydWUsXCJ1cm4uYXJwYVwiOnRydWUsXCJhc1wiOnRydWUsXCJnb3YuYXNcIjp0cnVlLFwiYXNpYVwiOnRydWUsXCJhdFwiOnRydWUsXCJhYy5hdFwiOnRydWUsXCJjby5hdFwiOnRydWUsXCJndi5hdFwiOnRydWUsXCJvci5hdFwiOnRydWUsXCJhdVwiOnRydWUsXCJjb20uYXVcIjp0cnVlLFwibmV0LmF1XCI6dHJ1ZSxcIm9yZy5hdVwiOnRydWUsXCJlZHUuYXVcIjp0cnVlLFwiZ292LmF1XCI6dHJ1ZSxcImFzbi5hdVwiOnRydWUsXCJpZC5hdVwiOnRydWUsXCJpbmZvLmF1XCI6dHJ1ZSxcImNvbmYuYXVcIjp0cnVlLFwib3ouYXVcIjp0cnVlLFwiYWN0LmF1XCI6dHJ1ZSxcIm5zdy5hdVwiOnRydWUsXCJudC5hdVwiOnRydWUsXCJxbGQuYXVcIjp0cnVlLFwic2EuYXVcIjp0cnVlLFwidGFzLmF1XCI6dHJ1ZSxcInZpYy5hdVwiOnRydWUsXCJ3YS5hdVwiOnRydWUsXCJhY3QuZWR1LmF1XCI6dHJ1ZSxcIm5zdy5lZHUuYXVcIjp0cnVlLFwibnQuZWR1LmF1XCI6dHJ1ZSxcInFsZC5lZHUuYXVcIjp0cnVlLFwic2EuZWR1LmF1XCI6dHJ1ZSxcInRhcy5lZHUuYXVcIjp0cnVlLFwidmljLmVkdS5hdVwiOnRydWUsXCJ3YS5lZHUuYXVcIjp0cnVlLFwicWxkLmdvdi5hdVwiOnRydWUsXCJzYS5nb3YuYXVcIjp0cnVlLFwidGFzLmdvdi5hdVwiOnRydWUsXCJ2aWMuZ292LmF1XCI6dHJ1ZSxcIndhLmdvdi5hdVwiOnRydWUsXCJhd1wiOnRydWUsXCJjb20uYXdcIjp0cnVlLFwiYXhcIjp0cnVlLFwiYXpcIjp0cnVlLFwiY29tLmF6XCI6dHJ1ZSxcIm5ldC5helwiOnRydWUsXCJpbnQuYXpcIjp0cnVlLFwiZ292LmF6XCI6dHJ1ZSxcIm9yZy5helwiOnRydWUsXCJlZHUuYXpcIjp0cnVlLFwiaW5mby5helwiOnRydWUsXCJwcC5helwiOnRydWUsXCJtaWwuYXpcIjp0cnVlLFwibmFtZS5helwiOnRydWUsXCJwcm8uYXpcIjp0cnVlLFwiYml6LmF6XCI6dHJ1ZSxcImJhXCI6dHJ1ZSxcIm9yZy5iYVwiOnRydWUsXCJuZXQuYmFcIjp0cnVlLFwiZWR1LmJhXCI6dHJ1ZSxcImdvdi5iYVwiOnRydWUsXCJtaWwuYmFcIjp0cnVlLFwidW5zYS5iYVwiOnRydWUsXCJ1bmJpLmJhXCI6dHJ1ZSxcImNvLmJhXCI6dHJ1ZSxcImNvbS5iYVwiOnRydWUsXCJycy5iYVwiOnRydWUsXCJiYlwiOnRydWUsXCJiaXouYmJcIjp0cnVlLFwiY28uYmJcIjp0cnVlLFwiY29tLmJiXCI6dHJ1ZSxcImVkdS5iYlwiOnRydWUsXCJnb3YuYmJcIjp0cnVlLFwiaW5mby5iYlwiOnRydWUsXCJuZXQuYmJcIjp0cnVlLFwib3JnLmJiXCI6dHJ1ZSxcInN0b3JlLmJiXCI6dHJ1ZSxcInR2LmJiXCI6dHJ1ZSxcIiouYmRcIjp0cnVlLFwiYmVcIjp0cnVlLFwiYWMuYmVcIjp0cnVlLFwiYmZcIjp0cnVlLFwiZ292LmJmXCI6dHJ1ZSxcImJnXCI6dHJ1ZSxcImEuYmdcIjp0cnVlLFwiYi5iZ1wiOnRydWUsXCJjLmJnXCI6dHJ1ZSxcImQuYmdcIjp0cnVlLFwiZS5iZ1wiOnRydWUsXCJmLmJnXCI6dHJ1ZSxcImcuYmdcIjp0cnVlLFwiaC5iZ1wiOnRydWUsXCJpLmJnXCI6dHJ1ZSxcImouYmdcIjp0cnVlLFwiay5iZ1wiOnRydWUsXCJsLmJnXCI6dHJ1ZSxcIm0uYmdcIjp0cnVlLFwibi5iZ1wiOnRydWUsXCJvLmJnXCI6dHJ1ZSxcInAuYmdcIjp0cnVlLFwicS5iZ1wiOnRydWUsXCJyLmJnXCI6dHJ1ZSxcInMuYmdcIjp0cnVlLFwidC5iZ1wiOnRydWUsXCJ1LmJnXCI6dHJ1ZSxcInYuYmdcIjp0cnVlLFwidy5iZ1wiOnRydWUsXCJ4LmJnXCI6dHJ1ZSxcInkuYmdcIjp0cnVlLFwiei5iZ1wiOnRydWUsXCIwLmJnXCI6dHJ1ZSxcIjEuYmdcIjp0cnVlLFwiMi5iZ1wiOnRydWUsXCIzLmJnXCI6dHJ1ZSxcIjQuYmdcIjp0cnVlLFwiNS5iZ1wiOnRydWUsXCI2LmJnXCI6dHJ1ZSxcIjcuYmdcIjp0cnVlLFwiOC5iZ1wiOnRydWUsXCI5LmJnXCI6dHJ1ZSxcImJoXCI6dHJ1ZSxcImNvbS5iaFwiOnRydWUsXCJlZHUuYmhcIjp0cnVlLFwibmV0LmJoXCI6dHJ1ZSxcIm9yZy5iaFwiOnRydWUsXCJnb3YuYmhcIjp0cnVlLFwiYmlcIjp0cnVlLFwiY28uYmlcIjp0cnVlLFwiY29tLmJpXCI6dHJ1ZSxcImVkdS5iaVwiOnRydWUsXCJvci5iaVwiOnRydWUsXCJvcmcuYmlcIjp0cnVlLFwiYml6XCI6dHJ1ZSxcImJqXCI6dHJ1ZSxcImFzc28uYmpcIjp0cnVlLFwiYmFycmVhdS5ialwiOnRydWUsXCJnb3V2LmJqXCI6dHJ1ZSxcImJtXCI6dHJ1ZSxcImNvbS5ibVwiOnRydWUsXCJlZHUuYm1cIjp0cnVlLFwiZ292LmJtXCI6dHJ1ZSxcIm5ldC5ibVwiOnRydWUsXCJvcmcuYm1cIjp0cnVlLFwiKi5iblwiOnRydWUsXCJib1wiOnRydWUsXCJjb20uYm9cIjp0cnVlLFwiZWR1LmJvXCI6dHJ1ZSxcImdvdi5ib1wiOnRydWUsXCJnb2IuYm9cIjp0cnVlLFwiaW50LmJvXCI6dHJ1ZSxcIm9yZy5ib1wiOnRydWUsXCJuZXQuYm9cIjp0cnVlLFwibWlsLmJvXCI6dHJ1ZSxcInR2LmJvXCI6dHJ1ZSxcImJyXCI6dHJ1ZSxcImFkbS5iclwiOnRydWUsXCJhZHYuYnJcIjp0cnVlLFwiYWdyLmJyXCI6dHJ1ZSxcImFtLmJyXCI6dHJ1ZSxcImFycS5iclwiOnRydWUsXCJhcnQuYnJcIjp0cnVlLFwiYXRvLmJyXCI6dHJ1ZSxcImIuYnJcIjp0cnVlLFwiYmlvLmJyXCI6dHJ1ZSxcImJsb2cuYnJcIjp0cnVlLFwiYm1kLmJyXCI6dHJ1ZSxcImNpbS5iclwiOnRydWUsXCJjbmcuYnJcIjp0cnVlLFwiY250LmJyXCI6dHJ1ZSxcImNvbS5iclwiOnRydWUsXCJjb29wLmJyXCI6dHJ1ZSxcImVjbi5iclwiOnRydWUsXCJlY28uYnJcIjp0cnVlLFwiZWR1LmJyXCI6dHJ1ZSxcImVtcC5iclwiOnRydWUsXCJlbmcuYnJcIjp0cnVlLFwiZXNwLmJyXCI6dHJ1ZSxcImV0Yy5iclwiOnRydWUsXCJldGkuYnJcIjp0cnVlLFwiZmFyLmJyXCI6dHJ1ZSxcImZsb2cuYnJcIjp0cnVlLFwiZm0uYnJcIjp0cnVlLFwiZm5kLmJyXCI6dHJ1ZSxcImZvdC5iclwiOnRydWUsXCJmc3QuYnJcIjp0cnVlLFwiZzEyLmJyXCI6dHJ1ZSxcImdnZi5iclwiOnRydWUsXCJnb3YuYnJcIjp0cnVlLFwiaW1iLmJyXCI6dHJ1ZSxcImluZC5iclwiOnRydWUsXCJpbmYuYnJcIjp0cnVlLFwiam9yLmJyXCI6dHJ1ZSxcImp1cy5iclwiOnRydWUsXCJsZWcuYnJcIjp0cnVlLFwibGVsLmJyXCI6dHJ1ZSxcIm1hdC5iclwiOnRydWUsXCJtZWQuYnJcIjp0cnVlLFwibWlsLmJyXCI6dHJ1ZSxcIm1wLmJyXCI6dHJ1ZSxcIm11cy5iclwiOnRydWUsXCJuZXQuYnJcIjp0cnVlLFwiKi5ub20uYnJcIjp0cnVlLFwibm90LmJyXCI6dHJ1ZSxcIm50ci5iclwiOnRydWUsXCJvZG8uYnJcIjp0cnVlLFwib3JnLmJyXCI6dHJ1ZSxcInBwZy5iclwiOnRydWUsXCJwcm8uYnJcIjp0cnVlLFwicHNjLmJyXCI6dHJ1ZSxcInBzaS5iclwiOnRydWUsXCJxc2wuYnJcIjp0cnVlLFwicmFkaW8uYnJcIjp0cnVlLFwicmVjLmJyXCI6dHJ1ZSxcInNsZy5iclwiOnRydWUsXCJzcnYuYnJcIjp0cnVlLFwidGF4aS5iclwiOnRydWUsXCJ0ZW8uYnJcIjp0cnVlLFwidG1wLmJyXCI6dHJ1ZSxcInRyZC5iclwiOnRydWUsXCJ0dXIuYnJcIjp0cnVlLFwidHYuYnJcIjp0cnVlLFwidmV0LmJyXCI6dHJ1ZSxcInZsb2cuYnJcIjp0cnVlLFwid2lraS5iclwiOnRydWUsXCJ6bGcuYnJcIjp0cnVlLFwiYnNcIjp0cnVlLFwiY29tLmJzXCI6dHJ1ZSxcIm5ldC5ic1wiOnRydWUsXCJvcmcuYnNcIjp0cnVlLFwiZWR1LmJzXCI6dHJ1ZSxcImdvdi5ic1wiOnRydWUsXCJidFwiOnRydWUsXCJjb20uYnRcIjp0cnVlLFwiZWR1LmJ0XCI6dHJ1ZSxcImdvdi5idFwiOnRydWUsXCJuZXQuYnRcIjp0cnVlLFwib3JnLmJ0XCI6dHJ1ZSxcImJ2XCI6dHJ1ZSxcImJ3XCI6dHJ1ZSxcImNvLmJ3XCI6dHJ1ZSxcIm9yZy5id1wiOnRydWUsXCJieVwiOnRydWUsXCJnb3YuYnlcIjp0cnVlLFwibWlsLmJ5XCI6dHJ1ZSxcImNvbS5ieVwiOnRydWUsXCJvZi5ieVwiOnRydWUsXCJielwiOnRydWUsXCJjb20uYnpcIjp0cnVlLFwibmV0LmJ6XCI6dHJ1ZSxcIm9yZy5ielwiOnRydWUsXCJlZHUuYnpcIjp0cnVlLFwiZ292LmJ6XCI6dHJ1ZSxcImNhXCI6dHJ1ZSxcImFiLmNhXCI6dHJ1ZSxcImJjLmNhXCI6dHJ1ZSxcIm1iLmNhXCI6dHJ1ZSxcIm5iLmNhXCI6dHJ1ZSxcIm5mLmNhXCI6dHJ1ZSxcIm5sLmNhXCI6dHJ1ZSxcIm5zLmNhXCI6dHJ1ZSxcIm50LmNhXCI6dHJ1ZSxcIm51LmNhXCI6dHJ1ZSxcIm9uLmNhXCI6dHJ1ZSxcInBlLmNhXCI6dHJ1ZSxcInFjLmNhXCI6dHJ1ZSxcInNrLmNhXCI6dHJ1ZSxcInlrLmNhXCI6dHJ1ZSxcImdjLmNhXCI6dHJ1ZSxcImNhdFwiOnRydWUsXCJjY1wiOnRydWUsXCJjZFwiOnRydWUsXCJnb3YuY2RcIjp0cnVlLFwiY2ZcIjp0cnVlLFwiY2dcIjp0cnVlLFwiY2hcIjp0cnVlLFwiY2lcIjp0cnVlLFwib3JnLmNpXCI6dHJ1ZSxcIm9yLmNpXCI6dHJ1ZSxcImNvbS5jaVwiOnRydWUsXCJjby5jaVwiOnRydWUsXCJlZHUuY2lcIjp0cnVlLFwiZWQuY2lcIjp0cnVlLFwiYWMuY2lcIjp0cnVlLFwibmV0LmNpXCI6dHJ1ZSxcImdvLmNpXCI6dHJ1ZSxcImFzc28uY2lcIjp0cnVlLFwieG4tLWFyb3BvcnQtYnlhLmNpXCI6dHJ1ZSxcImludC5jaVwiOnRydWUsXCJwcmVzc2UuY2lcIjp0cnVlLFwibWQuY2lcIjp0cnVlLFwiZ291di5jaVwiOnRydWUsXCIqLmNrXCI6dHJ1ZSxcInd3dy5ja1wiOmZhbHNlLFwiY2xcIjp0cnVlLFwiZ292LmNsXCI6dHJ1ZSxcImdvYi5jbFwiOnRydWUsXCJjby5jbFwiOnRydWUsXCJtaWwuY2xcIjp0cnVlLFwiY21cIjp0cnVlLFwiY28uY21cIjp0cnVlLFwiY29tLmNtXCI6dHJ1ZSxcImdvdi5jbVwiOnRydWUsXCJuZXQuY21cIjp0cnVlLFwiY25cIjp0cnVlLFwiYWMuY25cIjp0cnVlLFwiY29tLmNuXCI6dHJ1ZSxcImVkdS5jblwiOnRydWUsXCJnb3YuY25cIjp0cnVlLFwibmV0LmNuXCI6dHJ1ZSxcIm9yZy5jblwiOnRydWUsXCJtaWwuY25cIjp0cnVlLFwieG4tLTU1cXg1ZC5jblwiOnRydWUsXCJ4bi0taW8wYTdpLmNuXCI6dHJ1ZSxcInhuLS1vZDBhbGcuY25cIjp0cnVlLFwiYWguY25cIjp0cnVlLFwiYmouY25cIjp0cnVlLFwiY3EuY25cIjp0cnVlLFwiZmouY25cIjp0cnVlLFwiZ2QuY25cIjp0cnVlLFwiZ3MuY25cIjp0cnVlLFwiZ3ouY25cIjp0cnVlLFwiZ3guY25cIjp0cnVlLFwiaGEuY25cIjp0cnVlLFwiaGIuY25cIjp0cnVlLFwiaGUuY25cIjp0cnVlLFwiaGkuY25cIjp0cnVlLFwiaGwuY25cIjp0cnVlLFwiaG4uY25cIjp0cnVlLFwiamwuY25cIjp0cnVlLFwianMuY25cIjp0cnVlLFwianguY25cIjp0cnVlLFwibG4uY25cIjp0cnVlLFwibm0uY25cIjp0cnVlLFwibnguY25cIjp0cnVlLFwicWguY25cIjp0cnVlLFwic2MuY25cIjp0cnVlLFwic2QuY25cIjp0cnVlLFwic2guY25cIjp0cnVlLFwic24uY25cIjp0cnVlLFwic3guY25cIjp0cnVlLFwidGouY25cIjp0cnVlLFwieGouY25cIjp0cnVlLFwieHouY25cIjp0cnVlLFwieW4uY25cIjp0cnVlLFwiemouY25cIjp0cnVlLFwiaGsuY25cIjp0cnVlLFwibW8uY25cIjp0cnVlLFwidHcuY25cIjp0cnVlLFwiY29cIjp0cnVlLFwiYXJ0cy5jb1wiOnRydWUsXCJjb20uY29cIjp0cnVlLFwiZWR1LmNvXCI6dHJ1ZSxcImZpcm0uY29cIjp0cnVlLFwiZ292LmNvXCI6dHJ1ZSxcImluZm8uY29cIjp0cnVlLFwiaW50LmNvXCI6dHJ1ZSxcIm1pbC5jb1wiOnRydWUsXCJuZXQuY29cIjp0cnVlLFwibm9tLmNvXCI6dHJ1ZSxcIm9yZy5jb1wiOnRydWUsXCJyZWMuY29cIjp0cnVlLFwid2ViLmNvXCI6dHJ1ZSxcImNvbVwiOnRydWUsXCJjb29wXCI6dHJ1ZSxcImNyXCI6dHJ1ZSxcImFjLmNyXCI6dHJ1ZSxcImNvLmNyXCI6dHJ1ZSxcImVkLmNyXCI6dHJ1ZSxcImZpLmNyXCI6dHJ1ZSxcImdvLmNyXCI6dHJ1ZSxcIm9yLmNyXCI6dHJ1ZSxcInNhLmNyXCI6dHJ1ZSxcImN1XCI6dHJ1ZSxcImNvbS5jdVwiOnRydWUsXCJlZHUuY3VcIjp0cnVlLFwib3JnLmN1XCI6dHJ1ZSxcIm5ldC5jdVwiOnRydWUsXCJnb3YuY3VcIjp0cnVlLFwiaW5mLmN1XCI6dHJ1ZSxcImN2XCI6dHJ1ZSxcImN3XCI6dHJ1ZSxcImNvbS5jd1wiOnRydWUsXCJlZHUuY3dcIjp0cnVlLFwibmV0LmN3XCI6dHJ1ZSxcIm9yZy5jd1wiOnRydWUsXCJjeFwiOnRydWUsXCJnb3YuY3hcIjp0cnVlLFwiYWMuY3lcIjp0cnVlLFwiYml6LmN5XCI6dHJ1ZSxcImNvbS5jeVwiOnRydWUsXCJla2xvZ2VzLmN5XCI6dHJ1ZSxcImdvdi5jeVwiOnRydWUsXCJsdGQuY3lcIjp0cnVlLFwibmFtZS5jeVwiOnRydWUsXCJuZXQuY3lcIjp0cnVlLFwib3JnLmN5XCI6dHJ1ZSxcInBhcmxpYW1lbnQuY3lcIjp0cnVlLFwicHJlc3MuY3lcIjp0cnVlLFwicHJvLmN5XCI6dHJ1ZSxcInRtLmN5XCI6dHJ1ZSxcImN6XCI6dHJ1ZSxcImRlXCI6dHJ1ZSxcImRqXCI6dHJ1ZSxcImRrXCI6dHJ1ZSxcImRtXCI6dHJ1ZSxcImNvbS5kbVwiOnRydWUsXCJuZXQuZG1cIjp0cnVlLFwib3JnLmRtXCI6dHJ1ZSxcImVkdS5kbVwiOnRydWUsXCJnb3YuZG1cIjp0cnVlLFwiZG9cIjp0cnVlLFwiYXJ0LmRvXCI6dHJ1ZSxcImNvbS5kb1wiOnRydWUsXCJlZHUuZG9cIjp0cnVlLFwiZ29iLmRvXCI6dHJ1ZSxcImdvdi5kb1wiOnRydWUsXCJtaWwuZG9cIjp0cnVlLFwibmV0LmRvXCI6dHJ1ZSxcIm9yZy5kb1wiOnRydWUsXCJzbGQuZG9cIjp0cnVlLFwid2ViLmRvXCI6dHJ1ZSxcImR6XCI6dHJ1ZSxcImNvbS5kelwiOnRydWUsXCJvcmcuZHpcIjp0cnVlLFwibmV0LmR6XCI6dHJ1ZSxcImdvdi5kelwiOnRydWUsXCJlZHUuZHpcIjp0cnVlLFwiYXNzby5kelwiOnRydWUsXCJwb2wuZHpcIjp0cnVlLFwiYXJ0LmR6XCI6dHJ1ZSxcImVjXCI6dHJ1ZSxcImNvbS5lY1wiOnRydWUsXCJpbmZvLmVjXCI6dHJ1ZSxcIm5ldC5lY1wiOnRydWUsXCJmaW4uZWNcIjp0cnVlLFwiazEyLmVjXCI6dHJ1ZSxcIm1lZC5lY1wiOnRydWUsXCJwcm8uZWNcIjp0cnVlLFwib3JnLmVjXCI6dHJ1ZSxcImVkdS5lY1wiOnRydWUsXCJnb3YuZWNcIjp0cnVlLFwiZ29iLmVjXCI6dHJ1ZSxcIm1pbC5lY1wiOnRydWUsXCJlZHVcIjp0cnVlLFwiZWVcIjp0cnVlLFwiZWR1LmVlXCI6dHJ1ZSxcImdvdi5lZVwiOnRydWUsXCJyaWlrLmVlXCI6dHJ1ZSxcImxpYi5lZVwiOnRydWUsXCJtZWQuZWVcIjp0cnVlLFwiY29tLmVlXCI6dHJ1ZSxcInByaS5lZVwiOnRydWUsXCJhaXAuZWVcIjp0cnVlLFwib3JnLmVlXCI6dHJ1ZSxcImZpZS5lZVwiOnRydWUsXCJlZ1wiOnRydWUsXCJjb20uZWdcIjp0cnVlLFwiZWR1LmVnXCI6dHJ1ZSxcImV1bi5lZ1wiOnRydWUsXCJnb3YuZWdcIjp0cnVlLFwibWlsLmVnXCI6dHJ1ZSxcIm5hbWUuZWdcIjp0cnVlLFwibmV0LmVnXCI6dHJ1ZSxcIm9yZy5lZ1wiOnRydWUsXCJzY2kuZWdcIjp0cnVlLFwiKi5lclwiOnRydWUsXCJlc1wiOnRydWUsXCJjb20uZXNcIjp0cnVlLFwibm9tLmVzXCI6dHJ1ZSxcIm9yZy5lc1wiOnRydWUsXCJnb2IuZXNcIjp0cnVlLFwiZWR1LmVzXCI6dHJ1ZSxcImV0XCI6dHJ1ZSxcImNvbS5ldFwiOnRydWUsXCJnb3YuZXRcIjp0cnVlLFwib3JnLmV0XCI6dHJ1ZSxcImVkdS5ldFwiOnRydWUsXCJiaXouZXRcIjp0cnVlLFwibmFtZS5ldFwiOnRydWUsXCJpbmZvLmV0XCI6dHJ1ZSxcIm5ldC5ldFwiOnRydWUsXCJldVwiOnRydWUsXCJmaVwiOnRydWUsXCJhbGFuZC5maVwiOnRydWUsXCIqLmZqXCI6dHJ1ZSxcIiouZmtcIjp0cnVlLFwiZm1cIjp0cnVlLFwiZm9cIjp0cnVlLFwiZnJcIjp0cnVlLFwiY29tLmZyXCI6dHJ1ZSxcImFzc28uZnJcIjp0cnVlLFwibm9tLmZyXCI6dHJ1ZSxcInByZC5mclwiOnRydWUsXCJwcmVzc2UuZnJcIjp0cnVlLFwidG0uZnJcIjp0cnVlLFwiYWVyb3BvcnQuZnJcIjp0cnVlLFwiYXNzZWRpYy5mclwiOnRydWUsXCJhdm9jYXQuZnJcIjp0cnVlLFwiYXZvdWVzLmZyXCI6dHJ1ZSxcImNjaS5mclwiOnRydWUsXCJjaGFtYmFncmkuZnJcIjp0cnVlLFwiY2hpcnVyZ2llbnMtZGVudGlzdGVzLmZyXCI6dHJ1ZSxcImV4cGVydHMtY29tcHRhYmxlcy5mclwiOnRydWUsXCJnZW9tZXRyZS1leHBlcnQuZnJcIjp0cnVlLFwiZ291di5mclwiOnRydWUsXCJncmV0YS5mclwiOnRydWUsXCJodWlzc2llci1qdXN0aWNlLmZyXCI6dHJ1ZSxcIm1lZGVjaW4uZnJcIjp0cnVlLFwibm90YWlyZXMuZnJcIjp0cnVlLFwicGhhcm1hY2llbi5mclwiOnRydWUsXCJwb3J0LmZyXCI6dHJ1ZSxcInZldGVyaW5haXJlLmZyXCI6dHJ1ZSxcImdhXCI6dHJ1ZSxcImdiXCI6dHJ1ZSxcImdkXCI6dHJ1ZSxcImdlXCI6dHJ1ZSxcImNvbS5nZVwiOnRydWUsXCJlZHUuZ2VcIjp0cnVlLFwiZ292LmdlXCI6dHJ1ZSxcIm9yZy5nZVwiOnRydWUsXCJtaWwuZ2VcIjp0cnVlLFwibmV0LmdlXCI6dHJ1ZSxcInB2dC5nZVwiOnRydWUsXCJnZlwiOnRydWUsXCJnZ1wiOnRydWUsXCJjby5nZ1wiOnRydWUsXCJuZXQuZ2dcIjp0cnVlLFwib3JnLmdnXCI6dHJ1ZSxcImdoXCI6dHJ1ZSxcImNvbS5naFwiOnRydWUsXCJlZHUuZ2hcIjp0cnVlLFwiZ292LmdoXCI6dHJ1ZSxcIm9yZy5naFwiOnRydWUsXCJtaWwuZ2hcIjp0cnVlLFwiZ2lcIjp0cnVlLFwiY29tLmdpXCI6dHJ1ZSxcImx0ZC5naVwiOnRydWUsXCJnb3YuZ2lcIjp0cnVlLFwibW9kLmdpXCI6dHJ1ZSxcImVkdS5naVwiOnRydWUsXCJvcmcuZ2lcIjp0cnVlLFwiZ2xcIjp0cnVlLFwiY28uZ2xcIjp0cnVlLFwiY29tLmdsXCI6dHJ1ZSxcImVkdS5nbFwiOnRydWUsXCJuZXQuZ2xcIjp0cnVlLFwib3JnLmdsXCI6dHJ1ZSxcImdtXCI6dHJ1ZSxcImduXCI6dHJ1ZSxcImFjLmduXCI6dHJ1ZSxcImNvbS5nblwiOnRydWUsXCJlZHUuZ25cIjp0cnVlLFwiZ292LmduXCI6dHJ1ZSxcIm9yZy5nblwiOnRydWUsXCJuZXQuZ25cIjp0cnVlLFwiZ292XCI6dHJ1ZSxcImdwXCI6dHJ1ZSxcImNvbS5ncFwiOnRydWUsXCJuZXQuZ3BcIjp0cnVlLFwibW9iaS5ncFwiOnRydWUsXCJlZHUuZ3BcIjp0cnVlLFwib3JnLmdwXCI6dHJ1ZSxcImFzc28uZ3BcIjp0cnVlLFwiZ3FcIjp0cnVlLFwiZ3JcIjp0cnVlLFwiY29tLmdyXCI6dHJ1ZSxcImVkdS5nclwiOnRydWUsXCJuZXQuZ3JcIjp0cnVlLFwib3JnLmdyXCI6dHJ1ZSxcImdvdi5nclwiOnRydWUsXCJnc1wiOnRydWUsXCJndFwiOnRydWUsXCJjb20uZ3RcIjp0cnVlLFwiZWR1Lmd0XCI6dHJ1ZSxcImdvYi5ndFwiOnRydWUsXCJpbmQuZ3RcIjp0cnVlLFwibWlsLmd0XCI6dHJ1ZSxcIm5ldC5ndFwiOnRydWUsXCJvcmcuZ3RcIjp0cnVlLFwiKi5ndVwiOnRydWUsXCJnd1wiOnRydWUsXCJneVwiOnRydWUsXCJjby5neVwiOnRydWUsXCJjb20uZ3lcIjp0cnVlLFwibmV0Lmd5XCI6dHJ1ZSxcImhrXCI6dHJ1ZSxcImNvbS5oa1wiOnRydWUsXCJlZHUuaGtcIjp0cnVlLFwiZ292LmhrXCI6dHJ1ZSxcImlkdi5oa1wiOnRydWUsXCJuZXQuaGtcIjp0cnVlLFwib3JnLmhrXCI6dHJ1ZSxcInhuLS01NXF4NWQuaGtcIjp0cnVlLFwieG4tLXdjdnMyMmQuaGtcIjp0cnVlLFwieG4tLWxjdnIzMmQuaGtcIjp0cnVlLFwieG4tLW14dHExbS5oa1wiOnRydWUsXCJ4bi0tZ21xdzVhLmhrXCI6dHJ1ZSxcInhuLS1jaXFwbi5oa1wiOnRydWUsXCJ4bi0tZ21xMDUwaS5oa1wiOnRydWUsXCJ4bi0temYwYXZ4LmhrXCI6dHJ1ZSxcInhuLS1pbzBhN2kuaGtcIjp0cnVlLFwieG4tLW1rMGF4aS5oa1wiOnRydWUsXCJ4bi0tb2QwYWxnLmhrXCI6dHJ1ZSxcInhuLS1vZDBhcTNiLmhrXCI6dHJ1ZSxcInhuLS10bjBhZy5oa1wiOnRydWUsXCJ4bi0tdWMwYXR2LmhrXCI6dHJ1ZSxcInhuLS11YzBheTRhLmhrXCI6dHJ1ZSxcImhtXCI6dHJ1ZSxcImhuXCI6dHJ1ZSxcImNvbS5oblwiOnRydWUsXCJlZHUuaG5cIjp0cnVlLFwib3JnLmhuXCI6dHJ1ZSxcIm5ldC5oblwiOnRydWUsXCJtaWwuaG5cIjp0cnVlLFwiZ29iLmhuXCI6dHJ1ZSxcImhyXCI6dHJ1ZSxcIml6LmhyXCI6dHJ1ZSxcImZyb20uaHJcIjp0cnVlLFwibmFtZS5oclwiOnRydWUsXCJjb20uaHJcIjp0cnVlLFwiaHRcIjp0cnVlLFwiY29tLmh0XCI6dHJ1ZSxcInNob3AuaHRcIjp0cnVlLFwiZmlybS5odFwiOnRydWUsXCJpbmZvLmh0XCI6dHJ1ZSxcImFkdWx0Lmh0XCI6dHJ1ZSxcIm5ldC5odFwiOnRydWUsXCJwcm8uaHRcIjp0cnVlLFwib3JnLmh0XCI6dHJ1ZSxcIm1lZC5odFwiOnRydWUsXCJhcnQuaHRcIjp0cnVlLFwiY29vcC5odFwiOnRydWUsXCJwb2wuaHRcIjp0cnVlLFwiYXNzby5odFwiOnRydWUsXCJlZHUuaHRcIjp0cnVlLFwicmVsLmh0XCI6dHJ1ZSxcImdvdXYuaHRcIjp0cnVlLFwicGVyc28uaHRcIjp0cnVlLFwiaHVcIjp0cnVlLFwiY28uaHVcIjp0cnVlLFwiaW5mby5odVwiOnRydWUsXCJvcmcuaHVcIjp0cnVlLFwicHJpdi5odVwiOnRydWUsXCJzcG9ydC5odVwiOnRydWUsXCJ0bS5odVwiOnRydWUsXCIyMDAwLmh1XCI6dHJ1ZSxcImFncmFyLmh1XCI6dHJ1ZSxcImJvbHQuaHVcIjp0cnVlLFwiY2FzaW5vLmh1XCI6dHJ1ZSxcImNpdHkuaHVcIjp0cnVlLFwiZXJvdGljYS5odVwiOnRydWUsXCJlcm90aWthLmh1XCI6dHJ1ZSxcImZpbG0uaHVcIjp0cnVlLFwiZm9ydW0uaHVcIjp0cnVlLFwiZ2FtZXMuaHVcIjp0cnVlLFwiaG90ZWwuaHVcIjp0cnVlLFwiaW5nYXRsYW4uaHVcIjp0cnVlLFwiam9nYXN6Lmh1XCI6dHJ1ZSxcImtvbnl2ZWxvLmh1XCI6dHJ1ZSxcImxha2FzLmh1XCI6dHJ1ZSxcIm1lZGlhLmh1XCI6dHJ1ZSxcIm5ld3MuaHVcIjp0cnVlLFwicmVrbGFtLmh1XCI6dHJ1ZSxcInNleC5odVwiOnRydWUsXCJzaG9wLmh1XCI6dHJ1ZSxcInN1bGkuaHVcIjp0cnVlLFwic3pleC5odVwiOnRydWUsXCJ0b3pzZGUuaHVcIjp0cnVlLFwidXRhemFzLmh1XCI6dHJ1ZSxcInZpZGVvLmh1XCI6dHJ1ZSxcImlkXCI6dHJ1ZSxcImFjLmlkXCI6dHJ1ZSxcImJpei5pZFwiOnRydWUsXCJjby5pZFwiOnRydWUsXCJkZXNhLmlkXCI6dHJ1ZSxcImdvLmlkXCI6dHJ1ZSxcIm1pbC5pZFwiOnRydWUsXCJteS5pZFwiOnRydWUsXCJuZXQuaWRcIjp0cnVlLFwib3IuaWRcIjp0cnVlLFwic2NoLmlkXCI6dHJ1ZSxcIndlYi5pZFwiOnRydWUsXCJpZVwiOnRydWUsXCJnb3YuaWVcIjp0cnVlLFwiaWxcIjp0cnVlLFwiYWMuaWxcIjp0cnVlLFwiY28uaWxcIjp0cnVlLFwiZ292LmlsXCI6dHJ1ZSxcImlkZi5pbFwiOnRydWUsXCJrMTIuaWxcIjp0cnVlLFwibXVuaS5pbFwiOnRydWUsXCJuZXQuaWxcIjp0cnVlLFwib3JnLmlsXCI6dHJ1ZSxcImltXCI6dHJ1ZSxcImFjLmltXCI6dHJ1ZSxcImNvLmltXCI6dHJ1ZSxcImNvbS5pbVwiOnRydWUsXCJsdGQuY28uaW1cIjp0cnVlLFwibmV0LmltXCI6dHJ1ZSxcIm9yZy5pbVwiOnRydWUsXCJwbGMuY28uaW1cIjp0cnVlLFwidHQuaW1cIjp0cnVlLFwidHYuaW1cIjp0cnVlLFwiaW5cIjp0cnVlLFwiY28uaW5cIjp0cnVlLFwiZmlybS5pblwiOnRydWUsXCJuZXQuaW5cIjp0cnVlLFwib3JnLmluXCI6dHJ1ZSxcImdlbi5pblwiOnRydWUsXCJpbmQuaW5cIjp0cnVlLFwibmljLmluXCI6dHJ1ZSxcImFjLmluXCI6dHJ1ZSxcImVkdS5pblwiOnRydWUsXCJyZXMuaW5cIjp0cnVlLFwiZ292LmluXCI6dHJ1ZSxcIm1pbC5pblwiOnRydWUsXCJpbmZvXCI6dHJ1ZSxcImludFwiOnRydWUsXCJldS5pbnRcIjp0cnVlLFwiaW9cIjp0cnVlLFwiY29tLmlvXCI6dHJ1ZSxcImlxXCI6dHJ1ZSxcImdvdi5pcVwiOnRydWUsXCJlZHUuaXFcIjp0cnVlLFwibWlsLmlxXCI6dHJ1ZSxcImNvbS5pcVwiOnRydWUsXCJvcmcuaXFcIjp0cnVlLFwibmV0LmlxXCI6dHJ1ZSxcImlyXCI6dHJ1ZSxcImFjLmlyXCI6dHJ1ZSxcImNvLmlyXCI6dHJ1ZSxcImdvdi5pclwiOnRydWUsXCJpZC5pclwiOnRydWUsXCJuZXQuaXJcIjp0cnVlLFwib3JnLmlyXCI6dHJ1ZSxcInNjaC5pclwiOnRydWUsXCJ4bi0tbWdiYTNhNGYxNmEuaXJcIjp0cnVlLFwieG4tLW1nYmEzYTRmcmEuaXJcIjp0cnVlLFwiaXNcIjp0cnVlLFwibmV0LmlzXCI6dHJ1ZSxcImNvbS5pc1wiOnRydWUsXCJlZHUuaXNcIjp0cnVlLFwiZ292LmlzXCI6dHJ1ZSxcIm9yZy5pc1wiOnRydWUsXCJpbnQuaXNcIjp0cnVlLFwiaXRcIjp0cnVlLFwiZ292Lml0XCI6dHJ1ZSxcImVkdS5pdFwiOnRydWUsXCJhYnIuaXRcIjp0cnVlLFwiYWJydXp6by5pdFwiOnRydWUsXCJhb3N0YS12YWxsZXkuaXRcIjp0cnVlLFwiYW9zdGF2YWxsZXkuaXRcIjp0cnVlLFwiYmFzLml0XCI6dHJ1ZSxcImJhc2lsaWNhdGEuaXRcIjp0cnVlLFwiY2FsLml0XCI6dHJ1ZSxcImNhbGFicmlhLml0XCI6dHJ1ZSxcImNhbS5pdFwiOnRydWUsXCJjYW1wYW5pYS5pdFwiOnRydWUsXCJlbWlsaWEtcm9tYWduYS5pdFwiOnRydWUsXCJlbWlsaWFyb21hZ25hLml0XCI6dHJ1ZSxcImVtci5pdFwiOnRydWUsXCJmcml1bGktdi1naXVsaWEuaXRcIjp0cnVlLFwiZnJpdWxpLXZlLWdpdWxpYS5pdFwiOnRydWUsXCJmcml1bGktdmVnaXVsaWEuaXRcIjp0cnVlLFwiZnJpdWxpLXZlbmV6aWEtZ2l1bGlhLml0XCI6dHJ1ZSxcImZyaXVsaS12ZW5lemlhZ2l1bGlhLml0XCI6dHJ1ZSxcImZyaXVsaS12Z2l1bGlhLml0XCI6dHJ1ZSxcImZyaXVsaXYtZ2l1bGlhLml0XCI6dHJ1ZSxcImZyaXVsaXZlLWdpdWxpYS5pdFwiOnRydWUsXCJmcml1bGl2ZWdpdWxpYS5pdFwiOnRydWUsXCJmcml1bGl2ZW5lemlhLWdpdWxpYS5pdFwiOnRydWUsXCJmcml1bGl2ZW5lemlhZ2l1bGlhLml0XCI6dHJ1ZSxcImZyaXVsaXZnaXVsaWEuaXRcIjp0cnVlLFwiZnZnLml0XCI6dHJ1ZSxcImxhei5pdFwiOnRydWUsXCJsYXppby5pdFwiOnRydWUsXCJsaWcuaXRcIjp0cnVlLFwibGlndXJpYS5pdFwiOnRydWUsXCJsb20uaXRcIjp0cnVlLFwibG9tYmFyZGlhLml0XCI6dHJ1ZSxcImxvbWJhcmR5Lml0XCI6dHJ1ZSxcImx1Y2FuaWEuaXRcIjp0cnVlLFwibWFyLml0XCI6dHJ1ZSxcIm1hcmNoZS5pdFwiOnRydWUsXCJtb2wuaXRcIjp0cnVlLFwibW9saXNlLml0XCI6dHJ1ZSxcInBpZWRtb250Lml0XCI6dHJ1ZSxcInBpZW1vbnRlLml0XCI6dHJ1ZSxcInBtbi5pdFwiOnRydWUsXCJwdWcuaXRcIjp0cnVlLFwicHVnbGlhLml0XCI6dHJ1ZSxcInNhci5pdFwiOnRydWUsXCJzYXJkZWduYS5pdFwiOnRydWUsXCJzYXJkaW5pYS5pdFwiOnRydWUsXCJzaWMuaXRcIjp0cnVlLFwic2ljaWxpYS5pdFwiOnRydWUsXCJzaWNpbHkuaXRcIjp0cnVlLFwidGFhLml0XCI6dHJ1ZSxcInRvcy5pdFwiOnRydWUsXCJ0b3NjYW5hLml0XCI6dHJ1ZSxcInRyZW50aW5vLWEtYWRpZ2UuaXRcIjp0cnVlLFwidHJlbnRpbm8tYWFkaWdlLml0XCI6dHJ1ZSxcInRyZW50aW5vLWFsdG8tYWRpZ2UuaXRcIjp0cnVlLFwidHJlbnRpbm8tYWx0b2FkaWdlLml0XCI6dHJ1ZSxcInRyZW50aW5vLXMtdGlyb2wuaXRcIjp0cnVlLFwidHJlbnRpbm8tc3Rpcm9sLml0XCI6dHJ1ZSxcInRyZW50aW5vLXN1ZC10aXJvbC5pdFwiOnRydWUsXCJ0cmVudGluby1zdWR0aXJvbC5pdFwiOnRydWUsXCJ0cmVudGluby1zdWVkLXRpcm9sLml0XCI6dHJ1ZSxcInRyZW50aW5vLXN1ZWR0aXJvbC5pdFwiOnRydWUsXCJ0cmVudGlub2EtYWRpZ2UuaXRcIjp0cnVlLFwidHJlbnRpbm9hYWRpZ2UuaXRcIjp0cnVlLFwidHJlbnRpbm9hbHRvLWFkaWdlLml0XCI6dHJ1ZSxcInRyZW50aW5vYWx0b2FkaWdlLml0XCI6dHJ1ZSxcInRyZW50aW5vcy10aXJvbC5pdFwiOnRydWUsXCJ0cmVudGlub3N0aXJvbC5pdFwiOnRydWUsXCJ0cmVudGlub3N1ZC10aXJvbC5pdFwiOnRydWUsXCJ0cmVudGlub3N1ZHRpcm9sLml0XCI6dHJ1ZSxcInRyZW50aW5vc3VlZC10aXJvbC5pdFwiOnRydWUsXCJ0cmVudGlub3N1ZWR0aXJvbC5pdFwiOnRydWUsXCJ0dXNjYW55Lml0XCI6dHJ1ZSxcInVtYi5pdFwiOnRydWUsXCJ1bWJyaWEuaXRcIjp0cnVlLFwidmFsLWQtYW9zdGEuaXRcIjp0cnVlLFwidmFsLWRhb3N0YS5pdFwiOnRydWUsXCJ2YWxkLWFvc3RhLml0XCI6dHJ1ZSxcInZhbGRhb3N0YS5pdFwiOnRydWUsXCJ2YWxsZS1hb3N0YS5pdFwiOnRydWUsXCJ2YWxsZS1kLWFvc3RhLml0XCI6dHJ1ZSxcInZhbGxlLWRhb3N0YS5pdFwiOnRydWUsXCJ2YWxsZWFvc3RhLml0XCI6dHJ1ZSxcInZhbGxlZC1hb3N0YS5pdFwiOnRydWUsXCJ2YWxsZWRhb3N0YS5pdFwiOnRydWUsXCJ2YWxsZWUtYW9zdGUuaXRcIjp0cnVlLFwidmFsbGVlYW9zdGUuaXRcIjp0cnVlLFwidmFvLml0XCI6dHJ1ZSxcInZkYS5pdFwiOnRydWUsXCJ2ZW4uaXRcIjp0cnVlLFwidmVuZXRvLml0XCI6dHJ1ZSxcImFnLml0XCI6dHJ1ZSxcImFncmlnZW50by5pdFwiOnRydWUsXCJhbC5pdFwiOnRydWUsXCJhbGVzc2FuZHJpYS5pdFwiOnRydWUsXCJhbHRvLWFkaWdlLml0XCI6dHJ1ZSxcImFsdG9hZGlnZS5pdFwiOnRydWUsXCJhbi5pdFwiOnRydWUsXCJhbmNvbmEuaXRcIjp0cnVlLFwiYW5kcmlhLWJhcmxldHRhLXRyYW5pLml0XCI6dHJ1ZSxcImFuZHJpYS10cmFuaS1iYXJsZXR0YS5pdFwiOnRydWUsXCJhbmRyaWFiYXJsZXR0YXRyYW5pLml0XCI6dHJ1ZSxcImFuZHJpYXRyYW5pYmFybGV0dGEuaXRcIjp0cnVlLFwiYW8uaXRcIjp0cnVlLFwiYW9zdGEuaXRcIjp0cnVlLFwiYW9zdGUuaXRcIjp0cnVlLFwiYXAuaXRcIjp0cnVlLFwiYXEuaXRcIjp0cnVlLFwiYXF1aWxhLml0XCI6dHJ1ZSxcImFyLml0XCI6dHJ1ZSxcImFyZXp6by5pdFwiOnRydWUsXCJhc2NvbGktcGljZW5vLml0XCI6dHJ1ZSxcImFzY29saXBpY2Vuby5pdFwiOnRydWUsXCJhc3RpLml0XCI6dHJ1ZSxcImF0Lml0XCI6dHJ1ZSxcImF2Lml0XCI6dHJ1ZSxcImF2ZWxsaW5vLml0XCI6dHJ1ZSxcImJhLml0XCI6dHJ1ZSxcImJhbHNhbi5pdFwiOnRydWUsXCJiYXJpLml0XCI6dHJ1ZSxcImJhcmxldHRhLXRyYW5pLWFuZHJpYS5pdFwiOnRydWUsXCJiYXJsZXR0YXRyYW5pYW5kcmlhLml0XCI6dHJ1ZSxcImJlbGx1bm8uaXRcIjp0cnVlLFwiYmVuZXZlbnRvLml0XCI6dHJ1ZSxcImJlcmdhbW8uaXRcIjp0cnVlLFwiYmcuaXRcIjp0cnVlLFwiYmkuaXRcIjp0cnVlLFwiYmllbGxhLml0XCI6dHJ1ZSxcImJsLml0XCI6dHJ1ZSxcImJuLml0XCI6dHJ1ZSxcImJvLml0XCI6dHJ1ZSxcImJvbG9nbmEuaXRcIjp0cnVlLFwiYm9semFuby5pdFwiOnRydWUsXCJib3plbi5pdFwiOnRydWUsXCJici5pdFwiOnRydWUsXCJicmVzY2lhLml0XCI6dHJ1ZSxcImJyaW5kaXNpLml0XCI6dHJ1ZSxcImJzLml0XCI6dHJ1ZSxcImJ0Lml0XCI6dHJ1ZSxcImJ6Lml0XCI6dHJ1ZSxcImNhLml0XCI6dHJ1ZSxcImNhZ2xpYXJpLml0XCI6dHJ1ZSxcImNhbHRhbmlzc2V0dGEuaXRcIjp0cnVlLFwiY2FtcGlkYW5vLW1lZGlvLml0XCI6dHJ1ZSxcImNhbXBpZGFub21lZGlvLml0XCI6dHJ1ZSxcImNhbXBvYmFzc28uaXRcIjp0cnVlLFwiY2FyYm9uaWEtaWdsZXNpYXMuaXRcIjp0cnVlLFwiY2FyYm9uaWFpZ2xlc2lhcy5pdFwiOnRydWUsXCJjYXJyYXJhLW1hc3NhLml0XCI6dHJ1ZSxcImNhcnJhcmFtYXNzYS5pdFwiOnRydWUsXCJjYXNlcnRhLml0XCI6dHJ1ZSxcImNhdGFuaWEuaXRcIjp0cnVlLFwiY2F0YW56YXJvLml0XCI6dHJ1ZSxcImNiLml0XCI6dHJ1ZSxcImNlLml0XCI6dHJ1ZSxcImNlc2VuYS1mb3JsaS5pdFwiOnRydWUsXCJjZXNlbmFmb3JsaS5pdFwiOnRydWUsXCJjaC5pdFwiOnRydWUsXCJjaGlldGkuaXRcIjp0cnVlLFwiY2kuaXRcIjp0cnVlLFwiY2wuaXRcIjp0cnVlLFwiY24uaXRcIjp0cnVlLFwiY28uaXRcIjp0cnVlLFwiY29tby5pdFwiOnRydWUsXCJjb3NlbnphLml0XCI6dHJ1ZSxcImNyLml0XCI6dHJ1ZSxcImNyZW1vbmEuaXRcIjp0cnVlLFwiY3JvdG9uZS5pdFwiOnRydWUsXCJjcy5pdFwiOnRydWUsXCJjdC5pdFwiOnRydWUsXCJjdW5lby5pdFwiOnRydWUsXCJjei5pdFwiOnRydWUsXCJkZWxsLW9nbGlhc3RyYS5pdFwiOnRydWUsXCJkZWxsb2dsaWFzdHJhLml0XCI6dHJ1ZSxcImVuLml0XCI6dHJ1ZSxcImVubmEuaXRcIjp0cnVlLFwiZmMuaXRcIjp0cnVlLFwiZmUuaXRcIjp0cnVlLFwiZmVybW8uaXRcIjp0cnVlLFwiZmVycmFyYS5pdFwiOnRydWUsXCJmZy5pdFwiOnRydWUsXCJmaS5pdFwiOnRydWUsXCJmaXJlbnplLml0XCI6dHJ1ZSxcImZsb3JlbmNlLml0XCI6dHJ1ZSxcImZtLml0XCI6dHJ1ZSxcImZvZ2dpYS5pdFwiOnRydWUsXCJmb3JsaS1jZXNlbmEuaXRcIjp0cnVlLFwiZm9ybGljZXNlbmEuaXRcIjp0cnVlLFwiZnIuaXRcIjp0cnVlLFwiZnJvc2lub25lLml0XCI6dHJ1ZSxcImdlLml0XCI6dHJ1ZSxcImdlbm9hLml0XCI6dHJ1ZSxcImdlbm92YS5pdFwiOnRydWUsXCJnby5pdFwiOnRydWUsXCJnb3JpemlhLml0XCI6dHJ1ZSxcImdyLml0XCI6dHJ1ZSxcImdyb3NzZXRvLml0XCI6dHJ1ZSxcImlnbGVzaWFzLWNhcmJvbmlhLml0XCI6dHJ1ZSxcImlnbGVzaWFzY2FyYm9uaWEuaXRcIjp0cnVlLFwiaW0uaXRcIjp0cnVlLFwiaW1wZXJpYS5pdFwiOnRydWUsXCJpcy5pdFwiOnRydWUsXCJpc2VybmlhLml0XCI6dHJ1ZSxcImtyLml0XCI6dHJ1ZSxcImxhLXNwZXppYS5pdFwiOnRydWUsXCJsYXF1aWxhLml0XCI6dHJ1ZSxcImxhc3BlemlhLml0XCI6dHJ1ZSxcImxhdGluYS5pdFwiOnRydWUsXCJsYy5pdFwiOnRydWUsXCJsZS5pdFwiOnRydWUsXCJsZWNjZS5pdFwiOnRydWUsXCJsZWNjby5pdFwiOnRydWUsXCJsaS5pdFwiOnRydWUsXCJsaXZvcm5vLml0XCI6dHJ1ZSxcImxvLml0XCI6dHJ1ZSxcImxvZGkuaXRcIjp0cnVlLFwibHQuaXRcIjp0cnVlLFwibHUuaXRcIjp0cnVlLFwibHVjY2EuaXRcIjp0cnVlLFwibWFjZXJhdGEuaXRcIjp0cnVlLFwibWFudG92YS5pdFwiOnRydWUsXCJtYXNzYS1jYXJyYXJhLml0XCI6dHJ1ZSxcIm1hc3NhY2FycmFyYS5pdFwiOnRydWUsXCJtYXRlcmEuaXRcIjp0cnVlLFwibWIuaXRcIjp0cnVlLFwibWMuaXRcIjp0cnVlLFwibWUuaXRcIjp0cnVlLFwibWVkaW8tY2FtcGlkYW5vLml0XCI6dHJ1ZSxcIm1lZGlvY2FtcGlkYW5vLml0XCI6dHJ1ZSxcIm1lc3NpbmEuaXRcIjp0cnVlLFwibWkuaXRcIjp0cnVlLFwibWlsYW4uaXRcIjp0cnVlLFwibWlsYW5vLml0XCI6dHJ1ZSxcIm1uLml0XCI6dHJ1ZSxcIm1vLml0XCI6dHJ1ZSxcIm1vZGVuYS5pdFwiOnRydWUsXCJtb256YS1icmlhbnphLml0XCI6dHJ1ZSxcIm1vbnphLWUtZGVsbGEtYnJpYW56YS5pdFwiOnRydWUsXCJtb256YS5pdFwiOnRydWUsXCJtb256YWJyaWFuemEuaXRcIjp0cnVlLFwibW9uemFlYnJpYW56YS5pdFwiOnRydWUsXCJtb256YWVkZWxsYWJyaWFuemEuaXRcIjp0cnVlLFwibXMuaXRcIjp0cnVlLFwibXQuaXRcIjp0cnVlLFwibmEuaXRcIjp0cnVlLFwibmFwbGVzLml0XCI6dHJ1ZSxcIm5hcG9saS5pdFwiOnRydWUsXCJuby5pdFwiOnRydWUsXCJub3ZhcmEuaXRcIjp0cnVlLFwibnUuaXRcIjp0cnVlLFwibnVvcm8uaXRcIjp0cnVlLFwib2cuaXRcIjp0cnVlLFwib2dsaWFzdHJhLml0XCI6dHJ1ZSxcIm9sYmlhLXRlbXBpby5pdFwiOnRydWUsXCJvbGJpYXRlbXBpby5pdFwiOnRydWUsXCJvci5pdFwiOnRydWUsXCJvcmlzdGFuby5pdFwiOnRydWUsXCJvdC5pdFwiOnRydWUsXCJwYS5pdFwiOnRydWUsXCJwYWRvdmEuaXRcIjp0cnVlLFwicGFkdWEuaXRcIjp0cnVlLFwicGFsZXJtby5pdFwiOnRydWUsXCJwYXJtYS5pdFwiOnRydWUsXCJwYXZpYS5pdFwiOnRydWUsXCJwYy5pdFwiOnRydWUsXCJwZC5pdFwiOnRydWUsXCJwZS5pdFwiOnRydWUsXCJwZXJ1Z2lhLml0XCI6dHJ1ZSxcInBlc2Fyby11cmJpbm8uaXRcIjp0cnVlLFwicGVzYXJvdXJiaW5vLml0XCI6dHJ1ZSxcInBlc2NhcmEuaXRcIjp0cnVlLFwicGcuaXRcIjp0cnVlLFwicGkuaXRcIjp0cnVlLFwicGlhY2VuemEuaXRcIjp0cnVlLFwicGlzYS5pdFwiOnRydWUsXCJwaXN0b2lhLml0XCI6dHJ1ZSxcInBuLml0XCI6dHJ1ZSxcInBvLml0XCI6dHJ1ZSxcInBvcmRlbm9uZS5pdFwiOnRydWUsXCJwb3RlbnphLml0XCI6dHJ1ZSxcInByLml0XCI6dHJ1ZSxcInByYXRvLml0XCI6dHJ1ZSxcInB0Lml0XCI6dHJ1ZSxcInB1Lml0XCI6dHJ1ZSxcInB2Lml0XCI6dHJ1ZSxcInB6Lml0XCI6dHJ1ZSxcInJhLml0XCI6dHJ1ZSxcInJhZ3VzYS5pdFwiOnRydWUsXCJyYXZlbm5hLml0XCI6dHJ1ZSxcInJjLml0XCI6dHJ1ZSxcInJlLml0XCI6dHJ1ZSxcInJlZ2dpby1jYWxhYnJpYS5pdFwiOnRydWUsXCJyZWdnaW8tZW1pbGlhLml0XCI6dHJ1ZSxcInJlZ2dpb2NhbGFicmlhLml0XCI6dHJ1ZSxcInJlZ2dpb2VtaWxpYS5pdFwiOnRydWUsXCJyZy5pdFwiOnRydWUsXCJyaS5pdFwiOnRydWUsXCJyaWV0aS5pdFwiOnRydWUsXCJyaW1pbmkuaXRcIjp0cnVlLFwicm0uaXRcIjp0cnVlLFwicm4uaXRcIjp0cnVlLFwicm8uaXRcIjp0cnVlLFwicm9tYS5pdFwiOnRydWUsXCJyb21lLml0XCI6dHJ1ZSxcInJvdmlnby5pdFwiOnRydWUsXCJzYS5pdFwiOnRydWUsXCJzYWxlcm5vLml0XCI6dHJ1ZSxcInNhc3NhcmkuaXRcIjp0cnVlLFwic2F2b25hLml0XCI6dHJ1ZSxcInNpLml0XCI6dHJ1ZSxcInNpZW5hLml0XCI6dHJ1ZSxcInNpcmFjdXNhLml0XCI6dHJ1ZSxcInNvLml0XCI6dHJ1ZSxcInNvbmRyaW8uaXRcIjp0cnVlLFwic3AuaXRcIjp0cnVlLFwic3IuaXRcIjp0cnVlLFwic3MuaXRcIjp0cnVlLFwic3VlZHRpcm9sLml0XCI6dHJ1ZSxcInN2Lml0XCI6dHJ1ZSxcInRhLml0XCI6dHJ1ZSxcInRhcmFudG8uaXRcIjp0cnVlLFwidGUuaXRcIjp0cnVlLFwidGVtcGlvLW9sYmlhLml0XCI6dHJ1ZSxcInRlbXBpb29sYmlhLml0XCI6dHJ1ZSxcInRlcmFtby5pdFwiOnRydWUsXCJ0ZXJuaS5pdFwiOnRydWUsXCJ0bi5pdFwiOnRydWUsXCJ0by5pdFwiOnRydWUsXCJ0b3Jpbm8uaXRcIjp0cnVlLFwidHAuaXRcIjp0cnVlLFwidHIuaXRcIjp0cnVlLFwidHJhbmktYW5kcmlhLWJhcmxldHRhLml0XCI6dHJ1ZSxcInRyYW5pLWJhcmxldHRhLWFuZHJpYS5pdFwiOnRydWUsXCJ0cmFuaWFuZHJpYWJhcmxldHRhLml0XCI6dHJ1ZSxcInRyYW5pYmFybGV0dGFhbmRyaWEuaXRcIjp0cnVlLFwidHJhcGFuaS5pdFwiOnRydWUsXCJ0cmVudGluby5pdFwiOnRydWUsXCJ0cmVudG8uaXRcIjp0cnVlLFwidHJldmlzby5pdFwiOnRydWUsXCJ0cmllc3RlLml0XCI6dHJ1ZSxcInRzLml0XCI6dHJ1ZSxcInR1cmluLml0XCI6dHJ1ZSxcInR2Lml0XCI6dHJ1ZSxcInVkLml0XCI6dHJ1ZSxcInVkaW5lLml0XCI6dHJ1ZSxcInVyYmluby1wZXNhcm8uaXRcIjp0cnVlLFwidXJiaW5vcGVzYXJvLml0XCI6dHJ1ZSxcInZhLml0XCI6dHJ1ZSxcInZhcmVzZS5pdFwiOnRydWUsXCJ2Yi5pdFwiOnRydWUsXCJ2Yy5pdFwiOnRydWUsXCJ2ZS5pdFwiOnRydWUsXCJ2ZW5lemlhLml0XCI6dHJ1ZSxcInZlbmljZS5pdFwiOnRydWUsXCJ2ZXJiYW5pYS5pdFwiOnRydWUsXCJ2ZXJjZWxsaS5pdFwiOnRydWUsXCJ2ZXJvbmEuaXRcIjp0cnVlLFwidmkuaXRcIjp0cnVlLFwidmliby12YWxlbnRpYS5pdFwiOnRydWUsXCJ2aWJvdmFsZW50aWEuaXRcIjp0cnVlLFwidmljZW56YS5pdFwiOnRydWUsXCJ2aXRlcmJvLml0XCI6dHJ1ZSxcInZyLml0XCI6dHJ1ZSxcInZzLml0XCI6dHJ1ZSxcInZ0Lml0XCI6dHJ1ZSxcInZ2Lml0XCI6dHJ1ZSxcImplXCI6dHJ1ZSxcImNvLmplXCI6dHJ1ZSxcIm5ldC5qZVwiOnRydWUsXCJvcmcuamVcIjp0cnVlLFwiKi5qbVwiOnRydWUsXCJqb1wiOnRydWUsXCJjb20uam9cIjp0cnVlLFwib3JnLmpvXCI6dHJ1ZSxcIm5ldC5qb1wiOnRydWUsXCJlZHUuam9cIjp0cnVlLFwic2NoLmpvXCI6dHJ1ZSxcImdvdi5qb1wiOnRydWUsXCJtaWwuam9cIjp0cnVlLFwibmFtZS5qb1wiOnRydWUsXCJqb2JzXCI6dHJ1ZSxcImpwXCI6dHJ1ZSxcImFjLmpwXCI6dHJ1ZSxcImFkLmpwXCI6dHJ1ZSxcImNvLmpwXCI6dHJ1ZSxcImVkLmpwXCI6dHJ1ZSxcImdvLmpwXCI6dHJ1ZSxcImdyLmpwXCI6dHJ1ZSxcImxnLmpwXCI6dHJ1ZSxcIm5lLmpwXCI6dHJ1ZSxcIm9yLmpwXCI6dHJ1ZSxcImFpY2hpLmpwXCI6dHJ1ZSxcImFraXRhLmpwXCI6dHJ1ZSxcImFvbW9yaS5qcFwiOnRydWUsXCJjaGliYS5qcFwiOnRydWUsXCJlaGltZS5qcFwiOnRydWUsXCJmdWt1aS5qcFwiOnRydWUsXCJmdWt1b2thLmpwXCI6dHJ1ZSxcImZ1a3VzaGltYS5qcFwiOnRydWUsXCJnaWZ1LmpwXCI6dHJ1ZSxcImd1bm1hLmpwXCI6dHJ1ZSxcImhpcm9zaGltYS5qcFwiOnRydWUsXCJob2trYWlkby5qcFwiOnRydWUsXCJoeW9nby5qcFwiOnRydWUsXCJpYmFyYWtpLmpwXCI6dHJ1ZSxcImlzaGlrYXdhLmpwXCI6dHJ1ZSxcIml3YXRlLmpwXCI6dHJ1ZSxcImthZ2F3YS5qcFwiOnRydWUsXCJrYWdvc2hpbWEuanBcIjp0cnVlLFwia2FuYWdhd2EuanBcIjp0cnVlLFwia29jaGkuanBcIjp0cnVlLFwia3VtYW1vdG8uanBcIjp0cnVlLFwia3lvdG8uanBcIjp0cnVlLFwibWllLmpwXCI6dHJ1ZSxcIm1peWFnaS5qcFwiOnRydWUsXCJtaXlhemFraS5qcFwiOnRydWUsXCJuYWdhbm8uanBcIjp0cnVlLFwibmFnYXNha2kuanBcIjp0cnVlLFwibmFyYS5qcFwiOnRydWUsXCJuaWlnYXRhLmpwXCI6dHJ1ZSxcIm9pdGEuanBcIjp0cnVlLFwib2theWFtYS5qcFwiOnRydWUsXCJva2luYXdhLmpwXCI6dHJ1ZSxcIm9zYWthLmpwXCI6dHJ1ZSxcInNhZ2EuanBcIjp0cnVlLFwic2FpdGFtYS5qcFwiOnRydWUsXCJzaGlnYS5qcFwiOnRydWUsXCJzaGltYW5lLmpwXCI6dHJ1ZSxcInNoaXp1b2thLmpwXCI6dHJ1ZSxcInRvY2hpZ2kuanBcIjp0cnVlLFwidG9rdXNoaW1hLmpwXCI6dHJ1ZSxcInRva3lvLmpwXCI6dHJ1ZSxcInRvdHRvcmkuanBcIjp0cnVlLFwidG95YW1hLmpwXCI6dHJ1ZSxcIndha2F5YW1hLmpwXCI6dHJ1ZSxcInlhbWFnYXRhLmpwXCI6dHJ1ZSxcInlhbWFndWNoaS5qcFwiOnRydWUsXCJ5YW1hbmFzaGkuanBcIjp0cnVlLFwieG4tLTRwdnhzLmpwXCI6dHJ1ZSxcInhuLS12Z3U0MDJjLmpwXCI6dHJ1ZSxcInhuLS1jM3MxNG0uanBcIjp0cnVlLFwieG4tLWY2cXg1M2EuanBcIjp0cnVlLFwieG4tLThwdnI0dS5qcFwiOnRydWUsXCJ4bi0tdWlzdDIyaC5qcFwiOnRydWUsXCJ4bi0tZGpyczcyZDZ1eS5qcFwiOnRydWUsXCJ4bi0tbWtydTQ1aS5qcFwiOnRydWUsXCJ4bi0tMHRycTdwN25uLmpwXCI6dHJ1ZSxcInhuLS04bHRyNjJrLmpwXCI6dHJ1ZSxcInhuLS0ybTRhMTVlLmpwXCI6dHJ1ZSxcInhuLS1lZnZuOXMuanBcIjp0cnVlLFwieG4tLTMydnAzMGguanBcIjp0cnVlLFwieG4tLTRpdDc5N2suanBcIjp0cnVlLFwieG4tLTFscXM3MWQuanBcIjp0cnVlLFwieG4tLTVydHA0OWMuanBcIjp0cnVlLFwieG4tLTVqczA0NWQuanBcIjp0cnVlLFwieG4tLWVocXo1Nm4uanBcIjp0cnVlLFwieG4tLTFscXMwM24uanBcIjp0cnVlLFwieG4tLXFxcXQxMW0uanBcIjp0cnVlLFwieG4tLWticnE3by5qcFwiOnRydWUsXCJ4bi0tcHNzdTMzbC5qcFwiOnRydWUsXCJ4bi0tbnRzcTE3Zy5qcFwiOnRydWUsXCJ4bi0tdWlzejNnLmpwXCI6dHJ1ZSxcInhuLS02YnR3NWEuanBcIjp0cnVlLFwieG4tLTFjdHdvLmpwXCI6dHJ1ZSxcInhuLS02b3J4MnIuanBcIjp0cnVlLFwieG4tLXJodDYxZS5qcFwiOnRydWUsXCJ4bi0tcmh0Mjd6LmpwXCI6dHJ1ZSxcInhuLS1kanR5NGsuanBcIjp0cnVlLFwieG4tLW5pdDIyNWsuanBcIjp0cnVlLFwieG4tLXJodDNkLmpwXCI6dHJ1ZSxcInhuLS1rbHR5NXguanBcIjp0cnVlLFwieG4tLWtsdHg5YS5qcFwiOnRydWUsXCJ4bi0ta2x0cDdkLmpwXCI6dHJ1ZSxcInhuLS11dXd1NThhLmpwXCI6dHJ1ZSxcInhuLS16YngwMjVkLmpwXCI6dHJ1ZSxcInhuLS1udHNvMGlxeDNhLmpwXCI6dHJ1ZSxcInhuLS1lbHFxMTZoLmpwXCI6dHJ1ZSxcInhuLS00aXQxNjhkLmpwXCI6dHJ1ZSxcInhuLS1rbHQ3ODdkLmpwXCI6dHJ1ZSxcInhuLS1ybnkzMWguanBcIjp0cnVlLFwieG4tLTd0MGEyNjRjLmpwXCI6dHJ1ZSxcInhuLS01cnRxMzRrLmpwXCI6dHJ1ZSxcInhuLS1rN3luOTVlLmpwXCI6dHJ1ZSxcInhuLS10b3IxMzFvLmpwXCI6dHJ1ZSxcInhuLS1kNXF2N3o4NzZjLmpwXCI6dHJ1ZSxcIioua2F3YXNha2kuanBcIjp0cnVlLFwiKi5raXRha3l1c2h1LmpwXCI6dHJ1ZSxcIioua29iZS5qcFwiOnRydWUsXCIqLm5hZ295YS5qcFwiOnRydWUsXCIqLnNhcHBvcm8uanBcIjp0cnVlLFwiKi5zZW5kYWkuanBcIjp0cnVlLFwiKi55b2tvaGFtYS5qcFwiOnRydWUsXCJjaXR5Lmthd2FzYWtpLmpwXCI6ZmFsc2UsXCJjaXR5LmtpdGFreXVzaHUuanBcIjpmYWxzZSxcImNpdHkua29iZS5qcFwiOmZhbHNlLFwiY2l0eS5uYWdveWEuanBcIjpmYWxzZSxcImNpdHkuc2FwcG9yby5qcFwiOmZhbHNlLFwiY2l0eS5zZW5kYWkuanBcIjpmYWxzZSxcImNpdHkueW9rb2hhbWEuanBcIjpmYWxzZSxcImFpc2FpLmFpY2hpLmpwXCI6dHJ1ZSxcImFtYS5haWNoaS5qcFwiOnRydWUsXCJhbmpvLmFpY2hpLmpwXCI6dHJ1ZSxcImFzdWtlLmFpY2hpLmpwXCI6dHJ1ZSxcImNoaXJ5dS5haWNoaS5qcFwiOnRydWUsXCJjaGl0YS5haWNoaS5qcFwiOnRydWUsXCJmdXNvLmFpY2hpLmpwXCI6dHJ1ZSxcImdhbWFnb3JpLmFpY2hpLmpwXCI6dHJ1ZSxcImhhbmRhLmFpY2hpLmpwXCI6dHJ1ZSxcImhhenUuYWljaGkuanBcIjp0cnVlLFwiaGVraW5hbi5haWNoaS5qcFwiOnRydWUsXCJoaWdhc2hpdXJhLmFpY2hpLmpwXCI6dHJ1ZSxcImljaGlub21peWEuYWljaGkuanBcIjp0cnVlLFwiaW5hemF3YS5haWNoaS5qcFwiOnRydWUsXCJpbnV5YW1hLmFpY2hpLmpwXCI6dHJ1ZSxcImlzc2hpa2kuYWljaGkuanBcIjp0cnVlLFwiaXdha3VyYS5haWNoaS5qcFwiOnRydWUsXCJrYW5pZS5haWNoaS5qcFwiOnRydWUsXCJrYXJpeWEuYWljaGkuanBcIjp0cnVlLFwia2FzdWdhaS5haWNoaS5qcFwiOnRydWUsXCJraXJhLmFpY2hpLmpwXCI6dHJ1ZSxcImtpeW9zdS5haWNoaS5qcFwiOnRydWUsXCJrb21ha2kuYWljaGkuanBcIjp0cnVlLFwia29uYW4uYWljaGkuanBcIjp0cnVlLFwia290YS5haWNoaS5qcFwiOnRydWUsXCJtaWhhbWEuYWljaGkuanBcIjp0cnVlLFwibWl5b3NoaS5haWNoaS5qcFwiOnRydWUsXCJuaXNoaW8uYWljaGkuanBcIjp0cnVlLFwibmlzc2hpbi5haWNoaS5qcFwiOnRydWUsXCJvYnUuYWljaGkuanBcIjp0cnVlLFwib2d1Y2hpLmFpY2hpLmpwXCI6dHJ1ZSxcIm9oYXJ1LmFpY2hpLmpwXCI6dHJ1ZSxcIm9rYXpha2kuYWljaGkuanBcIjp0cnVlLFwib3dhcmlhc2FoaS5haWNoaS5qcFwiOnRydWUsXCJzZXRvLmFpY2hpLmpwXCI6dHJ1ZSxcInNoaWthdHN1LmFpY2hpLmpwXCI6dHJ1ZSxcInNoaW5zaGlyby5haWNoaS5qcFwiOnRydWUsXCJzaGl0YXJhLmFpY2hpLmpwXCI6dHJ1ZSxcInRhaGFyYS5haWNoaS5qcFwiOnRydWUsXCJ0YWthaGFtYS5haWNoaS5qcFwiOnRydWUsXCJ0b2Jpc2hpbWEuYWljaGkuanBcIjp0cnVlLFwidG9laS5haWNoaS5qcFwiOnRydWUsXCJ0b2dvLmFpY2hpLmpwXCI6dHJ1ZSxcInRva2FpLmFpY2hpLmpwXCI6dHJ1ZSxcInRva29uYW1lLmFpY2hpLmpwXCI6dHJ1ZSxcInRveW9ha2UuYWljaGkuanBcIjp0cnVlLFwidG95b2hhc2hpLmFpY2hpLmpwXCI6dHJ1ZSxcInRveW9rYXdhLmFpY2hpLmpwXCI6dHJ1ZSxcInRveW9uZS5haWNoaS5qcFwiOnRydWUsXCJ0b3lvdGEuYWljaGkuanBcIjp0cnVlLFwidHN1c2hpbWEuYWljaGkuanBcIjp0cnVlLFwieWF0b21pLmFpY2hpLmpwXCI6dHJ1ZSxcImFraXRhLmFraXRhLmpwXCI6dHJ1ZSxcImRhaXNlbi5ha2l0YS5qcFwiOnRydWUsXCJmdWppc2F0by5ha2l0YS5qcFwiOnRydWUsXCJnb2pvbWUuYWtpdGEuanBcIjp0cnVlLFwiaGFjaGlyb2dhdGEuYWtpdGEuanBcIjp0cnVlLFwiaGFwcG91LmFraXRhLmpwXCI6dHJ1ZSxcImhpZ2FzaGluYXJ1c2UuYWtpdGEuanBcIjp0cnVlLFwiaG9uam8uYWtpdGEuanBcIjp0cnVlLFwiaG9uanlvLmFraXRhLmpwXCI6dHJ1ZSxcImlrYXdhLmFraXRhLmpwXCI6dHJ1ZSxcImthbWlrb2FuaS5ha2l0YS5qcFwiOnRydWUsXCJrYW1pb2thLmFraXRhLmpwXCI6dHJ1ZSxcImthdGFnYW1pLmFraXRhLmpwXCI6dHJ1ZSxcImthenVuby5ha2l0YS5qcFwiOnRydWUsXCJraXRhYWtpdGEuYWtpdGEuanBcIjp0cnVlLFwia29zYWthLmFraXRhLmpwXCI6dHJ1ZSxcImt5b3dhLmFraXRhLmpwXCI6dHJ1ZSxcIm1pc2F0by5ha2l0YS5qcFwiOnRydWUsXCJtaXRhbmUuYWtpdGEuanBcIjp0cnVlLFwibW9yaXlvc2hpLmFraXRhLmpwXCI6dHJ1ZSxcIm5pa2Foby5ha2l0YS5qcFwiOnRydWUsXCJub3NoaXJvLmFraXRhLmpwXCI6dHJ1ZSxcIm9kYXRlLmFraXRhLmpwXCI6dHJ1ZSxcIm9nYS5ha2l0YS5qcFwiOnRydWUsXCJvZ2F0YS5ha2l0YS5qcFwiOnRydWUsXCJzZW1ib2t1LmFraXRhLmpwXCI6dHJ1ZSxcInlva290ZS5ha2l0YS5qcFwiOnRydWUsXCJ5dXJpaG9uam8uYWtpdGEuanBcIjp0cnVlLFwiYW9tb3JpLmFvbW9yaS5qcFwiOnRydWUsXCJnb25vaGUuYW9tb3JpLmpwXCI6dHJ1ZSxcImhhY2hpbm9oZS5hb21vcmkuanBcIjp0cnVlLFwiaGFzaGlrYW1pLmFvbW9yaS5qcFwiOnRydWUsXCJoaXJhbmFpLmFvbW9yaS5qcFwiOnRydWUsXCJoaXJvc2FraS5hb21vcmkuanBcIjp0cnVlLFwiaXRheWFuYWdpLmFvbW9yaS5qcFwiOnRydWUsXCJrdXJvaXNoaS5hb21vcmkuanBcIjp0cnVlLFwibWlzYXdhLmFvbW9yaS5qcFwiOnRydWUsXCJtdXRzdS5hb21vcmkuanBcIjp0cnVlLFwibmFrYWRvbWFyaS5hb21vcmkuanBcIjp0cnVlLFwibm9oZWppLmFvbW9yaS5qcFwiOnRydWUsXCJvaXJhc2UuYW9tb3JpLmpwXCI6dHJ1ZSxcIm93YW5pLmFvbW9yaS5qcFwiOnRydWUsXCJyb2t1bm9oZS5hb21vcmkuanBcIjp0cnVlLFwic2Fubm9oZS5hb21vcmkuanBcIjp0cnVlLFwic2hpY2hpbm9oZS5hb21vcmkuanBcIjp0cnVlLFwic2hpbmdvLmFvbW9yaS5qcFwiOnRydWUsXCJ0YWtrby5hb21vcmkuanBcIjp0cnVlLFwidG93YWRhLmFvbW9yaS5qcFwiOnRydWUsXCJ0c3VnYXJ1LmFvbW9yaS5qcFwiOnRydWUsXCJ0c3VydXRhLmFvbW9yaS5qcFwiOnRydWUsXCJhYmlrby5jaGliYS5qcFwiOnRydWUsXCJhc2FoaS5jaGliYS5qcFwiOnRydWUsXCJjaG9uYW4uY2hpYmEuanBcIjp0cnVlLFwiY2hvc2VpLmNoaWJhLmpwXCI6dHJ1ZSxcImNob3NoaS5jaGliYS5qcFwiOnRydWUsXCJjaHVvLmNoaWJhLmpwXCI6dHJ1ZSxcImZ1bmFiYXNoaS5jaGliYS5qcFwiOnRydWUsXCJmdXR0c3UuY2hpYmEuanBcIjp0cnVlLFwiaGFuYW1pZ2F3YS5jaGliYS5qcFwiOnRydWUsXCJpY2hpaGFyYS5jaGliYS5qcFwiOnRydWUsXCJpY2hpa2F3YS5jaGliYS5qcFwiOnRydWUsXCJpY2hpbm9taXlhLmNoaWJhLmpwXCI6dHJ1ZSxcImluemFpLmNoaWJhLmpwXCI6dHJ1ZSxcImlzdW1pLmNoaWJhLmpwXCI6dHJ1ZSxcImthbWFnYXlhLmNoaWJhLmpwXCI6dHJ1ZSxcImthbW9nYXdhLmNoaWJhLmpwXCI6dHJ1ZSxcImthc2hpd2EuY2hpYmEuanBcIjp0cnVlLFwia2F0b3JpLmNoaWJhLmpwXCI6dHJ1ZSxcImthdHN1dXJhLmNoaWJhLmpwXCI6dHJ1ZSxcImtpbWl0c3UuY2hpYmEuanBcIjp0cnVlLFwia2lzYXJhenUuY2hpYmEuanBcIjp0cnVlLFwia296YWtpLmNoaWJhLmpwXCI6dHJ1ZSxcImt1anVrdXJpLmNoaWJhLmpwXCI6dHJ1ZSxcImt5b25hbi5jaGliYS5qcFwiOnRydWUsXCJtYXRzdWRvLmNoaWJhLmpwXCI6dHJ1ZSxcIm1pZG9yaS5jaGliYS5qcFwiOnRydWUsXCJtaWhhbWEuY2hpYmEuanBcIjp0cnVlLFwibWluYW1pYm9zby5jaGliYS5qcFwiOnRydWUsXCJtb2JhcmEuY2hpYmEuanBcIjp0cnVlLFwibXV0c3V6YXdhLmNoaWJhLmpwXCI6dHJ1ZSxcIm5hZ2FyYS5jaGliYS5qcFwiOnRydWUsXCJuYWdhcmV5YW1hLmNoaWJhLmpwXCI6dHJ1ZSxcIm5hcmFzaGluby5jaGliYS5qcFwiOnRydWUsXCJuYXJpdGEuY2hpYmEuanBcIjp0cnVlLFwibm9kYS5jaGliYS5qcFwiOnRydWUsXCJvYW1pc2hpcmFzYXRvLmNoaWJhLmpwXCI6dHJ1ZSxcIm9taWdhd2EuY2hpYmEuanBcIjp0cnVlLFwib25qdWt1LmNoaWJhLmpwXCI6dHJ1ZSxcIm90YWtpLmNoaWJhLmpwXCI6dHJ1ZSxcInNha2FlLmNoaWJhLmpwXCI6dHJ1ZSxcInNha3VyYS5jaGliYS5qcFwiOnRydWUsXCJzaGltb2Z1c2EuY2hpYmEuanBcIjp0cnVlLFwic2hpcmFrby5jaGliYS5qcFwiOnRydWUsXCJzaGlyb2kuY2hpYmEuanBcIjp0cnVlLFwic2hpc3VpLmNoaWJhLmpwXCI6dHJ1ZSxcInNvZGVnYXVyYS5jaGliYS5qcFwiOnRydWUsXCJzb3NhLmNoaWJhLmpwXCI6dHJ1ZSxcInRha28uY2hpYmEuanBcIjp0cnVlLFwidGF0ZXlhbWEuY2hpYmEuanBcIjp0cnVlLFwidG9nYW5lLmNoaWJhLmpwXCI6dHJ1ZSxcInRvaG5vc2hvLmNoaWJhLmpwXCI6dHJ1ZSxcInRvbWlzYXRvLmNoaWJhLmpwXCI6dHJ1ZSxcInVyYXlhc3UuY2hpYmEuanBcIjp0cnVlLFwieWFjaGltYXRhLmNoaWJhLmpwXCI6dHJ1ZSxcInlhY2hpeW8uY2hpYmEuanBcIjp0cnVlLFwieW9rYWljaGliYS5jaGliYS5qcFwiOnRydWUsXCJ5b2tvc2hpYmFoaWthcmkuY2hpYmEuanBcIjp0cnVlLFwieW90c3VrYWlkby5jaGliYS5qcFwiOnRydWUsXCJhaW5hbi5laGltZS5qcFwiOnRydWUsXCJob25haS5laGltZS5qcFwiOnRydWUsXCJpa2F0YS5laGltZS5qcFwiOnRydWUsXCJpbWFiYXJpLmVoaW1lLmpwXCI6dHJ1ZSxcIml5by5laGltZS5qcFwiOnRydWUsXCJrYW1pamltYS5laGltZS5qcFwiOnRydWUsXCJraWhva3UuZWhpbWUuanBcIjp0cnVlLFwia3VtYWtvZ2VuLmVoaW1lLmpwXCI6dHJ1ZSxcIm1hc2FraS5laGltZS5qcFwiOnRydWUsXCJtYXRzdW5vLmVoaW1lLmpwXCI6dHJ1ZSxcIm1hdHN1eWFtYS5laGltZS5qcFwiOnRydWUsXCJuYW1pa2F0YS5laGltZS5qcFwiOnRydWUsXCJuaWloYW1hLmVoaW1lLmpwXCI6dHJ1ZSxcIm96dS5laGltZS5qcFwiOnRydWUsXCJzYWlqby5laGltZS5qcFwiOnRydWUsXCJzZWl5by5laGltZS5qcFwiOnRydWUsXCJzaGlrb2t1Y2h1by5laGltZS5qcFwiOnRydWUsXCJ0b2JlLmVoaW1lLmpwXCI6dHJ1ZSxcInRvb24uZWhpbWUuanBcIjp0cnVlLFwidWNoaWtvLmVoaW1lLmpwXCI6dHJ1ZSxcInV3YWppbWEuZWhpbWUuanBcIjp0cnVlLFwieWF3YXRhaGFtYS5laGltZS5qcFwiOnRydWUsXCJlY2hpemVuLmZ1a3VpLmpwXCI6dHJ1ZSxcImVpaGVpamkuZnVrdWkuanBcIjp0cnVlLFwiZnVrdWkuZnVrdWkuanBcIjp0cnVlLFwiaWtlZGEuZnVrdWkuanBcIjp0cnVlLFwia2F0c3V5YW1hLmZ1a3VpLmpwXCI6dHJ1ZSxcIm1paGFtYS5mdWt1aS5qcFwiOnRydWUsXCJtaW5hbWllY2hpemVuLmZ1a3VpLmpwXCI6dHJ1ZSxcIm9iYW1hLmZ1a3VpLmpwXCI6dHJ1ZSxcIm9oaS5mdWt1aS5qcFwiOnRydWUsXCJvbm8uZnVrdWkuanBcIjp0cnVlLFwic2FiYWUuZnVrdWkuanBcIjp0cnVlLFwic2FrYWkuZnVrdWkuanBcIjp0cnVlLFwidGFrYWhhbWEuZnVrdWkuanBcIjp0cnVlLFwidHN1cnVnYS5mdWt1aS5qcFwiOnRydWUsXCJ3YWthc2EuZnVrdWkuanBcIjp0cnVlLFwiYXNoaXlhLmZ1a3Vva2EuanBcIjp0cnVlLFwiYnV6ZW4uZnVrdW9rYS5qcFwiOnRydWUsXCJjaGlrdWdvLmZ1a3Vva2EuanBcIjp0cnVlLFwiY2hpa3Voby5mdWt1b2thLmpwXCI6dHJ1ZSxcImNoaWt1am8uZnVrdW9rYS5qcFwiOnRydWUsXCJjaGlrdXNoaW5vLmZ1a3Vva2EuanBcIjp0cnVlLFwiY2hpa3V6ZW4uZnVrdW9rYS5qcFwiOnRydWUsXCJjaHVvLmZ1a3Vva2EuanBcIjp0cnVlLFwiZGF6YWlmdS5mdWt1b2thLmpwXCI6dHJ1ZSxcImZ1a3VjaGkuZnVrdW9rYS5qcFwiOnRydWUsXCJoYWthdGEuZnVrdW9rYS5qcFwiOnRydWUsXCJoaWdhc2hpLmZ1a3Vva2EuanBcIjp0cnVlLFwiaGlyb2thd2EuZnVrdW9rYS5qcFwiOnRydWUsXCJoaXNheWFtYS5mdWt1b2thLmpwXCI6dHJ1ZSxcImlpenVrYS5mdWt1b2thLmpwXCI6dHJ1ZSxcImluYXRzdWtpLmZ1a3Vva2EuanBcIjp0cnVlLFwia2Foby5mdWt1b2thLmpwXCI6dHJ1ZSxcImthc3VnYS5mdWt1b2thLmpwXCI6dHJ1ZSxcImthc3V5YS5mdWt1b2thLmpwXCI6dHJ1ZSxcImthd2FyYS5mdWt1b2thLmpwXCI6dHJ1ZSxcImtlaXNlbi5mdWt1b2thLmpwXCI6dHJ1ZSxcImtvZ2EuZnVrdW9rYS5qcFwiOnRydWUsXCJrdXJhdGUuZnVrdW9rYS5qcFwiOnRydWUsXCJrdXJvZ2kuZnVrdW9rYS5qcFwiOnRydWUsXCJrdXJ1bWUuZnVrdW9rYS5qcFwiOnRydWUsXCJtaW5hbWkuZnVrdW9rYS5qcFwiOnRydWUsXCJtaXlha28uZnVrdW9rYS5qcFwiOnRydWUsXCJtaXlhbWEuZnVrdW9rYS5qcFwiOnRydWUsXCJtaXlhd2FrYS5mdWt1b2thLmpwXCI6dHJ1ZSxcIm1penVtYWtpLmZ1a3Vva2EuanBcIjp0cnVlLFwibXVuYWthdGEuZnVrdW9rYS5qcFwiOnRydWUsXCJuYWthZ2F3YS5mdWt1b2thLmpwXCI6dHJ1ZSxcIm5ha2FtYS5mdWt1b2thLmpwXCI6dHJ1ZSxcIm5pc2hpLmZ1a3Vva2EuanBcIjp0cnVlLFwibm9nYXRhLmZ1a3Vva2EuanBcIjp0cnVlLFwib2dvcmkuZnVrdW9rYS5qcFwiOnRydWUsXCJva2FnYWtpLmZ1a3Vva2EuanBcIjp0cnVlLFwib2thd2EuZnVrdW9rYS5qcFwiOnRydWUsXCJva2kuZnVrdW9rYS5qcFwiOnRydWUsXCJvbXV0YS5mdWt1b2thLmpwXCI6dHJ1ZSxcIm9uZ2EuZnVrdW9rYS5qcFwiOnRydWUsXCJvbm9qby5mdWt1b2thLmpwXCI6dHJ1ZSxcIm90by5mdWt1b2thLmpwXCI6dHJ1ZSxcInNhaWdhd2EuZnVrdW9rYS5qcFwiOnRydWUsXCJzYXNhZ3VyaS5mdWt1b2thLmpwXCI6dHJ1ZSxcInNoaW5ndS5mdWt1b2thLmpwXCI6dHJ1ZSxcInNoaW55b3NoaXRvbWkuZnVrdW9rYS5qcFwiOnRydWUsXCJzaG9uYWkuZnVrdW9rYS5qcFwiOnRydWUsXCJzb2VkYS5mdWt1b2thLmpwXCI6dHJ1ZSxcInN1ZS5mdWt1b2thLmpwXCI6dHJ1ZSxcInRhY2hpYXJhaS5mdWt1b2thLmpwXCI6dHJ1ZSxcInRhZ2F3YS5mdWt1b2thLmpwXCI6dHJ1ZSxcInRha2F0YS5mdWt1b2thLmpwXCI6dHJ1ZSxcInRvaG8uZnVrdW9rYS5qcFwiOnRydWUsXCJ0b3lvdHN1LmZ1a3Vva2EuanBcIjp0cnVlLFwidHN1aWtpLmZ1a3Vva2EuanBcIjp0cnVlLFwidWtpaGEuZnVrdW9rYS5qcFwiOnRydWUsXCJ1bWkuZnVrdW9rYS5qcFwiOnRydWUsXCJ1c3VpLmZ1a3Vva2EuanBcIjp0cnVlLFwieWFtYWRhLmZ1a3Vva2EuanBcIjp0cnVlLFwieWFtZS5mdWt1b2thLmpwXCI6dHJ1ZSxcInlhbmFnYXdhLmZ1a3Vva2EuanBcIjp0cnVlLFwieXVrdWhhc2hpLmZ1a3Vva2EuanBcIjp0cnVlLFwiYWl6dWJhbmdlLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJhaXp1bWlzYXRvLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJhaXp1d2FrYW1hdHN1LmZ1a3VzaGltYS5qcFwiOnRydWUsXCJhc2FrYXdhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJiYW5kYWkuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcImRhdGUuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcImZ1a3VzaGltYS5mdWt1c2hpbWEuanBcIjp0cnVlLFwiZnVydWRvbm8uZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcImZ1dGFiYS5mdWt1c2hpbWEuanBcIjp0cnVlLFwiaGFuYXdhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJoaWdhc2hpLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJoaXJhdGEuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcImhpcm9uby5mdWt1c2hpbWEuanBcIjp0cnVlLFwiaWl0YXRlLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJpbmF3YXNoaXJvLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJpc2hpa2F3YS5mdWt1c2hpbWEuanBcIjp0cnVlLFwiaXdha2kuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcIml6dW1pemFraS5mdWt1c2hpbWEuanBcIjp0cnVlLFwia2FnYW1paXNoaS5mdWt1c2hpbWEuanBcIjp0cnVlLFwia2FuZXlhbWEuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcImthd2FtYXRhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJraXRha2F0YS5mdWt1c2hpbWEuanBcIjp0cnVlLFwia2l0YXNoaW9iYXJhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJrb29yaS5mdWt1c2hpbWEuanBcIjp0cnVlLFwia29yaXlhbWEuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcImt1bmltaS5mdWt1c2hpbWEuanBcIjp0cnVlLFwibWloYXJ1LmZ1a3VzaGltYS5qcFwiOnRydWUsXCJtaXNoaW1hLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJuYW1pZS5mdWt1c2hpbWEuanBcIjp0cnVlLFwibmFuZ28uZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcIm5pc2hpYWl6dS5mdWt1c2hpbWEuanBcIjp0cnVlLFwibmlzaGlnby5mdWt1c2hpbWEuanBcIjp0cnVlLFwib2t1bWEuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcIm9tb3RlZ28uZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcIm9uby5mdWt1c2hpbWEuanBcIjp0cnVlLFwib3RhbWEuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcInNhbWVnYXdhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJzaGltb2dvLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJzaGlyYWthd2EuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcInNob3dhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJzb21hLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJzdWthZ2F3YS5mdWt1c2hpbWEuanBcIjp0cnVlLFwidGFpc2hpbi5mdWt1c2hpbWEuanBcIjp0cnVlLFwidGFtYWthd2EuZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcInRhbmFndXJhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJ0ZW5laS5mdWt1c2hpbWEuanBcIjp0cnVlLFwieWFidWtpLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJ5YW1hdG8uZnVrdXNoaW1hLmpwXCI6dHJ1ZSxcInlhbWF0c3VyaS5mdWt1c2hpbWEuanBcIjp0cnVlLFwieWFuYWl6dS5mdWt1c2hpbWEuanBcIjp0cnVlLFwieXVnYXdhLmZ1a3VzaGltYS5qcFwiOnRydWUsXCJhbnBhY2hpLmdpZnUuanBcIjp0cnVlLFwiZW5hLmdpZnUuanBcIjp0cnVlLFwiZ2lmdS5naWZ1LmpwXCI6dHJ1ZSxcImdpbmFuLmdpZnUuanBcIjp0cnVlLFwiZ29kby5naWZ1LmpwXCI6dHJ1ZSxcImd1am8uZ2lmdS5qcFwiOnRydWUsXCJoYXNoaW1hLmdpZnUuanBcIjp0cnVlLFwiaGljaGlzby5naWZ1LmpwXCI6dHJ1ZSxcImhpZGEuZ2lmdS5qcFwiOnRydWUsXCJoaWdhc2hpc2hpcmFrYXdhLmdpZnUuanBcIjp0cnVlLFwiaWJpZ2F3YS5naWZ1LmpwXCI6dHJ1ZSxcImlrZWRhLmdpZnUuanBcIjp0cnVlLFwia2FrYW1pZ2FoYXJhLmdpZnUuanBcIjp0cnVlLFwia2FuaS5naWZ1LmpwXCI6dHJ1ZSxcImthc2FoYXJhLmdpZnUuanBcIjp0cnVlLFwia2FzYW1hdHN1LmdpZnUuanBcIjp0cnVlLFwia2F3YXVlLmdpZnUuanBcIjp0cnVlLFwia2l0YWdhdGEuZ2lmdS5qcFwiOnRydWUsXCJtaW5vLmdpZnUuanBcIjp0cnVlLFwibWlub2thbW8uZ2lmdS5qcFwiOnRydWUsXCJtaXRha2UuZ2lmdS5qcFwiOnRydWUsXCJtaXp1bmFtaS5naWZ1LmpwXCI6dHJ1ZSxcIm1vdG9zdS5naWZ1LmpwXCI6dHJ1ZSxcIm5ha2F0c3VnYXdhLmdpZnUuanBcIjp0cnVlLFwib2dha2kuZ2lmdS5qcFwiOnRydWUsXCJzYWthaG9naS5naWZ1LmpwXCI6dHJ1ZSxcInNla2kuZ2lmdS5qcFwiOnRydWUsXCJzZWtpZ2FoYXJhLmdpZnUuanBcIjp0cnVlLFwic2hpcmFrYXdhLmdpZnUuanBcIjp0cnVlLFwidGFqaW1pLmdpZnUuanBcIjp0cnVlLFwidGFrYXlhbWEuZ2lmdS5qcFwiOnRydWUsXCJ0YXJ1aS5naWZ1LmpwXCI6dHJ1ZSxcInRva2kuZ2lmdS5qcFwiOnRydWUsXCJ0b21pa2EuZ2lmdS5qcFwiOnRydWUsXCJ3YW5vdWNoaS5naWZ1LmpwXCI6dHJ1ZSxcInlhbWFnYXRhLmdpZnUuanBcIjp0cnVlLFwieWFvdHN1LmdpZnUuanBcIjp0cnVlLFwieW9yby5naWZ1LmpwXCI6dHJ1ZSxcImFubmFrYS5ndW5tYS5qcFwiOnRydWUsXCJjaGl5b2RhLmd1bm1hLmpwXCI6dHJ1ZSxcImZ1amlva2EuZ3VubWEuanBcIjp0cnVlLFwiaGlnYXNoaWFnYXRzdW1hLmd1bm1hLmpwXCI6dHJ1ZSxcImlzZXNha2kuZ3VubWEuanBcIjp0cnVlLFwiaXRha3VyYS5ndW5tYS5qcFwiOnRydWUsXCJrYW5uYS5ndW5tYS5qcFwiOnRydWUsXCJrYW5yYS5ndW5tYS5qcFwiOnRydWUsXCJrYXRhc2hpbmEuZ3VubWEuanBcIjp0cnVlLFwia2F3YWJhLmd1bm1hLmpwXCI6dHJ1ZSxcImtpcnl1Lmd1bm1hLmpwXCI6dHJ1ZSxcImt1c2F0c3UuZ3VubWEuanBcIjp0cnVlLFwibWFlYmFzaGkuZ3VubWEuanBcIjp0cnVlLFwibWVpd2EuZ3VubWEuanBcIjp0cnVlLFwibWlkb3JpLmd1bm1hLmpwXCI6dHJ1ZSxcIm1pbmFrYW1pLmd1bm1hLmpwXCI6dHJ1ZSxcIm5hZ2Fub2hhcmEuZ3VubWEuanBcIjp0cnVlLFwibmFrYW5vam8uZ3VubWEuanBcIjp0cnVlLFwibmFubW9rdS5ndW5tYS5qcFwiOnRydWUsXCJudW1hdGEuZ3VubWEuanBcIjp0cnVlLFwib2l6dW1pLmd1bm1hLmpwXCI6dHJ1ZSxcIm9yYS5ndW5tYS5qcFwiOnRydWUsXCJvdGEuZ3VubWEuanBcIjp0cnVlLFwic2hpYnVrYXdhLmd1bm1hLmpwXCI6dHJ1ZSxcInNoaW1vbml0YS5ndW5tYS5qcFwiOnRydWUsXCJzaGludG8uZ3VubWEuanBcIjp0cnVlLFwic2hvd2EuZ3VubWEuanBcIjp0cnVlLFwidGFrYXNha2kuZ3VubWEuanBcIjp0cnVlLFwidGFrYXlhbWEuZ3VubWEuanBcIjp0cnVlLFwidGFtYW11cmEuZ3VubWEuanBcIjp0cnVlLFwidGF0ZWJheWFzaGkuZ3VubWEuanBcIjp0cnVlLFwidG9taW9rYS5ndW5tYS5qcFwiOnRydWUsXCJ0c3VraXlvbm8uZ3VubWEuanBcIjp0cnVlLFwidHN1bWFnb2kuZ3VubWEuanBcIjp0cnVlLFwidWVuby5ndW5tYS5qcFwiOnRydWUsXCJ5b3NoaW9rYS5ndW5tYS5qcFwiOnRydWUsXCJhc2FtaW5hbWkuaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcImRhaXdhLmhpcm9zaGltYS5qcFwiOnRydWUsXCJldGFqaW1hLmhpcm9zaGltYS5qcFwiOnRydWUsXCJmdWNodS5oaXJvc2hpbWEuanBcIjp0cnVlLFwiZnVrdXlhbWEuaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcImhhdHN1a2FpY2hpLmhpcm9zaGltYS5qcFwiOnRydWUsXCJoaWdhc2hpaGlyb3NoaW1hLmhpcm9zaGltYS5qcFwiOnRydWUsXCJob25nby5oaXJvc2hpbWEuanBcIjp0cnVlLFwiamluc2VraWtvZ2VuLmhpcm9zaGltYS5qcFwiOnRydWUsXCJrYWl0YS5oaXJvc2hpbWEuanBcIjp0cnVlLFwia3VpLmhpcm9zaGltYS5qcFwiOnRydWUsXCJrdW1hbm8uaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcImt1cmUuaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcIm1paGFyYS5oaXJvc2hpbWEuanBcIjp0cnVlLFwibWl5b3NoaS5oaXJvc2hpbWEuanBcIjp0cnVlLFwibmFrYS5oaXJvc2hpbWEuanBcIjp0cnVlLFwib25vbWljaGkuaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcIm9zYWtpa2FtaWppbWEuaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcIm90YWtlLmhpcm9zaGltYS5qcFwiOnRydWUsXCJzYWthLmhpcm9zaGltYS5qcFwiOnRydWUsXCJzZXJhLmhpcm9zaGltYS5qcFwiOnRydWUsXCJzZXJhbmlzaGkuaGlyb3NoaW1hLmpwXCI6dHJ1ZSxcInNoaW5pY2hpLmhpcm9zaGltYS5qcFwiOnRydWUsXCJzaG9iYXJhLmhpcm9zaGltYS5qcFwiOnRydWUsXCJ0YWtlaGFyYS5oaXJvc2hpbWEuanBcIjp0cnVlLFwiYWJhc2hpcmkuaG9ra2FpZG8uanBcIjp0cnVlLFwiYWJpcmEuaG9ra2FpZG8uanBcIjp0cnVlLFwiYWliZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJha2FiaXJhLmhva2thaWRvLmpwXCI6dHJ1ZSxcImFra2VzaGkuaG9ra2FpZG8uanBcIjp0cnVlLFwiYXNhaGlrYXdhLmhva2thaWRvLmpwXCI6dHJ1ZSxcImFzaGliZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJhc2hvcm8uaG9ra2FpZG8uanBcIjp0cnVlLFwiYXNzYWJ1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcImF0c3VtYS5ob2trYWlkby5qcFwiOnRydWUsXCJiaWJhaS5ob2trYWlkby5qcFwiOnRydWUsXCJiaWVpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImJpZnVrYS5ob2trYWlkby5qcFwiOnRydWUsXCJiaWhvcm8uaG9ra2FpZG8uanBcIjp0cnVlLFwiYmlyYXRvcmkuaG9ra2FpZG8uanBcIjp0cnVlLFwiY2hpcHB1YmV0c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwiY2hpdG9zZS5ob2trYWlkby5qcFwiOnRydWUsXCJkYXRlLmhva2thaWRvLmpwXCI6dHJ1ZSxcImViZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJlbWJldHN1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcImVuaXdhLmhva2thaWRvLmpwXCI6dHJ1ZSxcImVyaW1vLmhva2thaWRvLmpwXCI6dHJ1ZSxcImVzYW4uaG9ra2FpZG8uanBcIjp0cnVlLFwiZXNhc2hpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImZ1a2FnYXdhLmhva2thaWRvLmpwXCI6dHJ1ZSxcImZ1a3VzaGltYS5ob2trYWlkby5qcFwiOnRydWUsXCJmdXJhbm8uaG9ra2FpZG8uanBcIjp0cnVlLFwiZnVydWJpcmEuaG9ra2FpZG8uanBcIjp0cnVlLFwiaGFib3JvLmhva2thaWRvLmpwXCI6dHJ1ZSxcImhha29kYXRlLmhva2thaWRvLmpwXCI6dHJ1ZSxcImhhbWF0b25iZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJoaWRha2EuaG9ra2FpZG8uanBcIjp0cnVlLFwiaGlnYXNoaWthZ3VyYS5ob2trYWlkby5qcFwiOnRydWUsXCJoaWdhc2hpa2F3YS5ob2trYWlkby5qcFwiOnRydWUsXCJoaXJvby5ob2trYWlkby5qcFwiOnRydWUsXCJob2t1cnl1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcImhva3V0by5ob2trYWlkby5qcFwiOnRydWUsXCJob25iZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJob3Jva2FuYWkuaG9ra2FpZG8uanBcIjp0cnVlLFwiaG9yb25vYmUuaG9ra2FpZG8uanBcIjp0cnVlLFwiaWtlZGEuaG9ra2FpZG8uanBcIjp0cnVlLFwiaW1ha2FuZS5ob2trYWlkby5qcFwiOnRydWUsXCJpc2hpa2FyaS5ob2trYWlkby5qcFwiOnRydWUsXCJpd2FtaXphd2EuaG9ra2FpZG8uanBcIjp0cnVlLFwiaXdhbmFpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImthbWlmdXJhbm8uaG9ra2FpZG8uanBcIjp0cnVlLFwia2FtaWthd2EuaG9ra2FpZG8uanBcIjp0cnVlLFwia2FtaXNoaWhvcm8uaG9ra2FpZG8uanBcIjp0cnVlLFwia2FtaXN1bmFnYXdhLmhva2thaWRvLmpwXCI6dHJ1ZSxcImthbW9lbmFpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImtheWFiZS5ob2trYWlkby5qcFwiOnRydWUsXCJrZW1idWNoaS5ob2trYWlkby5qcFwiOnRydWUsXCJraWtvbmFpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImtpbW9iZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJraXRhaGlyb3NoaW1hLmhva2thaWRvLmpwXCI6dHJ1ZSxcImtpdGFtaS5ob2trYWlkby5qcFwiOnRydWUsXCJraXlvc2F0by5ob2trYWlkby5qcFwiOnRydWUsXCJrb3NoaW1penUuaG9ra2FpZG8uanBcIjp0cnVlLFwia3VubmVwcHUuaG9ra2FpZG8uanBcIjp0cnVlLFwia3VyaXlhbWEuaG9ra2FpZG8uanBcIjp0cnVlLFwia3Vyb21hdHN1bmFpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImt1c2hpcm8uaG9ra2FpZG8uanBcIjp0cnVlLFwia3V0Y2hhbi5ob2trYWlkby5qcFwiOnRydWUsXCJreW93YS5ob2trYWlkby5qcFwiOnRydWUsXCJtYXNoaWtlLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm1hdHN1bWFlLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm1pa2FzYS5ob2trYWlkby5qcFwiOnRydWUsXCJtaW5hbWlmdXJhbm8uaG9ra2FpZG8uanBcIjp0cnVlLFwibW9tYmV0c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwibW9zZXVzaGkuaG9ra2FpZG8uanBcIjp0cnVlLFwibXVrYXdhLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm11cm9yYW4uaG9ra2FpZG8uanBcIjp0cnVlLFwibmFpZS5ob2trYWlkby5qcFwiOnRydWUsXCJuYWthZ2F3YS5ob2trYWlkby5qcFwiOnRydWUsXCJuYWthc2F0c3VuYWkuaG9ra2FpZG8uanBcIjp0cnVlLFwibmFrYXRvbWJldHN1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcIm5hbmFlLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm5hbnBvcm8uaG9ra2FpZG8uanBcIjp0cnVlLFwibmF5b3JvLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm5lbXVyby5ob2trYWlkby5qcFwiOnRydWUsXCJuaWlrYXBwdS5ob2trYWlkby5qcFwiOnRydWUsXCJuaWtpLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm5pc2hpb2tvcHBlLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm5vYm9yaWJldHN1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcIm51bWF0YS5ob2trYWlkby5qcFwiOnRydWUsXCJvYmloaXJvLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm9iaXJhLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm9rZXRvLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm9rb3BwZS5ob2trYWlkby5qcFwiOnRydWUsXCJvdGFydS5ob2trYWlkby5qcFwiOnRydWUsXCJvdG9iZS5ob2trYWlkby5qcFwiOnRydWUsXCJvdG9mdWtlLmhva2thaWRvLmpwXCI6dHJ1ZSxcIm90b2luZXBwdS5ob2trYWlkby5qcFwiOnRydWUsXCJvdW11Lmhva2thaWRvLmpwXCI6dHJ1ZSxcIm96b3JhLmhva2thaWRvLmpwXCI6dHJ1ZSxcInBpcHB1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcInJhbmtvc2hpLmhva2thaWRvLmpwXCI6dHJ1ZSxcInJlYnVuLmhva2thaWRvLmpwXCI6dHJ1ZSxcInJpa3ViZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJyaXNoaXJpLmhva2thaWRvLmpwXCI6dHJ1ZSxcInJpc2hpcmlmdWppLmhva2thaWRvLmpwXCI6dHJ1ZSxcInNhcm9tYS5ob2trYWlkby5qcFwiOnRydWUsXCJzYXJ1ZnV0c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hha290YW4uaG9ra2FpZG8uanBcIjp0cnVlLFwic2hhcmkuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hpYmVjaGEuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hpYmV0c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hpa2FiZS5ob2trYWlkby5qcFwiOnRydWUsXCJzaGlrYW9pLmhva2thaWRvLmpwXCI6dHJ1ZSxcInNoaW1hbWFraS5ob2trYWlkby5qcFwiOnRydWUsXCJzaGltaXp1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcInNoaW1va2F3YS5ob2trYWlkby5qcFwiOnRydWUsXCJzaGluc2hpbm90c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hpbnRva3UuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hpcmFudWthLmhva2thaWRvLmpwXCI6dHJ1ZSxcInNoaXJhb2kuaG9ra2FpZG8uanBcIjp0cnVlLFwic2hpcml1Y2hpLmhva2thaWRvLmpwXCI6dHJ1ZSxcInNvYmV0c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwic3VuYWdhd2EuaG9ra2FpZG8uanBcIjp0cnVlLFwidGFpa2kuaG9ra2FpZG8uanBcIjp0cnVlLFwidGFrYXN1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcInRha2lrYXdhLmhva2thaWRvLmpwXCI6dHJ1ZSxcInRha2lub3VlLmhva2thaWRvLmpwXCI6dHJ1ZSxcInRlc2hpa2FnYS5ob2trYWlkby5qcFwiOnRydWUsXCJ0b2JldHN1Lmhva2thaWRvLmpwXCI6dHJ1ZSxcInRvaG1hLmhva2thaWRvLmpwXCI6dHJ1ZSxcInRvbWFrb21haS5ob2trYWlkby5qcFwiOnRydWUsXCJ0b21hcmkuaG9ra2FpZG8uanBcIjp0cnVlLFwidG95YS5ob2trYWlkby5qcFwiOnRydWUsXCJ0b3lha28uaG9ra2FpZG8uanBcIjp0cnVlLFwidG95b3RvbWkuaG9ra2FpZG8uanBcIjp0cnVlLFwidG95b3VyYS5ob2trYWlkby5qcFwiOnRydWUsXCJ0c3ViZXRzdS5ob2trYWlkby5qcFwiOnRydWUsXCJ0c3VraWdhdGEuaG9ra2FpZG8uanBcIjp0cnVlLFwidXJha2F3YS5ob2trYWlkby5qcFwiOnRydWUsXCJ1cmF1c3UuaG9ra2FpZG8uanBcIjp0cnVlLFwidXJ5dS5ob2trYWlkby5qcFwiOnRydWUsXCJ1dGFzaGluYWkuaG9ra2FpZG8uanBcIjp0cnVlLFwid2Fra2FuYWkuaG9ra2FpZG8uanBcIjp0cnVlLFwid2Fzc2FtdS5ob2trYWlkby5qcFwiOnRydWUsXCJ5YWt1bW8uaG9ra2FpZG8uanBcIjp0cnVlLFwieW9pY2hpLmhva2thaWRvLmpwXCI6dHJ1ZSxcImFpb2kuaHlvZ28uanBcIjp0cnVlLFwiYWthc2hpLmh5b2dvLmpwXCI6dHJ1ZSxcImFrby5oeW9nby5qcFwiOnRydWUsXCJhbWFnYXNha2kuaHlvZ28uanBcIjp0cnVlLFwiYW9nYWtpLmh5b2dvLmpwXCI6dHJ1ZSxcImFzYWdvLmh5b2dvLmpwXCI6dHJ1ZSxcImFzaGl5YS5oeW9nby5qcFwiOnRydWUsXCJhd2FqaS5oeW9nby5qcFwiOnRydWUsXCJmdWt1c2FraS5oeW9nby5qcFwiOnRydWUsXCJnb3NoaWtpLmh5b2dvLmpwXCI6dHJ1ZSxcImhhcmltYS5oeW9nby5qcFwiOnRydWUsXCJoaW1lamkuaHlvZ28uanBcIjp0cnVlLFwiaWNoaWthd2EuaHlvZ28uanBcIjp0cnVlLFwiaW5hZ2F3YS5oeW9nby5qcFwiOnRydWUsXCJpdGFtaS5oeW9nby5qcFwiOnRydWUsXCJrYWtvZ2F3YS5oeW9nby5qcFwiOnRydWUsXCJrYW1pZ29yaS5oeW9nby5qcFwiOnRydWUsXCJrYW1pa2F3YS5oeW9nby5qcFwiOnRydWUsXCJrYXNhaS5oeW9nby5qcFwiOnRydWUsXCJrYXN1Z2EuaHlvZ28uanBcIjp0cnVlLFwia2F3YW5pc2hpLmh5b2dvLmpwXCI6dHJ1ZSxcIm1pa2kuaHlvZ28uanBcIjp0cnVlLFwibWluYW1pYXdhamkuaHlvZ28uanBcIjp0cnVlLFwibmlzaGlub21peWEuaHlvZ28uanBcIjp0cnVlLFwibmlzaGl3YWtpLmh5b2dvLmpwXCI6dHJ1ZSxcIm9uby5oeW9nby5qcFwiOnRydWUsXCJzYW5kYS5oeW9nby5qcFwiOnRydWUsXCJzYW5uYW4uaHlvZ28uanBcIjp0cnVlLFwic2FzYXlhbWEuaHlvZ28uanBcIjp0cnVlLFwic2F5by5oeW9nby5qcFwiOnRydWUsXCJzaGluZ3UuaHlvZ28uanBcIjp0cnVlLFwic2hpbm9uc2VuLmh5b2dvLmpwXCI6dHJ1ZSxcInNoaXNvLmh5b2dvLmpwXCI6dHJ1ZSxcInN1bW90by5oeW9nby5qcFwiOnRydWUsXCJ0YWlzaGkuaHlvZ28uanBcIjp0cnVlLFwidGFrYS5oeW9nby5qcFwiOnRydWUsXCJ0YWthcmF6dWthLmh5b2dvLmpwXCI6dHJ1ZSxcInRha2FzYWdvLmh5b2dvLmpwXCI6dHJ1ZSxcInRha2luby5oeW9nby5qcFwiOnRydWUsXCJ0YW1iYS5oeW9nby5qcFwiOnRydWUsXCJ0YXRzdW5vLmh5b2dvLmpwXCI6dHJ1ZSxcInRveW9va2EuaHlvZ28uanBcIjp0cnVlLFwieWFidS5oeW9nby5qcFwiOnRydWUsXCJ5YXNoaXJvLmh5b2dvLmpwXCI6dHJ1ZSxcInlva2EuaHlvZ28uanBcIjp0cnVlLFwieW9rYXdhLmh5b2dvLmpwXCI6dHJ1ZSxcImFtaS5pYmFyYWtpLmpwXCI6dHJ1ZSxcImFzYWhpLmliYXJha2kuanBcIjp0cnVlLFwiYmFuZG8uaWJhcmFraS5qcFwiOnRydWUsXCJjaGlrdXNlaS5pYmFyYWtpLmpwXCI6dHJ1ZSxcImRhaWdvLmliYXJha2kuanBcIjp0cnVlLFwiZnVqaXNoaXJvLmliYXJha2kuanBcIjp0cnVlLFwiaGl0YWNoaS5pYmFyYWtpLmpwXCI6dHJ1ZSxcImhpdGFjaGluYWthLmliYXJha2kuanBcIjp0cnVlLFwiaGl0YWNoaW9taXlhLmliYXJha2kuanBcIjp0cnVlLFwiaGl0YWNoaW90YS5pYmFyYWtpLmpwXCI6dHJ1ZSxcImliYXJha2kuaWJhcmFraS5qcFwiOnRydWUsXCJpbmEuaWJhcmFraS5qcFwiOnRydWUsXCJpbmFzaGlraS5pYmFyYWtpLmpwXCI6dHJ1ZSxcIml0YWtvLmliYXJha2kuanBcIjp0cnVlLFwiaXdhbWEuaWJhcmFraS5qcFwiOnRydWUsXCJqb3NvLmliYXJha2kuanBcIjp0cnVlLFwia2FtaXN1LmliYXJha2kuanBcIjp0cnVlLFwia2FzYW1hLmliYXJha2kuanBcIjp0cnVlLFwia2FzaGltYS5pYmFyYWtpLmpwXCI6dHJ1ZSxcImthc3VtaWdhdXJhLmliYXJha2kuanBcIjp0cnVlLFwia29nYS5pYmFyYWtpLmpwXCI6dHJ1ZSxcIm1paG8uaWJhcmFraS5qcFwiOnRydWUsXCJtaXRvLmliYXJha2kuanBcIjp0cnVlLFwibW9yaXlhLmliYXJha2kuanBcIjp0cnVlLFwibmFrYS5pYmFyYWtpLmpwXCI6dHJ1ZSxcIm5hbWVnYXRhLmliYXJha2kuanBcIjp0cnVlLFwib2FyYWkuaWJhcmFraS5qcFwiOnRydWUsXCJvZ2F3YS5pYmFyYWtpLmpwXCI6dHJ1ZSxcIm9taXRhbWEuaWJhcmFraS5qcFwiOnRydWUsXCJyeXVnYXNha2kuaWJhcmFraS5qcFwiOnRydWUsXCJzYWthaS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInNha3VyYWdhd2EuaWJhcmFraS5qcFwiOnRydWUsXCJzaGltb2RhdGUuaWJhcmFraS5qcFwiOnRydWUsXCJzaGltb3RzdW1hLmliYXJha2kuanBcIjp0cnVlLFwic2hpcm9zYXRvLmliYXJha2kuanBcIjp0cnVlLFwic293YS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInN1aWZ1LmliYXJha2kuanBcIjp0cnVlLFwidGFrYWhhZ2kuaWJhcmFraS5qcFwiOnRydWUsXCJ0YW1hdHN1a3VyaS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInRva2FpLmliYXJha2kuanBcIjp0cnVlLFwidG9tb2JlLmliYXJha2kuanBcIjp0cnVlLFwidG9uZS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInRvcmlkZS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInRzdWNoaXVyYS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInRzdWt1YmEuaWJhcmFraS5qcFwiOnRydWUsXCJ1Y2hpaGFyYS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInVzaGlrdS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInlhY2hpeW8uaWJhcmFraS5qcFwiOnRydWUsXCJ5YW1hZ2F0YS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInlhd2FyYS5pYmFyYWtpLmpwXCI6dHJ1ZSxcInl1a2kuaWJhcmFraS5qcFwiOnRydWUsXCJhbmFtaXp1LmlzaGlrYXdhLmpwXCI6dHJ1ZSxcImhha3VpLmlzaGlrYXdhLmpwXCI6dHJ1ZSxcImhha3VzYW4uaXNoaWthd2EuanBcIjp0cnVlLFwia2FnYS5pc2hpa2F3YS5qcFwiOnRydWUsXCJrYWhva3UuaXNoaWthd2EuanBcIjp0cnVlLFwia2FuYXphd2EuaXNoaWthd2EuanBcIjp0cnVlLFwia2F3YWtpdGEuaXNoaWthd2EuanBcIjp0cnVlLFwia29tYXRzdS5pc2hpa2F3YS5qcFwiOnRydWUsXCJuYWthbm90by5pc2hpa2F3YS5qcFwiOnRydWUsXCJuYW5hby5pc2hpa2F3YS5qcFwiOnRydWUsXCJub21pLmlzaGlrYXdhLmpwXCI6dHJ1ZSxcIm5vbm9pY2hpLmlzaGlrYXdhLmpwXCI6dHJ1ZSxcIm5vdG8uaXNoaWthd2EuanBcIjp0cnVlLFwic2hpa2EuaXNoaWthd2EuanBcIjp0cnVlLFwic3V6dS5pc2hpa2F3YS5qcFwiOnRydWUsXCJ0c3ViYXRhLmlzaGlrYXdhLmpwXCI6dHJ1ZSxcInRzdXJ1Z2kuaXNoaWthd2EuanBcIjp0cnVlLFwidWNoaW5hZGEuaXNoaWthd2EuanBcIjp0cnVlLFwid2FqaW1hLmlzaGlrYXdhLmpwXCI6dHJ1ZSxcImZ1ZGFpLml3YXRlLmpwXCI6dHJ1ZSxcImZ1amlzYXdhLml3YXRlLmpwXCI6dHJ1ZSxcImhhbmFtYWtpLml3YXRlLmpwXCI6dHJ1ZSxcImhpcmFpenVtaS5pd2F0ZS5qcFwiOnRydWUsXCJoaXJvbm8uaXdhdGUuanBcIjp0cnVlLFwiaWNoaW5vaGUuaXdhdGUuanBcIjp0cnVlLFwiaWNoaW5vc2VraS5pd2F0ZS5qcFwiOnRydWUsXCJpd2FpenVtaS5pd2F0ZS5qcFwiOnRydWUsXCJpd2F0ZS5pd2F0ZS5qcFwiOnRydWUsXCJqb2JvamkuaXdhdGUuanBcIjp0cnVlLFwia2FtYWlzaGkuaXdhdGUuanBcIjp0cnVlLFwia2FuZWdhc2FraS5pd2F0ZS5qcFwiOnRydWUsXCJrYXJ1bWFpLml3YXRlLmpwXCI6dHJ1ZSxcImthd2FpLml3YXRlLmpwXCI6dHJ1ZSxcImtpdGFrYW1pLml3YXRlLmpwXCI6dHJ1ZSxcImt1amkuaXdhdGUuanBcIjp0cnVlLFwia3Vub2hlLml3YXRlLmpwXCI6dHJ1ZSxcImt1enVtYWtpLml3YXRlLmpwXCI6dHJ1ZSxcIm1peWFrby5pd2F0ZS5qcFwiOnRydWUsXCJtaXp1c2F3YS5pd2F0ZS5qcFwiOnRydWUsXCJtb3Jpb2thLml3YXRlLmpwXCI6dHJ1ZSxcIm5pbm9oZS5pd2F0ZS5qcFwiOnRydWUsXCJub2RhLml3YXRlLmpwXCI6dHJ1ZSxcIm9mdW5hdG8uaXdhdGUuanBcIjp0cnVlLFwib3NodS5pd2F0ZS5qcFwiOnRydWUsXCJvdHN1Y2hpLml3YXRlLmpwXCI6dHJ1ZSxcInJpa3V6ZW50YWthdGEuaXdhdGUuanBcIjp0cnVlLFwic2hpd2EuaXdhdGUuanBcIjp0cnVlLFwic2hpenVrdWlzaGkuaXdhdGUuanBcIjp0cnVlLFwic3VtaXRhLml3YXRlLmpwXCI6dHJ1ZSxcInRhbm9oYXRhLml3YXRlLmpwXCI6dHJ1ZSxcInRvbm8uaXdhdGUuanBcIjp0cnVlLFwieWFoYWJhLml3YXRlLmpwXCI6dHJ1ZSxcInlhbWFkYS5pd2F0ZS5qcFwiOnRydWUsXCJheWFnYXdhLmthZ2F3YS5qcFwiOnRydWUsXCJoaWdhc2hpa2FnYXdhLmthZ2F3YS5qcFwiOnRydWUsXCJrYW5vbmppLmthZ2F3YS5qcFwiOnRydWUsXCJrb3RvaGlyYS5rYWdhd2EuanBcIjp0cnVlLFwibWFubm8ua2FnYXdhLmpwXCI6dHJ1ZSxcIm1hcnVnYW1lLmthZ2F3YS5qcFwiOnRydWUsXCJtaXRveW8ua2FnYXdhLmpwXCI6dHJ1ZSxcIm5hb3NoaW1hLmthZ2F3YS5qcFwiOnRydWUsXCJzYW51a2kua2FnYXdhLmpwXCI6dHJ1ZSxcInRhZG90c3Uua2FnYXdhLmpwXCI6dHJ1ZSxcInRha2FtYXRzdS5rYWdhd2EuanBcIjp0cnVlLFwidG9ub3Noby5rYWdhd2EuanBcIjp0cnVlLFwidWNoaW5vbWkua2FnYXdhLmpwXCI6dHJ1ZSxcInV0YXp1LmthZ2F3YS5qcFwiOnRydWUsXCJ6ZW50c3VqaS5rYWdhd2EuanBcIjp0cnVlLFwiYWt1bmUua2Fnb3NoaW1hLmpwXCI6dHJ1ZSxcImFtYW1pLmthZ29zaGltYS5qcFwiOnRydWUsXCJoaW9raS5rYWdvc2hpbWEuanBcIjp0cnVlLFwiaXNhLmthZ29zaGltYS5qcFwiOnRydWUsXCJpc2VuLmthZ29zaGltYS5qcFwiOnRydWUsXCJpenVtaS5rYWdvc2hpbWEuanBcIjp0cnVlLFwia2Fnb3NoaW1hLmthZ29zaGltYS5qcFwiOnRydWUsXCJrYW5veWEua2Fnb3NoaW1hLmpwXCI6dHJ1ZSxcImthd2FuYWJlLmthZ29zaGltYS5qcFwiOnRydWUsXCJraW5rby5rYWdvc2hpbWEuanBcIjp0cnVlLFwia291eWFtYS5rYWdvc2hpbWEuanBcIjp0cnVlLFwibWFrdXJhemFraS5rYWdvc2hpbWEuanBcIjp0cnVlLFwibWF0c3Vtb3RvLmthZ29zaGltYS5qcFwiOnRydWUsXCJtaW5hbWl0YW5lLmthZ29zaGltYS5qcFwiOnRydWUsXCJuYWthdGFuZS5rYWdvc2hpbWEuanBcIjp0cnVlLFwibmlzaGlub29tb3RlLmthZ29zaGltYS5qcFwiOnRydWUsXCJzYXRzdW1hc2VuZGFpLmthZ29zaGltYS5qcFwiOnRydWUsXCJzb28ua2Fnb3NoaW1hLmpwXCI6dHJ1ZSxcInRhcnVtaXp1LmthZ29zaGltYS5qcFwiOnRydWUsXCJ5dXN1aS5rYWdvc2hpbWEuanBcIjp0cnVlLFwiYWlrYXdhLmthbmFnYXdhLmpwXCI6dHJ1ZSxcImF0c3VnaS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJheWFzZS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJjaGlnYXNha2kua2FuYWdhd2EuanBcIjp0cnVlLFwiZWJpbmEua2FuYWdhd2EuanBcIjp0cnVlLFwiZnVqaXNhd2Eua2FuYWdhd2EuanBcIjp0cnVlLFwiaGFkYW5vLmthbmFnYXdhLmpwXCI6dHJ1ZSxcImhha29uZS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJoaXJhdHN1a2Eua2FuYWdhd2EuanBcIjp0cnVlLFwiaXNlaGFyYS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJrYWlzZWkua2FuYWdhd2EuanBcIjp0cnVlLFwia2FtYWt1cmEua2FuYWdhd2EuanBcIjp0cnVlLFwia2l5b2thd2Eua2FuYWdhd2EuanBcIjp0cnVlLFwibWF0c3VkYS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJtaW5hbWlhc2hpZ2FyYS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJtaXVyYS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJuYWthaS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJuaW5vbWl5YS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJvZGF3YXJhLmthbmFnYXdhLmpwXCI6dHJ1ZSxcIm9pLmthbmFnYXdhLmpwXCI6dHJ1ZSxcIm9pc28ua2FuYWdhd2EuanBcIjp0cnVlLFwic2FnYW1paGFyYS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJzYW11a2F3YS5rYW5hZ2F3YS5qcFwiOnRydWUsXCJ0c3VrdWkua2FuYWdhd2EuanBcIjp0cnVlLFwieWFtYWtpdGEua2FuYWdhd2EuanBcIjp0cnVlLFwieWFtYXRvLmthbmFnYXdhLmpwXCI6dHJ1ZSxcInlva29zdWthLmthbmFnYXdhLmpwXCI6dHJ1ZSxcInl1Z2F3YXJhLmthbmFnYXdhLmpwXCI6dHJ1ZSxcInphbWEua2FuYWdhd2EuanBcIjp0cnVlLFwienVzaGkua2FuYWdhd2EuanBcIjp0cnVlLFwiYWtpLmtvY2hpLmpwXCI6dHJ1ZSxcImdlaXNlaS5rb2NoaS5qcFwiOnRydWUsXCJoaWRha2Eua29jaGkuanBcIjp0cnVlLFwiaGlnYXNoaXRzdW5vLmtvY2hpLmpwXCI6dHJ1ZSxcImluby5rb2NoaS5qcFwiOnRydWUsXCJrYWdhbWkua29jaGkuanBcIjp0cnVlLFwia2FtaS5rb2NoaS5qcFwiOnRydWUsXCJraXRhZ2F3YS5rb2NoaS5qcFwiOnRydWUsXCJrb2NoaS5rb2NoaS5qcFwiOnRydWUsXCJtaWhhcmEua29jaGkuanBcIjp0cnVlLFwibW90b3lhbWEua29jaGkuanBcIjp0cnVlLFwibXVyb3RvLmtvY2hpLmpwXCI6dHJ1ZSxcIm5haGFyaS5rb2NoaS5qcFwiOnRydWUsXCJuYWthbXVyYS5rb2NoaS5qcFwiOnRydWUsXCJuYW5rb2t1LmtvY2hpLmpwXCI6dHJ1ZSxcIm5pc2hpdG9zYS5rb2NoaS5qcFwiOnRydWUsXCJuaXlvZG9nYXdhLmtvY2hpLmpwXCI6dHJ1ZSxcIm9jaGkua29jaGkuanBcIjp0cnVlLFwib2thd2Eua29jaGkuanBcIjp0cnVlLFwib3RveW8ua29jaGkuanBcIjp0cnVlLFwib3RzdWtpLmtvY2hpLmpwXCI6dHJ1ZSxcInNha2F3YS5rb2NoaS5qcFwiOnRydWUsXCJzdWt1bW8ua29jaGkuanBcIjp0cnVlLFwic3VzYWtpLmtvY2hpLmpwXCI6dHJ1ZSxcInRvc2Eua29jaGkuanBcIjp0cnVlLFwidG9zYXNoaW1penUua29jaGkuanBcIjp0cnVlLFwidG95by5rb2NoaS5qcFwiOnRydWUsXCJ0c3Vuby5rb2NoaS5qcFwiOnRydWUsXCJ1bWFqaS5rb2NoaS5qcFwiOnRydWUsXCJ5YXN1ZGEua29jaGkuanBcIjp0cnVlLFwieXVzdWhhcmEua29jaGkuanBcIjp0cnVlLFwiYW1ha3VzYS5rdW1hbW90by5qcFwiOnRydWUsXCJhcmFvLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcImFzby5rdW1hbW90by5qcFwiOnRydWUsXCJjaG95by5rdW1hbW90by5qcFwiOnRydWUsXCJneW9rdXRvLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcImhpdG95b3NoaS5rdW1hbW90by5qcFwiOnRydWUsXCJrYW1pYW1ha3VzYS5rdW1hbW90by5qcFwiOnRydWUsXCJrYXNoaW1hLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcImtpa3VjaGkua3VtYW1vdG8uanBcIjp0cnVlLFwia29zYS5rdW1hbW90by5qcFwiOnRydWUsXCJrdW1hbW90by5rdW1hbW90by5qcFwiOnRydWUsXCJtYXNoaWtpLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcIm1pZnVuZS5rdW1hbW90by5qcFwiOnRydWUsXCJtaW5hbWF0YS5rdW1hbW90by5qcFwiOnRydWUsXCJtaW5hbWlvZ3VuaS5rdW1hbW90by5qcFwiOnRydWUsXCJuYWdhc3Uua3VtYW1vdG8uanBcIjp0cnVlLFwibmlzaGloYXJhLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcIm9ndW5pLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcIm96dS5rdW1hbW90by5qcFwiOnRydWUsXCJzdW1vdG8ua3VtYW1vdG8uanBcIjp0cnVlLFwidGFrYW1vcmkua3VtYW1vdG8uanBcIjp0cnVlLFwidWtpLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcInV0by5rdW1hbW90by5qcFwiOnRydWUsXCJ5YW1hZ2Eua3VtYW1vdG8uanBcIjp0cnVlLFwieWFtYXRvLmt1bWFtb3RvLmpwXCI6dHJ1ZSxcInlhdHN1c2hpcm8ua3VtYW1vdG8uanBcIjp0cnVlLFwiYXlhYmUua3lvdG8uanBcIjp0cnVlLFwiZnVrdWNoaXlhbWEua3lvdG8uanBcIjp0cnVlLFwiaGlnYXNoaXlhbWEua3lvdG8uanBcIjp0cnVlLFwiaWRlLmt5b3RvLmpwXCI6dHJ1ZSxcImluZS5reW90by5qcFwiOnRydWUsXCJqb3lvLmt5b3RvLmpwXCI6dHJ1ZSxcImthbWVva2Eua3lvdG8uanBcIjp0cnVlLFwia2Ftby5reW90by5qcFwiOnRydWUsXCJraXRhLmt5b3RvLmpwXCI6dHJ1ZSxcImtpenUua3lvdG8uanBcIjp0cnVlLFwia3VtaXlhbWEua3lvdG8uanBcIjp0cnVlLFwia3lvdGFtYmEua3lvdG8uanBcIjp0cnVlLFwia3lvdGFuYWJlLmt5b3RvLmpwXCI6dHJ1ZSxcImt5b3RhbmdvLmt5b3RvLmpwXCI6dHJ1ZSxcIm1haXp1cnUua3lvdG8uanBcIjp0cnVlLFwibWluYW1pLmt5b3RvLmpwXCI6dHJ1ZSxcIm1pbmFtaXlhbWFzaGlyby5reW90by5qcFwiOnRydWUsXCJtaXlhenUua3lvdG8uanBcIjp0cnVlLFwibXVrby5reW90by5qcFwiOnRydWUsXCJuYWdhb2tha3lvLmt5b3RvLmpwXCI6dHJ1ZSxcIm5ha2FneW8ua3lvdG8uanBcIjp0cnVlLFwibmFudGFuLmt5b3RvLmpwXCI6dHJ1ZSxcIm95YW1hemFraS5reW90by5qcFwiOnRydWUsXCJzYWt5by5reW90by5qcFwiOnRydWUsXCJzZWlrYS5reW90by5qcFwiOnRydWUsXCJ0YW5hYmUua3lvdG8uanBcIjp0cnVlLFwidWppLmt5b3RvLmpwXCI6dHJ1ZSxcInVqaXRhd2FyYS5reW90by5qcFwiOnRydWUsXCJ3YXp1a2Eua3lvdG8uanBcIjp0cnVlLFwieWFtYXNoaW5hLmt5b3RvLmpwXCI6dHJ1ZSxcInlhd2F0YS5reW90by5qcFwiOnRydWUsXCJhc2FoaS5taWUuanBcIjp0cnVlLFwiaW5hYmUubWllLmpwXCI6dHJ1ZSxcImlzZS5taWUuanBcIjp0cnVlLFwia2FtZXlhbWEubWllLmpwXCI6dHJ1ZSxcImthd2Fnb2UubWllLmpwXCI6dHJ1ZSxcImtpaG8ubWllLmpwXCI6dHJ1ZSxcImtpc29zYWtpLm1pZS5qcFwiOnRydWUsXCJraXdhLm1pZS5qcFwiOnRydWUsXCJrb21vbm8ubWllLmpwXCI6dHJ1ZSxcImt1bWFuby5taWUuanBcIjp0cnVlLFwia3V3YW5hLm1pZS5qcFwiOnRydWUsXCJtYXRzdXNha2EubWllLmpwXCI6dHJ1ZSxcIm1laXdhLm1pZS5qcFwiOnRydWUsXCJtaWhhbWEubWllLmpwXCI6dHJ1ZSxcIm1pbmFtaWlzZS5taWUuanBcIjp0cnVlLFwibWlzdWdpLm1pZS5qcFwiOnRydWUsXCJtaXlhbWEubWllLmpwXCI6dHJ1ZSxcIm5hYmFyaS5taWUuanBcIjp0cnVlLFwic2hpbWEubWllLmpwXCI6dHJ1ZSxcInN1enVrYS5taWUuanBcIjp0cnVlLFwidGFkby5taWUuanBcIjp0cnVlLFwidGFpa2kubWllLmpwXCI6dHJ1ZSxcInRha2kubWllLmpwXCI6dHJ1ZSxcInRhbWFraS5taWUuanBcIjp0cnVlLFwidG9iYS5taWUuanBcIjp0cnVlLFwidHN1Lm1pZS5qcFwiOnRydWUsXCJ1ZG9uby5taWUuanBcIjp0cnVlLFwidXJlc2hpbm8ubWllLmpwXCI6dHJ1ZSxcIndhdGFyYWkubWllLmpwXCI6dHJ1ZSxcInlva2thaWNoaS5taWUuanBcIjp0cnVlLFwiZnVydWthd2EubWl5YWdpLmpwXCI6dHJ1ZSxcImhpZ2FzaGltYXRzdXNoaW1hLm1peWFnaS5qcFwiOnRydWUsXCJpc2hpbm9tYWtpLm1peWFnaS5qcFwiOnRydWUsXCJpd2FudW1hLm1peWFnaS5qcFwiOnRydWUsXCJrYWt1ZGEubWl5YWdpLmpwXCI6dHJ1ZSxcImthbWkubWl5YWdpLmpwXCI6dHJ1ZSxcImthd2FzYWtpLm1peWFnaS5qcFwiOnRydWUsXCJrZXNlbm51bWEubWl5YWdpLmpwXCI6dHJ1ZSxcIm1hcnVtb3JpLm1peWFnaS5qcFwiOnRydWUsXCJtYXRzdXNoaW1hLm1peWFnaS5qcFwiOnRydWUsXCJtaW5hbWlzYW5yaWt1Lm1peWFnaS5qcFwiOnRydWUsXCJtaXNhdG8ubWl5YWdpLmpwXCI6dHJ1ZSxcIm11cmF0YS5taXlhZ2kuanBcIjp0cnVlLFwibmF0b3JpLm1peWFnaS5qcFwiOnRydWUsXCJvZ2F3YXJhLm1peWFnaS5qcFwiOnRydWUsXCJvaGlyYS5taXlhZ2kuanBcIjp0cnVlLFwib25hZ2F3YS5taXlhZ2kuanBcIjp0cnVlLFwib3Nha2kubWl5YWdpLmpwXCI6dHJ1ZSxcInJpZnUubWl5YWdpLmpwXCI6dHJ1ZSxcInNlbWluZS5taXlhZ2kuanBcIjp0cnVlLFwic2hpYmF0YS5taXlhZ2kuanBcIjp0cnVlLFwic2hpY2hpa2FzaHVrdS5taXlhZ2kuanBcIjp0cnVlLFwic2hpa2FtYS5taXlhZ2kuanBcIjp0cnVlLFwic2hpb2dhbWEubWl5YWdpLmpwXCI6dHJ1ZSxcInNoaXJvaXNoaS5taXlhZ2kuanBcIjp0cnVlLFwidGFnYWpvLm1peWFnaS5qcFwiOnRydWUsXCJ0YWl3YS5taXlhZ2kuanBcIjp0cnVlLFwidG9tZS5taXlhZ2kuanBcIjp0cnVlLFwidG9taXlhLm1peWFnaS5qcFwiOnRydWUsXCJ3YWt1eWEubWl5YWdpLmpwXCI6dHJ1ZSxcIndhdGFyaS5taXlhZ2kuanBcIjp0cnVlLFwieWFtYW1vdG8ubWl5YWdpLmpwXCI6dHJ1ZSxcInphby5taXlhZ2kuanBcIjp0cnVlLFwiYXlhLm1peWF6YWtpLmpwXCI6dHJ1ZSxcImViaW5vLm1peWF6YWtpLmpwXCI6dHJ1ZSxcImdva2FzZS5taXlhemFraS5qcFwiOnRydWUsXCJoeXVnYS5taXlhemFraS5qcFwiOnRydWUsXCJrYWRvZ2F3YS5taXlhemFraS5qcFwiOnRydWUsXCJrYXdhbWluYW1pLm1peWF6YWtpLmpwXCI6dHJ1ZSxcImtpam8ubWl5YXpha2kuanBcIjp0cnVlLFwia2l0YWdhd2EubWl5YXpha2kuanBcIjp0cnVlLFwia2l0YWthdGEubWl5YXpha2kuanBcIjp0cnVlLFwia2l0YXVyYS5taXlhemFraS5qcFwiOnRydWUsXCJrb2JheWFzaGkubWl5YXpha2kuanBcIjp0cnVlLFwia3VuaXRvbWkubWl5YXpha2kuanBcIjp0cnVlLFwia3VzaGltYS5taXlhemFraS5qcFwiOnRydWUsXCJtaW1hdGEubWl5YXpha2kuanBcIjp0cnVlLFwibWl5YWtvbm9qby5taXlhemFraS5qcFwiOnRydWUsXCJtaXlhemFraS5taXlhemFraS5qcFwiOnRydWUsXCJtb3JvdHN1a2EubWl5YXpha2kuanBcIjp0cnVlLFwibmljaGluYW4ubWl5YXpha2kuanBcIjp0cnVlLFwibmlzaGltZXJhLm1peWF6YWtpLmpwXCI6dHJ1ZSxcIm5vYmVva2EubWl5YXpha2kuanBcIjp0cnVlLFwic2FpdG8ubWl5YXpha2kuanBcIjp0cnVlLFwic2hpaWJhLm1peWF6YWtpLmpwXCI6dHJ1ZSxcInNoaW50b21pLm1peWF6YWtpLmpwXCI6dHJ1ZSxcInRha2FoYXJ1Lm1peWF6YWtpLmpwXCI6dHJ1ZSxcInRha2FuYWJlLm1peWF6YWtpLmpwXCI6dHJ1ZSxcInRha2F6YWtpLm1peWF6YWtpLmpwXCI6dHJ1ZSxcInRzdW5vLm1peWF6YWtpLmpwXCI6dHJ1ZSxcImFjaGkubmFnYW5vLmpwXCI6dHJ1ZSxcImFnZW1hdHN1Lm5hZ2Fuby5qcFwiOnRydWUsXCJhbmFuLm5hZ2Fuby5qcFwiOnRydWUsXCJhb2tpLm5hZ2Fuby5qcFwiOnRydWUsXCJhc2FoaS5uYWdhbm8uanBcIjp0cnVlLFwiYXp1bWluby5uYWdhbm8uanBcIjp0cnVlLFwiY2hpa3Vob2t1Lm5hZ2Fuby5qcFwiOnRydWUsXCJjaGlrdW1hLm5hZ2Fuby5qcFwiOnRydWUsXCJjaGluby5uYWdhbm8uanBcIjp0cnVlLFwiZnVqaW1pLm5hZ2Fuby5qcFwiOnRydWUsXCJoYWt1YmEubmFnYW5vLmpwXCI6dHJ1ZSxcImhhcmEubmFnYW5vLmpwXCI6dHJ1ZSxcImhpcmF5YS5uYWdhbm8uanBcIjp0cnVlLFwiaWlkYS5uYWdhbm8uanBcIjp0cnVlLFwiaWlqaW1hLm5hZ2Fuby5qcFwiOnRydWUsXCJpaXlhbWEubmFnYW5vLmpwXCI6dHJ1ZSxcImlpenVuYS5uYWdhbm8uanBcIjp0cnVlLFwiaWtlZGEubmFnYW5vLmpwXCI6dHJ1ZSxcImlrdXNha2EubmFnYW5vLmpwXCI6dHJ1ZSxcImluYS5uYWdhbm8uanBcIjp0cnVlLFwia2FydWl6YXdhLm5hZ2Fuby5qcFwiOnRydWUsXCJrYXdha2FtaS5uYWdhbm8uanBcIjp0cnVlLFwia2lzby5uYWdhbm8uanBcIjp0cnVlLFwia2lzb2Z1a3VzaGltYS5uYWdhbm8uanBcIjp0cnVlLFwia2l0YWFpa2kubmFnYW5vLmpwXCI6dHJ1ZSxcImtvbWFnYW5lLm5hZ2Fuby5qcFwiOnRydWUsXCJrb21vcm8ubmFnYW5vLmpwXCI6dHJ1ZSxcIm1hdHN1a2F3YS5uYWdhbm8uanBcIjp0cnVlLFwibWF0c3Vtb3RvLm5hZ2Fuby5qcFwiOnRydWUsXCJtaWFzYS5uYWdhbm8uanBcIjp0cnVlLFwibWluYW1pYWlraS5uYWdhbm8uanBcIjp0cnVlLFwibWluYW1pbWFraS5uYWdhbm8uanBcIjp0cnVlLFwibWluYW1pbWlub3dhLm5hZ2Fuby5qcFwiOnRydWUsXCJtaW5vd2EubmFnYW5vLmpwXCI6dHJ1ZSxcIm1peWFkYS5uYWdhbm8uanBcIjp0cnVlLFwibWl5b3RhLm5hZ2Fuby5qcFwiOnRydWUsXCJtb2NoaXp1a2kubmFnYW5vLmpwXCI6dHJ1ZSxcIm5hZ2Fuby5uYWdhbm8uanBcIjp0cnVlLFwibmFnYXdhLm5hZ2Fuby5qcFwiOnRydWUsXCJuYWdpc28ubmFnYW5vLmpwXCI6dHJ1ZSxcIm5ha2FnYXdhLm5hZ2Fuby5qcFwiOnRydWUsXCJuYWthbm8ubmFnYW5vLmpwXCI6dHJ1ZSxcIm5vemF3YW9uc2VuLm5hZ2Fuby5qcFwiOnRydWUsXCJvYnVzZS5uYWdhbm8uanBcIjp0cnVlLFwib2dhd2EubmFnYW5vLmpwXCI6dHJ1ZSxcIm9rYXlhLm5hZ2Fuby5qcFwiOnRydWUsXCJvbWFjaGkubmFnYW5vLmpwXCI6dHJ1ZSxcIm9taS5uYWdhbm8uanBcIjp0cnVlLFwib29rdXdhLm5hZ2Fuby5qcFwiOnRydWUsXCJvb3NoaWthLm5hZ2Fuby5qcFwiOnRydWUsXCJvdGFraS5uYWdhbm8uanBcIjp0cnVlLFwib3RhcmkubmFnYW5vLmpwXCI6dHJ1ZSxcInNha2FlLm5hZ2Fuby5qcFwiOnRydWUsXCJzYWtha2kubmFnYW5vLmpwXCI6dHJ1ZSxcInNha3UubmFnYW5vLmpwXCI6dHJ1ZSxcInNha3Voby5uYWdhbm8uanBcIjp0cnVlLFwic2hpbW9zdXdhLm5hZ2Fuby5qcFwiOnRydWUsXCJzaGluYW5vbWFjaGkubmFnYW5vLmpwXCI6dHJ1ZSxcInNoaW9qaXJpLm5hZ2Fuby5qcFwiOnRydWUsXCJzdXdhLm5hZ2Fuby5qcFwiOnRydWUsXCJzdXpha2EubmFnYW5vLmpwXCI6dHJ1ZSxcInRha2FnaS5uYWdhbm8uanBcIjp0cnVlLFwidGFrYW1vcmkubmFnYW5vLmpwXCI6dHJ1ZSxcInRha2F5YW1hLm5hZ2Fuby5qcFwiOnRydWUsXCJ0YXRlc2hpbmEubmFnYW5vLmpwXCI6dHJ1ZSxcInRhdHN1bm8ubmFnYW5vLmpwXCI6dHJ1ZSxcInRvZ2FrdXNoaS5uYWdhbm8uanBcIjp0cnVlLFwidG9ndXJhLm5hZ2Fuby5qcFwiOnRydWUsXCJ0b21pLm5hZ2Fuby5qcFwiOnRydWUsXCJ1ZWRhLm5hZ2Fuby5qcFwiOnRydWUsXCJ3YWRhLm5hZ2Fuby5qcFwiOnRydWUsXCJ5YW1hZ2F0YS5uYWdhbm8uanBcIjp0cnVlLFwieWFtYW5vdWNoaS5uYWdhbm8uanBcIjp0cnVlLFwieWFzYWthLm5hZ2Fuby5qcFwiOnRydWUsXCJ5YXN1b2thLm5hZ2Fuby5qcFwiOnRydWUsXCJjaGlqaXdhLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcImZ1dHN1Lm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcImdvdG8ubmFnYXNha2kuanBcIjp0cnVlLFwiaGFzYW1pLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcImhpcmFkby5uYWdhc2FraS5qcFwiOnRydWUsXCJpa2kubmFnYXNha2kuanBcIjp0cnVlLFwiaXNhaGF5YS5uYWdhc2FraS5qcFwiOnRydWUsXCJrYXdhdGFuYS5uYWdhc2FraS5qcFwiOnRydWUsXCJrdWNoaW5vdHN1Lm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcIm1hdHN1dXJhLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcIm5hZ2FzYWtpLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcIm9iYW1hLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcIm9tdXJhLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcIm9zZXRvLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcInNhaWthaS5uYWdhc2FraS5qcFwiOnRydWUsXCJzYXNlYm8ubmFnYXNha2kuanBcIjp0cnVlLFwic2VpaGkubmFnYXNha2kuanBcIjp0cnVlLFwic2hpbWFiYXJhLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcInNoaW5rYW1pZ290by5uYWdhc2FraS5qcFwiOnRydWUsXCJ0b2dpdHN1Lm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcInRzdXNoaW1hLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcInVuemVuLm5hZ2FzYWtpLmpwXCI6dHJ1ZSxcImFuZG8ubmFyYS5qcFwiOnRydWUsXCJnb3NlLm5hcmEuanBcIjp0cnVlLFwiaGVndXJpLm5hcmEuanBcIjp0cnVlLFwiaGlnYXNoaXlvc2hpbm8ubmFyYS5qcFwiOnRydWUsXCJpa2FydWdhLm5hcmEuanBcIjp0cnVlLFwiaWtvbWEubmFyYS5qcFwiOnRydWUsXCJrYW1pa2l0YXlhbWEubmFyYS5qcFwiOnRydWUsXCJrYW5tYWtpLm5hcmEuanBcIjp0cnVlLFwia2FzaGliYS5uYXJhLmpwXCI6dHJ1ZSxcImthc2hpaGFyYS5uYXJhLmpwXCI6dHJ1ZSxcImthdHN1cmFnaS5uYXJhLmpwXCI6dHJ1ZSxcImthd2FpLm5hcmEuanBcIjp0cnVlLFwia2F3YWthbWkubmFyYS5qcFwiOnRydWUsXCJrYXdhbmlzaGkubmFyYS5qcFwiOnRydWUsXCJrb3J5by5uYXJhLmpwXCI6dHJ1ZSxcImt1cm90YWtpLm5hcmEuanBcIjp0cnVlLFwibWl0c3VlLm5hcmEuanBcIjp0cnVlLFwibWl5YWtlLm5hcmEuanBcIjp0cnVlLFwibmFyYS5uYXJhLmpwXCI6dHJ1ZSxcIm5vc2VnYXdhLm5hcmEuanBcIjp0cnVlLFwib2ppLm5hcmEuanBcIjp0cnVlLFwib3VkYS5uYXJhLmpwXCI6dHJ1ZSxcIm95b2RvLm5hcmEuanBcIjp0cnVlLFwic2FrdXJhaS5uYXJhLmpwXCI6dHJ1ZSxcInNhbmdvLm5hcmEuanBcIjp0cnVlLFwic2hpbW9pY2hpLm5hcmEuanBcIjp0cnVlLFwic2hpbW9raXRheWFtYS5uYXJhLmpwXCI6dHJ1ZSxcInNoaW5qby5uYXJhLmpwXCI6dHJ1ZSxcInNvbmkubmFyYS5qcFwiOnRydWUsXCJ0YWthdG9yaS5uYXJhLmpwXCI6dHJ1ZSxcInRhd2FyYW1vdG8ubmFyYS5qcFwiOnRydWUsXCJ0ZW5rYXdhLm5hcmEuanBcIjp0cnVlLFwidGVucmkubmFyYS5qcFwiOnRydWUsXCJ1ZGEubmFyYS5qcFwiOnRydWUsXCJ5YW1hdG9rb3JpeWFtYS5uYXJhLmpwXCI6dHJ1ZSxcInlhbWF0b3Rha2FkYS5uYXJhLmpwXCI6dHJ1ZSxcInlhbWF6b2UubmFyYS5qcFwiOnRydWUsXCJ5b3NoaW5vLm5hcmEuanBcIjp0cnVlLFwiYWdhLm5paWdhdGEuanBcIjp0cnVlLFwiYWdhbm8ubmlpZ2F0YS5qcFwiOnRydWUsXCJnb3Nlbi5uaWlnYXRhLmpwXCI6dHJ1ZSxcIml0b2lnYXdhLm5paWdhdGEuanBcIjp0cnVlLFwiaXp1bW96YWtpLm5paWdhdGEuanBcIjp0cnVlLFwiam9ldHN1Lm5paWdhdGEuanBcIjp0cnVlLFwia2Ftby5uaWlnYXRhLmpwXCI6dHJ1ZSxcImthcml3YS5uaWlnYXRhLmpwXCI6dHJ1ZSxcImthc2hpd2F6YWtpLm5paWdhdGEuanBcIjp0cnVlLFwibWluYW1pdW9udW1hLm5paWdhdGEuanBcIjp0cnVlLFwibWl0c3VrZS5uaWlnYXRhLmpwXCI6dHJ1ZSxcIm11aWthLm5paWdhdGEuanBcIjp0cnVlLFwibXVyYWthbWkubmlpZ2F0YS5qcFwiOnRydWUsXCJteW9rby5uaWlnYXRhLmpwXCI6dHJ1ZSxcIm5hZ2Fva2EubmlpZ2F0YS5qcFwiOnRydWUsXCJuaWlnYXRhLm5paWdhdGEuanBcIjp0cnVlLFwib2ppeWEubmlpZ2F0YS5qcFwiOnRydWUsXCJvbWkubmlpZ2F0YS5qcFwiOnRydWUsXCJzYWRvLm5paWdhdGEuanBcIjp0cnVlLFwic2Fuam8ubmlpZ2F0YS5qcFwiOnRydWUsXCJzZWlyby5uaWlnYXRhLmpwXCI6dHJ1ZSxcInNlaXJvdS5uaWlnYXRhLmpwXCI6dHJ1ZSxcInNla2lrYXdhLm5paWdhdGEuanBcIjp0cnVlLFwic2hpYmF0YS5uaWlnYXRhLmpwXCI6dHJ1ZSxcInRhZ2FtaS5uaWlnYXRhLmpwXCI6dHJ1ZSxcInRhaW5haS5uaWlnYXRhLmpwXCI6dHJ1ZSxcInRvY2hpby5uaWlnYXRhLmpwXCI6dHJ1ZSxcInRva2FtYWNoaS5uaWlnYXRhLmpwXCI6dHJ1ZSxcInRzdWJhbWUubmlpZ2F0YS5qcFwiOnRydWUsXCJ0c3VuYW4ubmlpZ2F0YS5qcFwiOnRydWUsXCJ1b251bWEubmlpZ2F0YS5qcFwiOnRydWUsXCJ5YWhpa28ubmlpZ2F0YS5qcFwiOnRydWUsXCJ5b2l0YS5uaWlnYXRhLmpwXCI6dHJ1ZSxcInl1emF3YS5uaWlnYXRhLmpwXCI6dHJ1ZSxcImJlcHB1Lm9pdGEuanBcIjp0cnVlLFwiYnVuZ29vbm8ub2l0YS5qcFwiOnRydWUsXCJidW5nb3Rha2FkYS5vaXRhLmpwXCI6dHJ1ZSxcImhhc2FtYS5vaXRhLmpwXCI6dHJ1ZSxcImhpamkub2l0YS5qcFwiOnRydWUsXCJoaW1lc2hpbWEub2l0YS5qcFwiOnRydWUsXCJoaXRhLm9pdGEuanBcIjp0cnVlLFwia2FtaXRzdWUub2l0YS5qcFwiOnRydWUsXCJrb2tvbm9lLm9pdGEuanBcIjp0cnVlLFwia3VqdS5vaXRhLmpwXCI6dHJ1ZSxcImt1bmlzYWtpLm9pdGEuanBcIjp0cnVlLFwia3VzdS5vaXRhLmpwXCI6dHJ1ZSxcIm9pdGEub2l0YS5qcFwiOnRydWUsXCJzYWlraS5vaXRhLmpwXCI6dHJ1ZSxcInRha2V0YS5vaXRhLmpwXCI6dHJ1ZSxcInRzdWt1bWkub2l0YS5qcFwiOnRydWUsXCJ1c2Eub2l0YS5qcFwiOnRydWUsXCJ1c3VraS5vaXRhLmpwXCI6dHJ1ZSxcInl1ZnUub2l0YS5qcFwiOnRydWUsXCJha2Fpd2Eub2theWFtYS5qcFwiOnRydWUsXCJhc2FrdWNoaS5va2F5YW1hLmpwXCI6dHJ1ZSxcImJpemVuLm9rYXlhbWEuanBcIjp0cnVlLFwiaGF5YXNoaW1hLm9rYXlhbWEuanBcIjp0cnVlLFwiaWJhcmEub2theWFtYS5qcFwiOnRydWUsXCJrYWdhbWluby5va2F5YW1hLmpwXCI6dHJ1ZSxcImthc2Fva2Eub2theWFtYS5qcFwiOnRydWUsXCJraWJpY2h1by5va2F5YW1hLmpwXCI6dHJ1ZSxcImt1bWVuYW4ub2theWFtYS5qcFwiOnRydWUsXCJrdXJhc2hpa2kub2theWFtYS5qcFwiOnRydWUsXCJtYW5pd2Eub2theWFtYS5qcFwiOnRydWUsXCJtaXNha2kub2theWFtYS5qcFwiOnRydWUsXCJuYWdpLm9rYXlhbWEuanBcIjp0cnVlLFwibmlpbWkub2theWFtYS5qcFwiOnRydWUsXCJuaXNoaWF3YWt1cmEub2theWFtYS5qcFwiOnRydWUsXCJva2F5YW1hLm9rYXlhbWEuanBcIjp0cnVlLFwic2F0b3Noby5va2F5YW1hLmpwXCI6dHJ1ZSxcInNldG91Y2hpLm9rYXlhbWEuanBcIjp0cnVlLFwic2hpbmpvLm9rYXlhbWEuanBcIjp0cnVlLFwic2hvby5va2F5YW1hLmpwXCI6dHJ1ZSxcInNvamEub2theWFtYS5qcFwiOnRydWUsXCJ0YWthaGFzaGkub2theWFtYS5qcFwiOnRydWUsXCJ0YW1hbm8ub2theWFtYS5qcFwiOnRydWUsXCJ0c3V5YW1hLm9rYXlhbWEuanBcIjp0cnVlLFwid2FrZS5va2F5YW1hLmpwXCI6dHJ1ZSxcInlha2FnZS5va2F5YW1hLmpwXCI6dHJ1ZSxcImFndW5pLm9raW5hd2EuanBcIjp0cnVlLFwiZ2lub3dhbi5va2luYXdhLmpwXCI6dHJ1ZSxcImdpbm96YS5va2luYXdhLmpwXCI6dHJ1ZSxcImd1c2hpa2FtaS5va2luYXdhLmpwXCI6dHJ1ZSxcImhhZWJhcnUub2tpbmF3YS5qcFwiOnRydWUsXCJoaWdhc2hpLm9raW5hd2EuanBcIjp0cnVlLFwiaGlyYXJhLm9raW5hd2EuanBcIjp0cnVlLFwiaWhleWEub2tpbmF3YS5qcFwiOnRydWUsXCJpc2hpZ2FraS5va2luYXdhLmpwXCI6dHJ1ZSxcImlzaGlrYXdhLm9raW5hd2EuanBcIjp0cnVlLFwiaXRvbWFuLm9raW5hd2EuanBcIjp0cnVlLFwiaXplbmEub2tpbmF3YS5qcFwiOnRydWUsXCJrYWRlbmEub2tpbmF3YS5qcFwiOnRydWUsXCJraW4ub2tpbmF3YS5qcFwiOnRydWUsXCJraXRhZGFpdG8ub2tpbmF3YS5qcFwiOnRydWUsXCJraXRhbmFrYWd1c3VrdS5va2luYXdhLmpwXCI6dHJ1ZSxcImt1bWVqaW1hLm9raW5hd2EuanBcIjp0cnVlLFwia3VuaWdhbWkub2tpbmF3YS5qcFwiOnRydWUsXCJtaW5hbWlkYWl0by5va2luYXdhLmpwXCI6dHJ1ZSxcIm1vdG9idS5va2luYXdhLmpwXCI6dHJ1ZSxcIm5hZ28ub2tpbmF3YS5qcFwiOnRydWUsXCJuYWhhLm9raW5hd2EuanBcIjp0cnVlLFwibmFrYWd1c3VrdS5va2luYXdhLmpwXCI6dHJ1ZSxcIm5ha2lqaW4ub2tpbmF3YS5qcFwiOnRydWUsXCJuYW5qby5va2luYXdhLmpwXCI6dHJ1ZSxcIm5pc2hpaGFyYS5va2luYXdhLmpwXCI6dHJ1ZSxcIm9naW1pLm9raW5hd2EuanBcIjp0cnVlLFwib2tpbmF3YS5va2luYXdhLmpwXCI6dHJ1ZSxcIm9ubmEub2tpbmF3YS5qcFwiOnRydWUsXCJzaGltb2ppLm9raW5hd2EuanBcIjp0cnVlLFwidGFrZXRvbWkub2tpbmF3YS5qcFwiOnRydWUsXCJ0YXJhbWEub2tpbmF3YS5qcFwiOnRydWUsXCJ0b2thc2hpa2kub2tpbmF3YS5qcFwiOnRydWUsXCJ0b21pZ3VzdWt1Lm9raW5hd2EuanBcIjp0cnVlLFwidG9uYWtpLm9raW5hd2EuanBcIjp0cnVlLFwidXJhc29lLm9raW5hd2EuanBcIjp0cnVlLFwidXJ1bWEub2tpbmF3YS5qcFwiOnRydWUsXCJ5YWVzZS5va2luYXdhLmpwXCI6dHJ1ZSxcInlvbWl0YW4ub2tpbmF3YS5qcFwiOnRydWUsXCJ5b25hYmFydS5va2luYXdhLmpwXCI6dHJ1ZSxcInlvbmFndW5pLm9raW5hd2EuanBcIjp0cnVlLFwiemFtYW1pLm9raW5hd2EuanBcIjp0cnVlLFwiYWJlbm8ub3Nha2EuanBcIjp0cnVlLFwiY2hpaGF5YWFrYXNha2Eub3Nha2EuanBcIjp0cnVlLFwiY2h1by5vc2FrYS5qcFwiOnRydWUsXCJkYWl0by5vc2FrYS5qcFwiOnRydWUsXCJmdWppaWRlcmEub3Nha2EuanBcIjp0cnVlLFwiaGFiaWtpbm8ub3Nha2EuanBcIjp0cnVlLFwiaGFubmFuLm9zYWthLmpwXCI6dHJ1ZSxcImhpZ2FzaGlvc2FrYS5vc2FrYS5qcFwiOnRydWUsXCJoaWdhc2hpc3VtaXlvc2hpLm9zYWthLmpwXCI6dHJ1ZSxcImhpZ2FzaGl5b2RvZ2F3YS5vc2FrYS5qcFwiOnRydWUsXCJoaXJha2F0YS5vc2FrYS5qcFwiOnRydWUsXCJpYmFyYWtpLm9zYWthLmpwXCI6dHJ1ZSxcImlrZWRhLm9zYWthLmpwXCI6dHJ1ZSxcIml6dW1pLm9zYWthLmpwXCI6dHJ1ZSxcIml6dW1pb3RzdS5vc2FrYS5qcFwiOnRydWUsXCJpenVtaXNhbm8ub3Nha2EuanBcIjp0cnVlLFwia2Fkb21hLm9zYWthLmpwXCI6dHJ1ZSxcImthaXp1a2Eub3Nha2EuanBcIjp0cnVlLFwia2FuYW4ub3Nha2EuanBcIjp0cnVlLFwia2FzaGl3YXJhLm9zYWthLmpwXCI6dHJ1ZSxcImthdGFuby5vc2FrYS5qcFwiOnRydWUsXCJrYXdhY2hpbmFnYW5vLm9zYWthLmpwXCI6dHJ1ZSxcImtpc2hpd2FkYS5vc2FrYS5qcFwiOnRydWUsXCJraXRhLm9zYWthLmpwXCI6dHJ1ZSxcImt1bWF0b3JpLm9zYWthLmpwXCI6dHJ1ZSxcIm1hdHN1YmFyYS5vc2FrYS5qcFwiOnRydWUsXCJtaW5hdG8ub3Nha2EuanBcIjp0cnVlLFwibWlub2gub3Nha2EuanBcIjp0cnVlLFwibWlzYWtpLm9zYWthLmpwXCI6dHJ1ZSxcIm1vcmlndWNoaS5vc2FrYS5qcFwiOnRydWUsXCJuZXlhZ2F3YS5vc2FrYS5qcFwiOnRydWUsXCJuaXNoaS5vc2FrYS5qcFwiOnRydWUsXCJub3NlLm9zYWthLmpwXCI6dHJ1ZSxcIm9zYWthc2F5YW1hLm9zYWthLmpwXCI6dHJ1ZSxcInNha2FpLm9zYWthLmpwXCI6dHJ1ZSxcInNheWFtYS5vc2FrYS5qcFwiOnRydWUsXCJzZW5uYW4ub3Nha2EuanBcIjp0cnVlLFwic2V0dHN1Lm9zYWthLmpwXCI6dHJ1ZSxcInNoaWpvbmF3YXRlLm9zYWthLmpwXCI6dHJ1ZSxcInNoaW1hbW90by5vc2FrYS5qcFwiOnRydWUsXCJzdWl0YS5vc2FrYS5qcFwiOnRydWUsXCJ0YWRhb2thLm9zYWthLmpwXCI6dHJ1ZSxcInRhaXNoaS5vc2FrYS5qcFwiOnRydWUsXCJ0YWppcmkub3Nha2EuanBcIjp0cnVlLFwidGFrYWlzaGkub3Nha2EuanBcIjp0cnVlLFwidGFrYXRzdWtpLm9zYWthLmpwXCI6dHJ1ZSxcInRvbmRhYmF5YXNoaS5vc2FrYS5qcFwiOnRydWUsXCJ0b3lvbmFrYS5vc2FrYS5qcFwiOnRydWUsXCJ0b3lvbm8ub3Nha2EuanBcIjp0cnVlLFwieWFvLm9zYWthLmpwXCI6dHJ1ZSxcImFyaWFrZS5zYWdhLmpwXCI6dHJ1ZSxcImFyaXRhLnNhZ2EuanBcIjp0cnVlLFwiZnVrdWRvbWkuc2FnYS5qcFwiOnRydWUsXCJnZW5rYWkuc2FnYS5qcFwiOnRydWUsXCJoYW1hdGFtYS5zYWdhLmpwXCI6dHJ1ZSxcImhpemVuLnNhZ2EuanBcIjp0cnVlLFwiaW1hcmkuc2FnYS5qcFwiOnRydWUsXCJrYW1pbWluZS5zYWdhLmpwXCI6dHJ1ZSxcImthbnpha2kuc2FnYS5qcFwiOnRydWUsXCJrYXJhdHN1LnNhZ2EuanBcIjp0cnVlLFwia2FzaGltYS5zYWdhLmpwXCI6dHJ1ZSxcImtpdGFnYXRhLnNhZ2EuanBcIjp0cnVlLFwia2l0YWhhdGEuc2FnYS5qcFwiOnRydWUsXCJraXlhbWEuc2FnYS5qcFwiOnRydWUsXCJrb3Vob2t1LnNhZ2EuanBcIjp0cnVlLFwia3l1cmFnaS5zYWdhLmpwXCI6dHJ1ZSxcIm5pc2hpYXJpdGEuc2FnYS5qcFwiOnRydWUsXCJvZ2kuc2FnYS5qcFwiOnRydWUsXCJvbWFjaGkuc2FnYS5qcFwiOnRydWUsXCJvdWNoaS5zYWdhLmpwXCI6dHJ1ZSxcInNhZ2Euc2FnYS5qcFwiOnRydWUsXCJzaGlyb2lzaGkuc2FnYS5qcFwiOnRydWUsXCJ0YWt1LnNhZ2EuanBcIjp0cnVlLFwidGFyYS5zYWdhLmpwXCI6dHJ1ZSxcInRvc3Uuc2FnYS5qcFwiOnRydWUsXCJ5b3NoaW5vZ2FyaS5zYWdhLmpwXCI6dHJ1ZSxcImFyYWthd2Euc2FpdGFtYS5qcFwiOnRydWUsXCJhc2FrYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImNoaWNoaWJ1LnNhaXRhbWEuanBcIjp0cnVlLFwiZnVqaW1pLnNhaXRhbWEuanBcIjp0cnVlLFwiZnVqaW1pbm8uc2FpdGFtYS5qcFwiOnRydWUsXCJmdWtheWEuc2FpdGFtYS5qcFwiOnRydWUsXCJoYW5uby5zYWl0YW1hLmpwXCI6dHJ1ZSxcImhhbnl1LnNhaXRhbWEuanBcIjp0cnVlLFwiaGFzdWRhLnNhaXRhbWEuanBcIjp0cnVlLFwiaGF0b2dheWEuc2FpdGFtYS5qcFwiOnRydWUsXCJoYXRveWFtYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImhpZGFrYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImhpZ2FzaGljaGljaGlidS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImhpZ2FzaGltYXRzdXlhbWEuc2FpdGFtYS5qcFwiOnRydWUsXCJob25qby5zYWl0YW1hLmpwXCI6dHJ1ZSxcImluYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImlydW1hLnNhaXRhbWEuanBcIjp0cnVlLFwiaXdhdHN1a2kuc2FpdGFtYS5qcFwiOnRydWUsXCJrYW1paXp1bWkuc2FpdGFtYS5qcFwiOnRydWUsXCJrYW1pa2F3YS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImthbWlzYXRvLnNhaXRhbWEuanBcIjp0cnVlLFwia2FzdWthYmUuc2FpdGFtYS5qcFwiOnRydWUsXCJrYXdhZ29lLnNhaXRhbWEuanBcIjp0cnVlLFwia2F3YWd1Y2hpLnNhaXRhbWEuanBcIjp0cnVlLFwia2F3YWppbWEuc2FpdGFtYS5qcFwiOnRydWUsXCJrYXpvLnNhaXRhbWEuanBcIjp0cnVlLFwia2l0YW1vdG8uc2FpdGFtYS5qcFwiOnRydWUsXCJrb3NoaWdheWEuc2FpdGFtYS5qcFwiOnRydWUsXCJrb3Vub3N1LnNhaXRhbWEuanBcIjp0cnVlLFwia3VraS5zYWl0YW1hLmpwXCI6dHJ1ZSxcImt1bWFnYXlhLnNhaXRhbWEuanBcIjp0cnVlLFwibWF0c3VidXNoaS5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm1pbmFuby5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm1pc2F0by5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm1peWFzaGlyby5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm1peW9zaGkuc2FpdGFtYS5qcFwiOnRydWUsXCJtb3JveWFtYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm5hZ2F0b3JvLnNhaXRhbWEuanBcIjp0cnVlLFwibmFtZWdhd2Euc2FpdGFtYS5qcFwiOnRydWUsXCJuaWl6YS5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm9nYW5vLnNhaXRhbWEuanBcIjp0cnVlLFwib2dhd2Euc2FpdGFtYS5qcFwiOnRydWUsXCJvZ29zZS5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm9rZWdhd2Euc2FpdGFtYS5qcFwiOnRydWUsXCJvbWl5YS5zYWl0YW1hLmpwXCI6dHJ1ZSxcIm90YWtpLnNhaXRhbWEuanBcIjp0cnVlLFwicmFuemFuLnNhaXRhbWEuanBcIjp0cnVlLFwicnlva2FtaS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInNhaXRhbWEuc2FpdGFtYS5qcFwiOnRydWUsXCJzYWthZG8uc2FpdGFtYS5qcFwiOnRydWUsXCJzYXR0ZS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInNheWFtYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInNoaWtpLnNhaXRhbWEuanBcIjp0cnVlLFwic2hpcmFva2Euc2FpdGFtYS5qcFwiOnRydWUsXCJzb2thLnNhaXRhbWEuanBcIjp0cnVlLFwic3VnaXRvLnNhaXRhbWEuanBcIjp0cnVlLFwidG9kYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInRva2lnYXdhLnNhaXRhbWEuanBcIjp0cnVlLFwidG9rb3JvemF3YS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInRzdXJ1Z2FzaGltYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInVyYXdhLnNhaXRhbWEuanBcIjp0cnVlLFwid2FyYWJpLnNhaXRhbWEuanBcIjp0cnVlLFwieWFzaGlvLnNhaXRhbWEuanBcIjp0cnVlLFwieW9rb3plLnNhaXRhbWEuanBcIjp0cnVlLFwieW9uby5zYWl0YW1hLmpwXCI6dHJ1ZSxcInlvcmlpLnNhaXRhbWEuanBcIjp0cnVlLFwieW9zaGlkYS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInlvc2hpa2F3YS5zYWl0YW1hLmpwXCI6dHJ1ZSxcInlvc2hpbWkuc2FpdGFtYS5qcFwiOnRydWUsXCJhaXNoby5zaGlnYS5qcFwiOnRydWUsXCJnYW1vLnNoaWdhLmpwXCI6dHJ1ZSxcImhpZ2FzaGlvbWkuc2hpZ2EuanBcIjp0cnVlLFwiaGlrb25lLnNoaWdhLmpwXCI6dHJ1ZSxcImtva2Euc2hpZ2EuanBcIjp0cnVlLFwia29uYW4uc2hpZ2EuanBcIjp0cnVlLFwia29zZWkuc2hpZ2EuanBcIjp0cnVlLFwia290by5zaGlnYS5qcFwiOnRydWUsXCJrdXNhdHN1LnNoaWdhLmpwXCI6dHJ1ZSxcIm1haWJhcmEuc2hpZ2EuanBcIjp0cnVlLFwibW9yaXlhbWEuc2hpZ2EuanBcIjp0cnVlLFwibmFnYWhhbWEuc2hpZ2EuanBcIjp0cnVlLFwibmlzaGlhemFpLnNoaWdhLmpwXCI6dHJ1ZSxcIm5vdG9nYXdhLnNoaWdhLmpwXCI6dHJ1ZSxcIm9taWhhY2hpbWFuLnNoaWdhLmpwXCI6dHJ1ZSxcIm90c3Uuc2hpZ2EuanBcIjp0cnVlLFwicml0dG8uc2hpZ2EuanBcIjp0cnVlLFwicnl1b2guc2hpZ2EuanBcIjp0cnVlLFwidGFrYXNoaW1hLnNoaWdhLmpwXCI6dHJ1ZSxcInRha2F0c3VraS5zaGlnYS5qcFwiOnRydWUsXCJ0b3JhaGltZS5zaGlnYS5qcFwiOnRydWUsXCJ0b3lvc2F0by5zaGlnYS5qcFwiOnRydWUsXCJ5YXN1LnNoaWdhLmpwXCI6dHJ1ZSxcImFrYWdpLnNoaW1hbmUuanBcIjp0cnVlLFwiYW1hLnNoaW1hbmUuanBcIjp0cnVlLFwiZ290c3Uuc2hpbWFuZS5qcFwiOnRydWUsXCJoYW1hZGEuc2hpbWFuZS5qcFwiOnRydWUsXCJoaWdhc2hpaXp1bW8uc2hpbWFuZS5qcFwiOnRydWUsXCJoaWthd2Euc2hpbWFuZS5qcFwiOnRydWUsXCJoaWtpbWkuc2hpbWFuZS5qcFwiOnRydWUsXCJpenVtby5zaGltYW5lLmpwXCI6dHJ1ZSxcImtha2lub2tpLnNoaW1hbmUuanBcIjp0cnVlLFwibWFzdWRhLnNoaW1hbmUuanBcIjp0cnVlLFwibWF0c3VlLnNoaW1hbmUuanBcIjp0cnVlLFwibWlzYXRvLnNoaW1hbmUuanBcIjp0cnVlLFwibmlzaGlub3NoaW1hLnNoaW1hbmUuanBcIjp0cnVlLFwib2hkYS5zaGltYW5lLmpwXCI6dHJ1ZSxcIm9raW5vc2hpbWEuc2hpbWFuZS5qcFwiOnRydWUsXCJva3VpenVtby5zaGltYW5lLmpwXCI6dHJ1ZSxcInNoaW1hbmUuc2hpbWFuZS5qcFwiOnRydWUsXCJ0YW1heXUuc2hpbWFuZS5qcFwiOnRydWUsXCJ0c3V3YW5vLnNoaW1hbmUuanBcIjp0cnVlLFwidW5uYW4uc2hpbWFuZS5qcFwiOnRydWUsXCJ5YWt1bW8uc2hpbWFuZS5qcFwiOnRydWUsXCJ5YXN1Z2kuc2hpbWFuZS5qcFwiOnRydWUsXCJ5YXRzdWthLnNoaW1hbmUuanBcIjp0cnVlLFwiYXJhaS5zaGl6dW9rYS5qcFwiOnRydWUsXCJhdGFtaS5zaGl6dW9rYS5qcFwiOnRydWUsXCJmdWppLnNoaXp1b2thLmpwXCI6dHJ1ZSxcImZ1amllZGEuc2hpenVva2EuanBcIjp0cnVlLFwiZnVqaWthd2Euc2hpenVva2EuanBcIjp0cnVlLFwiZnVqaW5vbWl5YS5zaGl6dW9rYS5qcFwiOnRydWUsXCJmdWt1cm9pLnNoaXp1b2thLmpwXCI6dHJ1ZSxcImdvdGVtYmEuc2hpenVva2EuanBcIjp0cnVlLFwiaGFpYmFyYS5zaGl6dW9rYS5qcFwiOnRydWUsXCJoYW1hbWF0c3Uuc2hpenVva2EuanBcIjp0cnVlLFwiaGlnYXNoaWl6dS5zaGl6dW9rYS5qcFwiOnRydWUsXCJpdG8uc2hpenVva2EuanBcIjp0cnVlLFwiaXdhdGEuc2hpenVva2EuanBcIjp0cnVlLFwiaXp1LnNoaXp1b2thLmpwXCI6dHJ1ZSxcIml6dW5va3VuaS5zaGl6dW9rYS5qcFwiOnRydWUsXCJrYWtlZ2F3YS5zaGl6dW9rYS5qcFwiOnRydWUsXCJrYW5uYW1pLnNoaXp1b2thLmpwXCI6dHJ1ZSxcImthd2FuZWhvbi5zaGl6dW9rYS5qcFwiOnRydWUsXCJrYXdhenUuc2hpenVva2EuanBcIjp0cnVlLFwia2lrdWdhd2Euc2hpenVva2EuanBcIjp0cnVlLFwia29zYWkuc2hpenVva2EuanBcIjp0cnVlLFwibWFraW5vaGFyYS5zaGl6dW9rYS5qcFwiOnRydWUsXCJtYXRzdXpha2kuc2hpenVva2EuanBcIjp0cnVlLFwibWluYW1paXp1LnNoaXp1b2thLmpwXCI6dHJ1ZSxcIm1pc2hpbWEuc2hpenVva2EuanBcIjp0cnVlLFwibW9yaW1hY2hpLnNoaXp1b2thLmpwXCI6dHJ1ZSxcIm5pc2hpaXp1LnNoaXp1b2thLmpwXCI6dHJ1ZSxcIm51bWF6dS5zaGl6dW9rYS5qcFwiOnRydWUsXCJvbWFlemFraS5zaGl6dW9rYS5qcFwiOnRydWUsXCJzaGltYWRhLnNoaXp1b2thLmpwXCI6dHJ1ZSxcInNoaW1penUuc2hpenVva2EuanBcIjp0cnVlLFwic2hpbW9kYS5zaGl6dW9rYS5qcFwiOnRydWUsXCJzaGl6dW9rYS5zaGl6dW9rYS5qcFwiOnRydWUsXCJzdXNvbm8uc2hpenVva2EuanBcIjp0cnVlLFwieWFpenUuc2hpenVva2EuanBcIjp0cnVlLFwieW9zaGlkYS5zaGl6dW9rYS5qcFwiOnRydWUsXCJhc2hpa2FnYS50b2NoaWdpLmpwXCI6dHJ1ZSxcImJhdG8udG9jaGlnaS5qcFwiOnRydWUsXCJoYWdhLnRvY2hpZ2kuanBcIjp0cnVlLFwiaWNoaWthaS50b2NoaWdpLmpwXCI6dHJ1ZSxcIml3YWZ1bmUudG9jaGlnaS5qcFwiOnRydWUsXCJrYW1pbm9rYXdhLnRvY2hpZ2kuanBcIjp0cnVlLFwia2FudW1hLnRvY2hpZ2kuanBcIjp0cnVlLFwia2FyYXN1eWFtYS50b2NoaWdpLmpwXCI6dHJ1ZSxcImt1cm9pc28udG9jaGlnaS5qcFwiOnRydWUsXCJtYXNoaWtvLnRvY2hpZ2kuanBcIjp0cnVlLFwibWlidS50b2NoaWdpLmpwXCI6dHJ1ZSxcIm1va2EudG9jaGlnaS5qcFwiOnRydWUsXCJtb3RlZ2kudG9jaGlnaS5qcFwiOnRydWUsXCJuYXN1LnRvY2hpZ2kuanBcIjp0cnVlLFwibmFzdXNoaW9iYXJhLnRvY2hpZ2kuanBcIjp0cnVlLFwibmlra28udG9jaGlnaS5qcFwiOnRydWUsXCJuaXNoaWthdGEudG9jaGlnaS5qcFwiOnRydWUsXCJub2dpLnRvY2hpZ2kuanBcIjp0cnVlLFwib2hpcmEudG9jaGlnaS5qcFwiOnRydWUsXCJvaHRhd2FyYS50b2NoaWdpLmpwXCI6dHJ1ZSxcIm95YW1hLnRvY2hpZ2kuanBcIjp0cnVlLFwic2FrdXJhLnRvY2hpZ2kuanBcIjp0cnVlLFwic2Fuby50b2NoaWdpLmpwXCI6dHJ1ZSxcInNoaW1vdHN1a2UudG9jaGlnaS5qcFwiOnRydWUsXCJzaGlveWEudG9jaGlnaS5qcFwiOnRydWUsXCJ0YWthbmV6YXdhLnRvY2hpZ2kuanBcIjp0cnVlLFwidG9jaGlnaS50b2NoaWdpLmpwXCI6dHJ1ZSxcInRzdWdhLnRvY2hpZ2kuanBcIjp0cnVlLFwidWppaWUudG9jaGlnaS5qcFwiOnRydWUsXCJ1dHN1bm9taXlhLnRvY2hpZ2kuanBcIjp0cnVlLFwieWFpdGEudG9jaGlnaS5qcFwiOnRydWUsXCJhaXp1bWkudG9rdXNoaW1hLmpwXCI6dHJ1ZSxcImFuYW4udG9rdXNoaW1hLmpwXCI6dHJ1ZSxcImljaGliYS50b2t1c2hpbWEuanBcIjp0cnVlLFwiaXRhbm8udG9rdXNoaW1hLmpwXCI6dHJ1ZSxcImthaW5hbi50b2t1c2hpbWEuanBcIjp0cnVlLFwia29tYXRzdXNoaW1hLnRva3VzaGltYS5qcFwiOnRydWUsXCJtYXRzdXNoaWdlLnRva3VzaGltYS5qcFwiOnRydWUsXCJtaW1hLnRva3VzaGltYS5qcFwiOnRydWUsXCJtaW5hbWkudG9rdXNoaW1hLmpwXCI6dHJ1ZSxcIm1peW9zaGkudG9rdXNoaW1hLmpwXCI6dHJ1ZSxcIm11Z2kudG9rdXNoaW1hLmpwXCI6dHJ1ZSxcIm5ha2FnYXdhLnRva3VzaGltYS5qcFwiOnRydWUsXCJuYXJ1dG8udG9rdXNoaW1hLmpwXCI6dHJ1ZSxcInNhbmFnb2NoaS50b2t1c2hpbWEuanBcIjp0cnVlLFwic2hpc2hpa3VpLnRva3VzaGltYS5qcFwiOnRydWUsXCJ0b2t1c2hpbWEudG9rdXNoaW1hLmpwXCI6dHJ1ZSxcIndhamlraS50b2t1c2hpbWEuanBcIjp0cnVlLFwiYWRhY2hpLnRva3lvLmpwXCI6dHJ1ZSxcImFraXJ1bm8udG9reW8uanBcIjp0cnVlLFwiYWtpc2hpbWEudG9reW8uanBcIjp0cnVlLFwiYW9nYXNoaW1hLnRva3lvLmpwXCI6dHJ1ZSxcImFyYWthd2EudG9reW8uanBcIjp0cnVlLFwiYnVua3lvLnRva3lvLmpwXCI6dHJ1ZSxcImNoaXlvZGEudG9reW8uanBcIjp0cnVlLFwiY2hvZnUudG9reW8uanBcIjp0cnVlLFwiY2h1by50b2t5by5qcFwiOnRydWUsXCJlZG9nYXdhLnRva3lvLmpwXCI6dHJ1ZSxcImZ1Y2h1LnRva3lvLmpwXCI6dHJ1ZSxcImZ1c3NhLnRva3lvLmpwXCI6dHJ1ZSxcImhhY2hpam8udG9reW8uanBcIjp0cnVlLFwiaGFjaGlvamkudG9reW8uanBcIjp0cnVlLFwiaGFtdXJhLnRva3lvLmpwXCI6dHJ1ZSxcImhpZ2FzaGlrdXJ1bWUudG9reW8uanBcIjp0cnVlLFwiaGlnYXNoaW11cmF5YW1hLnRva3lvLmpwXCI6dHJ1ZSxcImhpZ2FzaGl5YW1hdG8udG9reW8uanBcIjp0cnVlLFwiaGluby50b2t5by5qcFwiOnRydWUsXCJoaW5vZGUudG9reW8uanBcIjp0cnVlLFwiaGlub2hhcmEudG9reW8uanBcIjp0cnVlLFwiaW5hZ2kudG9reW8uanBcIjp0cnVlLFwiaXRhYmFzaGkudG9reW8uanBcIjp0cnVlLFwia2F0c3VzaGlrYS50b2t5by5qcFwiOnRydWUsXCJraXRhLnRva3lvLmpwXCI6dHJ1ZSxcImtpeW9zZS50b2t5by5qcFwiOnRydWUsXCJrb2RhaXJhLnRva3lvLmpwXCI6dHJ1ZSxcImtvZ2FuZWkudG9reW8uanBcIjp0cnVlLFwia29rdWJ1bmppLnRva3lvLmpwXCI6dHJ1ZSxcImtvbWFlLnRva3lvLmpwXCI6dHJ1ZSxcImtvdG8udG9reW8uanBcIjp0cnVlLFwia291enVzaGltYS50b2t5by5qcFwiOnRydWUsXCJrdW5pdGFjaGkudG9reW8uanBcIjp0cnVlLFwibWFjaGlkYS50b2t5by5qcFwiOnRydWUsXCJtZWd1cm8udG9reW8uanBcIjp0cnVlLFwibWluYXRvLnRva3lvLmpwXCI6dHJ1ZSxcIm1pdGFrYS50b2t5by5qcFwiOnRydWUsXCJtaXp1aG8udG9reW8uanBcIjp0cnVlLFwibXVzYXNoaW11cmF5YW1hLnRva3lvLmpwXCI6dHJ1ZSxcIm11c2FzaGluby50b2t5by5qcFwiOnRydWUsXCJuYWthbm8udG9reW8uanBcIjp0cnVlLFwibmVyaW1hLnRva3lvLmpwXCI6dHJ1ZSxcIm9nYXNhd2FyYS50b2t5by5qcFwiOnRydWUsXCJva3V0YW1hLnRva3lvLmpwXCI6dHJ1ZSxcIm9tZS50b2t5by5qcFwiOnRydWUsXCJvc2hpbWEudG9reW8uanBcIjp0cnVlLFwib3RhLnRva3lvLmpwXCI6dHJ1ZSxcInNldGFnYXlhLnRva3lvLmpwXCI6dHJ1ZSxcInNoaWJ1eWEudG9reW8uanBcIjp0cnVlLFwic2hpbmFnYXdhLnRva3lvLmpwXCI6dHJ1ZSxcInNoaW5qdWt1LnRva3lvLmpwXCI6dHJ1ZSxcInN1Z2luYW1pLnRva3lvLmpwXCI6dHJ1ZSxcInN1bWlkYS50b2t5by5qcFwiOnRydWUsXCJ0YWNoaWthd2EudG9reW8uanBcIjp0cnVlLFwidGFpdG8udG9reW8uanBcIjp0cnVlLFwidGFtYS50b2t5by5qcFwiOnRydWUsXCJ0b3NoaW1hLnRva3lvLmpwXCI6dHJ1ZSxcImNoaXp1LnRvdHRvcmkuanBcIjp0cnVlLFwiaGluby50b3R0b3JpLmpwXCI6dHJ1ZSxcImthd2FoYXJhLnRvdHRvcmkuanBcIjp0cnVlLFwia29nZS50b3R0b3JpLmpwXCI6dHJ1ZSxcImtvdG91cmEudG90dG9yaS5qcFwiOnRydWUsXCJtaXNhc2EudG90dG9yaS5qcFwiOnRydWUsXCJuYW5idS50b3R0b3JpLmpwXCI6dHJ1ZSxcIm5pY2hpbmFuLnRvdHRvcmkuanBcIjp0cnVlLFwic2FrYWltaW5hdG8udG90dG9yaS5qcFwiOnRydWUsXCJ0b3R0b3JpLnRvdHRvcmkuanBcIjp0cnVlLFwid2FrYXNhLnRvdHRvcmkuanBcIjp0cnVlLFwieWF6dS50b3R0b3JpLmpwXCI6dHJ1ZSxcInlvbmFnby50b3R0b3JpLmpwXCI6dHJ1ZSxcImFzYWhpLnRveWFtYS5qcFwiOnRydWUsXCJmdWNodS50b3lhbWEuanBcIjp0cnVlLFwiZnVrdW1pdHN1LnRveWFtYS5qcFwiOnRydWUsXCJmdW5haGFzaGkudG95YW1hLmpwXCI6dHJ1ZSxcImhpbWkudG95YW1hLmpwXCI6dHJ1ZSxcImltaXp1LnRveWFtYS5qcFwiOnRydWUsXCJpbmFtaS50b3lhbWEuanBcIjp0cnVlLFwiam9oYW5hLnRveWFtYS5qcFwiOnRydWUsXCJrYW1paWNoaS50b3lhbWEuanBcIjp0cnVlLFwia3Vyb2JlLnRveWFtYS5qcFwiOnRydWUsXCJuYWthbmlpa2F3YS50b3lhbWEuanBcIjp0cnVlLFwibmFtZXJpa2F3YS50b3lhbWEuanBcIjp0cnVlLFwibmFudG8udG95YW1hLmpwXCI6dHJ1ZSxcIm55dXplbi50b3lhbWEuanBcIjp0cnVlLFwib3lhYmUudG95YW1hLmpwXCI6dHJ1ZSxcInRhaXJhLnRveWFtYS5qcFwiOnRydWUsXCJ0YWthb2thLnRveWFtYS5qcFwiOnRydWUsXCJ0YXRleWFtYS50b3lhbWEuanBcIjp0cnVlLFwidG9nYS50b3lhbWEuanBcIjp0cnVlLFwidG9uYW1pLnRveWFtYS5qcFwiOnRydWUsXCJ0b3lhbWEudG95YW1hLmpwXCI6dHJ1ZSxcInVuYXp1a2kudG95YW1hLmpwXCI6dHJ1ZSxcInVvenUudG95YW1hLmpwXCI6dHJ1ZSxcInlhbWFkYS50b3lhbWEuanBcIjp0cnVlLFwiYXJpZGEud2FrYXlhbWEuanBcIjp0cnVlLFwiYXJpZGFnYXdhLndha2F5YW1hLmpwXCI6dHJ1ZSxcImdvYm8ud2FrYXlhbWEuanBcIjp0cnVlLFwiaGFzaGltb3RvLndha2F5YW1hLmpwXCI6dHJ1ZSxcImhpZGFrYS53YWtheWFtYS5qcFwiOnRydWUsXCJoaXJvZ2F3YS53YWtheWFtYS5qcFwiOnRydWUsXCJpbmFtaS53YWtheWFtYS5qcFwiOnRydWUsXCJpd2FkZS53YWtheWFtYS5qcFwiOnRydWUsXCJrYWluYW4ud2FrYXlhbWEuanBcIjp0cnVlLFwia2FtaXRvbmRhLndha2F5YW1hLmpwXCI6dHJ1ZSxcImthdHN1cmFnaS53YWtheWFtYS5qcFwiOnRydWUsXCJraW1pbm8ud2FrYXlhbWEuanBcIjp0cnVlLFwia2lub2thd2Eud2FrYXlhbWEuanBcIjp0cnVlLFwia2l0YXlhbWEud2FrYXlhbWEuanBcIjp0cnVlLFwia295YS53YWtheWFtYS5qcFwiOnRydWUsXCJrb3phLndha2F5YW1hLmpwXCI6dHJ1ZSxcImtvemFnYXdhLndha2F5YW1hLmpwXCI6dHJ1ZSxcImt1ZG95YW1hLndha2F5YW1hLmpwXCI6dHJ1ZSxcImt1c2hpbW90by53YWtheWFtYS5qcFwiOnRydWUsXCJtaWhhbWEud2FrYXlhbWEuanBcIjp0cnVlLFwibWlzYXRvLndha2F5YW1hLmpwXCI6dHJ1ZSxcIm5hY2hpa2F0c3V1cmEud2FrYXlhbWEuanBcIjp0cnVlLFwic2hpbmd1Lndha2F5YW1hLmpwXCI6dHJ1ZSxcInNoaXJhaGFtYS53YWtheWFtYS5qcFwiOnRydWUsXCJ0YWlqaS53YWtheWFtYS5qcFwiOnRydWUsXCJ0YW5hYmUud2FrYXlhbWEuanBcIjp0cnVlLFwid2FrYXlhbWEud2FrYXlhbWEuanBcIjp0cnVlLFwieXVhc2Eud2FrYXlhbWEuanBcIjp0cnVlLFwieXVyYS53YWtheWFtYS5qcFwiOnRydWUsXCJhc2FoaS55YW1hZ2F0YS5qcFwiOnRydWUsXCJmdW5hZ2F0YS55YW1hZ2F0YS5qcFwiOnRydWUsXCJoaWdhc2hpbmUueWFtYWdhdGEuanBcIjp0cnVlLFwiaWlkZS55YW1hZ2F0YS5qcFwiOnRydWUsXCJrYWhva3UueWFtYWdhdGEuanBcIjp0cnVlLFwia2FtaW5veWFtYS55YW1hZ2F0YS5qcFwiOnRydWUsXCJrYW5leWFtYS55YW1hZ2F0YS5qcFwiOnRydWUsXCJrYXdhbmlzaGkueWFtYWdhdGEuanBcIjp0cnVlLFwibWFtdXJvZ2F3YS55YW1hZ2F0YS5qcFwiOnRydWUsXCJtaWthd2EueWFtYWdhdGEuanBcIjp0cnVlLFwibXVyYXlhbWEueWFtYWdhdGEuanBcIjp0cnVlLFwibmFnYWkueWFtYWdhdGEuanBcIjp0cnVlLFwibmFrYXlhbWEueWFtYWdhdGEuanBcIjp0cnVlLFwibmFueW8ueWFtYWdhdGEuanBcIjp0cnVlLFwibmlzaGlrYXdhLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcIm9iYW5hemF3YS55YW1hZ2F0YS5qcFwiOnRydWUsXCJvZS55YW1hZ2F0YS5qcFwiOnRydWUsXCJvZ3VuaS55YW1hZ2F0YS5qcFwiOnRydWUsXCJvaGt1cmEueWFtYWdhdGEuanBcIjp0cnVlLFwib2lzaGlkYS55YW1hZ2F0YS5qcFwiOnRydWUsXCJzYWdhZS55YW1hZ2F0YS5qcFwiOnRydWUsXCJzYWthdGEueWFtYWdhdGEuanBcIjp0cnVlLFwic2FrZWdhd2EueWFtYWdhdGEuanBcIjp0cnVlLFwic2hpbmpvLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcInNoaXJhdGFrYS55YW1hZ2F0YS5qcFwiOnRydWUsXCJzaG9uYWkueWFtYWdhdGEuanBcIjp0cnVlLFwidGFrYWhhdGEueWFtYWdhdGEuanBcIjp0cnVlLFwidGVuZG8ueWFtYWdhdGEuanBcIjp0cnVlLFwidG96YXdhLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcInRzdXJ1b2thLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcInlhbWFnYXRhLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcInlhbWFub2JlLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcInlvbmV6YXdhLnlhbWFnYXRhLmpwXCI6dHJ1ZSxcInl1emEueWFtYWdhdGEuanBcIjp0cnVlLFwiYWJ1LnlhbWFndWNoaS5qcFwiOnRydWUsXCJoYWdpLnlhbWFndWNoaS5qcFwiOnRydWUsXCJoaWthcmkueWFtYWd1Y2hpLmpwXCI6dHJ1ZSxcImhvZnUueWFtYWd1Y2hpLmpwXCI6dHJ1ZSxcIml3YWt1bmkueWFtYWd1Y2hpLmpwXCI6dHJ1ZSxcImt1ZGFtYXRzdS55YW1hZ3VjaGkuanBcIjp0cnVlLFwibWl0b3UueWFtYWd1Y2hpLmpwXCI6dHJ1ZSxcIm5hZ2F0by55YW1hZ3VjaGkuanBcIjp0cnVlLFwib3NoaW1hLnlhbWFndWNoaS5qcFwiOnRydWUsXCJzaGltb25vc2VraS55YW1hZ3VjaGkuanBcIjp0cnVlLFwic2h1bmFuLnlhbWFndWNoaS5qcFwiOnRydWUsXCJ0YWJ1c2UueWFtYWd1Y2hpLmpwXCI6dHJ1ZSxcInRva3V5YW1hLnlhbWFndWNoaS5qcFwiOnRydWUsXCJ0b3lvdGEueWFtYWd1Y2hpLmpwXCI6dHJ1ZSxcInViZS55YW1hZ3VjaGkuanBcIjp0cnVlLFwieXV1LnlhbWFndWNoaS5qcFwiOnRydWUsXCJjaHVvLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJkb3NoaS55YW1hbmFzaGkuanBcIjp0cnVlLFwiZnVlZnVraS55YW1hbmFzaGkuanBcIjp0cnVlLFwiZnVqaWthd2EueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcImZ1amlrYXdhZ3VjaGlrby55YW1hbmFzaGkuanBcIjp0cnVlLFwiZnVqaXlvc2hpZGEueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcImhheWFrYXdhLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJob2t1dG8ueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcImljaGlrYXdhbWlzYXRvLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJrYWkueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcImtvZnUueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcImtvc2h1LnlhbWFuYXNoaS5qcFwiOnRydWUsXCJrb3N1Z2UueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcIm1pbmFtaS1hbHBzLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJtaW5vYnUueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcIm5ha2FtaWNoaS55YW1hbmFzaGkuanBcIjp0cnVlLFwibmFuYnUueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcIm5hcnVzYXdhLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJuaXJhc2FraS55YW1hbmFzaGkuanBcIjp0cnVlLFwibmlzaGlrYXRzdXJhLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJvc2hpbm8ueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcIm90c3VraS55YW1hbmFzaGkuanBcIjp0cnVlLFwic2hvd2EueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcInRhYmF5YW1hLnlhbWFuYXNoaS5qcFwiOnRydWUsXCJ0c3VydS55YW1hbmFzaGkuanBcIjp0cnVlLFwidWVub2hhcmEueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcInlhbWFuYWtha28ueWFtYW5hc2hpLmpwXCI6dHJ1ZSxcInlhbWFuYXNoaS55YW1hbmFzaGkuanBcIjp0cnVlLFwiKi5rZVwiOnRydWUsXCJrZ1wiOnRydWUsXCJvcmcua2dcIjp0cnVlLFwibmV0LmtnXCI6dHJ1ZSxcImNvbS5rZ1wiOnRydWUsXCJlZHUua2dcIjp0cnVlLFwiZ292LmtnXCI6dHJ1ZSxcIm1pbC5rZ1wiOnRydWUsXCIqLmtoXCI6dHJ1ZSxcImtpXCI6dHJ1ZSxcImVkdS5raVwiOnRydWUsXCJiaXoua2lcIjp0cnVlLFwibmV0LmtpXCI6dHJ1ZSxcIm9yZy5raVwiOnRydWUsXCJnb3Yua2lcIjp0cnVlLFwiaW5mby5raVwiOnRydWUsXCJjb20ua2lcIjp0cnVlLFwia21cIjp0cnVlLFwib3JnLmttXCI6dHJ1ZSxcIm5vbS5rbVwiOnRydWUsXCJnb3Yua21cIjp0cnVlLFwicHJkLmttXCI6dHJ1ZSxcInRtLmttXCI6dHJ1ZSxcImVkdS5rbVwiOnRydWUsXCJtaWwua21cIjp0cnVlLFwiYXNzLmttXCI6dHJ1ZSxcImNvbS5rbVwiOnRydWUsXCJjb29wLmttXCI6dHJ1ZSxcImFzc28ua21cIjp0cnVlLFwicHJlc3NlLmttXCI6dHJ1ZSxcIm1lZGVjaW4ua21cIjp0cnVlLFwibm90YWlyZXMua21cIjp0cnVlLFwicGhhcm1hY2llbnMua21cIjp0cnVlLFwidmV0ZXJpbmFpcmUua21cIjp0cnVlLFwiZ291di5rbVwiOnRydWUsXCJrblwiOnRydWUsXCJuZXQua25cIjp0cnVlLFwib3JnLmtuXCI6dHJ1ZSxcImVkdS5rblwiOnRydWUsXCJnb3Yua25cIjp0cnVlLFwia3BcIjp0cnVlLFwiY29tLmtwXCI6dHJ1ZSxcImVkdS5rcFwiOnRydWUsXCJnb3Yua3BcIjp0cnVlLFwib3JnLmtwXCI6dHJ1ZSxcInJlcC5rcFwiOnRydWUsXCJ0cmEua3BcIjp0cnVlLFwia3JcIjp0cnVlLFwiYWMua3JcIjp0cnVlLFwiY28ua3JcIjp0cnVlLFwiZXMua3JcIjp0cnVlLFwiZ28ua3JcIjp0cnVlLFwiaHMua3JcIjp0cnVlLFwia2cua3JcIjp0cnVlLFwibWlsLmtyXCI6dHJ1ZSxcIm1zLmtyXCI6dHJ1ZSxcIm5lLmtyXCI6dHJ1ZSxcIm9yLmtyXCI6dHJ1ZSxcInBlLmtyXCI6dHJ1ZSxcInJlLmtyXCI6dHJ1ZSxcInNjLmtyXCI6dHJ1ZSxcImJ1c2FuLmtyXCI6dHJ1ZSxcImNodW5nYnVrLmtyXCI6dHJ1ZSxcImNodW5nbmFtLmtyXCI6dHJ1ZSxcImRhZWd1LmtyXCI6dHJ1ZSxcImRhZWplb24ua3JcIjp0cnVlLFwiZ2FuZ3dvbi5rclwiOnRydWUsXCJnd2FuZ2p1LmtyXCI6dHJ1ZSxcImd5ZW9uZ2J1ay5rclwiOnRydWUsXCJneWVvbmdnaS5rclwiOnRydWUsXCJneWVvbmduYW0ua3JcIjp0cnVlLFwiaW5jaGVvbi5rclwiOnRydWUsXCJqZWp1LmtyXCI6dHJ1ZSxcImplb25idWsua3JcIjp0cnVlLFwiamVvbm5hbS5rclwiOnRydWUsXCJzZW91bC5rclwiOnRydWUsXCJ1bHNhbi5rclwiOnRydWUsXCIqLmt3XCI6dHJ1ZSxcImt5XCI6dHJ1ZSxcImVkdS5reVwiOnRydWUsXCJnb3Yua3lcIjp0cnVlLFwiY29tLmt5XCI6dHJ1ZSxcIm9yZy5reVwiOnRydWUsXCJuZXQua3lcIjp0cnVlLFwia3pcIjp0cnVlLFwib3JnLmt6XCI6dHJ1ZSxcImVkdS5relwiOnRydWUsXCJuZXQua3pcIjp0cnVlLFwiZ292Lmt6XCI6dHJ1ZSxcIm1pbC5relwiOnRydWUsXCJjb20ua3pcIjp0cnVlLFwibGFcIjp0cnVlLFwiaW50LmxhXCI6dHJ1ZSxcIm5ldC5sYVwiOnRydWUsXCJpbmZvLmxhXCI6dHJ1ZSxcImVkdS5sYVwiOnRydWUsXCJnb3YubGFcIjp0cnVlLFwicGVyLmxhXCI6dHJ1ZSxcImNvbS5sYVwiOnRydWUsXCJvcmcubGFcIjp0cnVlLFwibGJcIjp0cnVlLFwiY29tLmxiXCI6dHJ1ZSxcImVkdS5sYlwiOnRydWUsXCJnb3YubGJcIjp0cnVlLFwibmV0LmxiXCI6dHJ1ZSxcIm9yZy5sYlwiOnRydWUsXCJsY1wiOnRydWUsXCJjb20ubGNcIjp0cnVlLFwibmV0LmxjXCI6dHJ1ZSxcImNvLmxjXCI6dHJ1ZSxcIm9yZy5sY1wiOnRydWUsXCJlZHUubGNcIjp0cnVlLFwiZ292LmxjXCI6dHJ1ZSxcImxpXCI6dHJ1ZSxcImxrXCI6dHJ1ZSxcImdvdi5sa1wiOnRydWUsXCJzY2gubGtcIjp0cnVlLFwibmV0LmxrXCI6dHJ1ZSxcImludC5sa1wiOnRydWUsXCJjb20ubGtcIjp0cnVlLFwib3JnLmxrXCI6dHJ1ZSxcImVkdS5sa1wiOnRydWUsXCJuZ28ubGtcIjp0cnVlLFwic29jLmxrXCI6dHJ1ZSxcIndlYi5sa1wiOnRydWUsXCJsdGQubGtcIjp0cnVlLFwiYXNzbi5sa1wiOnRydWUsXCJncnAubGtcIjp0cnVlLFwiaG90ZWwubGtcIjp0cnVlLFwiYWMubGtcIjp0cnVlLFwibHJcIjp0cnVlLFwiY29tLmxyXCI6dHJ1ZSxcImVkdS5sclwiOnRydWUsXCJnb3YubHJcIjp0cnVlLFwib3JnLmxyXCI6dHJ1ZSxcIm5ldC5sclwiOnRydWUsXCJsc1wiOnRydWUsXCJjby5sc1wiOnRydWUsXCJvcmcubHNcIjp0cnVlLFwibHRcIjp0cnVlLFwiZ292Lmx0XCI6dHJ1ZSxcImx1XCI6dHJ1ZSxcImx2XCI6dHJ1ZSxcImNvbS5sdlwiOnRydWUsXCJlZHUubHZcIjp0cnVlLFwiZ292Lmx2XCI6dHJ1ZSxcIm9yZy5sdlwiOnRydWUsXCJtaWwubHZcIjp0cnVlLFwiaWQubHZcIjp0cnVlLFwibmV0Lmx2XCI6dHJ1ZSxcImFzbi5sdlwiOnRydWUsXCJjb25mLmx2XCI6dHJ1ZSxcImx5XCI6dHJ1ZSxcImNvbS5seVwiOnRydWUsXCJuZXQubHlcIjp0cnVlLFwiZ292Lmx5XCI6dHJ1ZSxcInBsYy5seVwiOnRydWUsXCJlZHUubHlcIjp0cnVlLFwic2NoLmx5XCI6dHJ1ZSxcIm1lZC5seVwiOnRydWUsXCJvcmcubHlcIjp0cnVlLFwiaWQubHlcIjp0cnVlLFwibWFcIjp0cnVlLFwiY28ubWFcIjp0cnVlLFwibmV0Lm1hXCI6dHJ1ZSxcImdvdi5tYVwiOnRydWUsXCJvcmcubWFcIjp0cnVlLFwiYWMubWFcIjp0cnVlLFwicHJlc3MubWFcIjp0cnVlLFwibWNcIjp0cnVlLFwidG0ubWNcIjp0cnVlLFwiYXNzby5tY1wiOnRydWUsXCJtZFwiOnRydWUsXCJtZVwiOnRydWUsXCJjby5tZVwiOnRydWUsXCJuZXQubWVcIjp0cnVlLFwib3JnLm1lXCI6dHJ1ZSxcImVkdS5tZVwiOnRydWUsXCJhYy5tZVwiOnRydWUsXCJnb3YubWVcIjp0cnVlLFwiaXRzLm1lXCI6dHJ1ZSxcInByaXYubWVcIjp0cnVlLFwibWdcIjp0cnVlLFwib3JnLm1nXCI6dHJ1ZSxcIm5vbS5tZ1wiOnRydWUsXCJnb3YubWdcIjp0cnVlLFwicHJkLm1nXCI6dHJ1ZSxcInRtLm1nXCI6dHJ1ZSxcImVkdS5tZ1wiOnRydWUsXCJtaWwubWdcIjp0cnVlLFwiY29tLm1nXCI6dHJ1ZSxcImNvLm1nXCI6dHJ1ZSxcIm1oXCI6dHJ1ZSxcIm1pbFwiOnRydWUsXCJta1wiOnRydWUsXCJjb20ubWtcIjp0cnVlLFwib3JnLm1rXCI6dHJ1ZSxcIm5ldC5ta1wiOnRydWUsXCJlZHUubWtcIjp0cnVlLFwiZ292Lm1rXCI6dHJ1ZSxcImluZi5ta1wiOnRydWUsXCJuYW1lLm1rXCI6dHJ1ZSxcIm1sXCI6dHJ1ZSxcImNvbS5tbFwiOnRydWUsXCJlZHUubWxcIjp0cnVlLFwiZ291di5tbFwiOnRydWUsXCJnb3YubWxcIjp0cnVlLFwibmV0Lm1sXCI6dHJ1ZSxcIm9yZy5tbFwiOnRydWUsXCJwcmVzc2UubWxcIjp0cnVlLFwiKi5tbVwiOnRydWUsXCJtblwiOnRydWUsXCJnb3YubW5cIjp0cnVlLFwiZWR1Lm1uXCI6dHJ1ZSxcIm9yZy5tblwiOnRydWUsXCJtb1wiOnRydWUsXCJjb20ubW9cIjp0cnVlLFwibmV0Lm1vXCI6dHJ1ZSxcIm9yZy5tb1wiOnRydWUsXCJlZHUubW9cIjp0cnVlLFwiZ292Lm1vXCI6dHJ1ZSxcIm1vYmlcIjp0cnVlLFwibXBcIjp0cnVlLFwibXFcIjp0cnVlLFwibXJcIjp0cnVlLFwiZ292Lm1yXCI6dHJ1ZSxcIm1zXCI6dHJ1ZSxcImNvbS5tc1wiOnRydWUsXCJlZHUubXNcIjp0cnVlLFwiZ292Lm1zXCI6dHJ1ZSxcIm5ldC5tc1wiOnRydWUsXCJvcmcubXNcIjp0cnVlLFwibXRcIjp0cnVlLFwiY29tLm10XCI6dHJ1ZSxcImVkdS5tdFwiOnRydWUsXCJuZXQubXRcIjp0cnVlLFwib3JnLm10XCI6dHJ1ZSxcIm11XCI6dHJ1ZSxcImNvbS5tdVwiOnRydWUsXCJuZXQubXVcIjp0cnVlLFwib3JnLm11XCI6dHJ1ZSxcImdvdi5tdVwiOnRydWUsXCJhYy5tdVwiOnRydWUsXCJjby5tdVwiOnRydWUsXCJvci5tdVwiOnRydWUsXCJtdXNldW1cIjp0cnVlLFwiYWNhZGVteS5tdXNldW1cIjp0cnVlLFwiYWdyaWN1bHR1cmUubXVzZXVtXCI6dHJ1ZSxcImFpci5tdXNldW1cIjp0cnVlLFwiYWlyZ3VhcmQubXVzZXVtXCI6dHJ1ZSxcImFsYWJhbWEubXVzZXVtXCI6dHJ1ZSxcImFsYXNrYS5tdXNldW1cIjp0cnVlLFwiYW1iZXIubXVzZXVtXCI6dHJ1ZSxcImFtYnVsYW5jZS5tdXNldW1cIjp0cnVlLFwiYW1lcmljYW4ubXVzZXVtXCI6dHJ1ZSxcImFtZXJpY2FuYS5tdXNldW1cIjp0cnVlLFwiYW1lcmljYW5hbnRpcXVlcy5tdXNldW1cIjp0cnVlLFwiYW1lcmljYW5hcnQubXVzZXVtXCI6dHJ1ZSxcImFtc3RlcmRhbS5tdXNldW1cIjp0cnVlLFwiYW5kLm11c2V1bVwiOnRydWUsXCJhbm5lZnJhbmsubXVzZXVtXCI6dHJ1ZSxcImFudGhyby5tdXNldW1cIjp0cnVlLFwiYW50aHJvcG9sb2d5Lm11c2V1bVwiOnRydWUsXCJhbnRpcXVlcy5tdXNldW1cIjp0cnVlLFwiYXF1YXJpdW0ubXVzZXVtXCI6dHJ1ZSxcImFyYm9yZXR1bS5tdXNldW1cIjp0cnVlLFwiYXJjaGFlb2xvZ2ljYWwubXVzZXVtXCI6dHJ1ZSxcImFyY2hhZW9sb2d5Lm11c2V1bVwiOnRydWUsXCJhcmNoaXRlY3R1cmUubXVzZXVtXCI6dHJ1ZSxcImFydC5tdXNldW1cIjp0cnVlLFwiYXJ0YW5kZGVzaWduLm11c2V1bVwiOnRydWUsXCJhcnRjZW50ZXIubXVzZXVtXCI6dHJ1ZSxcImFydGRlY28ubXVzZXVtXCI6dHJ1ZSxcImFydGVkdWNhdGlvbi5tdXNldW1cIjp0cnVlLFwiYXJ0Z2FsbGVyeS5tdXNldW1cIjp0cnVlLFwiYXJ0cy5tdXNldW1cIjp0cnVlLFwiYXJ0c2FuZGNyYWZ0cy5tdXNldW1cIjp0cnVlLFwiYXNtYXRhcnQubXVzZXVtXCI6dHJ1ZSxcImFzc2Fzc2luYXRpb24ubXVzZXVtXCI6dHJ1ZSxcImFzc2lzaS5tdXNldW1cIjp0cnVlLFwiYXNzb2NpYXRpb24ubXVzZXVtXCI6dHJ1ZSxcImFzdHJvbm9teS5tdXNldW1cIjp0cnVlLFwiYXRsYW50YS5tdXNldW1cIjp0cnVlLFwiYXVzdGluLm11c2V1bVwiOnRydWUsXCJhdXN0cmFsaWEubXVzZXVtXCI6dHJ1ZSxcImF1dG9tb3RpdmUubXVzZXVtXCI6dHJ1ZSxcImF2aWF0aW9uLm11c2V1bVwiOnRydWUsXCJheGlzLm11c2V1bVwiOnRydWUsXCJiYWRham96Lm11c2V1bVwiOnRydWUsXCJiYWdoZGFkLm11c2V1bVwiOnRydWUsXCJiYWhuLm11c2V1bVwiOnRydWUsXCJiYWxlLm11c2V1bVwiOnRydWUsXCJiYWx0aW1vcmUubXVzZXVtXCI6dHJ1ZSxcImJhcmNlbG9uYS5tdXNldW1cIjp0cnVlLFwiYmFzZWJhbGwubXVzZXVtXCI6dHJ1ZSxcImJhc2VsLm11c2V1bVwiOnRydWUsXCJiYXRocy5tdXNldW1cIjp0cnVlLFwiYmF1ZXJuLm11c2V1bVwiOnRydWUsXCJiZWF1eGFydHMubXVzZXVtXCI6dHJ1ZSxcImJlZWxkZW5nZWx1aWQubXVzZXVtXCI6dHJ1ZSxcImJlbGxldnVlLm11c2V1bVwiOnRydWUsXCJiZXJnYmF1Lm11c2V1bVwiOnRydWUsXCJiZXJrZWxleS5tdXNldW1cIjp0cnVlLFwiYmVybGluLm11c2V1bVwiOnRydWUsXCJiZXJuLm11c2V1bVwiOnRydWUsXCJiaWJsZS5tdXNldW1cIjp0cnVlLFwiYmlsYmFvLm11c2V1bVwiOnRydWUsXCJiaWxsLm11c2V1bVwiOnRydWUsXCJiaXJkYXJ0Lm11c2V1bVwiOnRydWUsXCJiaXJ0aHBsYWNlLm11c2V1bVwiOnRydWUsXCJib25uLm11c2V1bVwiOnRydWUsXCJib3N0b24ubXVzZXVtXCI6dHJ1ZSxcImJvdGFuaWNhbC5tdXNldW1cIjp0cnVlLFwiYm90YW5pY2FsZ2FyZGVuLm11c2V1bVwiOnRydWUsXCJib3RhbmljZ2FyZGVuLm11c2V1bVwiOnRydWUsXCJib3RhbnkubXVzZXVtXCI6dHJ1ZSxcImJyYW5keXdpbmV2YWxsZXkubXVzZXVtXCI6dHJ1ZSxcImJyYXNpbC5tdXNldW1cIjp0cnVlLFwiYnJpc3RvbC5tdXNldW1cIjp0cnVlLFwiYnJpdGlzaC5tdXNldW1cIjp0cnVlLFwiYnJpdGlzaGNvbHVtYmlhLm11c2V1bVwiOnRydWUsXCJicm9hZGNhc3QubXVzZXVtXCI6dHJ1ZSxcImJydW5lbC5tdXNldW1cIjp0cnVlLFwiYnJ1c3NlbC5tdXNldW1cIjp0cnVlLFwiYnJ1c3NlbHMubXVzZXVtXCI6dHJ1ZSxcImJydXhlbGxlcy5tdXNldW1cIjp0cnVlLFwiYnVpbGRpbmcubXVzZXVtXCI6dHJ1ZSxcImJ1cmdob2YubXVzZXVtXCI6dHJ1ZSxcImJ1cy5tdXNldW1cIjp0cnVlLFwiYnVzaGV5Lm11c2V1bVwiOnRydWUsXCJjYWRhcXVlcy5tdXNldW1cIjp0cnVlLFwiY2FsaWZvcm5pYS5tdXNldW1cIjp0cnVlLFwiY2FtYnJpZGdlLm11c2V1bVwiOnRydWUsXCJjYW4ubXVzZXVtXCI6dHJ1ZSxcImNhbmFkYS5tdXNldW1cIjp0cnVlLFwiY2FwZWJyZXRvbi5tdXNldW1cIjp0cnVlLFwiY2Fycmllci5tdXNldW1cIjp0cnVlLFwiY2FydG9vbmFydC5tdXNldW1cIjp0cnVlLFwiY2FzYWRlbGFtb25lZGEubXVzZXVtXCI6dHJ1ZSxcImNhc3RsZS5tdXNldW1cIjp0cnVlLFwiY2FzdHJlcy5tdXNldW1cIjp0cnVlLFwiY2VsdGljLm11c2V1bVwiOnRydWUsXCJjZW50ZXIubXVzZXVtXCI6dHJ1ZSxcImNoYXR0YW5vb2dhLm11c2V1bVwiOnRydWUsXCJjaGVsdGVuaGFtLm11c2V1bVwiOnRydWUsXCJjaGVzYXBlYWtlYmF5Lm11c2V1bVwiOnRydWUsXCJjaGljYWdvLm11c2V1bVwiOnRydWUsXCJjaGlsZHJlbi5tdXNldW1cIjp0cnVlLFwiY2hpbGRyZW5zLm11c2V1bVwiOnRydWUsXCJjaGlsZHJlbnNnYXJkZW4ubXVzZXVtXCI6dHJ1ZSxcImNoaXJvcHJhY3RpYy5tdXNldW1cIjp0cnVlLFwiY2hvY29sYXRlLm11c2V1bVwiOnRydWUsXCJjaHJpc3RpYW5zYnVyZy5tdXNldW1cIjp0cnVlLFwiY2luY2lubmF0aS5tdXNldW1cIjp0cnVlLFwiY2luZW1hLm11c2V1bVwiOnRydWUsXCJjaXJjdXMubXVzZXVtXCI6dHJ1ZSxcImNpdmlsaXNhdGlvbi5tdXNldW1cIjp0cnVlLFwiY2l2aWxpemF0aW9uLm11c2V1bVwiOnRydWUsXCJjaXZpbHdhci5tdXNldW1cIjp0cnVlLFwiY2xpbnRvbi5tdXNldW1cIjp0cnVlLFwiY2xvY2subXVzZXVtXCI6dHJ1ZSxcImNvYWwubXVzZXVtXCI6dHJ1ZSxcImNvYXN0YWxkZWZlbmNlLm11c2V1bVwiOnRydWUsXCJjb2R5Lm11c2V1bVwiOnRydWUsXCJjb2xkd2FyLm11c2V1bVwiOnRydWUsXCJjb2xsZWN0aW9uLm11c2V1bVwiOnRydWUsXCJjb2xvbmlhbHdpbGxpYW1zYnVyZy5tdXNldW1cIjp0cnVlLFwiY29sb3JhZG9wbGF0ZWF1Lm11c2V1bVwiOnRydWUsXCJjb2x1bWJpYS5tdXNldW1cIjp0cnVlLFwiY29sdW1idXMubXVzZXVtXCI6dHJ1ZSxcImNvbW11bmljYXRpb24ubXVzZXVtXCI6dHJ1ZSxcImNvbW11bmljYXRpb25zLm11c2V1bVwiOnRydWUsXCJjb21tdW5pdHkubXVzZXVtXCI6dHJ1ZSxcImNvbXB1dGVyLm11c2V1bVwiOnRydWUsXCJjb21wdXRlcmhpc3RvcnkubXVzZXVtXCI6dHJ1ZSxcInhuLS1jb211bmljYWVzLXY2YTJvLm11c2V1bVwiOnRydWUsXCJjb250ZW1wb3JhcnkubXVzZXVtXCI6dHJ1ZSxcImNvbnRlbXBvcmFyeWFydC5tdXNldW1cIjp0cnVlLFwiY29udmVudC5tdXNldW1cIjp0cnVlLFwiY29wZW5oYWdlbi5tdXNldW1cIjp0cnVlLFwiY29ycG9yYXRpb24ubXVzZXVtXCI6dHJ1ZSxcInhuLS1jb3JyZWlvcy1lLXRlbGVjb211bmljYWVzLWdoYzI5YS5tdXNldW1cIjp0cnVlLFwiY29ydmV0dGUubXVzZXVtXCI6dHJ1ZSxcImNvc3R1bWUubXVzZXVtXCI6dHJ1ZSxcImNvdW50cnllc3RhdGUubXVzZXVtXCI6dHJ1ZSxcImNvdW50eS5tdXNldW1cIjp0cnVlLFwiY3JhZnRzLm11c2V1bVwiOnRydWUsXCJjcmFuYnJvb2subXVzZXVtXCI6dHJ1ZSxcImNyZWF0aW9uLm11c2V1bVwiOnRydWUsXCJjdWx0dXJhbC5tdXNldW1cIjp0cnVlLFwiY3VsdHVyYWxjZW50ZXIubXVzZXVtXCI6dHJ1ZSxcImN1bHR1cmUubXVzZXVtXCI6dHJ1ZSxcImN5YmVyLm11c2V1bVwiOnRydWUsXCJjeW1ydS5tdXNldW1cIjp0cnVlLFwiZGFsaS5tdXNldW1cIjp0cnVlLFwiZGFsbGFzLm11c2V1bVwiOnRydWUsXCJkYXRhYmFzZS5tdXNldW1cIjp0cnVlLFwiZGRyLm11c2V1bVwiOnRydWUsXCJkZWNvcmF0aXZlYXJ0cy5tdXNldW1cIjp0cnVlLFwiZGVsYXdhcmUubXVzZXVtXCI6dHJ1ZSxcImRlbG1lbmhvcnN0Lm11c2V1bVwiOnRydWUsXCJkZW5tYXJrLm11c2V1bVwiOnRydWUsXCJkZXBvdC5tdXNldW1cIjp0cnVlLFwiZGVzaWduLm11c2V1bVwiOnRydWUsXCJkZXRyb2l0Lm11c2V1bVwiOnRydWUsXCJkaW5vc2F1ci5tdXNldW1cIjp0cnVlLFwiZGlzY292ZXJ5Lm11c2V1bVwiOnRydWUsXCJkb2xscy5tdXNldW1cIjp0cnVlLFwiZG9ub3N0aWEubXVzZXVtXCI6dHJ1ZSxcImR1cmhhbS5tdXNldW1cIjp0cnVlLFwiZWFzdGFmcmljYS5tdXNldW1cIjp0cnVlLFwiZWFzdGNvYXN0Lm11c2V1bVwiOnRydWUsXCJlZHVjYXRpb24ubXVzZXVtXCI6dHJ1ZSxcImVkdWNhdGlvbmFsLm11c2V1bVwiOnRydWUsXCJlZ3lwdGlhbi5tdXNldW1cIjp0cnVlLFwiZWlzZW5iYWhuLm11c2V1bVwiOnRydWUsXCJlbGJ1cmcubXVzZXVtXCI6dHJ1ZSxcImVsdmVuZHJlbGwubXVzZXVtXCI6dHJ1ZSxcImVtYnJvaWRlcnkubXVzZXVtXCI6dHJ1ZSxcImVuY3ljbG9wZWRpYy5tdXNldW1cIjp0cnVlLFwiZW5nbGFuZC5tdXNldW1cIjp0cnVlLFwiZW50b21vbG9neS5tdXNldW1cIjp0cnVlLFwiZW52aXJvbm1lbnQubXVzZXVtXCI6dHJ1ZSxcImVudmlyb25tZW50YWxjb25zZXJ2YXRpb24ubXVzZXVtXCI6dHJ1ZSxcImVwaWxlcHN5Lm11c2V1bVwiOnRydWUsXCJlc3NleC5tdXNldW1cIjp0cnVlLFwiZXN0YXRlLm11c2V1bVwiOnRydWUsXCJldGhub2xvZ3kubXVzZXVtXCI6dHJ1ZSxcImV4ZXRlci5tdXNldW1cIjp0cnVlLFwiZXhoaWJpdGlvbi5tdXNldW1cIjp0cnVlLFwiZmFtaWx5Lm11c2V1bVwiOnRydWUsXCJmYXJtLm11c2V1bVwiOnRydWUsXCJmYXJtZXF1aXBtZW50Lm11c2V1bVwiOnRydWUsXCJmYXJtZXJzLm11c2V1bVwiOnRydWUsXCJmYXJtc3RlYWQubXVzZXVtXCI6dHJ1ZSxcImZpZWxkLm11c2V1bVwiOnRydWUsXCJmaWd1ZXJlcy5tdXNldW1cIjp0cnVlLFwiZmlsYXRlbGlhLm11c2V1bVwiOnRydWUsXCJmaWxtLm11c2V1bVwiOnRydWUsXCJmaW5lYXJ0Lm11c2V1bVwiOnRydWUsXCJmaW5lYXJ0cy5tdXNldW1cIjp0cnVlLFwiZmlubGFuZC5tdXNldW1cIjp0cnVlLFwiZmxhbmRlcnMubXVzZXVtXCI6dHJ1ZSxcImZsb3JpZGEubXVzZXVtXCI6dHJ1ZSxcImZvcmNlLm11c2V1bVwiOnRydWUsXCJmb3J0bWlzc291bGEubXVzZXVtXCI6dHJ1ZSxcImZvcnR3b3J0aC5tdXNldW1cIjp0cnVlLFwiZm91bmRhdGlvbi5tdXNldW1cIjp0cnVlLFwiZnJhbmNhaXNlLm11c2V1bVwiOnRydWUsXCJmcmFua2Z1cnQubXVzZXVtXCI6dHJ1ZSxcImZyYW56aXNrYW5lci5tdXNldW1cIjp0cnVlLFwiZnJlZW1hc29ucnkubXVzZXVtXCI6dHJ1ZSxcImZyZWlidXJnLm11c2V1bVwiOnRydWUsXCJmcmlib3VyZy5tdXNldW1cIjp0cnVlLFwiZnJvZy5tdXNldW1cIjp0cnVlLFwiZnVuZGFjaW8ubXVzZXVtXCI6dHJ1ZSxcImZ1cm5pdHVyZS5tdXNldW1cIjp0cnVlLFwiZ2FsbGVyeS5tdXNldW1cIjp0cnVlLFwiZ2FyZGVuLm11c2V1bVwiOnRydWUsXCJnYXRld2F5Lm11c2V1bVwiOnRydWUsXCJnZWVsdmluY2subXVzZXVtXCI6dHJ1ZSxcImdlbW9sb2dpY2FsLm11c2V1bVwiOnRydWUsXCJnZW9sb2d5Lm11c2V1bVwiOnRydWUsXCJnZW9yZ2lhLm11c2V1bVwiOnRydWUsXCJnaWVzc2VuLm11c2V1bVwiOnRydWUsXCJnbGFzLm11c2V1bVwiOnRydWUsXCJnbGFzcy5tdXNldW1cIjp0cnVlLFwiZ29yZ2UubXVzZXVtXCI6dHJ1ZSxcImdyYW5kcmFwaWRzLm11c2V1bVwiOnRydWUsXCJncmF6Lm11c2V1bVwiOnRydWUsXCJndWVybnNleS5tdXNldW1cIjp0cnVlLFwiaGFsbG9mZmFtZS5tdXNldW1cIjp0cnVlLFwiaGFtYnVyZy5tdXNldW1cIjp0cnVlLFwiaGFuZHNvbi5tdXNldW1cIjp0cnVlLFwiaGFydmVzdGNlbGVicmF0aW9uLm11c2V1bVwiOnRydWUsXCJoYXdhaWkubXVzZXVtXCI6dHJ1ZSxcImhlYWx0aC5tdXNldW1cIjp0cnVlLFwiaGVpbWF0dW5kdWhyZW4ubXVzZXVtXCI6dHJ1ZSxcImhlbGxhcy5tdXNldW1cIjp0cnVlLFwiaGVsc2lua2kubXVzZXVtXCI6dHJ1ZSxcImhlbWJ5Z2RzZm9yYnVuZC5tdXNldW1cIjp0cnVlLFwiaGVyaXRhZ2UubXVzZXVtXCI6dHJ1ZSxcImhpc3RvaXJlLm11c2V1bVwiOnRydWUsXCJoaXN0b3JpY2FsLm11c2V1bVwiOnRydWUsXCJoaXN0b3JpY2Fsc29jaWV0eS5tdXNldW1cIjp0cnVlLFwiaGlzdG9yaWNob3VzZXMubXVzZXVtXCI6dHJ1ZSxcImhpc3RvcmlzY2gubXVzZXVtXCI6dHJ1ZSxcImhpc3RvcmlzY2hlcy5tdXNldW1cIjp0cnVlLFwiaGlzdG9yeS5tdXNldW1cIjp0cnVlLFwiaGlzdG9yeW9mc2NpZW5jZS5tdXNldW1cIjp0cnVlLFwiaG9yb2xvZ3kubXVzZXVtXCI6dHJ1ZSxcImhvdXNlLm11c2V1bVwiOnRydWUsXCJodW1hbml0aWVzLm11c2V1bVwiOnRydWUsXCJpbGx1c3RyYXRpb24ubXVzZXVtXCI6dHJ1ZSxcImltYWdlYW5kc291bmQubXVzZXVtXCI6dHJ1ZSxcImluZGlhbi5tdXNldW1cIjp0cnVlLFwiaW5kaWFuYS5tdXNldW1cIjp0cnVlLFwiaW5kaWFuYXBvbGlzLm11c2V1bVwiOnRydWUsXCJpbmRpYW5tYXJrZXQubXVzZXVtXCI6dHJ1ZSxcImludGVsbGlnZW5jZS5tdXNldW1cIjp0cnVlLFwiaW50ZXJhY3RpdmUubXVzZXVtXCI6dHJ1ZSxcImlyYXEubXVzZXVtXCI6dHJ1ZSxcImlyb24ubXVzZXVtXCI6dHJ1ZSxcImlzbGVvZm1hbi5tdXNldW1cIjp0cnVlLFwiamFtaXNvbi5tdXNldW1cIjp0cnVlLFwiamVmZmVyc29uLm11c2V1bVwiOnRydWUsXCJqZXJ1c2FsZW0ubXVzZXVtXCI6dHJ1ZSxcImpld2VscnkubXVzZXVtXCI6dHJ1ZSxcImpld2lzaC5tdXNldW1cIjp0cnVlLFwiamV3aXNoYXJ0Lm11c2V1bVwiOnRydWUsXCJqZmsubXVzZXVtXCI6dHJ1ZSxcImpvdXJuYWxpc20ubXVzZXVtXCI6dHJ1ZSxcImp1ZGFpY2EubXVzZXVtXCI6dHJ1ZSxcImp1ZHlnYXJsYW5kLm11c2V1bVwiOnRydWUsXCJqdWVkaXNjaGVzLm11c2V1bVwiOnRydWUsXCJqdWlmLm11c2V1bVwiOnRydWUsXCJrYXJhdGUubXVzZXVtXCI6dHJ1ZSxcImthcmlrYXR1ci5tdXNldW1cIjp0cnVlLFwia2lkcy5tdXNldW1cIjp0cnVlLFwia29lYmVuaGF2bi5tdXNldW1cIjp0cnVlLFwia29lbG4ubXVzZXVtXCI6dHJ1ZSxcImt1bnN0Lm11c2V1bVwiOnRydWUsXCJrdW5zdHNhbW1sdW5nLm11c2V1bVwiOnRydWUsXCJrdW5zdHVuZGRlc2lnbi5tdXNldW1cIjp0cnVlLFwibGFib3IubXVzZXVtXCI6dHJ1ZSxcImxhYm91ci5tdXNldW1cIjp0cnVlLFwibGFqb2xsYS5tdXNldW1cIjp0cnVlLFwibGFuY2FzaGlyZS5tdXNldW1cIjp0cnVlLFwibGFuZGVzLm11c2V1bVwiOnRydWUsXCJsYW5zLm11c2V1bVwiOnRydWUsXCJ4bi0tbG5zLXFsYS5tdXNldW1cIjp0cnVlLFwibGFyc3Nvbi5tdXNldW1cIjp0cnVlLFwibGV3aXNtaWxsZXIubXVzZXVtXCI6dHJ1ZSxcImxpbmNvbG4ubXVzZXVtXCI6dHJ1ZSxcImxpbnoubXVzZXVtXCI6dHJ1ZSxcImxpdmluZy5tdXNldW1cIjp0cnVlLFwibGl2aW5naGlzdG9yeS5tdXNldW1cIjp0cnVlLFwibG9jYWxoaXN0b3J5Lm11c2V1bVwiOnRydWUsXCJsb25kb24ubXVzZXVtXCI6dHJ1ZSxcImxvc2FuZ2VsZXMubXVzZXVtXCI6dHJ1ZSxcImxvdXZyZS5tdXNldW1cIjp0cnVlLFwibG95YWxpc3QubXVzZXVtXCI6dHJ1ZSxcImx1Y2VybmUubXVzZXVtXCI6dHJ1ZSxcImx1eGVtYm91cmcubXVzZXVtXCI6dHJ1ZSxcImx1emVybi5tdXNldW1cIjp0cnVlLFwibWFkLm11c2V1bVwiOnRydWUsXCJtYWRyaWQubXVzZXVtXCI6dHJ1ZSxcIm1hbGxvcmNhLm11c2V1bVwiOnRydWUsXCJtYW5jaGVzdGVyLm11c2V1bVwiOnRydWUsXCJtYW5zaW9uLm11c2V1bVwiOnRydWUsXCJtYW5zaW9ucy5tdXNldW1cIjp0cnVlLFwibWFueC5tdXNldW1cIjp0cnVlLFwibWFyYnVyZy5tdXNldW1cIjp0cnVlLFwibWFyaXRpbWUubXVzZXVtXCI6dHJ1ZSxcIm1hcml0aW1vLm11c2V1bVwiOnRydWUsXCJtYXJ5bGFuZC5tdXNldW1cIjp0cnVlLFwibWFyeWxodXJzdC5tdXNldW1cIjp0cnVlLFwibWVkaWEubXVzZXVtXCI6dHJ1ZSxcIm1lZGljYWwubXVzZXVtXCI6dHJ1ZSxcIm1lZGl6aW5oaXN0b3Jpc2NoZXMubXVzZXVtXCI6dHJ1ZSxcIm1lZXJlcy5tdXNldW1cIjp0cnVlLFwibWVtb3JpYWwubXVzZXVtXCI6dHJ1ZSxcIm1lc2F2ZXJkZS5tdXNldW1cIjp0cnVlLFwibWljaGlnYW4ubXVzZXVtXCI6dHJ1ZSxcIm1pZGF0bGFudGljLm11c2V1bVwiOnRydWUsXCJtaWxpdGFyeS5tdXNldW1cIjp0cnVlLFwibWlsbC5tdXNldW1cIjp0cnVlLFwibWluZXJzLm11c2V1bVwiOnRydWUsXCJtaW5pbmcubXVzZXVtXCI6dHJ1ZSxcIm1pbm5lc290YS5tdXNldW1cIjp0cnVlLFwibWlzc2lsZS5tdXNldW1cIjp0cnVlLFwibWlzc291bGEubXVzZXVtXCI6dHJ1ZSxcIm1vZGVybi5tdXNldW1cIjp0cnVlLFwibW9tYS5tdXNldW1cIjp0cnVlLFwibW9uZXkubXVzZXVtXCI6dHJ1ZSxcIm1vbm1vdXRoLm11c2V1bVwiOnRydWUsXCJtb250aWNlbGxvLm11c2V1bVwiOnRydWUsXCJtb250cmVhbC5tdXNldW1cIjp0cnVlLFwibW9zY293Lm11c2V1bVwiOnRydWUsXCJtb3RvcmN5Y2xlLm11c2V1bVwiOnRydWUsXCJtdWVuY2hlbi5tdXNldW1cIjp0cnVlLFwibXVlbnN0ZXIubXVzZXVtXCI6dHJ1ZSxcIm11bGhvdXNlLm11c2V1bVwiOnRydWUsXCJtdW5jaWUubXVzZXVtXCI6dHJ1ZSxcIm11c2VldC5tdXNldW1cIjp0cnVlLFwibXVzZXVtY2VudGVyLm11c2V1bVwiOnRydWUsXCJtdXNldW12ZXJlbmlnaW5nLm11c2V1bVwiOnRydWUsXCJtdXNpYy5tdXNldW1cIjp0cnVlLFwibmF0aW9uYWwubXVzZXVtXCI6dHJ1ZSxcIm5hdGlvbmFsZmlyZWFybXMubXVzZXVtXCI6dHJ1ZSxcIm5hdGlvbmFsaGVyaXRhZ2UubXVzZXVtXCI6dHJ1ZSxcIm5hdGl2ZWFtZXJpY2FuLm11c2V1bVwiOnRydWUsXCJuYXR1cmFsaGlzdG9yeS5tdXNldW1cIjp0cnVlLFwibmF0dXJhbGhpc3RvcnltdXNldW0ubXVzZXVtXCI6dHJ1ZSxcIm5hdHVyYWxzY2llbmNlcy5tdXNldW1cIjp0cnVlLFwibmF0dXJlLm11c2V1bVwiOnRydWUsXCJuYXR1cmhpc3RvcmlzY2hlcy5tdXNldW1cIjp0cnVlLFwibmF0dXVyd2V0ZW5zY2hhcHBlbi5tdXNldW1cIjp0cnVlLFwibmF1bWJ1cmcubXVzZXVtXCI6dHJ1ZSxcIm5hdmFsLm11c2V1bVwiOnRydWUsXCJuZWJyYXNrYS5tdXNldW1cIjp0cnVlLFwibmV1ZXMubXVzZXVtXCI6dHJ1ZSxcIm5ld2hhbXBzaGlyZS5tdXNldW1cIjp0cnVlLFwibmV3amVyc2V5Lm11c2V1bVwiOnRydWUsXCJuZXdtZXhpY28ubXVzZXVtXCI6dHJ1ZSxcIm5ld3BvcnQubXVzZXVtXCI6dHJ1ZSxcIm5ld3NwYXBlci5tdXNldW1cIjp0cnVlLFwibmV3eW9yay5tdXNldW1cIjp0cnVlLFwibmllcGNlLm11c2V1bVwiOnRydWUsXCJub3Jmb2xrLm11c2V1bVwiOnRydWUsXCJub3J0aC5tdXNldW1cIjp0cnVlLFwibnJ3Lm11c2V1bVwiOnRydWUsXCJudWVybmJlcmcubXVzZXVtXCI6dHJ1ZSxcIm51cmVtYmVyZy5tdXNldW1cIjp0cnVlLFwibnljLm11c2V1bVwiOnRydWUsXCJueW55Lm11c2V1bVwiOnRydWUsXCJvY2Vhbm9ncmFwaGljLm11c2V1bVwiOnRydWUsXCJvY2Vhbm9ncmFwaGlxdWUubXVzZXVtXCI6dHJ1ZSxcIm9tYWhhLm11c2V1bVwiOnRydWUsXCJvbmxpbmUubXVzZXVtXCI6dHJ1ZSxcIm9udGFyaW8ubXVzZXVtXCI6dHJ1ZSxcIm9wZW5haXIubXVzZXVtXCI6dHJ1ZSxcIm9yZWdvbi5tdXNldW1cIjp0cnVlLFwib3JlZ29udHJhaWwubXVzZXVtXCI6dHJ1ZSxcIm90YWdvLm11c2V1bVwiOnRydWUsXCJveGZvcmQubXVzZXVtXCI6dHJ1ZSxcInBhY2lmaWMubXVzZXVtXCI6dHJ1ZSxcInBhZGVyYm9ybi5tdXNldW1cIjp0cnVlLFwicGFsYWNlLm11c2V1bVwiOnRydWUsXCJwYWxlby5tdXNldW1cIjp0cnVlLFwicGFsbXNwcmluZ3MubXVzZXVtXCI6dHJ1ZSxcInBhbmFtYS5tdXNldW1cIjp0cnVlLFwicGFyaXMubXVzZXVtXCI6dHJ1ZSxcInBhc2FkZW5hLm11c2V1bVwiOnRydWUsXCJwaGFybWFjeS5tdXNldW1cIjp0cnVlLFwicGhpbGFkZWxwaGlhLm11c2V1bVwiOnRydWUsXCJwaGlsYWRlbHBoaWFhcmVhLm11c2V1bVwiOnRydWUsXCJwaGlsYXRlbHkubXVzZXVtXCI6dHJ1ZSxcInBob2VuaXgubXVzZXVtXCI6dHJ1ZSxcInBob3RvZ3JhcGh5Lm11c2V1bVwiOnRydWUsXCJwaWxvdHMubXVzZXVtXCI6dHJ1ZSxcInBpdHRzYnVyZ2gubXVzZXVtXCI6dHJ1ZSxcInBsYW5ldGFyaXVtLm11c2V1bVwiOnRydWUsXCJwbGFudGF0aW9uLm11c2V1bVwiOnRydWUsXCJwbGFudHMubXVzZXVtXCI6dHJ1ZSxcInBsYXphLm11c2V1bVwiOnRydWUsXCJwb3J0YWwubXVzZXVtXCI6dHJ1ZSxcInBvcnRsYW5kLm11c2V1bVwiOnRydWUsXCJwb3J0bGxpZ2F0Lm11c2V1bVwiOnRydWUsXCJwb3N0cy1hbmQtdGVsZWNvbW11bmljYXRpb25zLm11c2V1bVwiOnRydWUsXCJwcmVzZXJ2YXRpb24ubXVzZXVtXCI6dHJ1ZSxcInByZXNpZGlvLm11c2V1bVwiOnRydWUsXCJwcmVzcy5tdXNldW1cIjp0cnVlLFwicHJvamVjdC5tdXNldW1cIjp0cnVlLFwicHVibGljLm11c2V1bVwiOnRydWUsXCJwdWJvbC5tdXNldW1cIjp0cnVlLFwicXVlYmVjLm11c2V1bVwiOnRydWUsXCJyYWlscm9hZC5tdXNldW1cIjp0cnVlLFwicmFpbHdheS5tdXNldW1cIjp0cnVlLFwicmVzZWFyY2gubXVzZXVtXCI6dHJ1ZSxcInJlc2lzdGFuY2UubXVzZXVtXCI6dHJ1ZSxcInJpb2RlamFuZWlyby5tdXNldW1cIjp0cnVlLFwicm9jaGVzdGVyLm11c2V1bVwiOnRydWUsXCJyb2NrYXJ0Lm11c2V1bVwiOnRydWUsXCJyb21hLm11c2V1bVwiOnRydWUsXCJydXNzaWEubXVzZXVtXCI6dHJ1ZSxcInNhaW50bG91aXMubXVzZXVtXCI6dHJ1ZSxcInNhbGVtLm11c2V1bVwiOnRydWUsXCJzYWx2YWRvcmRhbGkubXVzZXVtXCI6dHJ1ZSxcInNhbHpidXJnLm11c2V1bVwiOnRydWUsXCJzYW5kaWVnby5tdXNldW1cIjp0cnVlLFwic2FuZnJhbmNpc2NvLm11c2V1bVwiOnRydWUsXCJzYW50YWJhcmJhcmEubXVzZXVtXCI6dHJ1ZSxcInNhbnRhY3J1ei5tdXNldW1cIjp0cnVlLFwic2FudGFmZS5tdXNldW1cIjp0cnVlLFwic2Fza2F0Y2hld2FuLm11c2V1bVwiOnRydWUsXCJzYXR4Lm11c2V1bVwiOnRydWUsXCJzYXZhbm5haGdhLm11c2V1bVwiOnRydWUsXCJzY2hsZXNpc2NoZXMubXVzZXVtXCI6dHJ1ZSxcInNjaG9lbmJydW5uLm11c2V1bVwiOnRydWUsXCJzY2hva29sYWRlbi5tdXNldW1cIjp0cnVlLFwic2Nob29sLm11c2V1bVwiOnRydWUsXCJzY2h3ZWl6Lm11c2V1bVwiOnRydWUsXCJzY2llbmNlLm11c2V1bVwiOnRydWUsXCJzY2llbmNlYW5kaGlzdG9yeS5tdXNldW1cIjp0cnVlLFwic2NpZW5jZWFuZGluZHVzdHJ5Lm11c2V1bVwiOnRydWUsXCJzY2llbmNlY2VudGVyLm11c2V1bVwiOnRydWUsXCJzY2llbmNlY2VudGVycy5tdXNldW1cIjp0cnVlLFwic2NpZW5jZS1maWN0aW9uLm11c2V1bVwiOnRydWUsXCJzY2llbmNlaGlzdG9yeS5tdXNldW1cIjp0cnVlLFwic2NpZW5jZXMubXVzZXVtXCI6dHJ1ZSxcInNjaWVuY2VzbmF0dXJlbGxlcy5tdXNldW1cIjp0cnVlLFwic2NvdGxhbmQubXVzZXVtXCI6dHJ1ZSxcInNlYXBvcnQubXVzZXVtXCI6dHJ1ZSxcInNldHRsZW1lbnQubXVzZXVtXCI6dHJ1ZSxcInNldHRsZXJzLm11c2V1bVwiOnRydWUsXCJzaGVsbC5tdXNldW1cIjp0cnVlLFwic2hlcmJyb29rZS5tdXNldW1cIjp0cnVlLFwic2liZW5pay5tdXNldW1cIjp0cnVlLFwic2lsay5tdXNldW1cIjp0cnVlLFwic2tpLm11c2V1bVwiOnRydWUsXCJza29sZS5tdXNldW1cIjp0cnVlLFwic29jaWV0eS5tdXNldW1cIjp0cnVlLFwic29sb2duZS5tdXNldW1cIjp0cnVlLFwic291bmRhbmR2aXNpb24ubXVzZXVtXCI6dHJ1ZSxcInNvdXRoY2Fyb2xpbmEubXVzZXVtXCI6dHJ1ZSxcInNvdXRod2VzdC5tdXNldW1cIjp0cnVlLFwic3BhY2UubXVzZXVtXCI6dHJ1ZSxcInNweS5tdXNldW1cIjp0cnVlLFwic3F1YXJlLm11c2V1bVwiOnRydWUsXCJzdGFkdC5tdXNldW1cIjp0cnVlLFwic3RhbGJhbnMubXVzZXVtXCI6dHJ1ZSxcInN0YXJuYmVyZy5tdXNldW1cIjp0cnVlLFwic3RhdGUubXVzZXVtXCI6dHJ1ZSxcInN0YXRlb2ZkZWxhd2FyZS5tdXNldW1cIjp0cnVlLFwic3RhdGlvbi5tdXNldW1cIjp0cnVlLFwic3RlYW0ubXVzZXVtXCI6dHJ1ZSxcInN0ZWllcm1hcmsubXVzZXVtXCI6dHJ1ZSxcInN0am9obi5tdXNldW1cIjp0cnVlLFwic3RvY2tob2xtLm11c2V1bVwiOnRydWUsXCJzdHBldGVyc2J1cmcubXVzZXVtXCI6dHJ1ZSxcInN0dXR0Z2FydC5tdXNldW1cIjp0cnVlLFwic3Vpc3NlLm11c2V1bVwiOnRydWUsXCJzdXJnZW9uc2hhbGwubXVzZXVtXCI6dHJ1ZSxcInN1cnJleS5tdXNldW1cIjp0cnVlLFwic3ZpenplcmEubXVzZXVtXCI6dHJ1ZSxcInN3ZWRlbi5tdXNldW1cIjp0cnVlLFwic3lkbmV5Lm11c2V1bVwiOnRydWUsXCJ0YW5rLm11c2V1bVwiOnRydWUsXCJ0Y20ubXVzZXVtXCI6dHJ1ZSxcInRlY2hub2xvZ3kubXVzZXVtXCI6dHJ1ZSxcInRlbGVrb21tdW5pa2F0aW9uLm11c2V1bVwiOnRydWUsXCJ0ZWxldmlzaW9uLm11c2V1bVwiOnRydWUsXCJ0ZXhhcy5tdXNldW1cIjp0cnVlLFwidGV4dGlsZS5tdXNldW1cIjp0cnVlLFwidGhlYXRlci5tdXNldW1cIjp0cnVlLFwidGltZS5tdXNldW1cIjp0cnVlLFwidGltZWtlZXBpbmcubXVzZXVtXCI6dHJ1ZSxcInRvcG9sb2d5Lm11c2V1bVwiOnRydWUsXCJ0b3Jpbm8ubXVzZXVtXCI6dHJ1ZSxcInRvdWNoLm11c2V1bVwiOnRydWUsXCJ0b3duLm11c2V1bVwiOnRydWUsXCJ0cmFuc3BvcnQubXVzZXVtXCI6dHJ1ZSxcInRyZWUubXVzZXVtXCI6dHJ1ZSxcInRyb2xsZXkubXVzZXVtXCI6dHJ1ZSxcInRydXN0Lm11c2V1bVwiOnRydWUsXCJ0cnVzdGVlLm11c2V1bVwiOnRydWUsXCJ1aHJlbi5tdXNldW1cIjp0cnVlLFwidWxtLm11c2V1bVwiOnRydWUsXCJ1bmRlcnNlYS5tdXNldW1cIjp0cnVlLFwidW5pdmVyc2l0eS5tdXNldW1cIjp0cnVlLFwidXNhLm11c2V1bVwiOnRydWUsXCJ1c2FudGlxdWVzLm11c2V1bVwiOnRydWUsXCJ1c2FydHMubXVzZXVtXCI6dHJ1ZSxcInVzY291bnRyeWVzdGF0ZS5tdXNldW1cIjp0cnVlLFwidXNjdWx0dXJlLm11c2V1bVwiOnRydWUsXCJ1c2RlY29yYXRpdmVhcnRzLm11c2V1bVwiOnRydWUsXCJ1c2dhcmRlbi5tdXNldW1cIjp0cnVlLFwidXNoaXN0b3J5Lm11c2V1bVwiOnRydWUsXCJ1c2h1YWlhLm11c2V1bVwiOnRydWUsXCJ1c2xpdmluZ2hpc3RvcnkubXVzZXVtXCI6dHJ1ZSxcInV0YWgubXVzZXVtXCI6dHJ1ZSxcInV2aWMubXVzZXVtXCI6dHJ1ZSxcInZhbGxleS5tdXNldW1cIjp0cnVlLFwidmFudGFhLm11c2V1bVwiOnRydWUsXCJ2ZXJzYWlsbGVzLm11c2V1bVwiOnRydWUsXCJ2aWtpbmcubXVzZXVtXCI6dHJ1ZSxcInZpbGxhZ2UubXVzZXVtXCI6dHJ1ZSxcInZpcmdpbmlhLm11c2V1bVwiOnRydWUsXCJ2aXJ0dWFsLm11c2V1bVwiOnRydWUsXCJ2aXJ0dWVsLm11c2V1bVwiOnRydWUsXCJ2bGFhbmRlcmVuLm11c2V1bVwiOnRydWUsXCJ2b2xrZW5rdW5kZS5tdXNldW1cIjp0cnVlLFwid2FsZXMubXVzZXVtXCI6dHJ1ZSxcIndhbGxvbmllLm11c2V1bVwiOnRydWUsXCJ3YXIubXVzZXVtXCI6dHJ1ZSxcIndhc2hpbmd0b25kYy5tdXNldW1cIjp0cnVlLFwid2F0Y2hhbmRjbG9jay5tdXNldW1cIjp0cnVlLFwid2F0Y2gtYW5kLWNsb2NrLm11c2V1bVwiOnRydWUsXCJ3ZXN0ZXJuLm11c2V1bVwiOnRydWUsXCJ3ZXN0ZmFsZW4ubXVzZXVtXCI6dHJ1ZSxcIndoYWxpbmcubXVzZXVtXCI6dHJ1ZSxcIndpbGRsaWZlLm11c2V1bVwiOnRydWUsXCJ3aWxsaWFtc2J1cmcubXVzZXVtXCI6dHJ1ZSxcIndpbmRtaWxsLm11c2V1bVwiOnRydWUsXCJ3b3Jrc2hvcC5tdXNldW1cIjp0cnVlLFwieW9yay5tdXNldW1cIjp0cnVlLFwieW9ya3NoaXJlLm11c2V1bVwiOnRydWUsXCJ5b3NlbWl0ZS5tdXNldW1cIjp0cnVlLFwieW91dGgubXVzZXVtXCI6dHJ1ZSxcInpvb2xvZ2ljYWwubXVzZXVtXCI6dHJ1ZSxcInpvb2xvZ3kubXVzZXVtXCI6dHJ1ZSxcInhuLS05ZGJoYmxnNmRpLm11c2V1bVwiOnRydWUsXCJ4bi0taDFhZWdoLm11c2V1bVwiOnRydWUsXCJtdlwiOnRydWUsXCJhZXJvLm12XCI6dHJ1ZSxcImJpei5tdlwiOnRydWUsXCJjb20ubXZcIjp0cnVlLFwiY29vcC5tdlwiOnRydWUsXCJlZHUubXZcIjp0cnVlLFwiZ292Lm12XCI6dHJ1ZSxcImluZm8ubXZcIjp0cnVlLFwiaW50Lm12XCI6dHJ1ZSxcIm1pbC5tdlwiOnRydWUsXCJtdXNldW0ubXZcIjp0cnVlLFwibmFtZS5tdlwiOnRydWUsXCJuZXQubXZcIjp0cnVlLFwib3JnLm12XCI6dHJ1ZSxcInByby5tdlwiOnRydWUsXCJtd1wiOnRydWUsXCJhYy5td1wiOnRydWUsXCJiaXoubXdcIjp0cnVlLFwiY28ubXdcIjp0cnVlLFwiY29tLm13XCI6dHJ1ZSxcImNvb3AubXdcIjp0cnVlLFwiZWR1Lm13XCI6dHJ1ZSxcImdvdi5td1wiOnRydWUsXCJpbnQubXdcIjp0cnVlLFwibXVzZXVtLm13XCI6dHJ1ZSxcIm5ldC5td1wiOnRydWUsXCJvcmcubXdcIjp0cnVlLFwibXhcIjp0cnVlLFwiY29tLm14XCI6dHJ1ZSxcIm9yZy5teFwiOnRydWUsXCJnb2IubXhcIjp0cnVlLFwiZWR1Lm14XCI6dHJ1ZSxcIm5ldC5teFwiOnRydWUsXCJteVwiOnRydWUsXCJjb20ubXlcIjp0cnVlLFwibmV0Lm15XCI6dHJ1ZSxcIm9yZy5teVwiOnRydWUsXCJnb3YubXlcIjp0cnVlLFwiZWR1Lm15XCI6dHJ1ZSxcIm1pbC5teVwiOnRydWUsXCJuYW1lLm15XCI6dHJ1ZSxcIioubXpcIjp0cnVlLFwidGVsZWRhdGEubXpcIjpmYWxzZSxcIm5hXCI6dHJ1ZSxcImluZm8ubmFcIjp0cnVlLFwicHJvLm5hXCI6dHJ1ZSxcIm5hbWUubmFcIjp0cnVlLFwic2Nob29sLm5hXCI6dHJ1ZSxcIm9yLm5hXCI6dHJ1ZSxcImRyLm5hXCI6dHJ1ZSxcInVzLm5hXCI6dHJ1ZSxcIm14Lm5hXCI6dHJ1ZSxcImNhLm5hXCI6dHJ1ZSxcImluLm5hXCI6dHJ1ZSxcImNjLm5hXCI6dHJ1ZSxcInR2Lm5hXCI6dHJ1ZSxcIndzLm5hXCI6dHJ1ZSxcIm1vYmkubmFcIjp0cnVlLFwiY28ubmFcIjp0cnVlLFwiY29tLm5hXCI6dHJ1ZSxcIm9yZy5uYVwiOnRydWUsXCJuYW1lXCI6dHJ1ZSxcIm5jXCI6dHJ1ZSxcImFzc28ubmNcIjp0cnVlLFwibmVcIjp0cnVlLFwibmV0XCI6dHJ1ZSxcIm5mXCI6dHJ1ZSxcImNvbS5uZlwiOnRydWUsXCJuZXQubmZcIjp0cnVlLFwicGVyLm5mXCI6dHJ1ZSxcInJlYy5uZlwiOnRydWUsXCJ3ZWIubmZcIjp0cnVlLFwiYXJ0cy5uZlwiOnRydWUsXCJmaXJtLm5mXCI6dHJ1ZSxcImluZm8ubmZcIjp0cnVlLFwib3RoZXIubmZcIjp0cnVlLFwic3RvcmUubmZcIjp0cnVlLFwibmdcIjp0cnVlLFwiY29tLm5nXCI6dHJ1ZSxcImVkdS5uZ1wiOnRydWUsXCJuYW1lLm5nXCI6dHJ1ZSxcIm5ldC5uZ1wiOnRydWUsXCJvcmcubmdcIjp0cnVlLFwic2NoLm5nXCI6dHJ1ZSxcImdvdi5uZ1wiOnRydWUsXCJtaWwubmdcIjp0cnVlLFwibW9iaS5uZ1wiOnRydWUsXCIqLm5pXCI6dHJ1ZSxcIm5sXCI6dHJ1ZSxcImJ2Lm5sXCI6dHJ1ZSxcIm5vXCI6dHJ1ZSxcImZocy5ub1wiOnRydWUsXCJ2Z3Mubm9cIjp0cnVlLFwiZnlsa2VzYmlibC5ub1wiOnRydWUsXCJmb2xrZWJpYmwubm9cIjp0cnVlLFwibXVzZXVtLm5vXCI6dHJ1ZSxcImlkcmV0dC5ub1wiOnRydWUsXCJwcml2Lm5vXCI6dHJ1ZSxcIm1pbC5ub1wiOnRydWUsXCJzdGF0Lm5vXCI6dHJ1ZSxcImRlcC5ub1wiOnRydWUsXCJrb21tdW5lLm5vXCI6dHJ1ZSxcImhlcmFkLm5vXCI6dHJ1ZSxcImFhLm5vXCI6dHJ1ZSxcImFoLm5vXCI6dHJ1ZSxcImJ1Lm5vXCI6dHJ1ZSxcImZtLm5vXCI6dHJ1ZSxcImhsLm5vXCI6dHJ1ZSxcImhtLm5vXCI6dHJ1ZSxcImphbi1tYXllbi5ub1wiOnRydWUsXCJtci5ub1wiOnRydWUsXCJubC5ub1wiOnRydWUsXCJudC5ub1wiOnRydWUsXCJvZi5ub1wiOnRydWUsXCJvbC5ub1wiOnRydWUsXCJvc2xvLm5vXCI6dHJ1ZSxcInJsLm5vXCI6dHJ1ZSxcInNmLm5vXCI6dHJ1ZSxcInN0Lm5vXCI6dHJ1ZSxcInN2YWxiYXJkLm5vXCI6dHJ1ZSxcInRtLm5vXCI6dHJ1ZSxcInRyLm5vXCI6dHJ1ZSxcInZhLm5vXCI6dHJ1ZSxcInZmLm5vXCI6dHJ1ZSxcImdzLmFhLm5vXCI6dHJ1ZSxcImdzLmFoLm5vXCI6dHJ1ZSxcImdzLmJ1Lm5vXCI6dHJ1ZSxcImdzLmZtLm5vXCI6dHJ1ZSxcImdzLmhsLm5vXCI6dHJ1ZSxcImdzLmhtLm5vXCI6dHJ1ZSxcImdzLmphbi1tYXllbi5ub1wiOnRydWUsXCJncy5tci5ub1wiOnRydWUsXCJncy5ubC5ub1wiOnRydWUsXCJncy5udC5ub1wiOnRydWUsXCJncy5vZi5ub1wiOnRydWUsXCJncy5vbC5ub1wiOnRydWUsXCJncy5vc2xvLm5vXCI6dHJ1ZSxcImdzLnJsLm5vXCI6dHJ1ZSxcImdzLnNmLm5vXCI6dHJ1ZSxcImdzLnN0Lm5vXCI6dHJ1ZSxcImdzLnN2YWxiYXJkLm5vXCI6dHJ1ZSxcImdzLnRtLm5vXCI6dHJ1ZSxcImdzLnRyLm5vXCI6dHJ1ZSxcImdzLnZhLm5vXCI6dHJ1ZSxcImdzLnZmLm5vXCI6dHJ1ZSxcImFrcmVoYW1uLm5vXCI6dHJ1ZSxcInhuLS1rcmVoYW1uLWR4YS5ub1wiOnRydWUsXCJhbGdhcmQubm9cIjp0cnVlLFwieG4tLWxncmQtcG9hYy5ub1wiOnRydWUsXCJhcm5hLm5vXCI6dHJ1ZSxcImJydW11bmRkYWwubm9cIjp0cnVlLFwiYnJ5bmUubm9cIjp0cnVlLFwiYnJvbm5veXN1bmQubm9cIjp0cnVlLFwieG4tLWJybm55c3VuZC1tOGFjLm5vXCI6dHJ1ZSxcImRyb2Jhay5ub1wiOnRydWUsXCJ4bi0tZHJiYWstd3VhLm5vXCI6dHJ1ZSxcImVnZXJzdW5kLm5vXCI6dHJ1ZSxcImZldHN1bmQubm9cIjp0cnVlLFwiZmxvcm8ubm9cIjp0cnVlLFwieG4tLWZsb3ItanJhLm5vXCI6dHJ1ZSxcImZyZWRyaWtzdGFkLm5vXCI6dHJ1ZSxcImhva2tzdW5kLm5vXCI6dHJ1ZSxcImhvbmVmb3NzLm5vXCI6dHJ1ZSxcInhuLS1obmVmb3NzLXExYS5ub1wiOnRydWUsXCJqZXNzaGVpbS5ub1wiOnRydWUsXCJqb3JwZWxhbmQubm9cIjp0cnVlLFwieG4tLWpycGVsYW5kLTU0YS5ub1wiOnRydWUsXCJraXJrZW5lcy5ub1wiOnRydWUsXCJrb3BlcnZpay5ub1wiOnRydWUsXCJrcm9rc3RhZGVsdmEubm9cIjp0cnVlLFwibGFuZ2V2YWcubm9cIjp0cnVlLFwieG4tLWxhbmdldmctanhhLm5vXCI6dHJ1ZSxcImxlaXJ2aWsubm9cIjp0cnVlLFwibWpvbmRhbGVuLm5vXCI6dHJ1ZSxcInhuLS1tam5kYWxlbi02NGEubm9cIjp0cnVlLFwibW8taS1yYW5hLm5vXCI6dHJ1ZSxcIm1vc2pvZW4ubm9cIjp0cnVlLFwieG4tLW1vc2plbi1leWEubm9cIjp0cnVlLFwibmVzb2RkdGFuZ2VuLm5vXCI6dHJ1ZSxcIm9ya2FuZ2VyLm5vXCI6dHJ1ZSxcIm9zb3lyby5ub1wiOnRydWUsXCJ4bi0tb3N5cm8td3VhLm5vXCI6dHJ1ZSxcInJhaG9sdC5ub1wiOnRydWUsXCJ4bi0tcmhvbHQtbXJhLm5vXCI6dHJ1ZSxcInNhbmRuZXNzam9lbi5ub1wiOnRydWUsXCJ4bi0tc2FuZG5lc3NqZW4tb2diLm5vXCI6dHJ1ZSxcInNrZWRzbW9rb3JzZXQubm9cIjp0cnVlLFwic2xhdHR1bS5ub1wiOnRydWUsXCJzcGplbGthdmlrLm5vXCI6dHJ1ZSxcInN0YXRoZWxsZS5ub1wiOnRydWUsXCJzdGF2ZXJuLm5vXCI6dHJ1ZSxcInN0am9yZGFsc2hhbHNlbi5ub1wiOnRydWUsXCJ4bi0tc3RqcmRhbHNoYWxzZW4tc3FiLm5vXCI6dHJ1ZSxcInRhbmFuZ2VyLm5vXCI6dHJ1ZSxcInRyYW5ieS5ub1wiOnRydWUsXCJ2b3NzZXZhbmdlbi5ub1wiOnRydWUsXCJhZmpvcmQubm9cIjp0cnVlLFwieG4tLWZqb3JkLWxyYS5ub1wiOnRydWUsXCJhZ2RlbmVzLm5vXCI6dHJ1ZSxcImFsLm5vXCI6dHJ1ZSxcInhuLS1sLTFmYS5ub1wiOnRydWUsXCJhbGVzdW5kLm5vXCI6dHJ1ZSxcInhuLS1sZXN1bmQtaHVhLm5vXCI6dHJ1ZSxcImFsc3RhaGF1Zy5ub1wiOnRydWUsXCJhbHRhLm5vXCI6dHJ1ZSxcInhuLS1sdC1saWFjLm5vXCI6dHJ1ZSxcImFsYWhlYWRqdS5ub1wiOnRydWUsXCJ4bi0tbGFoZWFkanUtN3lhLm5vXCI6dHJ1ZSxcImFsdmRhbC5ub1wiOnRydWUsXCJhbWxpLm5vXCI6dHJ1ZSxcInhuLS1tbGktdGxhLm5vXCI6dHJ1ZSxcImFtb3Qubm9cIjp0cnVlLFwieG4tLW1vdC10bGEubm9cIjp0cnVlLFwiYW5kZWJ1Lm5vXCI6dHJ1ZSxcImFuZG95Lm5vXCI6dHJ1ZSxcInhuLS1hbmR5LWlyYS5ub1wiOnRydWUsXCJhbmRhc3VvbG8ubm9cIjp0cnVlLFwiYXJkYWwubm9cIjp0cnVlLFwieG4tLXJkYWwtcG9hLm5vXCI6dHJ1ZSxcImFyZW1hcmsubm9cIjp0cnVlLFwiYXJlbmRhbC5ub1wiOnRydWUsXCJ4bi0tcy0xZmEubm9cIjp0cnVlLFwiYXNlcmFsLm5vXCI6dHJ1ZSxcInhuLS1zZXJhbC1scmEubm9cIjp0cnVlLFwiYXNrZXIubm9cIjp0cnVlLFwiYXNraW0ubm9cIjp0cnVlLFwiYXNrdm9sbC5ub1wiOnRydWUsXCJhc2tveS5ub1wiOnRydWUsXCJ4bi0tYXNreS1pcmEubm9cIjp0cnVlLFwiYXNuZXMubm9cIjp0cnVlLFwieG4tLXNuZXMtcG9hLm5vXCI6dHJ1ZSxcImF1ZG5lZGFsbi5ub1wiOnRydWUsXCJhdWtyYS5ub1wiOnRydWUsXCJhdXJlLm5vXCI6dHJ1ZSxcImF1cmxhbmQubm9cIjp0cnVlLFwiYXVyc2tvZy1ob2xhbmQubm9cIjp0cnVlLFwieG4tLWF1cnNrb2ctaGxhbmQtam5iLm5vXCI6dHJ1ZSxcImF1c3Rldm9sbC5ub1wiOnRydWUsXCJhdXN0cmhlaW0ubm9cIjp0cnVlLFwiYXZlcm95Lm5vXCI6dHJ1ZSxcInhuLS1hdmVyeS15dWEubm9cIjp0cnVlLFwiYmFsZXN0cmFuZC5ub1wiOnRydWUsXCJiYWxsYW5nZW4ubm9cIjp0cnVlLFwiYmFsYXQubm9cIjp0cnVlLFwieG4tLWJsdC1lbGFiLm5vXCI6dHJ1ZSxcImJhbHNmam9yZC5ub1wiOnRydWUsXCJiYWhjY2F2dW90bmEubm9cIjp0cnVlLFwieG4tLWJoY2NhdnVvdG5hLWs3YS5ub1wiOnRydWUsXCJiYW1ibGUubm9cIjp0cnVlLFwiYmFyZHUubm9cIjp0cnVlLFwiYmVhcmR1Lm5vXCI6dHJ1ZSxcImJlaWFybi5ub1wiOnRydWUsXCJiYWpkZGFyLm5vXCI6dHJ1ZSxcInhuLS1iamRkYXItcHRhLm5vXCI6dHJ1ZSxcImJhaWRhci5ub1wiOnRydWUsXCJ4bi0tYmlkci01bmFjLm5vXCI6dHJ1ZSxcImJlcmcubm9cIjp0cnVlLFwiYmVyZ2VuLm5vXCI6dHJ1ZSxcImJlcmxldmFnLm5vXCI6dHJ1ZSxcInhuLS1iZXJsZXZnLWp4YS5ub1wiOnRydWUsXCJiZWFyYWx2YWhraS5ub1wiOnRydWUsXCJ4bi0tYmVhcmFsdmhraS15NGEubm9cIjp0cnVlLFwiYmluZGFsLm5vXCI6dHJ1ZSxcImJpcmtlbmVzLm5vXCI6dHJ1ZSxcImJqYXJrb3kubm9cIjp0cnVlLFwieG4tLWJqYXJreS1meWEubm9cIjp0cnVlLFwiYmplcmtyZWltLm5vXCI6dHJ1ZSxcImJqdWduLm5vXCI6dHJ1ZSxcImJvZG8ubm9cIjp0cnVlLFwieG4tLWJvZC0ybmEubm9cIjp0cnVlLFwiYmFkYWRkamEubm9cIjp0cnVlLFwieG4tLWJkZGRqLW1yYWJkLm5vXCI6dHJ1ZSxcImJ1ZGVqanUubm9cIjp0cnVlLFwiYm9rbi5ub1wiOnRydWUsXCJicmVtYW5nZXIubm9cIjp0cnVlLFwiYnJvbm5veS5ub1wiOnRydWUsXCJ4bi0tYnJubnktd3VhYy5ub1wiOnRydWUsXCJieWdsYW5kLm5vXCI6dHJ1ZSxcImJ5a2xlLm5vXCI6dHJ1ZSxcImJhcnVtLm5vXCI6dHJ1ZSxcInhuLS1icnVtLXZvYS5ub1wiOnRydWUsXCJiby50ZWxlbWFyay5ub1wiOnRydWUsXCJ4bi0tYi01Z2EudGVsZW1hcmsubm9cIjp0cnVlLFwiYm8ubm9yZGxhbmQubm9cIjp0cnVlLFwieG4tLWItNWdhLm5vcmRsYW5kLm5vXCI6dHJ1ZSxcImJpZXZhdC5ub1wiOnRydWUsXCJ4bi0tYmlldnQtMHFhLm5vXCI6dHJ1ZSxcImJvbWxvLm5vXCI6dHJ1ZSxcInhuLS1ibWxvLWdyYS5ub1wiOnRydWUsXCJiYXRzZmpvcmQubm9cIjp0cnVlLFwieG4tLWJ0c2Zqb3JkLTl6YS5ub1wiOnRydWUsXCJiYWhjYXZ1b3RuYS5ub1wiOnRydWUsXCJ4bi0tYmhjYXZ1b3RuYS1zNGEubm9cIjp0cnVlLFwiZG92cmUubm9cIjp0cnVlLFwiZHJhbW1lbi5ub1wiOnRydWUsXCJkcmFuZ2VkYWwubm9cIjp0cnVlLFwiZHlyb3kubm9cIjp0cnVlLFwieG4tLWR5cnktaXJhLm5vXCI6dHJ1ZSxcImRvbm5hLm5vXCI6dHJ1ZSxcInhuLS1kbm5hLWdyYS5ub1wiOnRydWUsXCJlaWQubm9cIjp0cnVlLFwiZWlkZmpvcmQubm9cIjp0cnVlLFwiZWlkc2Jlcmcubm9cIjp0cnVlLFwiZWlkc2tvZy5ub1wiOnRydWUsXCJlaWRzdm9sbC5ub1wiOnRydWUsXCJlaWdlcnN1bmQubm9cIjp0cnVlLFwiZWx2ZXJ1bS5ub1wiOnRydWUsXCJlbmViYWtrLm5vXCI6dHJ1ZSxcImVuZ2VyZGFsLm5vXCI6dHJ1ZSxcImV0bmUubm9cIjp0cnVlLFwiZXRuZWRhbC5ub1wiOnRydWUsXCJldmVuZXMubm9cIjp0cnVlLFwiZXZlbmFzc2kubm9cIjp0cnVlLFwieG4tLWV2ZW5pLTBxYTAxZ2Eubm9cIjp0cnVlLFwiZXZqZS1vZy1ob3JubmVzLm5vXCI6dHJ1ZSxcImZhcnN1bmQubm9cIjp0cnVlLFwiZmF1c2tlLm5vXCI6dHJ1ZSxcImZ1b3Nza28ubm9cIjp0cnVlLFwiZnVvaXNrdS5ub1wiOnRydWUsXCJmZWRqZS5ub1wiOnRydWUsXCJmZXQubm9cIjp0cnVlLFwiZmlubm95Lm5vXCI6dHJ1ZSxcInhuLS1maW5ueS15dWEubm9cIjp0cnVlLFwiZml0amFyLm5vXCI6dHJ1ZSxcImZqYWxlci5ub1wiOnRydWUsXCJmamVsbC5ub1wiOnRydWUsXCJmbGFrc3RhZC5ub1wiOnRydWUsXCJmbGF0YW5nZXIubm9cIjp0cnVlLFwiZmxla2tlZmpvcmQubm9cIjp0cnVlLFwiZmxlc2Jlcmcubm9cIjp0cnVlLFwiZmxvcmEubm9cIjp0cnVlLFwiZmxhLm5vXCI6dHJ1ZSxcInhuLS1mbC16aWEubm9cIjp0cnVlLFwiZm9sbGRhbC5ub1wiOnRydWUsXCJmb3JzYW5kLm5vXCI6dHJ1ZSxcImZvc25lcy5ub1wiOnRydWUsXCJmcmVpLm5vXCI6dHJ1ZSxcImZyb2duLm5vXCI6dHJ1ZSxcImZyb2xhbmQubm9cIjp0cnVlLFwiZnJvc3RhLm5vXCI6dHJ1ZSxcImZyYW5hLm5vXCI6dHJ1ZSxcInhuLS1mcm5hLXdvYS5ub1wiOnRydWUsXCJmcm95YS5ub1wiOnRydWUsXCJ4bi0tZnJ5YS1ocmEubm9cIjp0cnVlLFwiZnVzYS5ub1wiOnRydWUsXCJmeXJlc2RhbC5ub1wiOnRydWUsXCJmb3JkZS5ub1wiOnRydWUsXCJ4bi0tZnJkZS1ncmEubm9cIjp0cnVlLFwiZ2FtdmlrLm5vXCI6dHJ1ZSxcImdhbmdhdmlpa2Eubm9cIjp0cnVlLFwieG4tLWdnYXZpaWthLTh5YTQ3aC5ub1wiOnRydWUsXCJnYXVsYXIubm9cIjp0cnVlLFwiZ2F1c2RhbC5ub1wiOnRydWUsXCJnaWxkZXNrYWwubm9cIjp0cnVlLFwieG4tLWdpbGRlc2tsLWcwYS5ub1wiOnRydWUsXCJnaXNrZS5ub1wiOnRydWUsXCJnamVtbmVzLm5vXCI6dHJ1ZSxcImdqZXJkcnVtLm5vXCI6dHJ1ZSxcImdqZXJzdGFkLm5vXCI6dHJ1ZSxcImdqZXNkYWwubm9cIjp0cnVlLFwiZ2pvdmlrLm5vXCI6dHJ1ZSxcInhuLS1nanZpay13dWEubm9cIjp0cnVlLFwiZ2xvcHBlbi5ub1wiOnRydWUsXCJnb2wubm9cIjp0cnVlLFwiZ3Jhbi5ub1wiOnRydWUsXCJncmFuZS5ub1wiOnRydWUsXCJncmFudmluLm5vXCI6dHJ1ZSxcImdyYXRhbmdlbi5ub1wiOnRydWUsXCJncmltc3RhZC5ub1wiOnRydWUsXCJncm9uZy5ub1wiOnRydWUsXCJrcmFhbmdoa2Uubm9cIjp0cnVlLFwieG4tLWtyYW5naGtlLWIwYS5ub1wiOnRydWUsXCJncnVlLm5vXCI6dHJ1ZSxcImd1bGVuLm5vXCI6dHJ1ZSxcImhhZHNlbC5ub1wiOnRydWUsXCJoYWxkZW4ubm9cIjp0cnVlLFwiaGFsc2Eubm9cIjp0cnVlLFwiaGFtYXIubm9cIjp0cnVlLFwiaGFtYXJveS5ub1wiOnRydWUsXCJoYWJtZXIubm9cIjp0cnVlLFwieG4tLWhibWVyLXhxYS5ub1wiOnRydWUsXCJoYXBtaXIubm9cIjp0cnVlLFwieG4tLWhwbWlyLXhxYS5ub1wiOnRydWUsXCJoYW1tZXJmZXN0Lm5vXCI6dHJ1ZSxcImhhbW1hcmZlYXN0YS5ub1wiOnRydWUsXCJ4bi0taG1tcmZlYXN0YS1zNGFjLm5vXCI6dHJ1ZSxcImhhcmFtLm5vXCI6dHJ1ZSxcImhhcmVpZC5ub1wiOnRydWUsXCJoYXJzdGFkLm5vXCI6dHJ1ZSxcImhhc3Zpay5ub1wiOnRydWUsXCJha25vbHVva3RhLm5vXCI6dHJ1ZSxcInhuLS1rb2x1b2t0YS03eWE1N2gubm9cIjp0cnVlLFwiaGF0dGZqZWxsZGFsLm5vXCI6dHJ1ZSxcImFhcmJvcnRlLm5vXCI6dHJ1ZSxcImhhdWdlc3VuZC5ub1wiOnRydWUsXCJoZW1uZS5ub1wiOnRydWUsXCJoZW1uZXMubm9cIjp0cnVlLFwiaGVtc2VkYWwubm9cIjp0cnVlLFwiaGVyb3kubW9yZS1vZy1yb21zZGFsLm5vXCI6dHJ1ZSxcInhuLS1oZXJ5LWlyYS54bi0tbXJlLW9nLXJvbXNkYWwtcXFiLm5vXCI6dHJ1ZSxcImhlcm95Lm5vcmRsYW5kLm5vXCI6dHJ1ZSxcInhuLS1oZXJ5LWlyYS5ub3JkbGFuZC5ub1wiOnRydWUsXCJoaXRyYS5ub1wiOnRydWUsXCJoamFydGRhbC5ub1wiOnRydWUsXCJoamVsbWVsYW5kLm5vXCI6dHJ1ZSxcImhvYm9sLm5vXCI6dHJ1ZSxcInhuLS1ob2JsLWlyYS5ub1wiOnRydWUsXCJob2Yubm9cIjp0cnVlLFwiaG9sLm5vXCI6dHJ1ZSxcImhvbGUubm9cIjp0cnVlLFwiaG9sbWVzdHJhbmQubm9cIjp0cnVlLFwiaG9sdGFsZW4ubm9cIjp0cnVlLFwieG4tLWhvbHRsZW4taHhhLm5vXCI6dHJ1ZSxcImhvcm5pbmRhbC5ub1wiOnRydWUsXCJob3J0ZW4ubm9cIjp0cnVlLFwiaHVyZGFsLm5vXCI6dHJ1ZSxcImh1cnVtLm5vXCI6dHJ1ZSxcImh2YWxlci5ub1wiOnRydWUsXCJoeWxsZXN0YWQubm9cIjp0cnVlLFwiaGFnZWJvc3RhZC5ub1wiOnRydWUsXCJ4bi0taGdlYm9zdGFkLWczYS5ub1wiOnRydWUsXCJob3lhbmdlci5ub1wiOnRydWUsXCJ4bi0taHlhbmdlci1xMWEubm9cIjp0cnVlLFwiaG95bGFuZGV0Lm5vXCI6dHJ1ZSxcInhuLS1oeWxhbmRldC01NGEubm9cIjp0cnVlLFwiaGEubm9cIjp0cnVlLFwieG4tLWgtMmZhLm5vXCI6dHJ1ZSxcImliZXN0YWQubm9cIjp0cnVlLFwiaW5kZXJveS5ub1wiOnRydWUsXCJ4bi0taW5kZXJ5LWZ5YS5ub1wiOnRydWUsXCJpdmVsYW5kLm5vXCI6dHJ1ZSxcImpldm5ha2VyLm5vXCI6dHJ1ZSxcImpvbmRhbC5ub1wiOnRydWUsXCJqb2xzdGVyLm5vXCI6dHJ1ZSxcInhuLS1qbHN0ZXItYnlhLm5vXCI6dHJ1ZSxcImthcmFzam9rLm5vXCI6dHJ1ZSxcImthcmFzam9oa2Eubm9cIjp0cnVlLFwieG4tLWtyam9oa2EtaHdhYjQ5ai5ub1wiOnRydWUsXCJrYXJsc295Lm5vXCI6dHJ1ZSxcImdhbHNhLm5vXCI6dHJ1ZSxcInhuLS1nbHMtZWxhYy5ub1wiOnRydWUsXCJrYXJtb3kubm9cIjp0cnVlLFwieG4tLWthcm15LXl1YS5ub1wiOnRydWUsXCJrYXV0b2tlaW5vLm5vXCI6dHJ1ZSxcImd1b3ZkYWdlYWlkbnUubm9cIjp0cnVlLFwia2xlcHAubm9cIjp0cnVlLFwia2xhYnUubm9cIjp0cnVlLFwieG4tLWtsYnUtd29hLm5vXCI6dHJ1ZSxcImtvbmdzYmVyZy5ub1wiOnRydWUsXCJrb25nc3Zpbmdlci5ub1wiOnRydWUsXCJrcmFnZXJvLm5vXCI6dHJ1ZSxcInhuLS1rcmFnZXItZ3lhLm5vXCI6dHJ1ZSxcImtyaXN0aWFuc2FuZC5ub1wiOnRydWUsXCJrcmlzdGlhbnN1bmQubm9cIjp0cnVlLFwia3JvZHNoZXJhZC5ub1wiOnRydWUsXCJ4bi0ta3Jkc2hlcmFkLW04YS5ub1wiOnRydWUsXCJrdmFsc3VuZC5ub1wiOnRydWUsXCJyYWhra2VyYXZqdS5ub1wiOnRydWUsXCJ4bi0tcmhra2Vydmp1LTAxYWYubm9cIjp0cnVlLFwia3ZhbS5ub1wiOnRydWUsXCJrdmluZXNkYWwubm9cIjp0cnVlLFwia3Zpbm5oZXJhZC5ub1wiOnRydWUsXCJrdml0ZXNlaWQubm9cIjp0cnVlLFwia3ZpdHNveS5ub1wiOnRydWUsXCJ4bi0ta3ZpdHN5LWZ5YS5ub1wiOnRydWUsXCJrdmFmam9yZC5ub1wiOnRydWUsXCJ4bi0ta3Zmam9yZC1ueGEubm9cIjp0cnVlLFwiZ2llaHRhdnVvYXRuYS5ub1wiOnRydWUsXCJrdmFuYW5nZW4ubm9cIjp0cnVlLFwieG4tLWt2bmFuZ2VuLWswYS5ub1wiOnRydWUsXCJuYXZ1b3RuYS5ub1wiOnRydWUsXCJ4bi0tbnZ1b3RuYS1od2Eubm9cIjp0cnVlLFwia2Fmam9yZC5ub1wiOnRydWUsXCJ4bi0ta2Zqb3JkLWl1YS5ub1wiOnRydWUsXCJnYWl2dW90bmEubm9cIjp0cnVlLFwieG4tLWdpdnVvdG5hLTh5YS5ub1wiOnRydWUsXCJsYXJ2aWsubm9cIjp0cnVlLFwibGF2YW5nZW4ubm9cIjp0cnVlLFwibGF2YWdpcy5ub1wiOnRydWUsXCJsb2FiYXQubm9cIjp0cnVlLFwieG4tLWxvYWJ0LTBxYS5ub1wiOnRydWUsXCJsZWJlc2J5Lm5vXCI6dHJ1ZSxcImRhdnZlc2lpZGEubm9cIjp0cnVlLFwibGVpa2FuZ2VyLm5vXCI6dHJ1ZSxcImxlaXJmam9yZC5ub1wiOnRydWUsXCJsZWthLm5vXCI6dHJ1ZSxcImxla3N2aWsubm9cIjp0cnVlLFwibGVudmlrLm5vXCI6dHJ1ZSxcImxlYW5nYXZpaWthLm5vXCI6dHJ1ZSxcInhuLS1sZWFnYXZpaWthLTUyYi5ub1wiOnRydWUsXCJsZXNqYS5ub1wiOnRydWUsXCJsZXZhbmdlci5ub1wiOnRydWUsXCJsaWVyLm5vXCI6dHJ1ZSxcImxpZXJuZS5ub1wiOnRydWUsXCJsaWxsZWhhbW1lci5ub1wiOnRydWUsXCJsaWxsZXNhbmQubm9cIjp0cnVlLFwibGluZGVzbmVzLm5vXCI6dHJ1ZSxcImxpbmRhcy5ub1wiOnRydWUsXCJ4bi0tbGluZHMtcHJhLm5vXCI6dHJ1ZSxcImxvbS5ub1wiOnRydWUsXCJsb3BwYS5ub1wiOnRydWUsXCJsYWhwcGkubm9cIjp0cnVlLFwieG4tLWxocHBpLXhxYS5ub1wiOnRydWUsXCJsdW5kLm5vXCI6dHJ1ZSxcImx1bm5lci5ub1wiOnRydWUsXCJsdXJveS5ub1wiOnRydWUsXCJ4bi0tbHVyeS1pcmEubm9cIjp0cnVlLFwibHVzdGVyLm5vXCI6dHJ1ZSxcImx5bmdkYWwubm9cIjp0cnVlLFwibHluZ2VuLm5vXCI6dHJ1ZSxcIml2Z3Uubm9cIjp0cnVlLFwibGFyZGFsLm5vXCI6dHJ1ZSxcImxlcmRhbC5ub1wiOnRydWUsXCJ4bi0tbHJkYWwtc3JhLm5vXCI6dHJ1ZSxcImxvZGluZ2VuLm5vXCI6dHJ1ZSxcInhuLS1sZGluZ2VuLXExYS5ub1wiOnRydWUsXCJsb3JlbnNrb2cubm9cIjp0cnVlLFwieG4tLWxyZW5za29nLTU0YS5ub1wiOnRydWUsXCJsb3Rlbi5ub1wiOnRydWUsXCJ4bi0tbHRlbi1ncmEubm9cIjp0cnVlLFwibWFsdmlrLm5vXCI6dHJ1ZSxcIm1hc295Lm5vXCI6dHJ1ZSxcInhuLS1tc3ktdWxhMGgubm9cIjp0cnVlLFwibXVvc2F0Lm5vXCI6dHJ1ZSxcInhuLS1tdW9zdC0wcWEubm9cIjp0cnVlLFwibWFuZGFsLm5vXCI6dHJ1ZSxcIm1hcmtlci5ub1wiOnRydWUsXCJtYXJuYXJkYWwubm9cIjp0cnVlLFwibWFzZmpvcmRlbi5ub1wiOnRydWUsXCJtZWxhbmQubm9cIjp0cnVlLFwibWVsZGFsLm5vXCI6dHJ1ZSxcIm1lbGh1cy5ub1wiOnRydWUsXCJtZWxveS5ub1wiOnRydWUsXCJ4bi0tbWVseS1pcmEubm9cIjp0cnVlLFwibWVyYWtlci5ub1wiOnRydWUsXCJ4bi0tbWVya2VyLWt1YS5ub1wiOnRydWUsXCJtb2FyZWtlLm5vXCI6dHJ1ZSxcInhuLS1tb3Jla2UtanVhLm5vXCI6dHJ1ZSxcIm1pZHN1bmQubm9cIjp0cnVlLFwibWlkdHJlLWdhdWxkYWwubm9cIjp0cnVlLFwibW9kYWxlbi5ub1wiOnRydWUsXCJtb2R1bS5ub1wiOnRydWUsXCJtb2xkZS5ub1wiOnRydWUsXCJtb3NrZW5lcy5ub1wiOnRydWUsXCJtb3NzLm5vXCI6dHJ1ZSxcIm1vc3Zpay5ub1wiOnRydWUsXCJtYWxzZWx2Lm5vXCI6dHJ1ZSxcInhuLS1tbHNlbHYtaXVhLm5vXCI6dHJ1ZSxcIm1hbGF0dnVvcG1pLm5vXCI6dHJ1ZSxcInhuLS1tbGF0dnVvcG1pLXM0YS5ub1wiOnRydWUsXCJuYW1kYWxzZWlkLm5vXCI6dHJ1ZSxcImFlanJpZS5ub1wiOnRydWUsXCJuYW1zb3Mubm9cIjp0cnVlLFwibmFtc3Nrb2dhbi5ub1wiOnRydWUsXCJuYWFtZXNqZXZ1ZW1pZS5ub1wiOnRydWUsXCJ4bi0tbm1lc2pldnVlbWllLXRjYmEubm9cIjp0cnVlLFwibGFha2VzdnVlbWllLm5vXCI6dHJ1ZSxcIm5hbm5lc3RhZC5ub1wiOnRydWUsXCJuYXJ2aWsubm9cIjp0cnVlLFwibmFydmlpa2Eubm9cIjp0cnVlLFwibmF1c3RkYWwubm9cIjp0cnVlLFwibmVkcmUtZWlrZXIubm9cIjp0cnVlLFwibmVzLmFrZXJzaHVzLm5vXCI6dHJ1ZSxcIm5lcy5idXNrZXJ1ZC5ub1wiOnRydWUsXCJuZXNuYS5ub1wiOnRydWUsXCJuZXNvZGRlbi5ub1wiOnRydWUsXCJuZXNzZWJ5Lm5vXCI6dHJ1ZSxcInVuamFyZ2Eubm9cIjp0cnVlLFwieG4tLXVuanJnYS1ydGEubm9cIjp0cnVlLFwibmVzc2V0Lm5vXCI6dHJ1ZSxcIm5pc3NlZGFsLm5vXCI6dHJ1ZSxcIm5pdHRlZGFsLm5vXCI6dHJ1ZSxcIm5vcmQtYXVyZGFsLm5vXCI6dHJ1ZSxcIm5vcmQtZnJvbi5ub1wiOnRydWUsXCJub3JkLW9kYWwubm9cIjp0cnVlLFwibm9yZGRhbC5ub1wiOnRydWUsXCJub3Jka2FwcC5ub1wiOnRydWUsXCJkYXZ2ZW5qYXJnYS5ub1wiOnRydWUsXCJ4bi0tZGF2dmVuanJnYS15NGEubm9cIjp0cnVlLFwibm9yZHJlLWxhbmQubm9cIjp0cnVlLFwibm9yZHJlaXNhLm5vXCI6dHJ1ZSxcInJhaXNhLm5vXCI6dHJ1ZSxcInhuLS1yaXNhLTVuYS5ub1wiOnRydWUsXCJub3JlLW9nLXV2ZGFsLm5vXCI6dHJ1ZSxcIm5vdG9kZGVuLm5vXCI6dHJ1ZSxcIm5hcm95Lm5vXCI6dHJ1ZSxcInhuLS1ucnkteWxhNWcubm9cIjp0cnVlLFwibm90dGVyb3kubm9cIjp0cnVlLFwieG4tLW50dGVyeS1ieWFlLm5vXCI6dHJ1ZSxcIm9kZGEubm9cIjp0cnVlLFwib2tzbmVzLm5vXCI6dHJ1ZSxcInhuLS1rc25lcy11dWEubm9cIjp0cnVlLFwib3BwZGFsLm5vXCI6dHJ1ZSxcIm9wcGVnYXJkLm5vXCI6dHJ1ZSxcInhuLS1vcHBlZ3JkLWl4YS5ub1wiOnRydWUsXCJvcmtkYWwubm9cIjp0cnVlLFwib3JsYW5kLm5vXCI6dHJ1ZSxcInhuLS1ybGFuZC11dWEubm9cIjp0cnVlLFwib3Jza29nLm5vXCI6dHJ1ZSxcInhuLS1yc2tvZy11dWEubm9cIjp0cnVlLFwib3JzdGEubm9cIjp0cnVlLFwieG4tLXJzdGEtZnJhLm5vXCI6dHJ1ZSxcIm9zLmhlZG1hcmsubm9cIjp0cnVlLFwib3MuaG9yZGFsYW5kLm5vXCI6dHJ1ZSxcIm9zZW4ubm9cIjp0cnVlLFwib3N0ZXJveS5ub1wiOnRydWUsXCJ4bi0tb3N0ZXJ5LWZ5YS5ub1wiOnRydWUsXCJvc3RyZS10b3Rlbi5ub1wiOnRydWUsXCJ4bi0tc3RyZS10b3Rlbi16Y2Iubm9cIjp0cnVlLFwib3ZlcmhhbGxhLm5vXCI6dHJ1ZSxcIm92cmUtZWlrZXIubm9cIjp0cnVlLFwieG4tLXZyZS1laWtlci1rOGEubm9cIjp0cnVlLFwib3llci5ub1wiOnRydWUsXCJ4bi0teWVyLXpuYS5ub1wiOnRydWUsXCJveWdhcmRlbi5ub1wiOnRydWUsXCJ4bi0teWdhcmRlbi1wMWEubm9cIjp0cnVlLFwib3lzdHJlLXNsaWRyZS5ub1wiOnRydWUsXCJ4bi0teXN0cmUtc2xpZHJlLXVqYi5ub1wiOnRydWUsXCJwb3JzYW5nZXIubm9cIjp0cnVlLFwicG9yc2FuZ3Uubm9cIjp0cnVlLFwieG4tLXBvcnNndS1zdGEyNmYubm9cIjp0cnVlLFwicG9yc2dydW5uLm5vXCI6dHJ1ZSxcInJhZG95Lm5vXCI6dHJ1ZSxcInhuLS1yYWR5LWlyYS5ub1wiOnRydWUsXCJyYWtrZXN0YWQubm9cIjp0cnVlLFwicmFuYS5ub1wiOnRydWUsXCJydW92YXQubm9cIjp0cnVlLFwicmFuZGFiZXJnLm5vXCI6dHJ1ZSxcInJhdW1hLm5vXCI6dHJ1ZSxcInJlbmRhbGVuLm5vXCI6dHJ1ZSxcInJlbm5lYnUubm9cIjp0cnVlLFwicmVubmVzb3kubm9cIjp0cnVlLFwieG4tLXJlbm5lc3ktdjFhLm5vXCI6dHJ1ZSxcInJpbmRhbC5ub1wiOnRydWUsXCJyaW5nZWJ1Lm5vXCI6dHJ1ZSxcInJpbmdlcmlrZS5ub1wiOnRydWUsXCJyaW5nc2FrZXIubm9cIjp0cnVlLFwicmlzc2Eubm9cIjp0cnVlLFwicmlzb3Iubm9cIjp0cnVlLFwieG4tLXJpc3ItaXJhLm5vXCI6dHJ1ZSxcInJvYW4ubm9cIjp0cnVlLFwicm9sbGFnLm5vXCI6dHJ1ZSxcInJ5Z2dlLm5vXCI6dHJ1ZSxcInJhbGluZ2VuLm5vXCI6dHJ1ZSxcInhuLS1ybGluZ2VuLW14YS5ub1wiOnRydWUsXCJyb2RveS5ub1wiOnRydWUsXCJ4bi0tcmR5LTBuYWIubm9cIjp0cnVlLFwicm9tc2tvZy5ub1wiOnRydWUsXCJ4bi0tcm1za29nLWJ5YS5ub1wiOnRydWUsXCJyb3Jvcy5ub1wiOnRydWUsXCJ4bi0tcnJvcy1ncmEubm9cIjp0cnVlLFwicm9zdC5ub1wiOnRydWUsXCJ4bi0tcnN0LTBuYS5ub1wiOnRydWUsXCJyb3lrZW4ubm9cIjp0cnVlLFwieG4tLXJ5a2VuLXZ1YS5ub1wiOnRydWUsXCJyb3lydmlrLm5vXCI6dHJ1ZSxcInhuLS1yeXJ2aWstYnlhLm5vXCI6dHJ1ZSxcInJhZGUubm9cIjp0cnVlLFwieG4tLXJkZS11bGEubm9cIjp0cnVlLFwic2FsYW5nZW4ubm9cIjp0cnVlLFwic2llbGxhay5ub1wiOnRydWUsXCJzYWx0ZGFsLm5vXCI6dHJ1ZSxcInNhbGF0Lm5vXCI6dHJ1ZSxcInhuLS1zbHQtZWxhYi5ub1wiOnRydWUsXCJ4bi0tc2xhdC01bmEubm9cIjp0cnVlLFwic2FtbmFuZ2VyLm5vXCI6dHJ1ZSxcInNhbmRlLm1vcmUtb2ctcm9tc2RhbC5ub1wiOnRydWUsXCJzYW5kZS54bi0tbXJlLW9nLXJvbXNkYWwtcXFiLm5vXCI6dHJ1ZSxcInNhbmRlLnZlc3Rmb2xkLm5vXCI6dHJ1ZSxcInNhbmRlZmpvcmQubm9cIjp0cnVlLFwic2FuZG5lcy5ub1wiOnRydWUsXCJzYW5kb3kubm9cIjp0cnVlLFwieG4tLXNhbmR5LXl1YS5ub1wiOnRydWUsXCJzYXJwc2Jvcmcubm9cIjp0cnVlLFwic2F1ZGEubm9cIjp0cnVlLFwic2F1aGVyYWQubm9cIjp0cnVlLFwic2VsLm5vXCI6dHJ1ZSxcInNlbGJ1Lm5vXCI6dHJ1ZSxcInNlbGplLm5vXCI6dHJ1ZSxcInNlbGpvcmQubm9cIjp0cnVlLFwic2lnZGFsLm5vXCI6dHJ1ZSxcInNpbGphbi5ub1wiOnRydWUsXCJzaXJkYWwubm9cIjp0cnVlLFwic2thdW4ubm9cIjp0cnVlLFwic2tlZHNtby5ub1wiOnRydWUsXCJza2kubm9cIjp0cnVlLFwic2tpZW4ubm9cIjp0cnVlLFwic2tpcHR2ZXQubm9cIjp0cnVlLFwic2tqZXJ2b3kubm9cIjp0cnVlLFwieG4tLXNramVydnktdjFhLm5vXCI6dHJ1ZSxcInNraWVydmEubm9cIjp0cnVlLFwieG4tLXNraWVydi11dGEubm9cIjp0cnVlLFwic2tqYWsubm9cIjp0cnVlLFwieG4tLXNramstc29hLm5vXCI6dHJ1ZSxcInNrb2RqZS5ub1wiOnRydWUsXCJza2FubGFuZC5ub1wiOnRydWUsXCJ4bi0tc2tubGFuZC1meGEubm9cIjp0cnVlLFwic2thbml0Lm5vXCI6dHJ1ZSxcInhuLS1za25pdC15cWEubm9cIjp0cnVlLFwic21vbGEubm9cIjp0cnVlLFwieG4tLXNtbGEtaHJhLm5vXCI6dHJ1ZSxcInNuaWxsZmpvcmQubm9cIjp0cnVlLFwic25hc2Eubm9cIjp0cnVlLFwieG4tLXNuc2Etcm9hLm5vXCI6dHJ1ZSxcInNub2FzYS5ub1wiOnRydWUsXCJzbmFhc2Uubm9cIjp0cnVlLFwieG4tLXNuYXNlLW5yYS5ub1wiOnRydWUsXCJzb2duZGFsLm5vXCI6dHJ1ZSxcInNva25kYWwubm9cIjp0cnVlLFwic29sYS5ub1wiOnRydWUsXCJzb2x1bmQubm9cIjp0cnVlLFwic29uZ2RhbGVuLm5vXCI6dHJ1ZSxcInNvcnRsYW5kLm5vXCI6dHJ1ZSxcInNweWRlYmVyZy5ub1wiOnRydWUsXCJzdGFuZ2Uubm9cIjp0cnVlLFwic3RhdmFuZ2VyLm5vXCI6dHJ1ZSxcInN0ZWlnZW4ubm9cIjp0cnVlLFwic3RlaW5ramVyLm5vXCI6dHJ1ZSxcInN0am9yZGFsLm5vXCI6dHJ1ZSxcInhuLS1zdGpyZGFsLXMxYS5ub1wiOnRydWUsXCJzdG9ra2Uubm9cIjp0cnVlLFwic3Rvci1lbHZkYWwubm9cIjp0cnVlLFwic3RvcmQubm9cIjp0cnVlLFwic3RvcmRhbC5ub1wiOnRydWUsXCJzdG9yZmpvcmQubm9cIjp0cnVlLFwib21hc3Z1b3RuYS5ub1wiOnRydWUsXCJzdHJhbmQubm9cIjp0cnVlLFwic3RyYW5kYS5ub1wiOnRydWUsXCJzdHJ5bi5ub1wiOnRydWUsXCJzdWxhLm5vXCI6dHJ1ZSxcInN1bGRhbC5ub1wiOnRydWUsXCJzdW5kLm5vXCI6dHJ1ZSxcInN1bm5kYWwubm9cIjp0cnVlLFwic3VybmFkYWwubm9cIjp0cnVlLFwic3ZlaW8ubm9cIjp0cnVlLFwic3ZlbHZpay5ub1wiOnRydWUsXCJzeWtreWx2ZW4ubm9cIjp0cnVlLFwic29nbmUubm9cIjp0cnVlLFwieG4tLXNnbmUtZ3JhLm5vXCI6dHJ1ZSxcInNvbW5hLm5vXCI6dHJ1ZSxcInhuLS1zbW5hLWdyYS5ub1wiOnRydWUsXCJzb25kcmUtbGFuZC5ub1wiOnRydWUsXCJ4bi0tc25kcmUtbGFuZC0wY2Iubm9cIjp0cnVlLFwic29yLWF1cmRhbC5ub1wiOnRydWUsXCJ4bi0tc3ItYXVyZGFsLWw4YS5ub1wiOnRydWUsXCJzb3ItZnJvbi5ub1wiOnRydWUsXCJ4bi0tc3ItZnJvbi1xMWEubm9cIjp0cnVlLFwic29yLW9kYWwubm9cIjp0cnVlLFwieG4tLXNyLW9kYWwtcTFhLm5vXCI6dHJ1ZSxcInNvci12YXJhbmdlci5ub1wiOnRydWUsXCJ4bi0tc3ItdmFyYW5nZXItZ2diLm5vXCI6dHJ1ZSxcIm1hdHRhLXZhcmpqYXQubm9cIjp0cnVlLFwieG4tLW10dGEtdnJqamF0LWs3YWYubm9cIjp0cnVlLFwic29yZm9sZC5ub1wiOnRydWUsXCJ4bi0tc3Jmb2xkLWJ5YS5ub1wiOnRydWUsXCJzb3JyZWlzYS5ub1wiOnRydWUsXCJ4bi0tc3JyZWlzYS1xMWEubm9cIjp0cnVlLFwic29ydW0ubm9cIjp0cnVlLFwieG4tLXNydW0tZ3JhLm5vXCI6dHJ1ZSxcInRhbmEubm9cIjp0cnVlLFwiZGVhdG51Lm5vXCI6dHJ1ZSxcInRpbWUubm9cIjp0cnVlLFwidGluZ3ZvbGwubm9cIjp0cnVlLFwidGlubi5ub1wiOnRydWUsXCJ0amVsZHN1bmQubm9cIjp0cnVlLFwiZGllbGRkYW51b3JyaS5ub1wiOnRydWUsXCJ0am9tZS5ub1wiOnRydWUsXCJ4bi0tdGptZS1ocmEubm9cIjp0cnVlLFwidG9ra2Uubm9cIjp0cnVlLFwidG9sZ2Eubm9cIjp0cnVlLFwidG9yc2tlbi5ub1wiOnRydWUsXCJ0cmFub3kubm9cIjp0cnVlLFwieG4tLXRyYW55LXl1YS5ub1wiOnRydWUsXCJ0cm9tc28ubm9cIjp0cnVlLFwieG4tLXRyb21zLXp1YS5ub1wiOnRydWUsXCJ0cm9tc2Eubm9cIjp0cnVlLFwicm9tc2Eubm9cIjp0cnVlLFwidHJvbmRoZWltLm5vXCI6dHJ1ZSxcInRyb2FuZGluLm5vXCI6dHJ1ZSxcInRyeXNpbC5ub1wiOnRydWUsXCJ0cmFuYS5ub1wiOnRydWUsXCJ4bi0tdHJuYS13b2Eubm9cIjp0cnVlLFwidHJvZ3N0YWQubm9cIjp0cnVlLFwieG4tLXRyZ3N0YWQtcjFhLm5vXCI6dHJ1ZSxcInR2ZWRlc3RyYW5kLm5vXCI6dHJ1ZSxcInR5ZGFsLm5vXCI6dHJ1ZSxcInR5bnNldC5ub1wiOnRydWUsXCJ0eXNmam9yZC5ub1wiOnRydWUsXCJkaXZ0YXN2dW9kbmEubm9cIjp0cnVlLFwiZGl2dHRhc3Z1b3RuYS5ub1wiOnRydWUsXCJ0eXNuZXMubm9cIjp0cnVlLFwidHlzdmFyLm5vXCI6dHJ1ZSxcInhuLS10eXN2ci12cmEubm9cIjp0cnVlLFwidG9uc2Jlcmcubm9cIjp0cnVlLFwieG4tLXRuc2JlcmctcTFhLm5vXCI6dHJ1ZSxcInVsbGVuc2FrZXIubm9cIjp0cnVlLFwidWxsZW5zdmFuZy5ub1wiOnRydWUsXCJ1bHZpay5ub1wiOnRydWUsXCJ1dHNpcmEubm9cIjp0cnVlLFwidmFkc28ubm9cIjp0cnVlLFwieG4tLXZhZHMtanJhLm5vXCI6dHJ1ZSxcImNhaGNlc3VvbG8ubm9cIjp0cnVlLFwieG4tLWhjZXN1b2xvLTd5YTM1Yi5ub1wiOnRydWUsXCJ2YWtzZGFsLm5vXCI6dHJ1ZSxcInZhbGxlLm5vXCI6dHJ1ZSxcInZhbmcubm9cIjp0cnVlLFwidmFueWx2ZW4ubm9cIjp0cnVlLFwidmFyZG8ubm9cIjp0cnVlLFwieG4tLXZhcmQtanJhLm5vXCI6dHJ1ZSxcInZhcmdnYXQubm9cIjp0cnVlLFwieG4tLXZyZ2d0LXhxYWQubm9cIjp0cnVlLFwidmVmc24ubm9cIjp0cnVlLFwidmFhcHN0ZS5ub1wiOnRydWUsXCJ2ZWdhLm5vXCI6dHJ1ZSxcInZlZ2Fyc2hlaS5ub1wiOnRydWUsXCJ4bi0tdmVncnNoZWktYzBhLm5vXCI6dHJ1ZSxcInZlbm5lc2xhLm5vXCI6dHJ1ZSxcInZlcmRhbC5ub1wiOnRydWUsXCJ2ZXJyYW4ubm9cIjp0cnVlLFwidmVzdGJ5Lm5vXCI6dHJ1ZSxcInZlc3RuZXMubm9cIjp0cnVlLFwidmVzdHJlLXNsaWRyZS5ub1wiOnRydWUsXCJ2ZXN0cmUtdG90ZW4ubm9cIjp0cnVlLFwidmVzdHZhZ295Lm5vXCI6dHJ1ZSxcInhuLS12ZXN0dmd5LWl4YTZvLm5vXCI6dHJ1ZSxcInZldmVsc3RhZC5ub1wiOnRydWUsXCJ2aWsubm9cIjp0cnVlLFwidmlrbmEubm9cIjp0cnVlLFwidmluZGFmam9yZC5ub1wiOnRydWUsXCJ2b2xkYS5ub1wiOnRydWUsXCJ2b3NzLm5vXCI6dHJ1ZSxcInZhcm95Lm5vXCI6dHJ1ZSxcInhuLS12cnkteWxhNWcubm9cIjp0cnVlLFwidmFnYW4ubm9cIjp0cnVlLFwieG4tLXZnYW4tcW9hLm5vXCI6dHJ1ZSxcInZvYWdhdC5ub1wiOnRydWUsXCJ2YWdzb3kubm9cIjp0cnVlLFwieG4tLXZnc3ktcW9hMGoubm9cIjp0cnVlLFwidmFnYS5ub1wiOnRydWUsXCJ4bi0tdmcteWlhYi5ub1wiOnRydWUsXCJ2YWxlci5vc3Rmb2xkLm5vXCI6dHJ1ZSxcInhuLS12bGVyLXFvYS54bi0tc3Rmb2xkLTl4YS5ub1wiOnRydWUsXCJ2YWxlci5oZWRtYXJrLm5vXCI6dHJ1ZSxcInhuLS12bGVyLXFvYS5oZWRtYXJrLm5vXCI6dHJ1ZSxcIioubnBcIjp0cnVlLFwibnJcIjp0cnVlLFwiYml6Lm5yXCI6dHJ1ZSxcImluZm8ubnJcIjp0cnVlLFwiZ292Lm5yXCI6dHJ1ZSxcImVkdS5uclwiOnRydWUsXCJvcmcubnJcIjp0cnVlLFwibmV0Lm5yXCI6dHJ1ZSxcImNvbS5uclwiOnRydWUsXCJudVwiOnRydWUsXCJuelwiOnRydWUsXCJhYy5uelwiOnRydWUsXCJjby5uelwiOnRydWUsXCJjcmkubnpcIjp0cnVlLFwiZ2Vlay5uelwiOnRydWUsXCJnZW4ubnpcIjp0cnVlLFwiZ292dC5uelwiOnRydWUsXCJoZWFsdGgubnpcIjp0cnVlLFwiaXdpLm56XCI6dHJ1ZSxcImtpd2kubnpcIjp0cnVlLFwibWFvcmkubnpcIjp0cnVlLFwibWlsLm56XCI6dHJ1ZSxcInhuLS1tb3JpLXFzYS5uelwiOnRydWUsXCJuZXQubnpcIjp0cnVlLFwib3JnLm56XCI6dHJ1ZSxcInBhcmxpYW1lbnQubnpcIjp0cnVlLFwic2Nob29sLm56XCI6dHJ1ZSxcIm9tXCI6dHJ1ZSxcImNvLm9tXCI6dHJ1ZSxcImNvbS5vbVwiOnRydWUsXCJlZHUub21cIjp0cnVlLFwiZ292Lm9tXCI6dHJ1ZSxcIm1lZC5vbVwiOnRydWUsXCJtdXNldW0ub21cIjp0cnVlLFwibmV0Lm9tXCI6dHJ1ZSxcIm9yZy5vbVwiOnRydWUsXCJwcm8ub21cIjp0cnVlLFwib3JnXCI6dHJ1ZSxcInBhXCI6dHJ1ZSxcImFjLnBhXCI6dHJ1ZSxcImdvYi5wYVwiOnRydWUsXCJjb20ucGFcIjp0cnVlLFwib3JnLnBhXCI6dHJ1ZSxcInNsZC5wYVwiOnRydWUsXCJlZHUucGFcIjp0cnVlLFwibmV0LnBhXCI6dHJ1ZSxcImluZy5wYVwiOnRydWUsXCJhYm8ucGFcIjp0cnVlLFwibWVkLnBhXCI6dHJ1ZSxcIm5vbS5wYVwiOnRydWUsXCJwZVwiOnRydWUsXCJlZHUucGVcIjp0cnVlLFwiZ29iLnBlXCI6dHJ1ZSxcIm5vbS5wZVwiOnRydWUsXCJtaWwucGVcIjp0cnVlLFwib3JnLnBlXCI6dHJ1ZSxcImNvbS5wZVwiOnRydWUsXCJuZXQucGVcIjp0cnVlLFwicGZcIjp0cnVlLFwiY29tLnBmXCI6dHJ1ZSxcIm9yZy5wZlwiOnRydWUsXCJlZHUucGZcIjp0cnVlLFwiKi5wZ1wiOnRydWUsXCJwaFwiOnRydWUsXCJjb20ucGhcIjp0cnVlLFwibmV0LnBoXCI6dHJ1ZSxcIm9yZy5waFwiOnRydWUsXCJnb3YucGhcIjp0cnVlLFwiZWR1LnBoXCI6dHJ1ZSxcIm5nby5waFwiOnRydWUsXCJtaWwucGhcIjp0cnVlLFwiaS5waFwiOnRydWUsXCJwa1wiOnRydWUsXCJjb20ucGtcIjp0cnVlLFwibmV0LnBrXCI6dHJ1ZSxcImVkdS5wa1wiOnRydWUsXCJvcmcucGtcIjp0cnVlLFwiZmFtLnBrXCI6dHJ1ZSxcImJpei5wa1wiOnRydWUsXCJ3ZWIucGtcIjp0cnVlLFwiZ292LnBrXCI6dHJ1ZSxcImdvYi5wa1wiOnRydWUsXCJnb2sucGtcIjp0cnVlLFwiZ29uLnBrXCI6dHJ1ZSxcImdvcC5wa1wiOnRydWUsXCJnb3MucGtcIjp0cnVlLFwiaW5mby5wa1wiOnRydWUsXCJwbFwiOnRydWUsXCJjb20ucGxcIjp0cnVlLFwibmV0LnBsXCI6dHJ1ZSxcIm9yZy5wbFwiOnRydWUsXCJhaWQucGxcIjp0cnVlLFwiYWdyby5wbFwiOnRydWUsXCJhdG0ucGxcIjp0cnVlLFwiYXV0by5wbFwiOnRydWUsXCJiaXoucGxcIjp0cnVlLFwiZWR1LnBsXCI6dHJ1ZSxcImdtaW5hLnBsXCI6dHJ1ZSxcImdzbS5wbFwiOnRydWUsXCJpbmZvLnBsXCI6dHJ1ZSxcIm1haWwucGxcIjp0cnVlLFwibWlhc3RhLnBsXCI6dHJ1ZSxcIm1lZGlhLnBsXCI6dHJ1ZSxcIm1pbC5wbFwiOnRydWUsXCJuaWVydWNob21vc2NpLnBsXCI6dHJ1ZSxcIm5vbS5wbFwiOnRydWUsXCJwYy5wbFwiOnRydWUsXCJwb3dpYXQucGxcIjp0cnVlLFwicHJpdi5wbFwiOnRydWUsXCJyZWFsZXN0YXRlLnBsXCI6dHJ1ZSxcInJlbC5wbFwiOnRydWUsXCJzZXgucGxcIjp0cnVlLFwic2hvcC5wbFwiOnRydWUsXCJza2xlcC5wbFwiOnRydWUsXCJzb3MucGxcIjp0cnVlLFwic3prb2xhLnBsXCI6dHJ1ZSxcInRhcmdpLnBsXCI6dHJ1ZSxcInRtLnBsXCI6dHJ1ZSxcInRvdXJpc20ucGxcIjp0cnVlLFwidHJhdmVsLnBsXCI6dHJ1ZSxcInR1cnlzdHlrYS5wbFwiOnRydWUsXCJnb3YucGxcIjp0cnVlLFwiYXAuZ292LnBsXCI6dHJ1ZSxcImljLmdvdi5wbFwiOnRydWUsXCJpcy5nb3YucGxcIjp0cnVlLFwidXMuZ292LnBsXCI6dHJ1ZSxcImttcHNwLmdvdi5wbFwiOnRydWUsXCJrcHBzcC5nb3YucGxcIjp0cnVlLFwia3dwc3AuZ292LnBsXCI6dHJ1ZSxcInBzcC5nb3YucGxcIjp0cnVlLFwid3Nrci5nb3YucGxcIjp0cnVlLFwia3dwLmdvdi5wbFwiOnRydWUsXCJtdy5nb3YucGxcIjp0cnVlLFwidWcuZ292LnBsXCI6dHJ1ZSxcInVtLmdvdi5wbFwiOnRydWUsXCJ1bWlnLmdvdi5wbFwiOnRydWUsXCJ1Z2ltLmdvdi5wbFwiOnRydWUsXCJ1cG93Lmdvdi5wbFwiOnRydWUsXCJ1dy5nb3YucGxcIjp0cnVlLFwic3Rhcm9zdHdvLmdvdi5wbFwiOnRydWUsXCJwYS5nb3YucGxcIjp0cnVlLFwicG8uZ292LnBsXCI6dHJ1ZSxcInBzc2UuZ292LnBsXCI6dHJ1ZSxcInB1cC5nb3YucGxcIjp0cnVlLFwicnpndy5nb3YucGxcIjp0cnVlLFwic2EuZ292LnBsXCI6dHJ1ZSxcInNvLmdvdi5wbFwiOnRydWUsXCJzci5nb3YucGxcIjp0cnVlLFwid3NhLmdvdi5wbFwiOnRydWUsXCJza28uZ292LnBsXCI6dHJ1ZSxcInV6cy5nb3YucGxcIjp0cnVlLFwid2lpaC5nb3YucGxcIjp0cnVlLFwid2luYi5nb3YucGxcIjp0cnVlLFwicGluYi5nb3YucGxcIjp0cnVlLFwid2lvcy5nb3YucGxcIjp0cnVlLFwid2l0ZC5nb3YucGxcIjp0cnVlLFwid3ptaXV3Lmdvdi5wbFwiOnRydWUsXCJwaXcuZ292LnBsXCI6dHJ1ZSxcIndpdy5nb3YucGxcIjp0cnVlLFwiZ3Jpdy5nb3YucGxcIjp0cnVlLFwid2lmLmdvdi5wbFwiOnRydWUsXCJvdW0uZ292LnBsXCI6dHJ1ZSxcInNkbi5nb3YucGxcIjp0cnVlLFwienAuZ292LnBsXCI6dHJ1ZSxcInVwcG8uZ292LnBsXCI6dHJ1ZSxcIm11cC5nb3YucGxcIjp0cnVlLFwid3Vvei5nb3YucGxcIjp0cnVlLFwia29uc3VsYXQuZ292LnBsXCI6dHJ1ZSxcIm9pcm0uZ292LnBsXCI6dHJ1ZSxcImF1Z3VzdG93LnBsXCI6dHJ1ZSxcImJhYmlhLWdvcmEucGxcIjp0cnVlLFwiYmVkemluLnBsXCI6dHJ1ZSxcImJlc2tpZHkucGxcIjp0cnVlLFwiYmlhbG93aWV6YS5wbFwiOnRydWUsXCJiaWFseXN0b2sucGxcIjp0cnVlLFwiYmllbGF3YS5wbFwiOnRydWUsXCJiaWVzemN6YWR5LnBsXCI6dHJ1ZSxcImJvbGVzbGF3aWVjLnBsXCI6dHJ1ZSxcImJ5ZGdvc3pjei5wbFwiOnRydWUsXCJieXRvbS5wbFwiOnRydWUsXCJjaWVzenluLnBsXCI6dHJ1ZSxcImN6ZWxhZHoucGxcIjp0cnVlLFwiY3plc3QucGxcIjp0cnVlLFwiZGx1Z29sZWthLnBsXCI6dHJ1ZSxcImVsYmxhZy5wbFwiOnRydWUsXCJlbGsucGxcIjp0cnVlLFwiZ2xvZ293LnBsXCI6dHJ1ZSxcImduaWV6bm8ucGxcIjp0cnVlLFwiZ29ybGljZS5wbFwiOnRydWUsXCJncmFqZXdvLnBsXCI6dHJ1ZSxcImlsYXdhLnBsXCI6dHJ1ZSxcImphd29yem5vLnBsXCI6dHJ1ZSxcImplbGVuaWEtZ29yYS5wbFwiOnRydWUsXCJqZ29yYS5wbFwiOnRydWUsXCJrYWxpc3oucGxcIjp0cnVlLFwia2F6aW1pZXJ6LWRvbG55LnBsXCI6dHJ1ZSxcImthcnBhY3oucGxcIjp0cnVlLFwia2FydHV6eS5wbFwiOnRydWUsXCJrYXN6dWJ5LnBsXCI6dHJ1ZSxcImthdG93aWNlLnBsXCI6dHJ1ZSxcImtlcG5vLnBsXCI6dHJ1ZSxcImtldHJ6eW4ucGxcIjp0cnVlLFwia2xvZHprby5wbFwiOnRydWUsXCJrb2JpZXJ6eWNlLnBsXCI6dHJ1ZSxcImtvbG9icnplZy5wbFwiOnRydWUsXCJrb25pbi5wbFwiOnRydWUsXCJrb25za293b2xhLnBsXCI6dHJ1ZSxcImt1dG5vLnBsXCI6dHJ1ZSxcImxhcHkucGxcIjp0cnVlLFwibGVib3JrLnBsXCI6dHJ1ZSxcImxlZ25pY2EucGxcIjp0cnVlLFwibGV6YWpzay5wbFwiOnRydWUsXCJsaW1hbm93YS5wbFwiOnRydWUsXCJsb216YS5wbFwiOnRydWUsXCJsb3dpY3oucGxcIjp0cnVlLFwibHViaW4ucGxcIjp0cnVlLFwibHVrb3cucGxcIjp0cnVlLFwibWFsYm9yay5wbFwiOnRydWUsXCJtYWxvcG9sc2thLnBsXCI6dHJ1ZSxcIm1hem93c3plLnBsXCI6dHJ1ZSxcIm1henVyeS5wbFwiOnRydWUsXCJtaWVsZWMucGxcIjp0cnVlLFwibWllbG5vLnBsXCI6dHJ1ZSxcIm1yYWdvd28ucGxcIjp0cnVlLFwibmFrbG8ucGxcIjp0cnVlLFwibm93YXJ1ZGEucGxcIjp0cnVlLFwibnlzYS5wbFwiOnRydWUsXCJvbGF3YS5wbFwiOnRydWUsXCJvbGVja28ucGxcIjp0cnVlLFwib2xrdXN6LnBsXCI6dHJ1ZSxcIm9sc3p0eW4ucGxcIjp0cnVlLFwib3BvY3puby5wbFwiOnRydWUsXCJvcG9sZS5wbFwiOnRydWUsXCJvc3Ryb2RhLnBsXCI6dHJ1ZSxcIm9zdHJvbGVrYS5wbFwiOnRydWUsXCJvc3Ryb3dpZWMucGxcIjp0cnVlLFwib3N0cm93d2xrcC5wbFwiOnRydWUsXCJwaWxhLnBsXCI6dHJ1ZSxcInBpc3oucGxcIjp0cnVlLFwicG9kaGFsZS5wbFwiOnRydWUsXCJwb2RsYXNpZS5wbFwiOnRydWUsXCJwb2xrb3dpY2UucGxcIjp0cnVlLFwicG9tb3J6ZS5wbFwiOnRydWUsXCJwb21vcnNraWUucGxcIjp0cnVlLFwicHJvY2hvd2ljZS5wbFwiOnRydWUsXCJwcnVzemtvdy5wbFwiOnRydWUsXCJwcnpld29yc2sucGxcIjp0cnVlLFwicHVsYXd5LnBsXCI6dHJ1ZSxcInJhZG9tLnBsXCI6dHJ1ZSxcInJhd2EtbWF6LnBsXCI6dHJ1ZSxcInJ5Ym5pay5wbFwiOnRydWUsXCJyemVzem93LnBsXCI6dHJ1ZSxcInNhbm9rLnBsXCI6dHJ1ZSxcInNlam55LnBsXCI6dHJ1ZSxcInNsYXNrLnBsXCI6dHJ1ZSxcInNsdXBzay5wbFwiOnRydWUsXCJzb3Nub3dpZWMucGxcIjp0cnVlLFwic3RhbG93YS13b2xhLnBsXCI6dHJ1ZSxcInNrb2N6b3cucGxcIjp0cnVlLFwic3RhcmFjaG93aWNlLnBsXCI6dHJ1ZSxcInN0YXJnYXJkLnBsXCI6dHJ1ZSxcInN1d2Fsa2kucGxcIjp0cnVlLFwic3dpZG5pY2EucGxcIjp0cnVlLFwic3dpZWJvZHppbi5wbFwiOnRydWUsXCJzd2lub3Vqc2NpZS5wbFwiOnRydWUsXCJzemN6ZWNpbi5wbFwiOnRydWUsXCJzemN6eXRuby5wbFwiOnRydWUsXCJ0YXJub2JyemVnLnBsXCI6dHJ1ZSxcInRnb3J5LnBsXCI6dHJ1ZSxcInR1cmVrLnBsXCI6dHJ1ZSxcInR5Y2h5LnBsXCI6dHJ1ZSxcInVzdGthLnBsXCI6dHJ1ZSxcIndhbGJyenljaC5wbFwiOnRydWUsXCJ3YXJtaWEucGxcIjp0cnVlLFwid2Fyc3phd2EucGxcIjp0cnVlLFwid2F3LnBsXCI6dHJ1ZSxcIndlZ3Jvdy5wbFwiOnRydWUsXCJ3aWVsdW4ucGxcIjp0cnVlLFwid2xvY2wucGxcIjp0cnVlLFwid2xvY2xhd2VrLnBsXCI6dHJ1ZSxcIndvZHppc2xhdy5wbFwiOnRydWUsXCJ3b2xvbWluLnBsXCI6dHJ1ZSxcIndyb2NsYXcucGxcIjp0cnVlLFwiemFjaHBvbW9yLnBsXCI6dHJ1ZSxcInphZ2FuLnBsXCI6dHJ1ZSxcInphcm93LnBsXCI6dHJ1ZSxcInpnb3JhLnBsXCI6dHJ1ZSxcInpnb3J6ZWxlYy5wbFwiOnRydWUsXCJwbVwiOnRydWUsXCJwblwiOnRydWUsXCJnb3YucG5cIjp0cnVlLFwiY28ucG5cIjp0cnVlLFwib3JnLnBuXCI6dHJ1ZSxcImVkdS5wblwiOnRydWUsXCJuZXQucG5cIjp0cnVlLFwicG9zdFwiOnRydWUsXCJwclwiOnRydWUsXCJjb20ucHJcIjp0cnVlLFwibmV0LnByXCI6dHJ1ZSxcIm9yZy5wclwiOnRydWUsXCJnb3YucHJcIjp0cnVlLFwiZWR1LnByXCI6dHJ1ZSxcImlzbGEucHJcIjp0cnVlLFwicHJvLnByXCI6dHJ1ZSxcImJpei5wclwiOnRydWUsXCJpbmZvLnByXCI6dHJ1ZSxcIm5hbWUucHJcIjp0cnVlLFwiZXN0LnByXCI6dHJ1ZSxcInByb2YucHJcIjp0cnVlLFwiYWMucHJcIjp0cnVlLFwicHJvXCI6dHJ1ZSxcImFjYS5wcm9cIjp0cnVlLFwiYmFyLnByb1wiOnRydWUsXCJjcGEucHJvXCI6dHJ1ZSxcImp1ci5wcm9cIjp0cnVlLFwibGF3LnByb1wiOnRydWUsXCJtZWQucHJvXCI6dHJ1ZSxcImVuZy5wcm9cIjp0cnVlLFwicHNcIjp0cnVlLFwiZWR1LnBzXCI6dHJ1ZSxcImdvdi5wc1wiOnRydWUsXCJzZWMucHNcIjp0cnVlLFwicGxvLnBzXCI6dHJ1ZSxcImNvbS5wc1wiOnRydWUsXCJvcmcucHNcIjp0cnVlLFwibmV0LnBzXCI6dHJ1ZSxcInB0XCI6dHJ1ZSxcIm5ldC5wdFwiOnRydWUsXCJnb3YucHRcIjp0cnVlLFwib3JnLnB0XCI6dHJ1ZSxcImVkdS5wdFwiOnRydWUsXCJpbnQucHRcIjp0cnVlLFwicHVibC5wdFwiOnRydWUsXCJjb20ucHRcIjp0cnVlLFwibm9tZS5wdFwiOnRydWUsXCJwd1wiOnRydWUsXCJjby5wd1wiOnRydWUsXCJuZS5wd1wiOnRydWUsXCJvci5wd1wiOnRydWUsXCJlZC5wd1wiOnRydWUsXCJnby5wd1wiOnRydWUsXCJiZWxhdS5wd1wiOnRydWUsXCJweVwiOnRydWUsXCJjb20ucHlcIjp0cnVlLFwiY29vcC5weVwiOnRydWUsXCJlZHUucHlcIjp0cnVlLFwiZ292LnB5XCI6dHJ1ZSxcIm1pbC5weVwiOnRydWUsXCJuZXQucHlcIjp0cnVlLFwib3JnLnB5XCI6dHJ1ZSxcInFhXCI6dHJ1ZSxcImNvbS5xYVwiOnRydWUsXCJlZHUucWFcIjp0cnVlLFwiZ292LnFhXCI6dHJ1ZSxcIm1pbC5xYVwiOnRydWUsXCJuYW1lLnFhXCI6dHJ1ZSxcIm5ldC5xYVwiOnRydWUsXCJvcmcucWFcIjp0cnVlLFwic2NoLnFhXCI6dHJ1ZSxcInJlXCI6dHJ1ZSxcImNvbS5yZVwiOnRydWUsXCJhc3NvLnJlXCI6dHJ1ZSxcIm5vbS5yZVwiOnRydWUsXCJyb1wiOnRydWUsXCJjb20ucm9cIjp0cnVlLFwib3JnLnJvXCI6dHJ1ZSxcInRtLnJvXCI6dHJ1ZSxcIm50LnJvXCI6dHJ1ZSxcIm5vbS5yb1wiOnRydWUsXCJpbmZvLnJvXCI6dHJ1ZSxcInJlYy5yb1wiOnRydWUsXCJhcnRzLnJvXCI6dHJ1ZSxcImZpcm0ucm9cIjp0cnVlLFwic3RvcmUucm9cIjp0cnVlLFwid3d3LnJvXCI6dHJ1ZSxcInJzXCI6dHJ1ZSxcImNvLnJzXCI6dHJ1ZSxcIm9yZy5yc1wiOnRydWUsXCJlZHUucnNcIjp0cnVlLFwiYWMucnNcIjp0cnVlLFwiZ292LnJzXCI6dHJ1ZSxcImluLnJzXCI6dHJ1ZSxcInJ1XCI6dHJ1ZSxcImFjLnJ1XCI6dHJ1ZSxcImNvbS5ydVwiOnRydWUsXCJlZHUucnVcIjp0cnVlLFwiaW50LnJ1XCI6dHJ1ZSxcIm5ldC5ydVwiOnRydWUsXCJvcmcucnVcIjp0cnVlLFwicHAucnVcIjp0cnVlLFwiYWR5Z2V5YS5ydVwiOnRydWUsXCJhbHRhaS5ydVwiOnRydWUsXCJhbXVyLnJ1XCI6dHJ1ZSxcImFya2hhbmdlbHNrLnJ1XCI6dHJ1ZSxcImFzdHJha2hhbi5ydVwiOnRydWUsXCJiYXNoa2lyaWEucnVcIjp0cnVlLFwiYmVsZ29yb2QucnVcIjp0cnVlLFwiYmlyLnJ1XCI6dHJ1ZSxcImJyeWFuc2sucnVcIjp0cnVlLFwiYnVyeWF0aWEucnVcIjp0cnVlLFwiY2JnLnJ1XCI6dHJ1ZSxcImNoZWwucnVcIjp0cnVlLFwiY2hlbHlhYmluc2sucnVcIjp0cnVlLFwiY2hpdGEucnVcIjp0cnVlLFwiY2h1a290a2EucnVcIjp0cnVlLFwiY2h1dmFzaGlhLnJ1XCI6dHJ1ZSxcImRhZ2VzdGFuLnJ1XCI6dHJ1ZSxcImR1ZGlua2EucnVcIjp0cnVlLFwiZS1idXJnLnJ1XCI6dHJ1ZSxcImdyb3pueS5ydVwiOnRydWUsXCJpcmt1dHNrLnJ1XCI6dHJ1ZSxcIml2YW5vdm8ucnVcIjp0cnVlLFwiaXpoZXZzay5ydVwiOnRydWUsXCJqYXIucnVcIjp0cnVlLFwiam9zaGthci1vbGEucnVcIjp0cnVlLFwia2FsbXlraWEucnVcIjp0cnVlLFwia2FsdWdhLnJ1XCI6dHJ1ZSxcImthbWNoYXRrYS5ydVwiOnRydWUsXCJrYXJlbGlhLnJ1XCI6dHJ1ZSxcImthemFuLnJ1XCI6dHJ1ZSxcImtjaHIucnVcIjp0cnVlLFwia2VtZXJvdm8ucnVcIjp0cnVlLFwia2hhYmFyb3Zzay5ydVwiOnRydWUsXCJraGFrYXNzaWEucnVcIjp0cnVlLFwia2h2LnJ1XCI6dHJ1ZSxcImtpcm92LnJ1XCI6dHJ1ZSxcImtvZW5pZy5ydVwiOnRydWUsXCJrb21pLnJ1XCI6dHJ1ZSxcImtvc3Ryb21hLnJ1XCI6dHJ1ZSxcImtyYXNub3lhcnNrLnJ1XCI6dHJ1ZSxcImt1YmFuLnJ1XCI6dHJ1ZSxcImt1cmdhbi5ydVwiOnRydWUsXCJrdXJzay5ydVwiOnRydWUsXCJsaXBldHNrLnJ1XCI6dHJ1ZSxcIm1hZ2FkYW4ucnVcIjp0cnVlLFwibWFyaS5ydVwiOnRydWUsXCJtYXJpLWVsLnJ1XCI6dHJ1ZSxcIm1hcmluZS5ydVwiOnRydWUsXCJtb3Jkb3ZpYS5ydVwiOnRydWUsXCJtc2sucnVcIjp0cnVlLFwibXVybWFuc2sucnVcIjp0cnVlLFwibmFsY2hpay5ydVwiOnRydWUsXCJubm92LnJ1XCI6dHJ1ZSxcIm5vdi5ydVwiOnRydWUsXCJub3Zvc2liaXJzay5ydVwiOnRydWUsXCJuc2sucnVcIjp0cnVlLFwib21zay5ydVwiOnRydWUsXCJvcmVuYnVyZy5ydVwiOnRydWUsXCJvcnlvbC5ydVwiOnRydWUsXCJwYWxhbmEucnVcIjp0cnVlLFwicGVuemEucnVcIjp0cnVlLFwicGVybS5ydVwiOnRydWUsXCJwdHoucnVcIjp0cnVlLFwicm5kLnJ1XCI6dHJ1ZSxcInJ5YXphbi5ydVwiOnRydWUsXCJzYWtoYWxpbi5ydVwiOnRydWUsXCJzYW1hcmEucnVcIjp0cnVlLFwic2FyYXRvdi5ydVwiOnRydWUsXCJzaW1iaXJzay5ydVwiOnRydWUsXCJzbW9sZW5zay5ydVwiOnRydWUsXCJzcGIucnVcIjp0cnVlLFwic3RhdnJvcG9sLnJ1XCI6dHJ1ZSxcInN0di5ydVwiOnRydWUsXCJzdXJndXQucnVcIjp0cnVlLFwidGFtYm92LnJ1XCI6dHJ1ZSxcInRhdGFyc3Rhbi5ydVwiOnRydWUsXCJ0b20ucnVcIjp0cnVlLFwidG9tc2sucnVcIjp0cnVlLFwidHNhcml0c3luLnJ1XCI6dHJ1ZSxcInRzay5ydVwiOnRydWUsXCJ0dWxhLnJ1XCI6dHJ1ZSxcInR1dmEucnVcIjp0cnVlLFwidHZlci5ydVwiOnRydWUsXCJ0eXVtZW4ucnVcIjp0cnVlLFwidWRtLnJ1XCI6dHJ1ZSxcInVkbXVydGlhLnJ1XCI6dHJ1ZSxcInVsYW4tdWRlLnJ1XCI6dHJ1ZSxcInZsYWRpa2F2a2F6LnJ1XCI6dHJ1ZSxcInZsYWRpbWlyLnJ1XCI6dHJ1ZSxcInZsYWRpdm9zdG9rLnJ1XCI6dHJ1ZSxcInZvbGdvZ3JhZC5ydVwiOnRydWUsXCJ2b2xvZ2RhLnJ1XCI6dHJ1ZSxcInZvcm9uZXpoLnJ1XCI6dHJ1ZSxcInZybi5ydVwiOnRydWUsXCJ2eWF0a2EucnVcIjp0cnVlLFwieWFrdXRpYS5ydVwiOnRydWUsXCJ5YW1hbC5ydVwiOnRydWUsXCJ5YXJvc2xhdmwucnVcIjp0cnVlLFwieWVrYXRlcmluYnVyZy5ydVwiOnRydWUsXCJ5dXpobm8tc2FraGFsaW5zay5ydVwiOnRydWUsXCJhbXVyc2sucnVcIjp0cnVlLFwiYmFpa2FsLnJ1XCI6dHJ1ZSxcImNtdy5ydVwiOnRydWUsXCJmYXJlYXN0LnJ1XCI6dHJ1ZSxcImphbWFsLnJ1XCI6dHJ1ZSxcImttcy5ydVwiOnRydWUsXCJrLXVyYWxzay5ydVwiOnRydWUsXCJrdXN0YW5haS5ydVwiOnRydWUsXCJrdXpiYXNzLnJ1XCI6dHJ1ZSxcIm1hZ25pdGthLnJ1XCI6dHJ1ZSxcIm15dGlzLnJ1XCI6dHJ1ZSxcIm5ha2hvZGthLnJ1XCI6dHJ1ZSxcIm5rei5ydVwiOnRydWUsXCJub3JpbHNrLnJ1XCI6dHJ1ZSxcIm9za29sLnJ1XCI6dHJ1ZSxcInB5YXRpZ29yc2sucnVcIjp0cnVlLFwicnVidHNvdnNrLnJ1XCI6dHJ1ZSxcInNuei5ydVwiOnRydWUsXCJzeXpyYW4ucnVcIjp0cnVlLFwidmRvbnNrLnJ1XCI6dHJ1ZSxcInpncmFkLnJ1XCI6dHJ1ZSxcImdvdi5ydVwiOnRydWUsXCJtaWwucnVcIjp0cnVlLFwidGVzdC5ydVwiOnRydWUsXCJyd1wiOnRydWUsXCJnb3YucndcIjp0cnVlLFwibmV0LnJ3XCI6dHJ1ZSxcImVkdS5yd1wiOnRydWUsXCJhYy5yd1wiOnRydWUsXCJjb20ucndcIjp0cnVlLFwiY28ucndcIjp0cnVlLFwiaW50LnJ3XCI6dHJ1ZSxcIm1pbC5yd1wiOnRydWUsXCJnb3V2LnJ3XCI6dHJ1ZSxcInNhXCI6dHJ1ZSxcImNvbS5zYVwiOnRydWUsXCJuZXQuc2FcIjp0cnVlLFwib3JnLnNhXCI6dHJ1ZSxcImdvdi5zYVwiOnRydWUsXCJtZWQuc2FcIjp0cnVlLFwicHViLnNhXCI6dHJ1ZSxcImVkdS5zYVwiOnRydWUsXCJzY2guc2FcIjp0cnVlLFwic2JcIjp0cnVlLFwiY29tLnNiXCI6dHJ1ZSxcImVkdS5zYlwiOnRydWUsXCJnb3Yuc2JcIjp0cnVlLFwibmV0LnNiXCI6dHJ1ZSxcIm9yZy5zYlwiOnRydWUsXCJzY1wiOnRydWUsXCJjb20uc2NcIjp0cnVlLFwiZ292LnNjXCI6dHJ1ZSxcIm5ldC5zY1wiOnRydWUsXCJvcmcuc2NcIjp0cnVlLFwiZWR1LnNjXCI6dHJ1ZSxcInNkXCI6dHJ1ZSxcImNvbS5zZFwiOnRydWUsXCJuZXQuc2RcIjp0cnVlLFwib3JnLnNkXCI6dHJ1ZSxcImVkdS5zZFwiOnRydWUsXCJtZWQuc2RcIjp0cnVlLFwidHYuc2RcIjp0cnVlLFwiZ292LnNkXCI6dHJ1ZSxcImluZm8uc2RcIjp0cnVlLFwic2VcIjp0cnVlLFwiYS5zZVwiOnRydWUsXCJhYy5zZVwiOnRydWUsXCJiLnNlXCI6dHJ1ZSxcImJkLnNlXCI6dHJ1ZSxcImJyYW5kLnNlXCI6dHJ1ZSxcImMuc2VcIjp0cnVlLFwiZC5zZVwiOnRydWUsXCJlLnNlXCI6dHJ1ZSxcImYuc2VcIjp0cnVlLFwiZmguc2VcIjp0cnVlLFwiZmhzay5zZVwiOnRydWUsXCJmaHYuc2VcIjp0cnVlLFwiZy5zZVwiOnRydWUsXCJoLnNlXCI6dHJ1ZSxcImkuc2VcIjp0cnVlLFwiay5zZVwiOnRydWUsXCJrb21mb3JiLnNlXCI6dHJ1ZSxcImtvbW11bmFsZm9yYnVuZC5zZVwiOnRydWUsXCJrb212dXguc2VcIjp0cnVlLFwibC5zZVwiOnRydWUsXCJsYW5iaWIuc2VcIjp0cnVlLFwibS5zZVwiOnRydWUsXCJuLnNlXCI6dHJ1ZSxcIm5hdHVyYnJ1a3NneW1uLnNlXCI6dHJ1ZSxcIm8uc2VcIjp0cnVlLFwib3JnLnNlXCI6dHJ1ZSxcInAuc2VcIjp0cnVlLFwicGFydGkuc2VcIjp0cnVlLFwicHAuc2VcIjp0cnVlLFwicHJlc3Muc2VcIjp0cnVlLFwici5zZVwiOnRydWUsXCJzLnNlXCI6dHJ1ZSxcInQuc2VcIjp0cnVlLFwidG0uc2VcIjp0cnVlLFwidS5zZVwiOnRydWUsXCJ3LnNlXCI6dHJ1ZSxcInguc2VcIjp0cnVlLFwieS5zZVwiOnRydWUsXCJ6LnNlXCI6dHJ1ZSxcInNnXCI6dHJ1ZSxcImNvbS5zZ1wiOnRydWUsXCJuZXQuc2dcIjp0cnVlLFwib3JnLnNnXCI6dHJ1ZSxcImdvdi5zZ1wiOnRydWUsXCJlZHUuc2dcIjp0cnVlLFwicGVyLnNnXCI6dHJ1ZSxcInNoXCI6dHJ1ZSxcImNvbS5zaFwiOnRydWUsXCJuZXQuc2hcIjp0cnVlLFwiZ292LnNoXCI6dHJ1ZSxcIm9yZy5zaFwiOnRydWUsXCJtaWwuc2hcIjp0cnVlLFwic2lcIjp0cnVlLFwic2pcIjp0cnVlLFwic2tcIjp0cnVlLFwic2xcIjp0cnVlLFwiY29tLnNsXCI6dHJ1ZSxcIm5ldC5zbFwiOnRydWUsXCJlZHUuc2xcIjp0cnVlLFwiZ292LnNsXCI6dHJ1ZSxcIm9yZy5zbFwiOnRydWUsXCJzbVwiOnRydWUsXCJzblwiOnRydWUsXCJhcnQuc25cIjp0cnVlLFwiY29tLnNuXCI6dHJ1ZSxcImVkdS5zblwiOnRydWUsXCJnb3V2LnNuXCI6dHJ1ZSxcIm9yZy5zblwiOnRydWUsXCJwZXJzby5zblwiOnRydWUsXCJ1bml2LnNuXCI6dHJ1ZSxcInNvXCI6dHJ1ZSxcImNvbS5zb1wiOnRydWUsXCJuZXQuc29cIjp0cnVlLFwib3JnLnNvXCI6dHJ1ZSxcInNyXCI6dHJ1ZSxcInN0XCI6dHJ1ZSxcImNvLnN0XCI6dHJ1ZSxcImNvbS5zdFwiOnRydWUsXCJjb25zdWxhZG8uc3RcIjp0cnVlLFwiZWR1LnN0XCI6dHJ1ZSxcImVtYmFpeGFkYS5zdFwiOnRydWUsXCJnb3Yuc3RcIjp0cnVlLFwibWlsLnN0XCI6dHJ1ZSxcIm5ldC5zdFwiOnRydWUsXCJvcmcuc3RcIjp0cnVlLFwicHJpbmNpcGUuc3RcIjp0cnVlLFwic2FvdG9tZS5zdFwiOnRydWUsXCJzdG9yZS5zdFwiOnRydWUsXCJzdVwiOnRydWUsXCJhZHlnZXlhLnN1XCI6dHJ1ZSxcImFya2hhbmdlbHNrLnN1XCI6dHJ1ZSxcImJhbGFzaG92LnN1XCI6dHJ1ZSxcImJhc2hraXJpYS5zdVwiOnRydWUsXCJicnlhbnNrLnN1XCI6dHJ1ZSxcImRhZ2VzdGFuLnN1XCI6dHJ1ZSxcImdyb3pueS5zdVwiOnRydWUsXCJpdmFub3ZvLnN1XCI6dHJ1ZSxcImthbG15a2lhLnN1XCI6dHJ1ZSxcImthbHVnYS5zdVwiOnRydWUsXCJrYXJlbGlhLnN1XCI6dHJ1ZSxcImtoYWthc3NpYS5zdVwiOnRydWUsXCJrcmFzbm9kYXIuc3VcIjp0cnVlLFwia3VyZ2FuLnN1XCI6dHJ1ZSxcImxlbnVnLnN1XCI6dHJ1ZSxcIm1vcmRvdmlhLnN1XCI6dHJ1ZSxcIm1zay5zdVwiOnRydWUsXCJtdXJtYW5zay5zdVwiOnRydWUsXCJuYWxjaGlrLnN1XCI6dHJ1ZSxcIm5vdi5zdVwiOnRydWUsXCJvYm5pbnNrLnN1XCI6dHJ1ZSxcInBlbnphLnN1XCI6dHJ1ZSxcInBva3JvdnNrLnN1XCI6dHJ1ZSxcInNvY2hpLnN1XCI6dHJ1ZSxcInNwYi5zdVwiOnRydWUsXCJ0b2dsaWF0dGkuc3VcIjp0cnVlLFwidHJvaXRzay5zdVwiOnRydWUsXCJ0dWxhLnN1XCI6dHJ1ZSxcInR1dmEuc3VcIjp0cnVlLFwidmxhZGlrYXZrYXouc3VcIjp0cnVlLFwidmxhZGltaXIuc3VcIjp0cnVlLFwidm9sb2dkYS5zdVwiOnRydWUsXCJzdlwiOnRydWUsXCJjb20uc3ZcIjp0cnVlLFwiZWR1LnN2XCI6dHJ1ZSxcImdvYi5zdlwiOnRydWUsXCJvcmcuc3ZcIjp0cnVlLFwicmVkLnN2XCI6dHJ1ZSxcInN4XCI6dHJ1ZSxcImdvdi5zeFwiOnRydWUsXCJzeVwiOnRydWUsXCJlZHUuc3lcIjp0cnVlLFwiZ292LnN5XCI6dHJ1ZSxcIm5ldC5zeVwiOnRydWUsXCJtaWwuc3lcIjp0cnVlLFwiY29tLnN5XCI6dHJ1ZSxcIm9yZy5zeVwiOnRydWUsXCJzelwiOnRydWUsXCJjby5zelwiOnRydWUsXCJhYy5zelwiOnRydWUsXCJvcmcuc3pcIjp0cnVlLFwidGNcIjp0cnVlLFwidGRcIjp0cnVlLFwidGVsXCI6dHJ1ZSxcInRmXCI6dHJ1ZSxcInRnXCI6dHJ1ZSxcInRoXCI6dHJ1ZSxcImFjLnRoXCI6dHJ1ZSxcImNvLnRoXCI6dHJ1ZSxcImdvLnRoXCI6dHJ1ZSxcImluLnRoXCI6dHJ1ZSxcIm1pLnRoXCI6dHJ1ZSxcIm5ldC50aFwiOnRydWUsXCJvci50aFwiOnRydWUsXCJ0alwiOnRydWUsXCJhYy50alwiOnRydWUsXCJiaXoudGpcIjp0cnVlLFwiY28udGpcIjp0cnVlLFwiY29tLnRqXCI6dHJ1ZSxcImVkdS50alwiOnRydWUsXCJnby50alwiOnRydWUsXCJnb3YudGpcIjp0cnVlLFwiaW50LnRqXCI6dHJ1ZSxcIm1pbC50alwiOnRydWUsXCJuYW1lLnRqXCI6dHJ1ZSxcIm5ldC50alwiOnRydWUsXCJuaWMudGpcIjp0cnVlLFwib3JnLnRqXCI6dHJ1ZSxcInRlc3QudGpcIjp0cnVlLFwid2ViLnRqXCI6dHJ1ZSxcInRrXCI6dHJ1ZSxcInRsXCI6dHJ1ZSxcImdvdi50bFwiOnRydWUsXCJ0bVwiOnRydWUsXCJjb20udG1cIjp0cnVlLFwiY28udG1cIjp0cnVlLFwib3JnLnRtXCI6dHJ1ZSxcIm5ldC50bVwiOnRydWUsXCJub20udG1cIjp0cnVlLFwiZ292LnRtXCI6dHJ1ZSxcIm1pbC50bVwiOnRydWUsXCJlZHUudG1cIjp0cnVlLFwidG5cIjp0cnVlLFwiY29tLnRuXCI6dHJ1ZSxcImVucy50blwiOnRydWUsXCJmaW4udG5cIjp0cnVlLFwiZ292LnRuXCI6dHJ1ZSxcImluZC50blwiOnRydWUsXCJpbnRsLnRuXCI6dHJ1ZSxcIm5hdC50blwiOnRydWUsXCJuZXQudG5cIjp0cnVlLFwib3JnLnRuXCI6dHJ1ZSxcImluZm8udG5cIjp0cnVlLFwicGVyc28udG5cIjp0cnVlLFwidG91cmlzbS50blwiOnRydWUsXCJlZHVuZXQudG5cIjp0cnVlLFwicm5ydC50blwiOnRydWUsXCJybnMudG5cIjp0cnVlLFwicm51LnRuXCI6dHJ1ZSxcIm1pbmNvbS50blwiOnRydWUsXCJhZ3JpbmV0LnRuXCI6dHJ1ZSxcImRlZmVuc2UudG5cIjp0cnVlLFwidHVyZW4udG5cIjp0cnVlLFwidG9cIjp0cnVlLFwiY29tLnRvXCI6dHJ1ZSxcImdvdi50b1wiOnRydWUsXCJuZXQudG9cIjp0cnVlLFwib3JnLnRvXCI6dHJ1ZSxcImVkdS50b1wiOnRydWUsXCJtaWwudG9cIjp0cnVlLFwidHBcIjp0cnVlLFwidHJcIjp0cnVlLFwiY29tLnRyXCI6dHJ1ZSxcImluZm8udHJcIjp0cnVlLFwiYml6LnRyXCI6dHJ1ZSxcIm5ldC50clwiOnRydWUsXCJvcmcudHJcIjp0cnVlLFwid2ViLnRyXCI6dHJ1ZSxcImdlbi50clwiOnRydWUsXCJ0di50clwiOnRydWUsXCJhdi50clwiOnRydWUsXCJkci50clwiOnRydWUsXCJiYnMudHJcIjp0cnVlLFwibmFtZS50clwiOnRydWUsXCJ0ZWwudHJcIjp0cnVlLFwiZ292LnRyXCI6dHJ1ZSxcImJlbC50clwiOnRydWUsXCJwb2wudHJcIjp0cnVlLFwibWlsLnRyXCI6dHJ1ZSxcImsxMi50clwiOnRydWUsXCJlZHUudHJcIjp0cnVlLFwia2VwLnRyXCI6dHJ1ZSxcIm5jLnRyXCI6dHJ1ZSxcImdvdi5uYy50clwiOnRydWUsXCJ0cmF2ZWxcIjp0cnVlLFwidHRcIjp0cnVlLFwiY28udHRcIjp0cnVlLFwiY29tLnR0XCI6dHJ1ZSxcIm9yZy50dFwiOnRydWUsXCJuZXQudHRcIjp0cnVlLFwiYml6LnR0XCI6dHJ1ZSxcImluZm8udHRcIjp0cnVlLFwicHJvLnR0XCI6dHJ1ZSxcImludC50dFwiOnRydWUsXCJjb29wLnR0XCI6dHJ1ZSxcImpvYnMudHRcIjp0cnVlLFwibW9iaS50dFwiOnRydWUsXCJ0cmF2ZWwudHRcIjp0cnVlLFwibXVzZXVtLnR0XCI6dHJ1ZSxcImFlcm8udHRcIjp0cnVlLFwibmFtZS50dFwiOnRydWUsXCJnb3YudHRcIjp0cnVlLFwiZWR1LnR0XCI6dHJ1ZSxcInR2XCI6dHJ1ZSxcInR3XCI6dHJ1ZSxcImVkdS50d1wiOnRydWUsXCJnb3YudHdcIjp0cnVlLFwibWlsLnR3XCI6dHJ1ZSxcImNvbS50d1wiOnRydWUsXCJuZXQudHdcIjp0cnVlLFwib3JnLnR3XCI6dHJ1ZSxcImlkdi50d1wiOnRydWUsXCJnYW1lLnR3XCI6dHJ1ZSxcImViaXoudHdcIjp0cnVlLFwiY2x1Yi50d1wiOnRydWUsXCJ4bi0temYwYW82NGEudHdcIjp0cnVlLFwieG4tLXVjMGF0di50d1wiOnRydWUsXCJ4bi0tY3pydzI4Yi50d1wiOnRydWUsXCJ0elwiOnRydWUsXCJhYy50elwiOnRydWUsXCJjby50elwiOnRydWUsXCJnby50elwiOnRydWUsXCJob3RlbC50elwiOnRydWUsXCJpbmZvLnR6XCI6dHJ1ZSxcIm1lLnR6XCI6dHJ1ZSxcIm1pbC50elwiOnRydWUsXCJtb2JpLnR6XCI6dHJ1ZSxcIm5lLnR6XCI6dHJ1ZSxcIm9yLnR6XCI6dHJ1ZSxcInNjLnR6XCI6dHJ1ZSxcInR2LnR6XCI6dHJ1ZSxcInVhXCI6dHJ1ZSxcImNvbS51YVwiOnRydWUsXCJlZHUudWFcIjp0cnVlLFwiZ292LnVhXCI6dHJ1ZSxcImluLnVhXCI6dHJ1ZSxcIm5ldC51YVwiOnRydWUsXCJvcmcudWFcIjp0cnVlLFwiY2hlcmthc3N5LnVhXCI6dHJ1ZSxcImNoZXJrYXN5LnVhXCI6dHJ1ZSxcImNoZXJuaWdvdi51YVwiOnRydWUsXCJjaGVybmloaXYudWFcIjp0cnVlLFwiY2hlcm5pdnRzaS51YVwiOnRydWUsXCJjaGVybm92dHN5LnVhXCI6dHJ1ZSxcImNrLnVhXCI6dHJ1ZSxcImNuLnVhXCI6dHJ1ZSxcImNyLnVhXCI6dHJ1ZSxcImNyaW1lYS51YVwiOnRydWUsXCJjdi51YVwiOnRydWUsXCJkbi51YVwiOnRydWUsXCJkbmVwcm9wZXRyb3Zzay51YVwiOnRydWUsXCJkbmlwcm9wZXRyb3Zzay51YVwiOnRydWUsXCJkb21pbmljLnVhXCI6dHJ1ZSxcImRvbmV0c2sudWFcIjp0cnVlLFwiZHAudWFcIjp0cnVlLFwiaWYudWFcIjp0cnVlLFwiaXZhbm8tZnJhbmtpdnNrLnVhXCI6dHJ1ZSxcImtoLnVhXCI6dHJ1ZSxcImtoYXJraXYudWFcIjp0cnVlLFwia2hhcmtvdi51YVwiOnRydWUsXCJraGVyc29uLnVhXCI6dHJ1ZSxcImtobWVsbml0c2tpeS51YVwiOnRydWUsXCJraG1lbG55dHNreWkudWFcIjp0cnVlLFwia2lldi51YVwiOnRydWUsXCJraXJvdm9ncmFkLnVhXCI6dHJ1ZSxcImttLnVhXCI6dHJ1ZSxcImtyLnVhXCI6dHJ1ZSxcImtyeW0udWFcIjp0cnVlLFwia3MudWFcIjp0cnVlLFwia3YudWFcIjp0cnVlLFwia3lpdi51YVwiOnRydWUsXCJsZy51YVwiOnRydWUsXCJsdC51YVwiOnRydWUsXCJsdWdhbnNrLnVhXCI6dHJ1ZSxcImx1dHNrLnVhXCI6dHJ1ZSxcImx2LnVhXCI6dHJ1ZSxcImx2aXYudWFcIjp0cnVlLFwibWsudWFcIjp0cnVlLFwibXlrb2xhaXYudWFcIjp0cnVlLFwibmlrb2xhZXYudWFcIjp0cnVlLFwib2QudWFcIjp0cnVlLFwib2Rlc2EudWFcIjp0cnVlLFwib2Rlc3NhLnVhXCI6dHJ1ZSxcInBsLnVhXCI6dHJ1ZSxcInBvbHRhdmEudWFcIjp0cnVlLFwicml2bmUudWFcIjp0cnVlLFwicm92bm8udWFcIjp0cnVlLFwicnYudWFcIjp0cnVlLFwic2IudWFcIjp0cnVlLFwic2ViYXN0b3BvbC51YVwiOnRydWUsXCJzZXZhc3RvcG9sLnVhXCI6dHJ1ZSxcInNtLnVhXCI6dHJ1ZSxcInN1bXkudWFcIjp0cnVlLFwidGUudWFcIjp0cnVlLFwidGVybm9waWwudWFcIjp0cnVlLFwidXoudWFcIjp0cnVlLFwidXpoZ29yb2QudWFcIjp0cnVlLFwidmlubmljYS51YVwiOnRydWUsXCJ2aW5ueXRzaWEudWFcIjp0cnVlLFwidm4udWFcIjp0cnVlLFwidm9seW4udWFcIjp0cnVlLFwieWFsdGEudWFcIjp0cnVlLFwiemFwb3Jpemh6aGUudWFcIjp0cnVlLFwiemFwb3Jpemh6aGlhLnVhXCI6dHJ1ZSxcInpoaXRvbWlyLnVhXCI6dHJ1ZSxcInpoeXRvbXlyLnVhXCI6dHJ1ZSxcInpwLnVhXCI6dHJ1ZSxcInp0LnVhXCI6dHJ1ZSxcInVnXCI6dHJ1ZSxcImNvLnVnXCI6dHJ1ZSxcIm9yLnVnXCI6dHJ1ZSxcImFjLnVnXCI6dHJ1ZSxcInNjLnVnXCI6dHJ1ZSxcImdvLnVnXCI6dHJ1ZSxcIm5lLnVnXCI6dHJ1ZSxcImNvbS51Z1wiOnRydWUsXCJvcmcudWdcIjp0cnVlLFwidWtcIjp0cnVlLFwiYWMudWtcIjp0cnVlLFwiY28udWtcIjp0cnVlLFwiZ292LnVrXCI6dHJ1ZSxcImx0ZC51a1wiOnRydWUsXCJtZS51a1wiOnRydWUsXCJuZXQudWtcIjp0cnVlLFwibmhzLnVrXCI6dHJ1ZSxcIm9yZy51a1wiOnRydWUsXCJwbGMudWtcIjp0cnVlLFwicG9saWNlLnVrXCI6dHJ1ZSxcIiouc2NoLnVrXCI6dHJ1ZSxcInVzXCI6dHJ1ZSxcImRuaS51c1wiOnRydWUsXCJmZWQudXNcIjp0cnVlLFwiaXNhLnVzXCI6dHJ1ZSxcImtpZHMudXNcIjp0cnVlLFwibnNuLnVzXCI6dHJ1ZSxcImFrLnVzXCI6dHJ1ZSxcImFsLnVzXCI6dHJ1ZSxcImFyLnVzXCI6dHJ1ZSxcImFzLnVzXCI6dHJ1ZSxcImF6LnVzXCI6dHJ1ZSxcImNhLnVzXCI6dHJ1ZSxcImNvLnVzXCI6dHJ1ZSxcImN0LnVzXCI6dHJ1ZSxcImRjLnVzXCI6dHJ1ZSxcImRlLnVzXCI6dHJ1ZSxcImZsLnVzXCI6dHJ1ZSxcImdhLnVzXCI6dHJ1ZSxcImd1LnVzXCI6dHJ1ZSxcImhpLnVzXCI6dHJ1ZSxcImlhLnVzXCI6dHJ1ZSxcImlkLnVzXCI6dHJ1ZSxcImlsLnVzXCI6dHJ1ZSxcImluLnVzXCI6dHJ1ZSxcImtzLnVzXCI6dHJ1ZSxcImt5LnVzXCI6dHJ1ZSxcImxhLnVzXCI6dHJ1ZSxcIm1hLnVzXCI6dHJ1ZSxcIm1kLnVzXCI6dHJ1ZSxcIm1lLnVzXCI6dHJ1ZSxcIm1pLnVzXCI6dHJ1ZSxcIm1uLnVzXCI6dHJ1ZSxcIm1vLnVzXCI6dHJ1ZSxcIm1zLnVzXCI6dHJ1ZSxcIm10LnVzXCI6dHJ1ZSxcIm5jLnVzXCI6dHJ1ZSxcIm5kLnVzXCI6dHJ1ZSxcIm5lLnVzXCI6dHJ1ZSxcIm5oLnVzXCI6dHJ1ZSxcIm5qLnVzXCI6dHJ1ZSxcIm5tLnVzXCI6dHJ1ZSxcIm52LnVzXCI6dHJ1ZSxcIm55LnVzXCI6dHJ1ZSxcIm9oLnVzXCI6dHJ1ZSxcIm9rLnVzXCI6dHJ1ZSxcIm9yLnVzXCI6dHJ1ZSxcInBhLnVzXCI6dHJ1ZSxcInByLnVzXCI6dHJ1ZSxcInJpLnVzXCI6dHJ1ZSxcInNjLnVzXCI6dHJ1ZSxcInNkLnVzXCI6dHJ1ZSxcInRuLnVzXCI6dHJ1ZSxcInR4LnVzXCI6dHJ1ZSxcInV0LnVzXCI6dHJ1ZSxcInZpLnVzXCI6dHJ1ZSxcInZ0LnVzXCI6dHJ1ZSxcInZhLnVzXCI6dHJ1ZSxcIndhLnVzXCI6dHJ1ZSxcIndpLnVzXCI6dHJ1ZSxcInd2LnVzXCI6dHJ1ZSxcInd5LnVzXCI6dHJ1ZSxcImsxMi5hay51c1wiOnRydWUsXCJrMTIuYWwudXNcIjp0cnVlLFwiazEyLmFyLnVzXCI6dHJ1ZSxcImsxMi5hcy51c1wiOnRydWUsXCJrMTIuYXoudXNcIjp0cnVlLFwiazEyLmNhLnVzXCI6dHJ1ZSxcImsxMi5jby51c1wiOnRydWUsXCJrMTIuY3QudXNcIjp0cnVlLFwiazEyLmRjLnVzXCI6dHJ1ZSxcImsxMi5kZS51c1wiOnRydWUsXCJrMTIuZmwudXNcIjp0cnVlLFwiazEyLmdhLnVzXCI6dHJ1ZSxcImsxMi5ndS51c1wiOnRydWUsXCJrMTIuaWEudXNcIjp0cnVlLFwiazEyLmlkLnVzXCI6dHJ1ZSxcImsxMi5pbC51c1wiOnRydWUsXCJrMTIuaW4udXNcIjp0cnVlLFwiazEyLmtzLnVzXCI6dHJ1ZSxcImsxMi5reS51c1wiOnRydWUsXCJrMTIubGEudXNcIjp0cnVlLFwiazEyLm1hLnVzXCI6dHJ1ZSxcImsxMi5tZC51c1wiOnRydWUsXCJrMTIubWUudXNcIjp0cnVlLFwiazEyLm1pLnVzXCI6dHJ1ZSxcImsxMi5tbi51c1wiOnRydWUsXCJrMTIubW8udXNcIjp0cnVlLFwiazEyLm1zLnVzXCI6dHJ1ZSxcImsxMi5tdC51c1wiOnRydWUsXCJrMTIubmMudXNcIjp0cnVlLFwiazEyLm5lLnVzXCI6dHJ1ZSxcImsxMi5uaC51c1wiOnRydWUsXCJrMTIubmoudXNcIjp0cnVlLFwiazEyLm5tLnVzXCI6dHJ1ZSxcImsxMi5udi51c1wiOnRydWUsXCJrMTIubnkudXNcIjp0cnVlLFwiazEyLm9oLnVzXCI6dHJ1ZSxcImsxMi5vay51c1wiOnRydWUsXCJrMTIub3IudXNcIjp0cnVlLFwiazEyLnBhLnVzXCI6dHJ1ZSxcImsxMi5wci51c1wiOnRydWUsXCJrMTIucmkudXNcIjp0cnVlLFwiazEyLnNjLnVzXCI6dHJ1ZSxcImsxMi50bi51c1wiOnRydWUsXCJrMTIudHgudXNcIjp0cnVlLFwiazEyLnV0LnVzXCI6dHJ1ZSxcImsxMi52aS51c1wiOnRydWUsXCJrMTIudnQudXNcIjp0cnVlLFwiazEyLnZhLnVzXCI6dHJ1ZSxcImsxMi53YS51c1wiOnRydWUsXCJrMTIud2kudXNcIjp0cnVlLFwiazEyLnd5LnVzXCI6dHJ1ZSxcImNjLmFrLnVzXCI6dHJ1ZSxcImNjLmFsLnVzXCI6dHJ1ZSxcImNjLmFyLnVzXCI6dHJ1ZSxcImNjLmFzLnVzXCI6dHJ1ZSxcImNjLmF6LnVzXCI6dHJ1ZSxcImNjLmNhLnVzXCI6dHJ1ZSxcImNjLmNvLnVzXCI6dHJ1ZSxcImNjLmN0LnVzXCI6dHJ1ZSxcImNjLmRjLnVzXCI6dHJ1ZSxcImNjLmRlLnVzXCI6dHJ1ZSxcImNjLmZsLnVzXCI6dHJ1ZSxcImNjLmdhLnVzXCI6dHJ1ZSxcImNjLmd1LnVzXCI6dHJ1ZSxcImNjLmhpLnVzXCI6dHJ1ZSxcImNjLmlhLnVzXCI6dHJ1ZSxcImNjLmlkLnVzXCI6dHJ1ZSxcImNjLmlsLnVzXCI6dHJ1ZSxcImNjLmluLnVzXCI6dHJ1ZSxcImNjLmtzLnVzXCI6dHJ1ZSxcImNjLmt5LnVzXCI6dHJ1ZSxcImNjLmxhLnVzXCI6dHJ1ZSxcImNjLm1hLnVzXCI6dHJ1ZSxcImNjLm1kLnVzXCI6dHJ1ZSxcImNjLm1lLnVzXCI6dHJ1ZSxcImNjLm1pLnVzXCI6dHJ1ZSxcImNjLm1uLnVzXCI6dHJ1ZSxcImNjLm1vLnVzXCI6dHJ1ZSxcImNjLm1zLnVzXCI6dHJ1ZSxcImNjLm10LnVzXCI6dHJ1ZSxcImNjLm5jLnVzXCI6dHJ1ZSxcImNjLm5kLnVzXCI6dHJ1ZSxcImNjLm5lLnVzXCI6dHJ1ZSxcImNjLm5oLnVzXCI6dHJ1ZSxcImNjLm5qLnVzXCI6dHJ1ZSxcImNjLm5tLnVzXCI6dHJ1ZSxcImNjLm52LnVzXCI6dHJ1ZSxcImNjLm55LnVzXCI6dHJ1ZSxcImNjLm9oLnVzXCI6dHJ1ZSxcImNjLm9rLnVzXCI6dHJ1ZSxcImNjLm9yLnVzXCI6dHJ1ZSxcImNjLnBhLnVzXCI6dHJ1ZSxcImNjLnByLnVzXCI6dHJ1ZSxcImNjLnJpLnVzXCI6dHJ1ZSxcImNjLnNjLnVzXCI6dHJ1ZSxcImNjLnNkLnVzXCI6dHJ1ZSxcImNjLnRuLnVzXCI6dHJ1ZSxcImNjLnR4LnVzXCI6dHJ1ZSxcImNjLnV0LnVzXCI6dHJ1ZSxcImNjLnZpLnVzXCI6dHJ1ZSxcImNjLnZ0LnVzXCI6dHJ1ZSxcImNjLnZhLnVzXCI6dHJ1ZSxcImNjLndhLnVzXCI6dHJ1ZSxcImNjLndpLnVzXCI6dHJ1ZSxcImNjLnd2LnVzXCI6dHJ1ZSxcImNjLnd5LnVzXCI6dHJ1ZSxcImxpYi5hay51c1wiOnRydWUsXCJsaWIuYWwudXNcIjp0cnVlLFwibGliLmFyLnVzXCI6dHJ1ZSxcImxpYi5hcy51c1wiOnRydWUsXCJsaWIuYXoudXNcIjp0cnVlLFwibGliLmNhLnVzXCI6dHJ1ZSxcImxpYi5jby51c1wiOnRydWUsXCJsaWIuY3QudXNcIjp0cnVlLFwibGliLmRjLnVzXCI6dHJ1ZSxcImxpYi5kZS51c1wiOnRydWUsXCJsaWIuZmwudXNcIjp0cnVlLFwibGliLmdhLnVzXCI6dHJ1ZSxcImxpYi5ndS51c1wiOnRydWUsXCJsaWIuaGkudXNcIjp0cnVlLFwibGliLmlhLnVzXCI6dHJ1ZSxcImxpYi5pZC51c1wiOnRydWUsXCJsaWIuaWwudXNcIjp0cnVlLFwibGliLmluLnVzXCI6dHJ1ZSxcImxpYi5rcy51c1wiOnRydWUsXCJsaWIua3kudXNcIjp0cnVlLFwibGliLmxhLnVzXCI6dHJ1ZSxcImxpYi5tYS51c1wiOnRydWUsXCJsaWIubWQudXNcIjp0cnVlLFwibGliLm1lLnVzXCI6dHJ1ZSxcImxpYi5taS51c1wiOnRydWUsXCJsaWIubW4udXNcIjp0cnVlLFwibGliLm1vLnVzXCI6dHJ1ZSxcImxpYi5tcy51c1wiOnRydWUsXCJsaWIubXQudXNcIjp0cnVlLFwibGliLm5jLnVzXCI6dHJ1ZSxcImxpYi5uZC51c1wiOnRydWUsXCJsaWIubmUudXNcIjp0cnVlLFwibGliLm5oLnVzXCI6dHJ1ZSxcImxpYi5uai51c1wiOnRydWUsXCJsaWIubm0udXNcIjp0cnVlLFwibGliLm52LnVzXCI6dHJ1ZSxcImxpYi5ueS51c1wiOnRydWUsXCJsaWIub2gudXNcIjp0cnVlLFwibGliLm9rLnVzXCI6dHJ1ZSxcImxpYi5vci51c1wiOnRydWUsXCJsaWIucGEudXNcIjp0cnVlLFwibGliLnByLnVzXCI6dHJ1ZSxcImxpYi5yaS51c1wiOnRydWUsXCJsaWIuc2MudXNcIjp0cnVlLFwibGliLnNkLnVzXCI6dHJ1ZSxcImxpYi50bi51c1wiOnRydWUsXCJsaWIudHgudXNcIjp0cnVlLFwibGliLnV0LnVzXCI6dHJ1ZSxcImxpYi52aS51c1wiOnRydWUsXCJsaWIudnQudXNcIjp0cnVlLFwibGliLnZhLnVzXCI6dHJ1ZSxcImxpYi53YS51c1wiOnRydWUsXCJsaWIud2kudXNcIjp0cnVlLFwibGliLnd5LnVzXCI6dHJ1ZSxcInB2dC5rMTIubWEudXNcIjp0cnVlLFwiY2h0ci5rMTIubWEudXNcIjp0cnVlLFwicGFyb2NoLmsxMi5tYS51c1wiOnRydWUsXCJ1eVwiOnRydWUsXCJjb20udXlcIjp0cnVlLFwiZWR1LnV5XCI6dHJ1ZSxcImd1Yi51eVwiOnRydWUsXCJtaWwudXlcIjp0cnVlLFwibmV0LnV5XCI6dHJ1ZSxcIm9yZy51eVwiOnRydWUsXCJ1elwiOnRydWUsXCJjby51elwiOnRydWUsXCJjb20udXpcIjp0cnVlLFwibmV0LnV6XCI6dHJ1ZSxcIm9yZy51elwiOnRydWUsXCJ2YVwiOnRydWUsXCJ2Y1wiOnRydWUsXCJjb20udmNcIjp0cnVlLFwibmV0LnZjXCI6dHJ1ZSxcIm9yZy52Y1wiOnRydWUsXCJnb3YudmNcIjp0cnVlLFwibWlsLnZjXCI6dHJ1ZSxcImVkdS52Y1wiOnRydWUsXCJ2ZVwiOnRydWUsXCJhcnRzLnZlXCI6dHJ1ZSxcImNvLnZlXCI6dHJ1ZSxcImNvbS52ZVwiOnRydWUsXCJlMTIudmVcIjp0cnVlLFwiZWR1LnZlXCI6dHJ1ZSxcImZpcm0udmVcIjp0cnVlLFwiZ29iLnZlXCI6dHJ1ZSxcImdvdi52ZVwiOnRydWUsXCJpbmZvLnZlXCI6dHJ1ZSxcImludC52ZVwiOnRydWUsXCJtaWwudmVcIjp0cnVlLFwibmV0LnZlXCI6dHJ1ZSxcIm9yZy52ZVwiOnRydWUsXCJyZWMudmVcIjp0cnVlLFwic3RvcmUudmVcIjp0cnVlLFwidGVjLnZlXCI6dHJ1ZSxcIndlYi52ZVwiOnRydWUsXCJ2Z1wiOnRydWUsXCJ2aVwiOnRydWUsXCJjby52aVwiOnRydWUsXCJjb20udmlcIjp0cnVlLFwiazEyLnZpXCI6dHJ1ZSxcIm5ldC52aVwiOnRydWUsXCJvcmcudmlcIjp0cnVlLFwidm5cIjp0cnVlLFwiY29tLnZuXCI6dHJ1ZSxcIm5ldC52blwiOnRydWUsXCJvcmcudm5cIjp0cnVlLFwiZWR1LnZuXCI6dHJ1ZSxcImdvdi52blwiOnRydWUsXCJpbnQudm5cIjp0cnVlLFwiYWMudm5cIjp0cnVlLFwiYml6LnZuXCI6dHJ1ZSxcImluZm8udm5cIjp0cnVlLFwibmFtZS52blwiOnRydWUsXCJwcm8udm5cIjp0cnVlLFwiaGVhbHRoLnZuXCI6dHJ1ZSxcInZ1XCI6dHJ1ZSxcImNvbS52dVwiOnRydWUsXCJlZHUudnVcIjp0cnVlLFwibmV0LnZ1XCI6dHJ1ZSxcIm9yZy52dVwiOnRydWUsXCJ3ZlwiOnRydWUsXCJ3c1wiOnRydWUsXCJjb20ud3NcIjp0cnVlLFwibmV0LndzXCI6dHJ1ZSxcIm9yZy53c1wiOnRydWUsXCJnb3Yud3NcIjp0cnVlLFwiZWR1LndzXCI6dHJ1ZSxcInl0XCI6dHJ1ZSxcInhuLS1tZ2JhYW03YThoXCI6dHJ1ZSxcInhuLS15OWEzYXFcIjp0cnVlLFwieG4tLTU0YjdmdGEwY2NcIjp0cnVlLFwieG4tLTkwYWlzXCI6dHJ1ZSxcInhuLS1maXFzOHNcIjp0cnVlLFwieG4tLWZpcXo5c1wiOnRydWUsXCJ4bi0tbGdiYmF0MWFkOGpcIjp0cnVlLFwieG4tLXdnYmgxY1wiOnRydWUsXCJ4bi0tbm9kZVwiOnRydWUsXCJ4bi0tcXhhbVwiOnRydWUsXCJ4bi0tajZ3MTkzZ1wiOnRydWUsXCJ4bi0taDJicmo5Y1wiOnRydWUsXCJ4bi0tbWdiYmgxYTcxZVwiOnRydWUsXCJ4bi0tZnBjcmo5YzNkXCI6dHJ1ZSxcInhuLS1nZWNyajljXCI6dHJ1ZSxcInhuLS1zOWJyajljXCI6dHJ1ZSxcInhuLS00NWJyajljXCI6dHJ1ZSxcInhuLS14a2MyZGwzYTVlZTBoXCI6dHJ1ZSxcInhuLS1tZ2JhM2E0ZjE2YVwiOnRydWUsXCJ4bi0tbWdiYTNhNGZyYVwiOnRydWUsXCJ4bi0tbWdidHgyYlwiOnRydWUsXCJ4bi0tbWdiYXloN2dwYVwiOnRydWUsXCJ4bi0tM2UwYjcwN2VcIjp0cnVlLFwieG4tLTgwYW8yMWFcIjp0cnVlLFwieG4tLWZ6YzJjOWUyY1wiOnRydWUsXCJ4bi0teGtjMmFsM2h5ZTJhXCI6dHJ1ZSxcInhuLS1tZ2JjMGE5YXpjZ1wiOnRydWUsXCJ4bi0tZDFhbGZcIjp0cnVlLFwieG4tLWwxYWNjXCI6dHJ1ZSxcInhuLS1taXg4OTFmXCI6dHJ1ZSxcInhuLS1taXgwODJmXCI6dHJ1ZSxcInhuLS1tZ2J4NGNkMGFiXCI6dHJ1ZSxcInhuLS1tZ2I5YXdiZlwiOnRydWUsXCJ4bi0tbWdiYWk5YXpncXA2alwiOnRydWUsXCJ4bi0tbWdiYWk5YTVldmEwMGJcIjp0cnVlLFwieG4tLXlnYmkyYW1teFwiOnRydWUsXCJ4bi0tOTBhM2FjXCI6dHJ1ZSxcInhuLS1vMWFjLnhuLS05MGEzYWNcIjp0cnVlLFwieG4tLWMxYXZnLnhuLS05MGEzYWNcIjp0cnVlLFwieG4tLTkwYXpoLnhuLS05MGEzYWNcIjp0cnVlLFwieG4tLWQxYXQueG4tLTkwYTNhY1wiOnRydWUsXCJ4bi0tbzFhY2gueG4tLTkwYTNhY1wiOnRydWUsXCJ4bi0tODBhdS54bi0tOTBhM2FjXCI6dHJ1ZSxcInhuLS1wMWFpXCI6dHJ1ZSxcInhuLS13Z2JsNmFcIjp0cnVlLFwieG4tLW1nYmVycDRhNWQ0YXJcIjp0cnVlLFwieG4tLW1nYmVycDRhNWQ0YTg3Z1wiOnRydWUsXCJ4bi0tbWdicWx5N2MwYTY3ZmJjXCI6dHJ1ZSxcInhuLS1tZ2JxbHk3Y3ZhZnJcIjp0cnVlLFwieG4tLW1nYnBsMmZoXCI6dHJ1ZSxcInhuLS15ZnJvNGk2N29cIjp0cnVlLFwieG4tLWNsY2hjMGVhMGIyZzJhOWdjZFwiOnRydWUsXCJ4bi0tb2dicGY4ZmxcIjp0cnVlLFwieG4tLW1nYnRmOGZsXCI6dHJ1ZSxcInhuLS1vM2N3NGhcIjp0cnVlLFwieG4tLXBnYnMwZGhcIjp0cnVlLFwieG4tLWtwcnk1N2RcIjp0cnVlLFwieG4tLWtwcncxM2RcIjp0cnVlLFwieG4tLW5ueDM4OGFcIjp0cnVlLFwieG4tLWoxYW1oXCI6dHJ1ZSxcInhuLS1tZ2IyZGRlc1wiOnRydWUsXCJ4eHhcIjp0cnVlLFwiKi55ZVwiOnRydWUsXCJhYy56YVwiOnRydWUsXCJhZ3JpY2EuemFcIjp0cnVlLFwiYWx0LnphXCI6dHJ1ZSxcImNvLnphXCI6dHJ1ZSxcImVkdS56YVwiOnRydWUsXCJnb3YuemFcIjp0cnVlLFwiZ3JvbmRhci56YVwiOnRydWUsXCJsYXcuemFcIjp0cnVlLFwibWlsLnphXCI6dHJ1ZSxcIm5ldC56YVwiOnRydWUsXCJuZ28uemFcIjp0cnVlLFwibmlzLnphXCI6dHJ1ZSxcIm5vbS56YVwiOnRydWUsXCJvcmcuemFcIjp0cnVlLFwic2Nob29sLnphXCI6dHJ1ZSxcInRtLnphXCI6dHJ1ZSxcIndlYi56YVwiOnRydWUsXCIqLnptXCI6dHJ1ZSxcIiouendcIjp0cnVlLFwiYWFhXCI6dHJ1ZSxcImFhcnBcIjp0cnVlLFwiYWJhcnRoXCI6dHJ1ZSxcImFiYlwiOnRydWUsXCJhYmJvdHRcIjp0cnVlLFwiYWJidmllXCI6dHJ1ZSxcImFiY1wiOnRydWUsXCJhYmxlXCI6dHJ1ZSxcImFib2dhZG9cIjp0cnVlLFwiYWJ1ZGhhYmlcIjp0cnVlLFwiYWNhZGVteVwiOnRydWUsXCJhY2NlbnR1cmVcIjp0cnVlLFwiYWNjb3VudGFudFwiOnRydWUsXCJhY2NvdW50YW50c1wiOnRydWUsXCJhY29cIjp0cnVlLFwiYWN0aXZlXCI6dHJ1ZSxcImFjdG9yXCI6dHJ1ZSxcImFkYWNcIjp0cnVlLFwiYWRzXCI6dHJ1ZSxcImFkdWx0XCI6dHJ1ZSxcImFlZ1wiOnRydWUsXCJhZXRuYVwiOnRydWUsXCJhZmFtaWx5Y29tcGFueVwiOnRydWUsXCJhZmxcIjp0cnVlLFwiYWZyaWNhXCI6dHJ1ZSxcImFmcmljYW1hZ2ljXCI6dHJ1ZSxcImFnYWtoYW5cIjp0cnVlLFwiYWdlbmN5XCI6dHJ1ZSxcImFpZ1wiOnRydWUsXCJhaWdvXCI6dHJ1ZSxcImFpcmJ1c1wiOnRydWUsXCJhaXJmb3JjZVwiOnRydWUsXCJhaXJ0ZWxcIjp0cnVlLFwiYWtkblwiOnRydWUsXCJhbGZhcm9tZW9cIjp0cnVlLFwiYWxpYmFiYVwiOnRydWUsXCJhbGlwYXlcIjp0cnVlLFwiYWxsZmluYW56XCI6dHJ1ZSxcImFsbHN0YXRlXCI6dHJ1ZSxcImFsbHlcIjp0cnVlLFwiYWxzYWNlXCI6dHJ1ZSxcImFsc3RvbVwiOnRydWUsXCJhbWVyaWNhbmV4cHJlc3NcIjp0cnVlLFwiYW1lcmljYW5mYW1pbHlcIjp0cnVlLFwiYW1leFwiOnRydWUsXCJhbWZhbVwiOnRydWUsXCJhbWljYVwiOnRydWUsXCJhbXN0ZXJkYW1cIjp0cnVlLFwiYW5hbHl0aWNzXCI6dHJ1ZSxcImFuZHJvaWRcIjp0cnVlLFwiYW5xdWFuXCI6dHJ1ZSxcImFuelwiOnRydWUsXCJhb2xcIjp0cnVlLFwiYXBhcnRtZW50c1wiOnRydWUsXCJhcHBcIjp0cnVlLFwiYXBwbGVcIjp0cnVlLFwiYXF1YXJlbGxlXCI6dHJ1ZSxcImFyYW1jb1wiOnRydWUsXCJhcmNoaVwiOnRydWUsXCJhcm15XCI6dHJ1ZSxcImFydGVcIjp0cnVlLFwiYXNkYVwiOnRydWUsXCJhc3NvY2lhdGVzXCI6dHJ1ZSxcImF0aGxldGFcIjp0cnVlLFwiYXR0b3JuZXlcIjp0cnVlLFwiYXVjdGlvblwiOnRydWUsXCJhdWRpXCI6dHJ1ZSxcImF1ZGlibGVcIjp0cnVlLFwiYXVkaW9cIjp0cnVlLFwiYXVzcG9zdFwiOnRydWUsXCJhdXRob3JcIjp0cnVlLFwiYXV0b1wiOnRydWUsXCJhdXRvc1wiOnRydWUsXCJhdmlhbmNhXCI6dHJ1ZSxcImF3c1wiOnRydWUsXCJheGFcIjp0cnVlLFwiYXp1cmVcIjp0cnVlLFwiYmFieVwiOnRydWUsXCJiYWlkdVwiOnRydWUsXCJiYW5hbWV4XCI6dHJ1ZSxcImJhbmFuYXJlcHVibGljXCI6dHJ1ZSxcImJhbmRcIjp0cnVlLFwiYmFua1wiOnRydWUsXCJiYXJcIjp0cnVlLFwiYmFyY2Vsb25hXCI6dHJ1ZSxcImJhcmNsYXljYXJkXCI6dHJ1ZSxcImJhcmNsYXlzXCI6dHJ1ZSxcImJhcmVmb290XCI6dHJ1ZSxcImJhcmdhaW5zXCI6dHJ1ZSxcImJhc2tldGJhbGxcIjp0cnVlLFwiYmF1aGF1c1wiOnRydWUsXCJiYXllcm5cIjp0cnVlLFwiYmJjXCI6dHJ1ZSxcImJidFwiOnRydWUsXCJiYnZhXCI6dHJ1ZSxcImJjZ1wiOnRydWUsXCJiY25cIjp0cnVlLFwiYmVhdHNcIjp0cnVlLFwiYmVlclwiOnRydWUsXCJiZW50bGV5XCI6dHJ1ZSxcImJlcmxpblwiOnRydWUsXCJiZXN0XCI6dHJ1ZSxcImJlc3RidXlcIjp0cnVlLFwiYmV0XCI6dHJ1ZSxcImJoYXJ0aVwiOnRydWUsXCJiaWJsZVwiOnRydWUsXCJiaWRcIjp0cnVlLFwiYmlrZVwiOnRydWUsXCJiaW5nXCI6dHJ1ZSxcImJpbmdvXCI6dHJ1ZSxcImJpb1wiOnRydWUsXCJibGFja1wiOnRydWUsXCJibGFja2ZyaWRheVwiOnRydWUsXCJibGFuY29cIjp0cnVlLFwiYmxvY2tidXN0ZXJcIjp0cnVlLFwiYmxvZ1wiOnRydWUsXCJibG9vbWJlcmdcIjp0cnVlLFwiYmx1ZVwiOnRydWUsXCJibXNcIjp0cnVlLFwiYm13XCI6dHJ1ZSxcImJubFwiOnRydWUsXCJibnBwYXJpYmFzXCI6dHJ1ZSxcImJvYXRzXCI6dHJ1ZSxcImJvZWhyaW5nZXJcIjp0cnVlLFwiYm9mYVwiOnRydWUsXCJib21cIjp0cnVlLFwiYm9uZFwiOnRydWUsXCJib29cIjp0cnVlLFwiYm9va1wiOnRydWUsXCJib29raW5nXCI6dHJ1ZSxcImJvb3RzXCI6dHJ1ZSxcImJvc2NoXCI6dHJ1ZSxcImJvc3Rpa1wiOnRydWUsXCJib3RcIjp0cnVlLFwiYm91dGlxdWVcIjp0cnVlLFwiYnJhZGVzY29cIjp0cnVlLFwiYnJpZGdlc3RvbmVcIjp0cnVlLFwiYnJvYWR3YXlcIjp0cnVlLFwiYnJva2VyXCI6dHJ1ZSxcImJyb3RoZXJcIjp0cnVlLFwiYnJ1c3NlbHNcIjp0cnVlLFwiYnVkYXBlc3RcIjp0cnVlLFwiYnVnYXR0aVwiOnRydWUsXCJidWlsZFwiOnRydWUsXCJidWlsZGVyc1wiOnRydWUsXCJidXNpbmVzc1wiOnRydWUsXCJidXlcIjp0cnVlLFwiYnV6elwiOnRydWUsXCJiemhcIjp0cnVlLFwiY2FiXCI6dHJ1ZSxcImNhZmVcIjp0cnVlLFwiY2FsXCI6dHJ1ZSxcImNhbGxcIjp0cnVlLFwiY2Fsdmlua2xlaW5cIjp0cnVlLFwiY2FtZXJhXCI6dHJ1ZSxcImNhbXBcIjp0cnVlLFwiY2FuY2VycmVzZWFyY2hcIjp0cnVlLFwiY2Fub25cIjp0cnVlLFwiY2FwZXRvd25cIjp0cnVlLFwiY2FwaXRhbFwiOnRydWUsXCJjYXBpdGFsb25lXCI6dHJ1ZSxcImNhclwiOnRydWUsXCJjYXJhdmFuXCI6dHJ1ZSxcImNhcmRzXCI6dHJ1ZSxcImNhcmVcIjp0cnVlLFwiY2FyZWVyXCI6dHJ1ZSxcImNhcmVlcnNcIjp0cnVlLFwiY2Fyc1wiOnRydWUsXCJjYXJ0aWVyXCI6dHJ1ZSxcImNhc2FcIjp0cnVlLFwiY2FzZVwiOnRydWUsXCJjYXNlaWhcIjp0cnVlLFwiY2FzaFwiOnRydWUsXCJjYXNpbm9cIjp0cnVlLFwiY2F0ZXJpbmdcIjp0cnVlLFwiY2JhXCI6dHJ1ZSxcImNiblwiOnRydWUsXCJjYnJlXCI6dHJ1ZSxcImNic1wiOnRydWUsXCJjZWJcIjp0cnVlLFwiY2VudGVyXCI6dHJ1ZSxcImNlb1wiOnRydWUsXCJjZXJuXCI6dHJ1ZSxcImNmYVwiOnRydWUsXCJjZmRcIjp0cnVlLFwiY2hhbmVsXCI6dHJ1ZSxcImNoYW5uZWxcIjp0cnVlLFwiY2hhc2VcIjp0cnVlLFwiY2hhdFwiOnRydWUsXCJjaGVhcFwiOnRydWUsXCJjaGludGFpXCI6dHJ1ZSxcImNobG9lXCI6dHJ1ZSxcImNocmlzdG1hc1wiOnRydWUsXCJjaHJvbWVcIjp0cnVlLFwiY2hyeXNsZXJcIjp0cnVlLFwiY2h1cmNoXCI6dHJ1ZSxcImNpcHJpYW5pXCI6dHJ1ZSxcImNpcmNsZVwiOnRydWUsXCJjaXNjb1wiOnRydWUsXCJjaXRhZGVsXCI6dHJ1ZSxcImNpdGlcIjp0cnVlLFwiY2l0aWNcIjp0cnVlLFwiY2l0eVwiOnRydWUsXCJjaXR5ZWF0c1wiOnRydWUsXCJjbGFpbXNcIjp0cnVlLFwiY2xlYW5pbmdcIjp0cnVlLFwiY2xpY2tcIjp0cnVlLFwiY2xpbmljXCI6dHJ1ZSxcImNsb3RoaW5nXCI6dHJ1ZSxcImNsb3VkXCI6dHJ1ZSxcImNsdWJcIjp0cnVlLFwiY2x1Ym1lZFwiOnRydWUsXCJjb2FjaFwiOnRydWUsXCJjb2Rlc1wiOnRydWUsXCJjb2ZmZWVcIjp0cnVlLFwiY29sbGVnZVwiOnRydWUsXCJjb2xvZ25lXCI6dHJ1ZSxcImNvbWNhc3RcIjp0cnVlLFwiY29tbWJhbmtcIjp0cnVlLFwiY29tbXVuaXR5XCI6dHJ1ZSxcImNvbXBhbnlcIjp0cnVlLFwiY29tcHV0ZXJcIjp0cnVlLFwiY29tc2VjXCI6dHJ1ZSxcImNvbmRvc1wiOnRydWUsXCJjb25zdHJ1Y3Rpb25cIjp0cnVlLFwiY29uc3VsdGluZ1wiOnRydWUsXCJjb250YWN0XCI6dHJ1ZSxcImNvbnRyYWN0b3JzXCI6dHJ1ZSxcImNvb2tpbmdcIjp0cnVlLFwiY29va2luZ2NoYW5uZWxcIjp0cnVlLFwiY29vbFwiOnRydWUsXCJjb3JzaWNhXCI6dHJ1ZSxcImNvdW50cnlcIjp0cnVlLFwiY291cG9uXCI6dHJ1ZSxcImNvdXBvbnNcIjp0cnVlLFwiY291cnNlc1wiOnRydWUsXCJjcmVkaXRcIjp0cnVlLFwiY3JlZGl0Y2FyZFwiOnRydWUsXCJjcmVkaXR1bmlvblwiOnRydWUsXCJjcmlja2V0XCI6dHJ1ZSxcImNyb3duXCI6dHJ1ZSxcImNyc1wiOnRydWUsXCJjcnVpc2VzXCI6dHJ1ZSxcImNzY1wiOnRydWUsXCJjdWlzaW5lbGxhXCI6dHJ1ZSxcImN5bXJ1XCI6dHJ1ZSxcImN5b3VcIjp0cnVlLFwiZGFidXJcIjp0cnVlLFwiZGFkXCI6dHJ1ZSxcImRhbmNlXCI6dHJ1ZSxcImRhdGVcIjp0cnVlLFwiZGF0aW5nXCI6dHJ1ZSxcImRhdHN1blwiOnRydWUsXCJkYXlcIjp0cnVlLFwiZGNsa1wiOnRydWUsXCJkZHNcIjp0cnVlLFwiZGVhbFwiOnRydWUsXCJkZWFsZXJcIjp0cnVlLFwiZGVhbHNcIjp0cnVlLFwiZGVncmVlXCI6dHJ1ZSxcImRlbGl2ZXJ5XCI6dHJ1ZSxcImRlbGxcIjp0cnVlLFwiZGVsb2l0dGVcIjp0cnVlLFwiZGVsdGFcIjp0cnVlLFwiZGVtb2NyYXRcIjp0cnVlLFwiZGVudGFsXCI6dHJ1ZSxcImRlbnRpc3RcIjp0cnVlLFwiZGVzaVwiOnRydWUsXCJkZXNpZ25cIjp0cnVlLFwiZGV2XCI6dHJ1ZSxcImRobFwiOnRydWUsXCJkaWFtb25kc1wiOnRydWUsXCJkaWV0XCI6dHJ1ZSxcImRpZ2l0YWxcIjp0cnVlLFwiZGlyZWN0XCI6dHJ1ZSxcImRpcmVjdG9yeVwiOnRydWUsXCJkaXNjb3VudFwiOnRydWUsXCJkaXNjb3ZlclwiOnRydWUsXCJkaXNoXCI6dHJ1ZSxcImRucFwiOnRydWUsXCJkb2NzXCI6dHJ1ZSxcImRvZGdlXCI6dHJ1ZSxcImRvZ1wiOnRydWUsXCJkb2hhXCI6dHJ1ZSxcImRvbWFpbnNcIjp0cnVlLFwiZG9vc2FuXCI6dHJ1ZSxcImRvdFwiOnRydWUsXCJkb3dubG9hZFwiOnRydWUsXCJkcml2ZVwiOnRydWUsXCJkc3R2XCI6dHJ1ZSxcImR0dlwiOnRydWUsXCJkdWJhaVwiOnRydWUsXCJkdWNrXCI6dHJ1ZSxcImR1bmxvcFwiOnRydWUsXCJkdW5zXCI6dHJ1ZSxcImR1cG9udFwiOnRydWUsXCJkdXJiYW5cIjp0cnVlLFwiZHZhZ1wiOnRydWUsXCJkd2dcIjp0cnVlLFwiZWFydGhcIjp0cnVlLFwiZWF0XCI6dHJ1ZSxcImVkZWthXCI6dHJ1ZSxcImVkdWNhdGlvblwiOnRydWUsXCJlbWFpbFwiOnRydWUsXCJlbWVyY2tcIjp0cnVlLFwiZW1lcnNvblwiOnRydWUsXCJlbmVyZ3lcIjp0cnVlLFwiZW5naW5lZXJcIjp0cnVlLFwiZW5naW5lZXJpbmdcIjp0cnVlLFwiZW50ZXJwcmlzZXNcIjp0cnVlLFwiZXBvc3RcIjp0cnVlLFwiZXBzb25cIjp0cnVlLFwiZXF1aXBtZW50XCI6dHJ1ZSxcImVyaWNzc29uXCI6dHJ1ZSxcImVybmlcIjp0cnVlLFwiZXNxXCI6dHJ1ZSxcImVzdGF0ZVwiOnRydWUsXCJlc3VyYW5jZVwiOnRydWUsXCJldGlzYWxhdFwiOnRydWUsXCJldXJvdmlzaW9uXCI6dHJ1ZSxcImV1c1wiOnRydWUsXCJldmVudHNcIjp0cnVlLFwiZXZlcmJhbmtcIjp0cnVlLFwiZXhjaGFuZ2VcIjp0cnVlLFwiZXhwZXJ0XCI6dHJ1ZSxcImV4cG9zZWRcIjp0cnVlLFwiZXhwcmVzc1wiOnRydWUsXCJleHRyYXNwYWNlXCI6dHJ1ZSxcImZhZ2VcIjp0cnVlLFwiZmFpbFwiOnRydWUsXCJmYWlyd2luZHNcIjp0cnVlLFwiZmFpdGhcIjp0cnVlLFwiZmFtaWx5XCI6dHJ1ZSxcImZhblwiOnRydWUsXCJmYW5zXCI6dHJ1ZSxcImZhcm1cIjp0cnVlLFwiZmFybWVyc1wiOnRydWUsXCJmYXNoaW9uXCI6dHJ1ZSxcImZhc3RcIjp0cnVlLFwiZmVkZXhcIjp0cnVlLFwiZmVlZGJhY2tcIjp0cnVlLFwiZmVycmFyaVwiOnRydWUsXCJmZXJyZXJvXCI6dHJ1ZSxcImZpYXRcIjp0cnVlLFwiZmlkZWxpdHlcIjp0cnVlLFwiZmlkb1wiOnRydWUsXCJmaWxtXCI6dHJ1ZSxcImZpbmFsXCI6dHJ1ZSxcImZpbmFuY2VcIjp0cnVlLFwiZmluYW5jaWFsXCI6dHJ1ZSxcImZpcmVcIjp0cnVlLFwiZmlyZXN0b25lXCI6dHJ1ZSxcImZpcm1kYWxlXCI6dHJ1ZSxcImZpc2hcIjp0cnVlLFwiZmlzaGluZ1wiOnRydWUsXCJmaXRcIjp0cnVlLFwiZml0bmVzc1wiOnRydWUsXCJmbGlja3JcIjp0cnVlLFwiZmxpZ2h0c1wiOnRydWUsXCJmbGlyXCI6dHJ1ZSxcImZsb3Jpc3RcIjp0cnVlLFwiZmxvd2Vyc1wiOnRydWUsXCJmbHNtaWR0aFwiOnRydWUsXCJmbHlcIjp0cnVlLFwiZm9vXCI6dHJ1ZSxcImZvb2RuZXR3b3JrXCI6dHJ1ZSxcImZvb3RiYWxsXCI6dHJ1ZSxcImZvcmRcIjp0cnVlLFwiZm9yZXhcIjp0cnVlLFwiZm9yc2FsZVwiOnRydWUsXCJmb3J1bVwiOnRydWUsXCJmb3VuZGF0aW9uXCI6dHJ1ZSxcImZveFwiOnRydWUsXCJmcmVzZW5pdXNcIjp0cnVlLFwiZnJsXCI6dHJ1ZSxcImZyb2dhbnNcIjp0cnVlLFwiZnJvbnRkb29yXCI6dHJ1ZSxcImZyb250aWVyXCI6dHJ1ZSxcImZ0clwiOnRydWUsXCJmdWppdHN1XCI6dHJ1ZSxcImZ1aml4ZXJveFwiOnRydWUsXCJmdW5kXCI6dHJ1ZSxcImZ1cm5pdHVyZVwiOnRydWUsXCJmdXRib2xcIjp0cnVlLFwiZnlpXCI6dHJ1ZSxcImdhbFwiOnRydWUsXCJnYWxsZXJ5XCI6dHJ1ZSxcImdhbGxvXCI6dHJ1ZSxcImdhbGx1cFwiOnRydWUsXCJnYW1lXCI6dHJ1ZSxcImdhbWVzXCI6dHJ1ZSxcImdhcFwiOnRydWUsXCJnYXJkZW5cIjp0cnVlLFwiZ2JpelwiOnRydWUsXCJnZG5cIjp0cnVlLFwiZ2VhXCI6dHJ1ZSxcImdlbnRcIjp0cnVlLFwiZ2VudGluZ1wiOnRydWUsXCJnZW9yZ2VcIjp0cnVlLFwiZ2dlZVwiOnRydWUsXCJnaWZ0XCI6dHJ1ZSxcImdpZnRzXCI6dHJ1ZSxcImdpdmVzXCI6dHJ1ZSxcImdpdmluZ1wiOnRydWUsXCJnbGFkZVwiOnRydWUsXCJnbGFzc1wiOnRydWUsXCJnbGVcIjp0cnVlLFwiZ2xvYmFsXCI6dHJ1ZSxcImdsb2JvXCI6dHJ1ZSxcImdtYWlsXCI6dHJ1ZSxcImdtb1wiOnRydWUsXCJnbXhcIjp0cnVlLFwiZ29kYWRkeVwiOnRydWUsXCJnb2xkXCI6dHJ1ZSxcImdvbGRwb2ludFwiOnRydWUsXCJnb2xmXCI6dHJ1ZSxcImdvb1wiOnRydWUsXCJnb29kaGFuZHNcIjp0cnVlLFwiZ29vZHllYXJcIjp0cnVlLFwiZ29vZ1wiOnRydWUsXCJnb29nbGVcIjp0cnVlLFwiZ29wXCI6dHJ1ZSxcImdvdFwiOnRydWUsXCJnb3R2XCI6dHJ1ZSxcImdyYWluZ2VyXCI6dHJ1ZSxcImdyYXBoaWNzXCI6dHJ1ZSxcImdyYXRpc1wiOnRydWUsXCJncmVlblwiOnRydWUsXCJncmlwZVwiOnRydWUsXCJncm91cFwiOnRydWUsXCJndWFyZGlhblwiOnRydWUsXCJndWNjaVwiOnRydWUsXCJndWdlXCI6dHJ1ZSxcImd1aWRlXCI6dHJ1ZSxcImd1aXRhcnNcIjp0cnVlLFwiZ3VydVwiOnRydWUsXCJoYW1idXJnXCI6dHJ1ZSxcImhhbmdvdXRcIjp0cnVlLFwiaGF1c1wiOnRydWUsXCJoYm9cIjp0cnVlLFwiaGRmY1wiOnRydWUsXCJoZGZjYmFua1wiOnRydWUsXCJoZWFsdGhcIjp0cnVlLFwiaGVhbHRoY2FyZVwiOnRydWUsXCJoZWxwXCI6dHJ1ZSxcImhlbHNpbmtpXCI6dHJ1ZSxcImhlcmVcIjp0cnVlLFwiaGVybWVzXCI6dHJ1ZSxcImhndHZcIjp0cnVlLFwiaGlwaG9wXCI6dHJ1ZSxcImhpc2FtaXRzdVwiOnRydWUsXCJoaXRhY2hpXCI6dHJ1ZSxcImhpdlwiOnRydWUsXCJoa3RcIjp0cnVlLFwiaG9ja2V5XCI6dHJ1ZSxcImhvbGRpbmdzXCI6dHJ1ZSxcImhvbGlkYXlcIjp0cnVlLFwiaG9tZWRlcG90XCI6dHJ1ZSxcImhvbWVnb29kc1wiOnRydWUsXCJob21lc1wiOnRydWUsXCJob21lc2Vuc2VcIjp0cnVlLFwiaG9uZGFcIjp0cnVlLFwiaG9uZXl3ZWxsXCI6dHJ1ZSxcImhvcnNlXCI6dHJ1ZSxcImhvc3RcIjp0cnVlLFwiaG9zdGluZ1wiOnRydWUsXCJob3RcIjp0cnVlLFwiaG90ZWxlc1wiOnRydWUsXCJob3RtYWlsXCI6dHJ1ZSxcImhvdXNlXCI6dHJ1ZSxcImhvd1wiOnRydWUsXCJoc2JjXCI6dHJ1ZSxcImh0Y1wiOnRydWUsXCJodWdoZXNcIjp0cnVlLFwiaHlhdHRcIjp0cnVlLFwiaHl1bmRhaVwiOnRydWUsXCJpYm1cIjp0cnVlLFwiaWNiY1wiOnRydWUsXCJpY2VcIjp0cnVlLFwiaWN1XCI6dHJ1ZSxcImllZWVcIjp0cnVlLFwiaWZtXCI6dHJ1ZSxcImlpbmV0XCI6dHJ1ZSxcImlrYW5vXCI6dHJ1ZSxcImltYW1hdFwiOnRydWUsXCJpbWRiXCI6dHJ1ZSxcImltbW9cIjp0cnVlLFwiaW1tb2JpbGllblwiOnRydWUsXCJpbmR1c3RyaWVzXCI6dHJ1ZSxcImluZmluaXRpXCI6dHJ1ZSxcImluZ1wiOnRydWUsXCJpbmtcIjp0cnVlLFwiaW5zdGl0dXRlXCI6dHJ1ZSxcImluc3VyYW5jZVwiOnRydWUsXCJpbnN1cmVcIjp0cnVlLFwiaW50ZWxcIjp0cnVlLFwiaW50ZXJuYXRpb25hbFwiOnRydWUsXCJpbnR1aXRcIjp0cnVlLFwiaW52ZXN0bWVudHNcIjp0cnVlLFwiaXBpcmFuZ2FcIjp0cnVlLFwiaXJpc2hcIjp0cnVlLFwiaXNlbGVjdFwiOnRydWUsXCJpc21haWxpXCI6dHJ1ZSxcImlzdFwiOnRydWUsXCJpc3RhbmJ1bFwiOnRydWUsXCJpdGF1XCI6dHJ1ZSxcIml0dlwiOnRydWUsXCJpdmVjb1wiOnRydWUsXCJpd2NcIjp0cnVlLFwiamFndWFyXCI6dHJ1ZSxcImphdmFcIjp0cnVlLFwiamNiXCI6dHJ1ZSxcImpjcFwiOnRydWUsXCJqZWVwXCI6dHJ1ZSxcImpldHp0XCI6dHJ1ZSxcImpld2VscnlcIjp0cnVlLFwiamlvXCI6dHJ1ZSxcImpsY1wiOnRydWUsXCJqbGxcIjp0cnVlLFwiam1wXCI6dHJ1ZSxcImpualwiOnRydWUsXCJqb2J1cmdcIjp0cnVlLFwiam90XCI6dHJ1ZSxcImpveVwiOnRydWUsXCJqcG1vcmdhblwiOnRydWUsXCJqcHJzXCI6dHJ1ZSxcImp1ZWdvc1wiOnRydWUsXCJqdW5pcGVyXCI6dHJ1ZSxcImthdWZlblwiOnRydWUsXCJrZGRpXCI6dHJ1ZSxcImtlcnJ5aG90ZWxzXCI6dHJ1ZSxcImtlcnJ5bG9naXN0aWNzXCI6dHJ1ZSxcImtlcnJ5cHJvcGVydGllc1wiOnRydWUsXCJrZmhcIjp0cnVlLFwia2lhXCI6dHJ1ZSxcImtpbVwiOnRydWUsXCJraW5kZXJcIjp0cnVlLFwia2luZGxlXCI6dHJ1ZSxcImtpdGNoZW5cIjp0cnVlLFwia2l3aVwiOnRydWUsXCJrb2VsblwiOnRydWUsXCJrb21hdHN1XCI6dHJ1ZSxcImtvc2hlclwiOnRydWUsXCJrcG1nXCI6dHJ1ZSxcImtwblwiOnRydWUsXCJrcmRcIjp0cnVlLFwia3JlZFwiOnRydWUsXCJrdW9rZ3JvdXBcIjp0cnVlLFwia3lrbmV0XCI6dHJ1ZSxcImt5b3RvXCI6dHJ1ZSxcImxhY2FpeGFcIjp0cnVlLFwibGFkYnJva2VzXCI6dHJ1ZSxcImxhbWJvcmdoaW5pXCI6dHJ1ZSxcImxhbmNhc3RlclwiOnRydWUsXCJsYW5jaWFcIjp0cnVlLFwibGFuY29tZVwiOnRydWUsXCJsYW5kXCI6dHJ1ZSxcImxhbmRyb3ZlclwiOnRydWUsXCJsYW54ZXNzXCI6dHJ1ZSxcImxhc2FsbGVcIjp0cnVlLFwibGF0XCI6dHJ1ZSxcImxhdGlub1wiOnRydWUsXCJsYXRyb2JlXCI6dHJ1ZSxcImxhd1wiOnRydWUsXCJsYXd5ZXJcIjp0cnVlLFwibGRzXCI6dHJ1ZSxcImxlYXNlXCI6dHJ1ZSxcImxlY2xlcmNcIjp0cnVlLFwibGVmcmFrXCI6dHJ1ZSxcImxlZ2FsXCI6dHJ1ZSxcImxlZ29cIjp0cnVlLFwibGV4dXNcIjp0cnVlLFwibGdidFwiOnRydWUsXCJsaWFpc29uXCI6dHJ1ZSxcImxpZGxcIjp0cnVlLFwibGlmZVwiOnRydWUsXCJsaWZlaW5zdXJhbmNlXCI6dHJ1ZSxcImxpZmVzdHlsZVwiOnRydWUsXCJsaWdodGluZ1wiOnRydWUsXCJsaWtlXCI6dHJ1ZSxcImxpbGx5XCI6dHJ1ZSxcImxpbWl0ZWRcIjp0cnVlLFwibGltb1wiOnRydWUsXCJsaW5jb2xuXCI6dHJ1ZSxcImxpbmRlXCI6dHJ1ZSxcImxpbmtcIjp0cnVlLFwibGlwc3lcIjp0cnVlLFwibGl2ZVwiOnRydWUsXCJsaXZpbmdcIjp0cnVlLFwibGl4aWxcIjp0cnVlLFwibG9hblwiOnRydWUsXCJsb2Fuc1wiOnRydWUsXCJsb2NrZXJcIjp0cnVlLFwibG9jdXNcIjp0cnVlLFwibG9mdFwiOnRydWUsXCJsb2xcIjp0cnVlLFwibG9uZG9uXCI6dHJ1ZSxcImxvdHRlXCI6dHJ1ZSxcImxvdHRvXCI6dHJ1ZSxcImxvdmVcIjp0cnVlLFwibHBsXCI6dHJ1ZSxcImxwbGZpbmFuY2lhbFwiOnRydWUsXCJsdGRcIjp0cnVlLFwibHRkYVwiOnRydWUsXCJsdW5kYmVja1wiOnRydWUsXCJsdXBpblwiOnRydWUsXCJsdXhlXCI6dHJ1ZSxcImx1eHVyeVwiOnRydWUsXCJtYWN5c1wiOnRydWUsXCJtYWRyaWRcIjp0cnVlLFwibWFpZlwiOnRydWUsXCJtYWlzb25cIjp0cnVlLFwibWFrZXVwXCI6dHJ1ZSxcIm1hblwiOnRydWUsXCJtYW5hZ2VtZW50XCI6dHJ1ZSxcIm1hbmdvXCI6dHJ1ZSxcIm1hcmtldFwiOnRydWUsXCJtYXJrZXRpbmdcIjp0cnVlLFwibWFya2V0c1wiOnRydWUsXCJtYXJyaW90dFwiOnRydWUsXCJtYXJzaGFsbHNcIjp0cnVlLFwibWFzZXJhdGlcIjp0cnVlLFwibWF0dGVsXCI6dHJ1ZSxcIm1iYVwiOnRydWUsXCJtY2RcIjp0cnVlLFwibWNkb25hbGRzXCI6dHJ1ZSxcIm1ja2luc2V5XCI6dHJ1ZSxcIm1lZFwiOnRydWUsXCJtZWRpYVwiOnRydWUsXCJtZWV0XCI6dHJ1ZSxcIm1lbGJvdXJuZVwiOnRydWUsXCJtZW1lXCI6dHJ1ZSxcIm1lbW9yaWFsXCI6dHJ1ZSxcIm1lblwiOnRydWUsXCJtZW51XCI6dHJ1ZSxcIm1lb1wiOnRydWUsXCJtZXRsaWZlXCI6dHJ1ZSxcIm1pYW1pXCI6dHJ1ZSxcIm1pY3Jvc29mdFwiOnRydWUsXCJtaW5pXCI6dHJ1ZSxcIm1pbnRcIjp0cnVlLFwibWl0XCI6dHJ1ZSxcIm1pdHN1YmlzaGlcIjp0cnVlLFwibWxiXCI6dHJ1ZSxcIm1sc1wiOnRydWUsXCJtbWFcIjp0cnVlLFwibW5ldFwiOnRydWUsXCJtb2JpbHlcIjp0cnVlLFwibW9kYVwiOnRydWUsXCJtb2VcIjp0cnVlLFwibW9pXCI6dHJ1ZSxcIm1vbVwiOnRydWUsXCJtb25hc2hcIjp0cnVlLFwibW9uZXlcIjp0cnVlLFwibW9uc3RlclwiOnRydWUsXCJtb250YmxhbmNcIjp0cnVlLFwibW9wYXJcIjp0cnVlLFwibW9ybW9uXCI6dHJ1ZSxcIm1vcnRnYWdlXCI6dHJ1ZSxcIm1vc2Nvd1wiOnRydWUsXCJtb3RvXCI6dHJ1ZSxcIm1vdG9yY3ljbGVzXCI6dHJ1ZSxcIm1vdlwiOnRydWUsXCJtb3ZpZVwiOnRydWUsXCJtb3Zpc3RhclwiOnRydWUsXCJtc2RcIjp0cnVlLFwibXRuXCI6dHJ1ZSxcIm10cGNcIjp0cnVlLFwibXRyXCI6dHJ1ZSxcIm11bHRpY2hvaWNlXCI6dHJ1ZSxcIm11dHVhbFwiOnRydWUsXCJtdXR1ZWxsZVwiOnRydWUsXCJtemFuc2ltYWdpY1wiOnRydWUsXCJuYWJcIjp0cnVlLFwibmFkZXhcIjp0cnVlLFwibmFnb3lhXCI6dHJ1ZSxcIm5hc3BlcnNcIjp0cnVlLFwibmF0aW9ud2lkZVwiOnRydWUsXCJuYXR1cmFcIjp0cnVlLFwibmF2eVwiOnRydWUsXCJuYmFcIjp0cnVlLFwibmVjXCI6dHJ1ZSxcIm5ldGJhbmtcIjp0cnVlLFwibmV0ZmxpeFwiOnRydWUsXCJuZXR3b3JrXCI6dHJ1ZSxcIm5ldXN0YXJcIjp0cnVlLFwibmV3XCI6dHJ1ZSxcIm5ld2hvbGxhbmRcIjp0cnVlLFwibmV3c1wiOnRydWUsXCJuZXh0XCI6dHJ1ZSxcIm5leHRkaXJlY3RcIjp0cnVlLFwibmV4dXNcIjp0cnVlLFwibmZsXCI6dHJ1ZSxcIm5nb1wiOnRydWUsXCJuaGtcIjp0cnVlLFwibmljb1wiOnRydWUsXCJuaWtlXCI6dHJ1ZSxcIm5pa29uXCI6dHJ1ZSxcIm5pbmphXCI6dHJ1ZSxcIm5pc3NhblwiOnRydWUsXCJub2tpYVwiOnRydWUsXCJub3J0aHdlc3Rlcm5tdXR1YWxcIjp0cnVlLFwibm9ydG9uXCI6dHJ1ZSxcIm5vd1wiOnRydWUsXCJub3dydXpcIjp0cnVlLFwibm93dHZcIjp0cnVlLFwibnJhXCI6dHJ1ZSxcIm5yd1wiOnRydWUsXCJudHRcIjp0cnVlLFwibnljXCI6dHJ1ZSxcIm9iaVwiOnRydWUsXCJvYnNlcnZlclwiOnRydWUsXCJvZmZcIjp0cnVlLFwib2ZmaWNlXCI6dHJ1ZSxcIm9raW5hd2FcIjp0cnVlLFwib2xheWFuXCI6dHJ1ZSxcIm9sYXlhbmdyb3VwXCI6dHJ1ZSxcIm9sZG5hdnlcIjp0cnVlLFwib2xsb1wiOnRydWUsXCJvbWVnYVwiOnRydWUsXCJvbmVcIjp0cnVlLFwib25nXCI6dHJ1ZSxcIm9ubFwiOnRydWUsXCJvbmxpbmVcIjp0cnVlLFwib255b3Vyc2lkZVwiOnRydWUsXCJvb29cIjp0cnVlLFwib3BlblwiOnRydWUsXCJvcmFjbGVcIjp0cnVlLFwib3JhbmdlXCI6dHJ1ZSxcIm9yZ2FuaWNcIjp0cnVlLFwib3JpZW50ZXhwcmVzc1wiOnRydWUsXCJvc2FrYVwiOnRydWUsXCJvdHN1a2FcIjp0cnVlLFwib3R0XCI6dHJ1ZSxcIm92aFwiOnRydWUsXCJwYWdlXCI6dHJ1ZSxcInBhbXBlcmVkY2hlZlwiOnRydWUsXCJwYW5hc29uaWNcIjp0cnVlLFwicGFuZXJhaVwiOnRydWUsXCJwYXJpc1wiOnRydWUsXCJwYXJzXCI6dHJ1ZSxcInBhcnRuZXJzXCI6dHJ1ZSxcInBhcnRzXCI6dHJ1ZSxcInBhcnR5XCI6dHJ1ZSxcInBhc3NhZ2Vuc1wiOnRydWUsXCJwYXlcIjp0cnVlLFwicGF5dVwiOnRydWUsXCJwY2N3XCI6dHJ1ZSxcInBldFwiOnRydWUsXCJwZml6ZXJcIjp0cnVlLFwicGhhcm1hY3lcIjp0cnVlLFwicGhpbGlwc1wiOnRydWUsXCJwaG90b1wiOnRydWUsXCJwaG90b2dyYXBoeVwiOnRydWUsXCJwaG90b3NcIjp0cnVlLFwicGh5c2lvXCI6dHJ1ZSxcInBpYWdldFwiOnRydWUsXCJwaWNzXCI6dHJ1ZSxcInBpY3RldFwiOnRydWUsXCJwaWN0dXJlc1wiOnRydWUsXCJwaWRcIjp0cnVlLFwicGluXCI6dHJ1ZSxcInBpbmdcIjp0cnVlLFwicGlua1wiOnRydWUsXCJwaW9uZWVyXCI6dHJ1ZSxcInBpenphXCI6dHJ1ZSxcInBsYWNlXCI6dHJ1ZSxcInBsYXlcIjp0cnVlLFwicGxheXN0YXRpb25cIjp0cnVlLFwicGx1bWJpbmdcIjp0cnVlLFwicGx1c1wiOnRydWUsXCJwbmNcIjp0cnVlLFwicG9obFwiOnRydWUsXCJwb2tlclwiOnRydWUsXCJwb2xpdGllXCI6dHJ1ZSxcInBvcm5cIjp0cnVlLFwicHJhbWVyaWNhXCI6dHJ1ZSxcInByYXhpXCI6dHJ1ZSxcInByZXNzXCI6dHJ1ZSxcInByaW1lXCI6dHJ1ZSxcInByb2RcIjp0cnVlLFwicHJvZHVjdGlvbnNcIjp0cnVlLFwicHJvZlwiOnRydWUsXCJwcm9ncmVzc2l2ZVwiOnRydWUsXCJwcm9tb1wiOnRydWUsXCJwcm9wZXJ0aWVzXCI6dHJ1ZSxcInByb3BlcnR5XCI6dHJ1ZSxcInByb3RlY3Rpb25cIjp0cnVlLFwicHJ1XCI6dHJ1ZSxcInBydWRlbnRpYWxcIjp0cnVlLFwicHViXCI6dHJ1ZSxcInFwb25cIjp0cnVlLFwicXVlYmVjXCI6dHJ1ZSxcInF1ZXN0XCI6dHJ1ZSxcInF2Y1wiOnRydWUsXCJyYWNpbmdcIjp0cnVlLFwicmFpZFwiOnRydWUsXCJyZWFkXCI6dHJ1ZSxcInJlYWxlc3RhdGVcIjp0cnVlLFwicmVhbHRvclwiOnRydWUsXCJyZWFsdHlcIjp0cnVlLFwicmVjaXBlc1wiOnRydWUsXCJyZWRcIjp0cnVlLFwicmVkc3RvbmVcIjp0cnVlLFwicmVkdW1icmVsbGFcIjp0cnVlLFwicmVoYWJcIjp0cnVlLFwicmVpc2VcIjp0cnVlLFwicmVpc2VuXCI6dHJ1ZSxcInJlaXRcIjp0cnVlLFwicmVsaWFuY2VcIjp0cnVlLFwicmVuXCI6dHJ1ZSxcInJlbnRcIjp0cnVlLFwicmVudGFsc1wiOnRydWUsXCJyZXBhaXJcIjp0cnVlLFwicmVwb3J0XCI6dHJ1ZSxcInJlcHVibGljYW5cIjp0cnVlLFwicmVzdFwiOnRydWUsXCJyZXN0YXVyYW50XCI6dHJ1ZSxcInJldmlld1wiOnRydWUsXCJyZXZpZXdzXCI6dHJ1ZSxcInJleHJvdGhcIjp0cnVlLFwicmljaFwiOnRydWUsXCJyaWNoYXJkbGlcIjp0cnVlLFwicmljb2hcIjp0cnVlLFwicmlnaHRhdGhvbWVcIjp0cnVlLFwicmlsXCI6dHJ1ZSxcInJpb1wiOnRydWUsXCJyaXBcIjp0cnVlLFwicm9jaGVyXCI6dHJ1ZSxcInJvY2tzXCI6dHJ1ZSxcInJvZGVvXCI6dHJ1ZSxcInJvZ2Vyc1wiOnRydWUsXCJyb29tXCI6dHJ1ZSxcInJzdnBcIjp0cnVlLFwicnVoclwiOnRydWUsXCJydW5cIjp0cnVlLFwicndlXCI6dHJ1ZSxcInJ5dWt5dVwiOnRydWUsXCJzYWFybGFuZFwiOnRydWUsXCJzYWZlXCI6dHJ1ZSxcInNhZmV0eVwiOnRydWUsXCJzYWt1cmFcIjp0cnVlLFwic2FsZVwiOnRydWUsXCJzYWxvblwiOnRydWUsXCJzYW1zY2x1YlwiOnRydWUsXCJzYW1zdW5nXCI6dHJ1ZSxcInNhbmR2aWtcIjp0cnVlLFwic2FuZHZpa2Nvcm9tYW50XCI6dHJ1ZSxcInNhbm9maVwiOnRydWUsXCJzYXBcIjp0cnVlLFwic2Fwb1wiOnRydWUsXCJzYXJsXCI6dHJ1ZSxcInNhc1wiOnRydWUsXCJzYXZlXCI6dHJ1ZSxcInNheG9cIjp0cnVlLFwic2JpXCI6dHJ1ZSxcInNic1wiOnRydWUsXCJzY2FcIjp0cnVlLFwic2NiXCI6dHJ1ZSxcInNjaGFlZmZsZXJcIjp0cnVlLFwic2NobWlkdFwiOnRydWUsXCJzY2hvbGFyc2hpcHNcIjp0cnVlLFwic2Nob29sXCI6dHJ1ZSxcInNjaHVsZVwiOnRydWUsXCJzY2h3YXJ6XCI6dHJ1ZSxcInNjaWVuY2VcIjp0cnVlLFwic2Nqb2huc29uXCI6dHJ1ZSxcInNjb3JcIjp0cnVlLFwic2NvdFwiOnRydWUsXCJzZWF0XCI6dHJ1ZSxcInNlY3VyZVwiOnRydWUsXCJzZWN1cml0eVwiOnRydWUsXCJzZWVrXCI6dHJ1ZSxcInNlbmVyXCI6dHJ1ZSxcInNlcnZpY2VzXCI6dHJ1ZSxcInNlc1wiOnRydWUsXCJzZXZlblwiOnRydWUsXCJzZXdcIjp0cnVlLFwic2V4XCI6dHJ1ZSxcInNleHlcIjp0cnVlLFwic2ZyXCI6dHJ1ZSxcInNoYW5ncmlsYVwiOnRydWUsXCJzaGFycFwiOnRydWUsXCJzaGF3XCI6dHJ1ZSxcInNoZWxsXCI6dHJ1ZSxcInNoaWFcIjp0cnVlLFwic2hpa3NoYVwiOnRydWUsXCJzaG9lc1wiOnRydWUsXCJzaG91amlcIjp0cnVlLFwic2hvd1wiOnRydWUsXCJzaG93dGltZVwiOnRydWUsXCJzaHJpcmFtXCI6dHJ1ZSxcInNpbGtcIjp0cnVlLFwic2luYVwiOnRydWUsXCJzaW5nbGVzXCI6dHJ1ZSxcInNpdGVcIjp0cnVlLFwic2tpXCI6dHJ1ZSxcInNraW5cIjp0cnVlLFwic2t5XCI6dHJ1ZSxcInNreXBlXCI6dHJ1ZSxcInNsaW5nXCI6dHJ1ZSxcInNtYXJ0XCI6dHJ1ZSxcInNtaWxlXCI6dHJ1ZSxcInNuY2ZcIjp0cnVlLFwic29jY2VyXCI6dHJ1ZSxcInNvY2lhbFwiOnRydWUsXCJzb2Z0YmFua1wiOnRydWUsXCJzb2Z0d2FyZVwiOnRydWUsXCJzb2h1XCI6dHJ1ZSxcInNvbGFyXCI6dHJ1ZSxcInNvbHV0aW9uc1wiOnRydWUsXCJzb25nXCI6dHJ1ZSxcInNvbnlcIjp0cnVlLFwic295XCI6dHJ1ZSxcInNwYWNlXCI6dHJ1ZSxcInNwaWVnZWxcIjp0cnVlLFwic3BvdFwiOnRydWUsXCJzcHJlYWRiZXR0aW5nXCI6dHJ1ZSxcInNybFwiOnRydWUsXCJzcnRcIjp0cnVlLFwic3RhZGFcIjp0cnVlLFwic3RhcGxlc1wiOnRydWUsXCJzdGFyXCI6dHJ1ZSxcInN0YXJodWJcIjp0cnVlLFwic3RhdGViYW5rXCI6dHJ1ZSxcInN0YXRlZmFybVwiOnRydWUsXCJzdGF0b2lsXCI6dHJ1ZSxcInN0Y1wiOnRydWUsXCJzdGNncm91cFwiOnRydWUsXCJzdG9ja2hvbG1cIjp0cnVlLFwic3RvcmFnZVwiOnRydWUsXCJzdG9yZVwiOnRydWUsXCJzdHVkaW9cIjp0cnVlLFwic3R1ZHlcIjp0cnVlLFwic3R5bGVcIjp0cnVlLFwic3Vja3NcIjp0cnVlLFwic3VwZXJzcG9ydFwiOnRydWUsXCJzdXBwbGllc1wiOnRydWUsXCJzdXBwbHlcIjp0cnVlLFwic3VwcG9ydFwiOnRydWUsXCJzdXJmXCI6dHJ1ZSxcInN1cmdlcnlcIjp0cnVlLFwic3V6dWtpXCI6dHJ1ZSxcInN3YXRjaFwiOnRydWUsXCJzd2lmdGNvdmVyXCI6dHJ1ZSxcInN3aXNzXCI6dHJ1ZSxcInN5ZG5leVwiOnRydWUsXCJzeW1hbnRlY1wiOnRydWUsXCJzeXN0ZW1zXCI6dHJ1ZSxcInRhYlwiOnRydWUsXCJ0YWlwZWlcIjp0cnVlLFwidGFsa1wiOnRydWUsXCJ0YW9iYW9cIjp0cnVlLFwidGFyZ2V0XCI6dHJ1ZSxcInRhdGFtb3RvcnNcIjp0cnVlLFwidGF0YXJcIjp0cnVlLFwidGF0dG9vXCI6dHJ1ZSxcInRheFwiOnRydWUsXCJ0YXhpXCI6dHJ1ZSxcInRjaVwiOnRydWUsXCJ0ZGtcIjp0cnVlLFwidGVhbVwiOnRydWUsXCJ0ZWNoXCI6dHJ1ZSxcInRlY2hub2xvZ3lcIjp0cnVlLFwidGVsZWNpdHlcIjp0cnVlLFwidGVsZWZvbmljYVwiOnRydWUsXCJ0ZW1hc2VrXCI6dHJ1ZSxcInRlbm5pc1wiOnRydWUsXCJ0ZXZhXCI6dHJ1ZSxcInRoZFwiOnRydWUsXCJ0aGVhdGVyXCI6dHJ1ZSxcInRoZWF0cmVcIjp0cnVlLFwidGhlZ3VhcmRpYW5cIjp0cnVlLFwidGlhYVwiOnRydWUsXCJ0aWNrZXRzXCI6dHJ1ZSxcInRpZW5kYVwiOnRydWUsXCJ0aWZmYW55XCI6dHJ1ZSxcInRpcHNcIjp0cnVlLFwidGlyZXNcIjp0cnVlLFwidGlyb2xcIjp0cnVlLFwidGptYXh4XCI6dHJ1ZSxcInRqeFwiOnRydWUsXCJ0a21heHhcIjp0cnVlLFwidG1hbGxcIjp0cnVlLFwidG9kYXlcIjp0cnVlLFwidG9reW9cIjp0cnVlLFwidG9vbHNcIjp0cnVlLFwidG9wXCI6dHJ1ZSxcInRvcmF5XCI6dHJ1ZSxcInRvc2hpYmFcIjp0cnVlLFwidG90YWxcIjp0cnVlLFwidG91cnNcIjp0cnVlLFwidG93blwiOnRydWUsXCJ0b3lvdGFcIjp0cnVlLFwidG95c1wiOnRydWUsXCJ0cmFkZVwiOnRydWUsXCJ0cmFkaW5nXCI6dHJ1ZSxcInRyYWluaW5nXCI6dHJ1ZSxcInRyYXZlbGNoYW5uZWxcIjp0cnVlLFwidHJhdmVsZXJzXCI6dHJ1ZSxcInRyYXZlbGVyc2luc3VyYW5jZVwiOnRydWUsXCJ0cnVzdFwiOnRydWUsXCJ0cnZcIjp0cnVlLFwidHViZVwiOnRydWUsXCJ0dWlcIjp0cnVlLFwidHVuZXNcIjp0cnVlLFwidHVzaHVcIjp0cnVlLFwidHZzXCI6dHJ1ZSxcInViYW5rXCI6dHJ1ZSxcInVic1wiOnRydWUsXCJ1Y29ubmVjdFwiOnRydWUsXCJ1bml2ZXJzaXR5XCI6dHJ1ZSxcInVub1wiOnRydWUsXCJ1b2xcIjp0cnVlLFwidXBzXCI6dHJ1ZSxcInZhY2F0aW9uc1wiOnRydWUsXCJ2YW5hXCI6dHJ1ZSxcInZhbmd1YXJkXCI6dHJ1ZSxcInZlZ2FzXCI6dHJ1ZSxcInZlbnR1cmVzXCI6dHJ1ZSxcInZlcmlzaWduXCI6dHJ1ZSxcInZlcnNpY2hlcnVuZ1wiOnRydWUsXCJ2ZXRcIjp0cnVlLFwidmlhamVzXCI6dHJ1ZSxcInZpZGVvXCI6dHJ1ZSxcInZpZ1wiOnRydWUsXCJ2aWtpbmdcIjp0cnVlLFwidmlsbGFzXCI6dHJ1ZSxcInZpblwiOnRydWUsXCJ2aXBcIjp0cnVlLFwidmlyZ2luXCI6dHJ1ZSxcInZpc2FcIjp0cnVlLFwidmlzaW9uXCI6dHJ1ZSxcInZpc3RhXCI6dHJ1ZSxcInZpc3RhcHJpbnRcIjp0cnVlLFwidml2YVwiOnRydWUsXCJ2aXZvXCI6dHJ1ZSxcInZsYWFuZGVyZW5cIjp0cnVlLFwidm9ka2FcIjp0cnVlLFwidm9sa3N3YWdlblwiOnRydWUsXCJ2b3RlXCI6dHJ1ZSxcInZvdGluZ1wiOnRydWUsXCJ2b3RvXCI6dHJ1ZSxcInZveWFnZVwiOnRydWUsXCJ2dWVsb3NcIjp0cnVlLFwid2FsZXNcIjp0cnVlLFwid2FsbWFydFwiOnRydWUsXCJ3YWx0ZXJcIjp0cnVlLFwid2FuZ1wiOnRydWUsXCJ3YW5nZ291XCI6dHJ1ZSxcIndhcm1hblwiOnRydWUsXCJ3YXRjaFwiOnRydWUsXCJ3YXRjaGVzXCI6dHJ1ZSxcIndlYXRoZXJcIjp0cnVlLFwid2VhdGhlcmNoYW5uZWxcIjp0cnVlLFwid2ViY2FtXCI6dHJ1ZSxcIndlYmVyXCI6dHJ1ZSxcIndlYnNpdGVcIjp0cnVlLFwid2VkXCI6dHJ1ZSxcIndlZGRpbmdcIjp0cnVlLFwid2VpYm9cIjp0cnVlLFwid2VpclwiOnRydWUsXCJ3aG9zd2hvXCI6dHJ1ZSxcIndpZW5cIjp0cnVlLFwid2lraVwiOnRydWUsXCJ3aWxsaWFtaGlsbFwiOnRydWUsXCJ3aW5cIjp0cnVlLFwid2luZG93c1wiOnRydWUsXCJ3aW5lXCI6dHJ1ZSxcIndpbm5lcnNcIjp0cnVlLFwid21lXCI6dHJ1ZSxcIndvbHRlcnNrbHV3ZXJcIjp0cnVlLFwid29vZHNpZGVcIjp0cnVlLFwid29ya1wiOnRydWUsXCJ3b3Jrc1wiOnRydWUsXCJ3b3JsZFwiOnRydWUsXCJ3dGNcIjp0cnVlLFwid3RmXCI6dHJ1ZSxcInhib3hcIjp0cnVlLFwieGVyb3hcIjp0cnVlLFwieGZpbml0eVwiOnRydWUsXCJ4aWh1YW5cIjp0cnVlLFwieGluXCI6dHJ1ZSxcInhuLS0xMWI0YzNkXCI6dHJ1ZSxcInhuLS0xY2syZTFiXCI6dHJ1ZSxcInhuLS0xcXF3MjNhXCI6dHJ1ZSxcInhuLS0zMHJyN3lcIjp0cnVlLFwieG4tLTNic3QwMG1cIjp0cnVlLFwieG4tLTNkczQ0M2dcIjp0cnVlLFwieG4tLTNvcTE4dmw4cG4zNmFcIjp0cnVlLFwieG4tLTNweHU4a1wiOnRydWUsXCJ4bi0tNDJjMmQ5YVwiOnRydWUsXCJ4bi0tNDVxMTFjXCI6dHJ1ZSxcInhuLS00Z2JyaW1cIjp0cnVlLFwieG4tLTRncTQ4bGY5alwiOnRydWUsXCJ4bi0tNTVxdzQyZ1wiOnRydWUsXCJ4bi0tNTVxeDVkXCI6dHJ1ZSxcInhuLS01c3UzNGo5MzZiZ3NnXCI6dHJ1ZSxcInhuLS01dHptNWdcIjp0cnVlLFwieG4tLTZmcno4MmdcIjp0cnVlLFwieG4tLTZxcTk4NmIzeGxcIjp0cnVlLFwieG4tLTgwYWR4aGtzXCI6dHJ1ZSxcInhuLS04MGFzZWhkYlwiOnRydWUsXCJ4bi0tODBhc3dnXCI6dHJ1ZSxcInhuLS04eTBhMDYzYVwiOnRydWUsXCJ4bi0tOWRicTJhXCI6dHJ1ZSxcInhuLS05ZXQ1MnVcIjp0cnVlLFwieG4tLTlrcnQwMGFcIjp0cnVlLFwieG4tLWI0dzYwNWZlcmRcIjp0cnVlLFwieG4tLWJjazFiOWE1ZHJlNGNcIjp0cnVlLFwieG4tLWMxYXZnXCI6dHJ1ZSxcInhuLS1jMmJyN2dcIjp0cnVlLFwieG4tLWNjazJiM2JcIjp0cnVlLFwieG4tLWNnNGJraVwiOnRydWUsXCJ4bi0tY3pyNjk0YlwiOnRydWUsXCJ4bi0tY3pyczB0XCI6dHJ1ZSxcInhuLS1jenJ1MmRcIjp0cnVlLFwieG4tLWQxYWNqM2JcIjp0cnVlLFwieG4tLWVja3ZkdGM5ZFwiOnRydWUsXCJ4bi0tZWZ2eTg4aFwiOnRydWUsXCJ4bi0tZXN0djc1Z1wiOnRydWUsXCJ4bi0tZmN0NDI5a1wiOnRydWUsXCJ4bi0tZmhiZWlcIjp0cnVlLFwieG4tLWZpcTIyOGM1aHNcIjp0cnVlLFwieG4tLWZpcTY0YlwiOnRydWUsXCJ4bi0tZmpxNzIwYVwiOnRydWUsXCJ4bi0tZmx3MzUxZVwiOnRydWUsXCJ4bi0tZnp5czhkNjl1dmdtXCI6dHJ1ZSxcInhuLS1nMnh4NDhjXCI6dHJ1ZSxcInhuLS1nY2tyM2YwZlwiOnRydWUsXCJ4bi0taHh0ODE0ZVwiOnRydWUsXCJ4bi0taTFiNmIxYTZhMmVcIjp0cnVlLFwieG4tLWltcjUxM25cIjp0cnVlLFwieG4tLWlvMGE3aVwiOnRydWUsXCJ4bi0tajFhZWZcIjp0cnVlLFwieG4tLWpscTYxdTl3N2JcIjp0cnVlLFwieG4tLWp2cjE4OW1cIjp0cnVlLFwieG4tLWtjcng3N2QxeDRhXCI6dHJ1ZSxcInhuLS1rcHU3MTZmXCI6dHJ1ZSxcInhuLS1rcHV0M2lcIjp0cnVlLFwieG4tLW1nYmEzYTNlanRcIjp0cnVlLFwieG4tLW1nYmE3YzBiYm4wYVwiOnRydWUsXCJ4bi0tbWdiYWFrYzdkdmZcIjp0cnVlLFwieG4tLW1nYmFiMmJkXCI6dHJ1ZSxcInhuLS1tZ2JiOWZicG9iXCI6dHJ1ZSxcInhuLS1tZ2JjYTdkemRvXCI6dHJ1ZSxcInhuLS1tZ2J0M2RoZFwiOnRydWUsXCJ4bi0tbWsxYnU0NGNcIjp0cnVlLFwieG4tLW14dHExbVwiOnRydWUsXCJ4bi0tbmdiYzVhemRcIjp0cnVlLFwieG4tLW5nYmU5ZTBhXCI6dHJ1ZSxcInhuLS1ucXY3ZlwiOnRydWUsXCJ4bi0tbnF2N2ZzMDBlbWFcIjp0cnVlLFwieG4tLW55cXkyNmFcIjp0cnVlLFwieG4tLXAxYWNmXCI6dHJ1ZSxcInhuLS1wYnQ5NzdjXCI6dHJ1ZSxcInhuLS1wc3N5MnVcIjp0cnVlLFwieG4tLXE5anliNGNcIjp0cnVlLFwieG4tLXFja2ExcG1jXCI6dHJ1ZSxcInhuLS1yaHF2OTZnXCI6dHJ1ZSxcInhuLS1yb3Z1ODhiXCI6dHJ1ZSxcInhuLS1zZXM1NTRnXCI6dHJ1ZSxcInhuLS10NjBiNTZhXCI6dHJ1ZSxcInhuLS10Y2t3ZVwiOnRydWUsXCJ4bi0tdW51cDR5XCI6dHJ1ZSxcInhuLS12ZXJtZ2Vuc2JlcmF0ZXItY3RiXCI6dHJ1ZSxcInhuLS12ZXJtZ2Vuc2JlcmF0dW5nLXB3YlwiOnRydWUsXCJ4bi0tdmhxdXZcIjp0cnVlLFwieG4tLXZ1cTg2MWJcIjp0cnVlLFwieG4tLXc0cjg1ZWw4Zmh1NWRucmFcIjp0cnVlLFwieG4tLXc0cnM0MGxcIjp0cnVlLFwieG4tLXhocTUyMWJcIjp0cnVlLFwieG4tLXpmcjE2NGJcIjp0cnVlLFwieHBlcmlhXCI6dHJ1ZSxcInh5elwiOnRydWUsXCJ5YWNodHNcIjp0cnVlLFwieWFob29cIjp0cnVlLFwieWFtYXh1blwiOnRydWUsXCJ5YW5kZXhcIjp0cnVlLFwieW9kb2Jhc2hpXCI6dHJ1ZSxcInlvZ2FcIjp0cnVlLFwieW9rb2hhbWFcIjp0cnVlLFwieW91XCI6dHJ1ZSxcInlvdXR1YmVcIjp0cnVlLFwieXVuXCI6dHJ1ZSxcInphcHBvc1wiOnRydWUsXCJ6YXJhXCI6dHJ1ZSxcInplcm9cIjp0cnVlLFwiemlwXCI6dHJ1ZSxcInppcHBvXCI6dHJ1ZSxcInpvbmVcIjp0cnVlLFwienVlcmljaFwiOnRydWUsXCJjbG91ZGZyb250Lm5ldFwiOnRydWUsXCJhcC1ub3J0aGVhc3QtMS5jb21wdXRlLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiYXAtc291dGhlYXN0LTEuY29tcHV0ZS5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcImFwLXNvdXRoZWFzdC0yLmNvbXB1dGUuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJjbi1ub3J0aC0xLmNvbXB1dGUuYW1hem9uYXdzLmNuXCI6dHJ1ZSxcImNvbXB1dGUuYW1hem9uYXdzLmNuXCI6dHJ1ZSxcImNvbXB1dGUuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJjb21wdXRlLTEuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJldS13ZXN0LTEuY29tcHV0ZS5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcImV1LWNlbnRyYWwtMS5jb21wdXRlLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwic2EtZWFzdC0xLmNvbXB1dGUuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJ1cy1lYXN0LTEuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJ1cy1nb3Ytd2VzdC0xLmNvbXB1dGUuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJ1cy13ZXN0LTEuY29tcHV0ZS5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInVzLXdlc3QtMi5jb21wdXRlLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiei0xLmNvbXB1dGUtMS5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInotMi5jb21wdXRlLTEuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJlbGFzdGljYmVhbnN0YWxrLmNvbVwiOnRydWUsXCJlbGIuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJzMy5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInMzLWFwLW5vcnRoZWFzdC0xLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiczMtYXAtc291dGhlYXN0LTEuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJzMy1hcC1zb3V0aGVhc3QtMi5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInMzLWV4dGVybmFsLTEuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJzMy1leHRlcm5hbC0yLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiczMtZmlwcy11cy1nb3Ytd2VzdC0xLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiczMtZXUtY2VudHJhbC0xLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiczMtZXUtd2VzdC0xLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiczMtc2EtZWFzdC0xLmFtYXpvbmF3cy5jb21cIjp0cnVlLFwiczMtdXMtZ292LXdlc3QtMS5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInMzLXVzLXdlc3QtMS5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInMzLXVzLXdlc3QtMi5hbWF6b25hd3MuY29tXCI6dHJ1ZSxcInMzLmNuLW5vcnRoLTEuYW1hem9uYXdzLmNvbS5jblwiOnRydWUsXCJzMy5ldS1jZW50cmFsLTEuYW1hem9uYXdzLmNvbVwiOnRydWUsXCJiZXRhaW5hYm94LmNvbVwiOnRydWUsXCJhZS5vcmdcIjp0cnVlLFwiYXIuY29tXCI6dHJ1ZSxcImJyLmNvbVwiOnRydWUsXCJjbi5jb21cIjp0cnVlLFwiY29tLmRlXCI6dHJ1ZSxcImNvbS5zZVwiOnRydWUsXCJkZS5jb21cIjp0cnVlLFwiZXUuY29tXCI6dHJ1ZSxcImdiLmNvbVwiOnRydWUsXCJnYi5uZXRcIjp0cnVlLFwiaHUuY29tXCI6dHJ1ZSxcImh1Lm5ldFwiOnRydWUsXCJqcC5uZXRcIjp0cnVlLFwianBuLmNvbVwiOnRydWUsXCJrci5jb21cIjp0cnVlLFwibWV4LmNvbVwiOnRydWUsXCJuby5jb21cIjp0cnVlLFwicWMuY29tXCI6dHJ1ZSxcInJ1LmNvbVwiOnRydWUsXCJzYS5jb21cIjp0cnVlLFwic2UuY29tXCI6dHJ1ZSxcInNlLm5ldFwiOnRydWUsXCJ1ay5jb21cIjp0cnVlLFwidWsubmV0XCI6dHJ1ZSxcInVzLmNvbVwiOnRydWUsXCJ1eS5jb21cIjp0cnVlLFwiemEuYnpcIjp0cnVlLFwiemEuY29tXCI6dHJ1ZSxcImFmcmljYS5jb21cIjp0cnVlLFwiZ3IuY29tXCI6dHJ1ZSxcImluLm5ldFwiOnRydWUsXCJ1cy5vcmdcIjp0cnVlLFwiY28uY29tXCI6dHJ1ZSxcImMubGFcIjp0cnVlLFwiY2xvdWRjb250cm9sbGVkLmNvbVwiOnRydWUsXCJjbG91ZGNvbnRyb2xhcHAuY29tXCI6dHJ1ZSxcImNvLmNhXCI6dHJ1ZSxcImMuY2RuNzcub3JnXCI6dHJ1ZSxcImNkbjc3LXNzbC5uZXRcIjp0cnVlLFwici5jZG43Ny5uZXRcIjp0cnVlLFwicnNjLmNkbjc3Lm9yZ1wiOnRydWUsXCJzc2wub3JpZ2luLmNkbjc3LXNlY3VyZS5vcmdcIjp0cnVlLFwiY28ubmxcIjp0cnVlLFwiY28ubm9cIjp0cnVlLFwiKi5wbGF0Zm9ybS5zaFwiOnRydWUsXCJjdXBjYWtlLmlzXCI6dHJ1ZSxcImRyZWFtaG9zdGVycy5jb21cIjp0cnVlLFwiZHVja2Rucy5vcmdcIjp0cnVlLFwiZHluZG5zLWF0LWhvbWUuY29tXCI6dHJ1ZSxcImR5bmRucy1hdC13b3JrLmNvbVwiOnRydWUsXCJkeW5kbnMtYmxvZy5jb21cIjp0cnVlLFwiZHluZG5zLWZyZWUuY29tXCI6dHJ1ZSxcImR5bmRucy1ob21lLmNvbVwiOnRydWUsXCJkeW5kbnMtaXAuY29tXCI6dHJ1ZSxcImR5bmRucy1tYWlsLmNvbVwiOnRydWUsXCJkeW5kbnMtb2ZmaWNlLmNvbVwiOnRydWUsXCJkeW5kbnMtcGljcy5jb21cIjp0cnVlLFwiZHluZG5zLXJlbW90ZS5jb21cIjp0cnVlLFwiZHluZG5zLXNlcnZlci5jb21cIjp0cnVlLFwiZHluZG5zLXdlYi5jb21cIjp0cnVlLFwiZHluZG5zLXdpa2kuY29tXCI6dHJ1ZSxcImR5bmRucy13b3JrLmNvbVwiOnRydWUsXCJkeW5kbnMuYml6XCI6dHJ1ZSxcImR5bmRucy5pbmZvXCI6dHJ1ZSxcImR5bmRucy5vcmdcIjp0cnVlLFwiZHluZG5zLnR2XCI6dHJ1ZSxcImF0LWJhbmQtY2FtcC5uZXRcIjp0cnVlLFwiYXRoLmN4XCI6dHJ1ZSxcImJhcnJlbC1vZi1rbm93bGVkZ2UuaW5mb1wiOnRydWUsXCJiYXJyZWxsLW9mLWtub3dsZWRnZS5pbmZvXCI6dHJ1ZSxcImJldHRlci10aGFuLnR2XCI6dHJ1ZSxcImJsb2dkbnMuY29tXCI6dHJ1ZSxcImJsb2dkbnMubmV0XCI6dHJ1ZSxcImJsb2dkbnMub3JnXCI6dHJ1ZSxcImJsb2dzaXRlLm9yZ1wiOnRydWUsXCJib2xkbHlnb2luZ25vd2hlcmUub3JnXCI6dHJ1ZSxcImJyb2tlLWl0Lm5ldFwiOnRydWUsXCJidXlzaG91c2VzLm5ldFwiOnRydWUsXCJjZWNoaXJlLmNvbVwiOnRydWUsXCJkbnNhbGlhcy5jb21cIjp0cnVlLFwiZG5zYWxpYXMubmV0XCI6dHJ1ZSxcImRuc2FsaWFzLm9yZ1wiOnRydWUsXCJkbnNkb2pvLmNvbVwiOnRydWUsXCJkbnNkb2pvLm5ldFwiOnRydWUsXCJkbnNkb2pvLm9yZ1wiOnRydWUsXCJkb2VzLWl0Lm5ldFwiOnRydWUsXCJkb2VzbnRleGlzdC5jb21cIjp0cnVlLFwiZG9lc250ZXhpc3Qub3JnXCI6dHJ1ZSxcImRvbnRleGlzdC5jb21cIjp0cnVlLFwiZG9udGV4aXN0Lm5ldFwiOnRydWUsXCJkb250ZXhpc3Qub3JnXCI6dHJ1ZSxcImRvb21kbnMuY29tXCI6dHJ1ZSxcImRvb21kbnMub3JnXCI6dHJ1ZSxcImR2cmRucy5vcmdcIjp0cnVlLFwiZHluLW8tc2F1ci5jb21cIjp0cnVlLFwiZHluYWxpYXMuY29tXCI6dHJ1ZSxcImR5bmFsaWFzLm5ldFwiOnRydWUsXCJkeW5hbGlhcy5vcmdcIjp0cnVlLFwiZHluYXRob21lLm5ldFwiOnRydWUsXCJkeW5kbnMud3NcIjp0cnVlLFwiZW5kb2ZpbnRlcm5ldC5uZXRcIjp0cnVlLFwiZW5kb2ZpbnRlcm5ldC5vcmdcIjp0cnVlLFwiZW5kb2Z0aGVpbnRlcm5ldC5vcmdcIjp0cnVlLFwiZXN0LWEtbGEtbWFpc29uLmNvbVwiOnRydWUsXCJlc3QtYS1sYS1tYXNpb24uY29tXCI6dHJ1ZSxcImVzdC1sZS1wYXRyb24uY29tXCI6dHJ1ZSxcImVzdC1tb24tYmxvZ3VldXIuY29tXCI6dHJ1ZSxcImZvci1iZXR0ZXIuYml6XCI6dHJ1ZSxcImZvci1tb3JlLmJpelwiOnRydWUsXCJmb3Itb3VyLmluZm9cIjp0cnVlLFwiZm9yLXNvbWUuYml6XCI6dHJ1ZSxcImZvci10aGUuYml6XCI6dHJ1ZSxcImZvcmdvdC5oZXIubmFtZVwiOnRydWUsXCJmb3Jnb3QuaGlzLm5hbWVcIjp0cnVlLFwiZnJvbS1hay5jb21cIjp0cnVlLFwiZnJvbS1hbC5jb21cIjp0cnVlLFwiZnJvbS1hci5jb21cIjp0cnVlLFwiZnJvbS1hei5uZXRcIjp0cnVlLFwiZnJvbS1jYS5jb21cIjp0cnVlLFwiZnJvbS1jby5uZXRcIjp0cnVlLFwiZnJvbS1jdC5jb21cIjp0cnVlLFwiZnJvbS1kYy5jb21cIjp0cnVlLFwiZnJvbS1kZS5jb21cIjp0cnVlLFwiZnJvbS1mbC5jb21cIjp0cnVlLFwiZnJvbS1nYS5jb21cIjp0cnVlLFwiZnJvbS1oaS5jb21cIjp0cnVlLFwiZnJvbS1pYS5jb21cIjp0cnVlLFwiZnJvbS1pZC5jb21cIjp0cnVlLFwiZnJvbS1pbC5jb21cIjp0cnVlLFwiZnJvbS1pbi5jb21cIjp0cnVlLFwiZnJvbS1rcy5jb21cIjp0cnVlLFwiZnJvbS1reS5jb21cIjp0cnVlLFwiZnJvbS1sYS5uZXRcIjp0cnVlLFwiZnJvbS1tYS5jb21cIjp0cnVlLFwiZnJvbS1tZC5jb21cIjp0cnVlLFwiZnJvbS1tZS5vcmdcIjp0cnVlLFwiZnJvbS1taS5jb21cIjp0cnVlLFwiZnJvbS1tbi5jb21cIjp0cnVlLFwiZnJvbS1tby5jb21cIjp0cnVlLFwiZnJvbS1tcy5jb21cIjp0cnVlLFwiZnJvbS1tdC5jb21cIjp0cnVlLFwiZnJvbS1uYy5jb21cIjp0cnVlLFwiZnJvbS1uZC5jb21cIjp0cnVlLFwiZnJvbS1uZS5jb21cIjp0cnVlLFwiZnJvbS1uaC5jb21cIjp0cnVlLFwiZnJvbS1uai5jb21cIjp0cnVlLFwiZnJvbS1ubS5jb21cIjp0cnVlLFwiZnJvbS1udi5jb21cIjp0cnVlLFwiZnJvbS1ueS5uZXRcIjp0cnVlLFwiZnJvbS1vaC5jb21cIjp0cnVlLFwiZnJvbS1vay5jb21cIjp0cnVlLFwiZnJvbS1vci5jb21cIjp0cnVlLFwiZnJvbS1wYS5jb21cIjp0cnVlLFwiZnJvbS1wci5jb21cIjp0cnVlLFwiZnJvbS1yaS5jb21cIjp0cnVlLFwiZnJvbS1zYy5jb21cIjp0cnVlLFwiZnJvbS1zZC5jb21cIjp0cnVlLFwiZnJvbS10bi5jb21cIjp0cnVlLFwiZnJvbS10eC5jb21cIjp0cnVlLFwiZnJvbS11dC5jb21cIjp0cnVlLFwiZnJvbS12YS5jb21cIjp0cnVlLFwiZnJvbS12dC5jb21cIjp0cnVlLFwiZnJvbS13YS5jb21cIjp0cnVlLFwiZnJvbS13aS5jb21cIjp0cnVlLFwiZnJvbS13di5jb21cIjp0cnVlLFwiZnJvbS13eS5jb21cIjp0cnVlLFwiZnRwYWNjZXNzLmNjXCI6dHJ1ZSxcImZ1ZXR0ZXJ0ZGFzbmV0ei5kZVwiOnRydWUsXCJnYW1lLWhvc3Qub3JnXCI6dHJ1ZSxcImdhbWUtc2VydmVyLmNjXCI6dHJ1ZSxcImdldG15aXAuY29tXCI6dHJ1ZSxcImdldHMtaXQubmV0XCI6dHJ1ZSxcImdvLmR5bmRucy5vcmdcIjp0cnVlLFwiZ290ZG5zLmNvbVwiOnRydWUsXCJnb3RkbnMub3JnXCI6dHJ1ZSxcImdyb2tzLXRoZS5pbmZvXCI6dHJ1ZSxcImdyb2tzLXRoaXMuaW5mb1wiOnRydWUsXCJoYW0tcmFkaW8tb3AubmV0XCI6dHJ1ZSxcImhlcmUtZm9yLW1vcmUuaW5mb1wiOnRydWUsXCJob2JieS1zaXRlLmNvbVwiOnRydWUsXCJob2JieS1zaXRlLm9yZ1wiOnRydWUsXCJob21lLmR5bmRucy5vcmdcIjp0cnVlLFwiaG9tZWRucy5vcmdcIjp0cnVlLFwiaG9tZWZ0cC5uZXRcIjp0cnVlLFwiaG9tZWZ0cC5vcmdcIjp0cnVlLFwiaG9tZWlwLm5ldFwiOnRydWUsXCJob21lbGludXguY29tXCI6dHJ1ZSxcImhvbWVsaW51eC5uZXRcIjp0cnVlLFwiaG9tZWxpbnV4Lm9yZ1wiOnRydWUsXCJob21ldW5peC5jb21cIjp0cnVlLFwiaG9tZXVuaXgubmV0XCI6dHJ1ZSxcImhvbWV1bml4Lm9yZ1wiOnRydWUsXCJpYW1hbGxhbWEuY29tXCI6dHJ1ZSxcImluLXRoZS1iYW5kLm5ldFwiOnRydWUsXCJpcy1hLWFuYXJjaGlzdC5jb21cIjp0cnVlLFwiaXMtYS1ibG9nZ2VyLmNvbVwiOnRydWUsXCJpcy1hLWJvb2trZWVwZXIuY29tXCI6dHJ1ZSxcImlzLWEtYnJ1aW5zZmFuLm9yZ1wiOnRydWUsXCJpcy1hLWJ1bGxzLWZhbi5jb21cIjp0cnVlLFwiaXMtYS1jYW5kaWRhdGUub3JnXCI6dHJ1ZSxcImlzLWEtY2F0ZXJlci5jb21cIjp0cnVlLFwiaXMtYS1jZWx0aWNzZmFuLm9yZ1wiOnRydWUsXCJpcy1hLWNoZWYuY29tXCI6dHJ1ZSxcImlzLWEtY2hlZi5uZXRcIjp0cnVlLFwiaXMtYS1jaGVmLm9yZ1wiOnRydWUsXCJpcy1hLWNvbnNlcnZhdGl2ZS5jb21cIjp0cnVlLFwiaXMtYS1jcGEuY29tXCI6dHJ1ZSxcImlzLWEtY3ViaWNsZS1zbGF2ZS5jb21cIjp0cnVlLFwiaXMtYS1kZW1vY3JhdC5jb21cIjp0cnVlLFwiaXMtYS1kZXNpZ25lci5jb21cIjp0cnVlLFwiaXMtYS1kb2N0b3IuY29tXCI6dHJ1ZSxcImlzLWEtZmluYW5jaWFsYWR2aXNvci5jb21cIjp0cnVlLFwiaXMtYS1nZWVrLmNvbVwiOnRydWUsXCJpcy1hLWdlZWsubmV0XCI6dHJ1ZSxcImlzLWEtZ2Vlay5vcmdcIjp0cnVlLFwiaXMtYS1ncmVlbi5jb21cIjp0cnVlLFwiaXMtYS1ndXJ1LmNvbVwiOnRydWUsXCJpcy1hLWhhcmQtd29ya2VyLmNvbVwiOnRydWUsXCJpcy1hLWh1bnRlci5jb21cIjp0cnVlLFwiaXMtYS1rbmlnaHQub3JnXCI6dHJ1ZSxcImlzLWEtbGFuZHNjYXBlci5jb21cIjp0cnVlLFwiaXMtYS1sYXd5ZXIuY29tXCI6dHJ1ZSxcImlzLWEtbGliZXJhbC5jb21cIjp0cnVlLFwiaXMtYS1saWJlcnRhcmlhbi5jb21cIjp0cnVlLFwiaXMtYS1saW51eC11c2VyLm9yZ1wiOnRydWUsXCJpcy1hLWxsYW1hLmNvbVwiOnRydWUsXCJpcy1hLW11c2ljaWFuLmNvbVwiOnRydWUsXCJpcy1hLW5hc2NhcmZhbi5jb21cIjp0cnVlLFwiaXMtYS1udXJzZS5jb21cIjp0cnVlLFwiaXMtYS1wYWludGVyLmNvbVwiOnRydWUsXCJpcy1hLXBhdHNmYW4ub3JnXCI6dHJ1ZSxcImlzLWEtcGVyc29uYWx0cmFpbmVyLmNvbVwiOnRydWUsXCJpcy1hLXBob3RvZ3JhcGhlci5jb21cIjp0cnVlLFwiaXMtYS1wbGF5ZXIuY29tXCI6dHJ1ZSxcImlzLWEtcmVwdWJsaWNhbi5jb21cIjp0cnVlLFwiaXMtYS1yb2Nrc3Rhci5jb21cIjp0cnVlLFwiaXMtYS1zb2NpYWxpc3QuY29tXCI6dHJ1ZSxcImlzLWEtc294ZmFuLm9yZ1wiOnRydWUsXCJpcy1hLXN0dWRlbnQuY29tXCI6dHJ1ZSxcImlzLWEtdGVhY2hlci5jb21cIjp0cnVlLFwiaXMtYS10ZWNoaWUuY29tXCI6dHJ1ZSxcImlzLWEtdGhlcmFwaXN0LmNvbVwiOnRydWUsXCJpcy1hbi1hY2NvdW50YW50LmNvbVwiOnRydWUsXCJpcy1hbi1hY3Rvci5jb21cIjp0cnVlLFwiaXMtYW4tYWN0cmVzcy5jb21cIjp0cnVlLFwiaXMtYW4tYW5hcmNoaXN0LmNvbVwiOnRydWUsXCJpcy1hbi1hcnRpc3QuY29tXCI6dHJ1ZSxcImlzLWFuLWVuZ2luZWVyLmNvbVwiOnRydWUsXCJpcy1hbi1lbnRlcnRhaW5lci5jb21cIjp0cnVlLFwiaXMtYnkudXNcIjp0cnVlLFwiaXMtY2VydGlmaWVkLmNvbVwiOnRydWUsXCJpcy1mb3VuZC5vcmdcIjp0cnVlLFwiaXMtZ29uZS5jb21cIjp0cnVlLFwiaXMtaW50by1hbmltZS5jb21cIjp0cnVlLFwiaXMtaW50by1jYXJzLmNvbVwiOnRydWUsXCJpcy1pbnRvLWNhcnRvb25zLmNvbVwiOnRydWUsXCJpcy1pbnRvLWdhbWVzLmNvbVwiOnRydWUsXCJpcy1sZWV0LmNvbVwiOnRydWUsXCJpcy1sb3N0Lm9yZ1wiOnRydWUsXCJpcy1ub3QtY2VydGlmaWVkLmNvbVwiOnRydWUsXCJpcy1zYXZlZC5vcmdcIjp0cnVlLFwiaXMtc2xpY2suY29tXCI6dHJ1ZSxcImlzLXViZXJsZWV0LmNvbVwiOnRydWUsXCJpcy12ZXJ5LWJhZC5vcmdcIjp0cnVlLFwiaXMtdmVyeS1ldmlsLm9yZ1wiOnRydWUsXCJpcy12ZXJ5LWdvb2Qub3JnXCI6dHJ1ZSxcImlzLXZlcnktbmljZS5vcmdcIjp0cnVlLFwiaXMtdmVyeS1zd2VldC5vcmdcIjp0cnVlLFwiaXMtd2l0aC10aGViYW5kLmNvbVwiOnRydWUsXCJpc2EtZ2Vlay5jb21cIjp0cnVlLFwiaXNhLWdlZWsubmV0XCI6dHJ1ZSxcImlzYS1nZWVrLm9yZ1wiOnRydWUsXCJpc2EtaG9ja2V5bnV0LmNvbVwiOnRydWUsXCJpc3NtYXJ0ZXJ0aGFueW91LmNvbVwiOnRydWUsXCJpc3RlaW5nZWVrLmRlXCI6dHJ1ZSxcImlzdG1laW4uZGVcIjp0cnVlLFwia2lja3MtYXNzLm5ldFwiOnRydWUsXCJraWNrcy1hc3Mub3JnXCI6dHJ1ZSxcImtub3dzaXRhbGwuaW5mb1wiOnRydWUsXCJsYW5kLTQtc2FsZS51c1wiOnRydWUsXCJsZWJ0aW1uZXR6LmRlXCI6dHJ1ZSxcImxlaXR1bmdzZW4uZGVcIjp0cnVlLFwibGlrZXMtcGllLmNvbVwiOnRydWUsXCJsaWtlc2NhbmR5LmNvbVwiOnRydWUsXCJtZXJzZWluZS5udVwiOnRydWUsXCJtaW5lLm51XCI6dHJ1ZSxcIm1pc2NvbmZ1c2VkLm9yZ1wiOnRydWUsXCJteXBldHMud3NcIjp0cnVlLFwibXlwaG90b3MuY2NcIjp0cnVlLFwibmVhdC11cmwuY29tXCI6dHJ1ZSxcIm9mZmljZS1vbi10aGUubmV0XCI6dHJ1ZSxcIm9uLXRoZS13ZWIudHZcIjp0cnVlLFwicG9kem9uZS5uZXRcIjp0cnVlLFwicG9kem9uZS5vcmdcIjp0cnVlLFwicmVhZG15YmxvZy5vcmdcIjp0cnVlLFwic2F2ZXMtdGhlLXdoYWxlcy5jb21cIjp0cnVlLFwic2NyYXBwZXItc2l0ZS5uZXRcIjp0cnVlLFwic2NyYXBwaW5nLmNjXCI6dHJ1ZSxcInNlbGZpcC5iaXpcIjp0cnVlLFwic2VsZmlwLmNvbVwiOnRydWUsXCJzZWxmaXAuaW5mb1wiOnRydWUsXCJzZWxmaXAubmV0XCI6dHJ1ZSxcInNlbGZpcC5vcmdcIjp0cnVlLFwic2VsbHMtZm9yLWxlc3MuY29tXCI6dHJ1ZSxcInNlbGxzLWZvci11LmNvbVwiOnRydWUsXCJzZWxscy1pdC5uZXRcIjp0cnVlLFwic2VsbHN5b3VyaG9tZS5vcmdcIjp0cnVlLFwic2VydmViYnMuY29tXCI6dHJ1ZSxcInNlcnZlYmJzLm5ldFwiOnRydWUsXCJzZXJ2ZWJicy5vcmdcIjp0cnVlLFwic2VydmVmdHAubmV0XCI6dHJ1ZSxcInNlcnZlZnRwLm9yZ1wiOnRydWUsXCJzZXJ2ZWdhbWUub3JnXCI6dHJ1ZSxcInNoYWNrbmV0Lm51XCI6dHJ1ZSxcInNpbXBsZS11cmwuY29tXCI6dHJ1ZSxcInNwYWNlLXRvLXJlbnQuY29tXCI6dHJ1ZSxcInN0dWZmLTQtc2FsZS5vcmdcIjp0cnVlLFwic3R1ZmYtNC1zYWxlLnVzXCI6dHJ1ZSxcInRlYWNoZXMteW9nYS5jb21cIjp0cnVlLFwidGhydWhlcmUubmV0XCI6dHJ1ZSxcInRyYWV1bXRnZXJhZGUuZGVcIjp0cnVlLFwid2ViaG9wLmJpelwiOnRydWUsXCJ3ZWJob3AuaW5mb1wiOnRydWUsXCJ3ZWJob3AubmV0XCI6dHJ1ZSxcIndlYmhvcC5vcmdcIjp0cnVlLFwid29yc2UtdGhhbi50dlwiOnRydWUsXCJ3cml0ZXN0aGlzYmxvZy5jb21cIjp0cnVlLFwiZXUub3JnXCI6dHJ1ZSxcImFsLmV1Lm9yZ1wiOnRydWUsXCJhc3NvLmV1Lm9yZ1wiOnRydWUsXCJhdC5ldS5vcmdcIjp0cnVlLFwiYXUuZXUub3JnXCI6dHJ1ZSxcImJlLmV1Lm9yZ1wiOnRydWUsXCJiZy5ldS5vcmdcIjp0cnVlLFwiY2EuZXUub3JnXCI6dHJ1ZSxcImNkLmV1Lm9yZ1wiOnRydWUsXCJjaC5ldS5vcmdcIjp0cnVlLFwiY24uZXUub3JnXCI6dHJ1ZSxcImN5LmV1Lm9yZ1wiOnRydWUsXCJjei5ldS5vcmdcIjp0cnVlLFwiZGUuZXUub3JnXCI6dHJ1ZSxcImRrLmV1Lm9yZ1wiOnRydWUsXCJlZHUuZXUub3JnXCI6dHJ1ZSxcImVlLmV1Lm9yZ1wiOnRydWUsXCJlcy5ldS5vcmdcIjp0cnVlLFwiZmkuZXUub3JnXCI6dHJ1ZSxcImZyLmV1Lm9yZ1wiOnRydWUsXCJnci5ldS5vcmdcIjp0cnVlLFwiaHIuZXUub3JnXCI6dHJ1ZSxcImh1LmV1Lm9yZ1wiOnRydWUsXCJpZS5ldS5vcmdcIjp0cnVlLFwiaWwuZXUub3JnXCI6dHJ1ZSxcImluLmV1Lm9yZ1wiOnRydWUsXCJpbnQuZXUub3JnXCI6dHJ1ZSxcImlzLmV1Lm9yZ1wiOnRydWUsXCJpdC5ldS5vcmdcIjp0cnVlLFwianAuZXUub3JnXCI6dHJ1ZSxcImtyLmV1Lm9yZ1wiOnRydWUsXCJsdC5ldS5vcmdcIjp0cnVlLFwibHUuZXUub3JnXCI6dHJ1ZSxcImx2LmV1Lm9yZ1wiOnRydWUsXCJtYy5ldS5vcmdcIjp0cnVlLFwibWUuZXUub3JnXCI6dHJ1ZSxcIm1rLmV1Lm9yZ1wiOnRydWUsXCJtdC5ldS5vcmdcIjp0cnVlLFwibXkuZXUub3JnXCI6dHJ1ZSxcIm5ldC5ldS5vcmdcIjp0cnVlLFwibmcuZXUub3JnXCI6dHJ1ZSxcIm5sLmV1Lm9yZ1wiOnRydWUsXCJuby5ldS5vcmdcIjp0cnVlLFwibnouZXUub3JnXCI6dHJ1ZSxcInBhcmlzLmV1Lm9yZ1wiOnRydWUsXCJwbC5ldS5vcmdcIjp0cnVlLFwicHQuZXUub3JnXCI6dHJ1ZSxcInEtYS5ldS5vcmdcIjp0cnVlLFwicm8uZXUub3JnXCI6dHJ1ZSxcInJ1LmV1Lm9yZ1wiOnRydWUsXCJzZS5ldS5vcmdcIjp0cnVlLFwic2kuZXUub3JnXCI6dHJ1ZSxcInNrLmV1Lm9yZ1wiOnRydWUsXCJ0ci5ldS5vcmdcIjp0cnVlLFwidWsuZXUub3JnXCI6dHJ1ZSxcInVzLmV1Lm9yZ1wiOnRydWUsXCJhLnNzbC5mYXN0bHkubmV0XCI6dHJ1ZSxcImIuc3NsLmZhc3RseS5uZXRcIjp0cnVlLFwiZ2xvYmFsLnNzbC5mYXN0bHkubmV0XCI6dHJ1ZSxcImEucHJvZC5mYXN0bHkubmV0XCI6dHJ1ZSxcImdsb2JhbC5wcm9kLmZhc3RseS5uZXRcIjp0cnVlLFwiZmlyZWJhc2VhcHAuY29tXCI6dHJ1ZSxcImZseW5uaHViLmNvbVwiOnRydWUsXCJzZXJ2aWNlLmdvdi51a1wiOnRydWUsXCJnaXRodWIuaW9cIjp0cnVlLFwiZ2l0aHVidXNlcmNvbnRlbnQuY29tXCI6dHJ1ZSxcInJvLmNvbVwiOnRydWUsXCJhcHBzcG90LmNvbVwiOnRydWUsXCJibG9nc3BvdC5hZVwiOnRydWUsXCJibG9nc3BvdC5hbFwiOnRydWUsXCJibG9nc3BvdC5hbVwiOnRydWUsXCJibG9nc3BvdC5iYVwiOnRydWUsXCJibG9nc3BvdC5iZVwiOnRydWUsXCJibG9nc3BvdC5iZ1wiOnRydWUsXCJibG9nc3BvdC5ialwiOnRydWUsXCJibG9nc3BvdC5jYVwiOnRydWUsXCJibG9nc3BvdC5jZlwiOnRydWUsXCJibG9nc3BvdC5jaFwiOnRydWUsXCJibG9nc3BvdC5jbFwiOnRydWUsXCJibG9nc3BvdC5jby5hdFwiOnRydWUsXCJibG9nc3BvdC5jby5pZFwiOnRydWUsXCJibG9nc3BvdC5jby5pbFwiOnRydWUsXCJibG9nc3BvdC5jby5rZVwiOnRydWUsXCJibG9nc3BvdC5jby5uelwiOnRydWUsXCJibG9nc3BvdC5jby51a1wiOnRydWUsXCJibG9nc3BvdC5jby56YVwiOnRydWUsXCJibG9nc3BvdC5jb21cIjp0cnVlLFwiYmxvZ3Nwb3QuY29tLmFyXCI6dHJ1ZSxcImJsb2dzcG90LmNvbS5hdVwiOnRydWUsXCJibG9nc3BvdC5jb20uYnJcIjp0cnVlLFwiYmxvZ3Nwb3QuY29tLmJ5XCI6dHJ1ZSxcImJsb2dzcG90LmNvbS5jb1wiOnRydWUsXCJibG9nc3BvdC5jb20uY3lcIjp0cnVlLFwiYmxvZ3Nwb3QuY29tLmVlXCI6dHJ1ZSxcImJsb2dzcG90LmNvbS5lZ1wiOnRydWUsXCJibG9nc3BvdC5jb20uZXNcIjp0cnVlLFwiYmxvZ3Nwb3QuY29tLm10XCI6dHJ1ZSxcImJsb2dzcG90LmNvbS5uZ1wiOnRydWUsXCJibG9nc3BvdC5jb20udHJcIjp0cnVlLFwiYmxvZ3Nwb3QuY29tLnV5XCI6dHJ1ZSxcImJsb2dzcG90LmN2XCI6dHJ1ZSxcImJsb2dzcG90LmN6XCI6dHJ1ZSxcImJsb2dzcG90LmRlXCI6dHJ1ZSxcImJsb2dzcG90LmRrXCI6dHJ1ZSxcImJsb2dzcG90LmZpXCI6dHJ1ZSxcImJsb2dzcG90LmZyXCI6dHJ1ZSxcImJsb2dzcG90LmdyXCI6dHJ1ZSxcImJsb2dzcG90LmhrXCI6dHJ1ZSxcImJsb2dzcG90LmhyXCI6dHJ1ZSxcImJsb2dzcG90Lmh1XCI6dHJ1ZSxcImJsb2dzcG90LmllXCI6dHJ1ZSxcImJsb2dzcG90LmluXCI6dHJ1ZSxcImJsb2dzcG90LmlzXCI6dHJ1ZSxcImJsb2dzcG90Lml0XCI6dHJ1ZSxcImJsb2dzcG90LmpwXCI6dHJ1ZSxcImJsb2dzcG90LmtyXCI6dHJ1ZSxcImJsb2dzcG90LmxpXCI6dHJ1ZSxcImJsb2dzcG90Lmx0XCI6dHJ1ZSxcImJsb2dzcG90Lmx1XCI6dHJ1ZSxcImJsb2dzcG90Lm1kXCI6dHJ1ZSxcImJsb2dzcG90Lm1rXCI6dHJ1ZSxcImJsb2dzcG90Lm1yXCI6dHJ1ZSxcImJsb2dzcG90Lm14XCI6dHJ1ZSxcImJsb2dzcG90Lm15XCI6dHJ1ZSxcImJsb2dzcG90Lm5sXCI6dHJ1ZSxcImJsb2dzcG90Lm5vXCI6dHJ1ZSxcImJsb2dzcG90LnBlXCI6dHJ1ZSxcImJsb2dzcG90LnB0XCI6dHJ1ZSxcImJsb2dzcG90LnFhXCI6dHJ1ZSxcImJsb2dzcG90LnJlXCI6dHJ1ZSxcImJsb2dzcG90LnJvXCI6dHJ1ZSxcImJsb2dzcG90LnJzXCI6dHJ1ZSxcImJsb2dzcG90LnJ1XCI6dHJ1ZSxcImJsb2dzcG90LnNlXCI6dHJ1ZSxcImJsb2dzcG90LnNnXCI6dHJ1ZSxcImJsb2dzcG90LnNpXCI6dHJ1ZSxcImJsb2dzcG90LnNrXCI6dHJ1ZSxcImJsb2dzcG90LnNuXCI6dHJ1ZSxcImJsb2dzcG90LnRkXCI6dHJ1ZSxcImJsb2dzcG90LnR3XCI6dHJ1ZSxcImJsb2dzcG90LnVnXCI6dHJ1ZSxcImJsb2dzcG90LnZuXCI6dHJ1ZSxcImNvZGVzcG90LmNvbVwiOnRydWUsXCJnb29nbGVhcGlzLmNvbVwiOnRydWUsXCJnb29nbGVjb2RlLmNvbVwiOnRydWUsXCJwYWdlc3BlZWRtb2JpbGl6ZXIuY29tXCI6dHJ1ZSxcIndpdGhnb29nbGUuY29tXCI6dHJ1ZSxcIndpdGh5b3V0dWJlLmNvbVwiOnRydWUsXCJoZXJva3VhcHAuY29tXCI6dHJ1ZSxcImhlcm9rdXNzbC5jb21cIjp0cnVlLFwiaWtpLmZpXCI6dHJ1ZSxcImJpei5hdFwiOnRydWUsXCJpbmZvLmF0XCI6dHJ1ZSxcImNvLnBsXCI6dHJ1ZSxcImF6dXJld2Vic2l0ZXMubmV0XCI6dHJ1ZSxcImF6dXJlLW1vYmlsZS5uZXRcIjp0cnVlLFwiY2xvdWRhcHAubmV0XCI6dHJ1ZSxcImJtb2F0dGFjaG1lbnRzLm9yZ1wiOnRydWUsXCI0dS5jb21cIjp0cnVlLFwibmZzaG9zdC5jb21cIjp0cnVlLFwibnljLm1uXCI6dHJ1ZSxcIm5pZC5pb1wiOnRydWUsXCJvcGVyYXVuaXRlLmNvbVwiOnRydWUsXCJvdXRzeXN0ZW1zY2xvdWQuY29tXCI6dHJ1ZSxcImFydC5wbFwiOnRydWUsXCJnbGl3aWNlLnBsXCI6dHJ1ZSxcImtyYWtvdy5wbFwiOnRydWUsXCJwb3puYW4ucGxcIjp0cnVlLFwid3JvYy5wbFwiOnRydWUsXCJ6YWtvcGFuZS5wbFwiOnRydWUsXCJwYW50aGVvbi5pb1wiOnRydWUsXCJnb3RwYW50aGVvbi5jb21cIjp0cnVlLFwicHJpdi5hdFwiOnRydWUsXCJxYTIuY29tXCI6dHJ1ZSxcInJoY2xvdWQuY29tXCI6dHJ1ZSxcInNhbmRjYXRzLmlvXCI6dHJ1ZSxcImJpei51YVwiOnRydWUsXCJjby51YVwiOnRydWUsXCJwcC51YVwiOnRydWUsXCJzaW5hYXBwLmNvbVwiOnRydWUsXCJ2aXBzaW5hYXBwLmNvbVwiOnRydWUsXCIxa2FwcC5jb21cIjp0cnVlLFwiZ2RhLnBsXCI6dHJ1ZSxcImdkYW5zay5wbFwiOnRydWUsXCJnZHluaWEucGxcIjp0cnVlLFwibWVkLnBsXCI6dHJ1ZSxcInNvcG90LnBsXCI6dHJ1ZSxcImhrLmNvbVwiOnRydWUsXCJoay5vcmdcIjp0cnVlLFwibHRkLmhrXCI6dHJ1ZSxcImluYy5oa1wiOnRydWUsXCJ5b2xhc2l0ZS5jb21cIjp0cnVlLFwiemEubmV0XCI6dHJ1ZSxcInphLm9yZ1wiOnRydWV9KTtcblxuLy8gRU5EIG9mIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZpbGVcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90b3VnaC1jb29raWUvbGliL3B1YnN1ZmZpeC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3B1bnljb2RlL3B1bnljb2RlLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuLypqc2hpbnQgdW51c2VkOmZhbHNlICovXG5cbmZ1bmN0aW9uIFN0b3JlKCkge1xufVxuZXhwb3J0cy5TdG9yZSA9IFN0b3JlO1xuXG4vLyBTdG9yZXMgbWF5IGJlIHN5bmNocm9ub3VzLCBidXQgYXJlIHN0aWxsIHJlcXVpcmVkIHRvIHVzZSBhXG4vLyBDb250aW51YXRpb24tUGFzc2luZyBTdHlsZSBBUEkuICBUaGUgQ29va2llSmFyIGl0c2VsZiB3aWxsIGV4cG9zZSBhIFwiKlN5bmNcIlxuLy8gQVBJIHRoYXQgY29udmVydHMgZnJvbSBzeW5jaHJvbm91cy1jYWxsYmFja3MgdG8gaW1wZXJhdGl2ZSBzdHlsZS5cblN0b3JlLnByb3RvdHlwZS5zeW5jaHJvbm91cyA9IGZhbHNlO1xuXG5TdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZSA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwga2V5LCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmRDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignZmluZENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucHV0Q29va2llID0gZnVuY3Rpb24oY29va2llLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3B1dENvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51cGRhdGVDb29raWUgPSBmdW5jdGlvbihvbGRDb29raWUsIG5ld0Nvb2tpZSwgY2IpIHtcbiAgLy8gcmVjb21tZW5kZWQgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbjpcbiAgLy8gcmV0dXJuIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSwgY2IpO1xuICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUNvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZW1vdmVDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVtb3ZlQ29va2llcyA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmdldEFsbENvb2tpZXMgPSBmdW5jdGlvbihjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2dldEFsbENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkICh0aGVyZWZvcmUgamFyIGNhbm5vdCBiZSBzZXJpYWxpemVkKScpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90b3VnaC1jb29raWUvbGliL3N0b3JlLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpLlN0b3JlO1xudmFyIHBlcm11dGVEb21haW4gPSByZXF1aXJlKCcuL3Blcm11dGVEb21haW4nKS5wZXJtdXRlRG9tYWluO1xudmFyIHBhdGhNYXRjaCA9IHJlcXVpcmUoJy4vcGF0aE1hdGNoJykucGF0aE1hdGNoO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIE1lbW9yeUNvb2tpZVN0b3JlKCkge1xuICBTdG9yZS5jYWxsKHRoaXMpO1xuICB0aGlzLmlkeCA9IHt9O1xufVxudXRpbC5pbmhlcml0cyhNZW1vcnlDb29raWVTdG9yZSwgU3RvcmUpO1xuZXhwb3J0cy5NZW1vcnlDb29raWVTdG9yZSA9IE1lbW9yeUNvb2tpZVN0b3JlO1xuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLmlkeCA9IG51bGw7XG5cbi8vIFNpbmNlIGl0J3MganVzdCBhIHN0cnVjdCBpbiBSQU0sIHRoaXMgU3RvcmUgaXMgc3luY2hyb25vdXNcbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5zeW5jaHJvbm91cyA9IHRydWU7XG5cbi8vIGZvcmNlIGEgZGVmYXVsdCBkZXB0aDpcbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcInsgaWR4OiBcIit1dGlsLmluc3BlY3QodGhpcy5pZHgsIGZhbHNlLCAyKSsnIH0nO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLmZpbmRDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgaWYgKCF0aGlzLmlkeFtkb21haW5dKSB7XG4gICAgcmV0dXJuIGNiKG51bGwsdW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoIXRoaXMuaWR4W2RvbWFpbl1bcGF0aF0pIHtcbiAgICByZXR1cm4gY2IobnVsbCx1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiBjYihudWxsLHRoaXMuaWR4W2RvbWFpbl1bcGF0aF1ba2V5XXx8bnVsbCk7XG59O1xuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIGlmICghZG9tYWluKSB7XG4gICAgcmV0dXJuIGNiKG51bGwsW10pO1xuICB9XG5cbiAgdmFyIHBhdGhNYXRjaGVyO1xuICBpZiAoIXBhdGgpIHtcbiAgICAvLyBudWxsIG1lYW5zIFwiYWxsIHBhdGhzXCJcbiAgICBwYXRoTWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoQWxsKGRvbWFpbkluZGV4KSB7XG4gICAgICBmb3IgKHZhciBjdXJQYXRoIGluIGRvbWFpbkluZGV4KSB7XG4gICAgICAgIHZhciBwYXRoSW5kZXggPSBkb21haW5JbmRleFtjdXJQYXRoXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhdGhJbmRleCkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChwYXRoSW5kZXhba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIH0gZWxzZSB7XG4gICAgcGF0aE1hdGNoZXIgPSBmdW5jdGlvbiBtYXRjaFJGQyhkb21haW5JbmRleCkge1xuICAgICAgIC8vTk9URTogd2Ugc2hvdWxkIHVzZSBwYXRoLW1hdGNoIGFsZ29yaXRobSBmcm9tIFM1LjEuNCBoZXJlXG4gICAgICAgLy8oc2VlIDogaHR0cHM6Ly9naXRodWIuY29tL0Nocm9taXVtV2ViQXBwcy9jaHJvbWl1bS9ibG9iL2IzZDNiNGRhOGJiOTRjMWIyZTA2MTYwMGRmMTA2ZDU5MGZkYTM2MjAvbmV0L2Nvb2tpZXMvY2Fub25pY2FsX2Nvb2tpZS5jYyNMMjk5KVxuICAgICAgIE9iamVjdC5rZXlzKGRvbWFpbkluZGV4KS5mb3JFYWNoKGZ1bmN0aW9uIChjb29raWVQYXRoKSB7XG4gICAgICAgICBpZiAocGF0aE1hdGNoKHBhdGgsIGNvb2tpZVBhdGgpKSB7XG4gICAgICAgICAgIHZhciBwYXRoSW5kZXggPSBkb21haW5JbmRleFtjb29raWVQYXRoXTtcblxuICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhdGhJbmRleFtrZXldKTtcbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH0pO1xuICAgICB9O1xuICB9XG5cbiAgdmFyIGRvbWFpbnMgPSBwZXJtdXRlRG9tYWluKGRvbWFpbikgfHwgW2RvbWFpbl07XG4gIHZhciBpZHggPSB0aGlzLmlkeDtcbiAgZG9tYWlucy5mb3JFYWNoKGZ1bmN0aW9uKGN1ckRvbWFpbikge1xuICAgIHZhciBkb21haW5JbmRleCA9IGlkeFtjdXJEb21haW5dO1xuICAgIGlmICghZG9tYWluSW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGF0aE1hdGNoZXIoZG9tYWluSW5kZXgpO1xuICB9KTtcblxuICBjYihudWxsLHJlc3VsdHMpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnB1dENvb2tpZSA9IGZ1bmN0aW9uKGNvb2tpZSwgY2IpIHtcbiAgaWYgKCF0aGlzLmlkeFtjb29raWUuZG9tYWluXSkge1xuICAgIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dID0ge307XG4gIH1cbiAgaWYgKCF0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF0pIHtcbiAgICB0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF0gPSB7fTtcbiAgfVxuICB0aGlzLmlkeFtjb29raWUuZG9tYWluXVtjb29raWUucGF0aF1bY29va2llLmtleV0gPSBjb29raWU7XG4gIGNiKG51bGwpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnVwZGF0ZUNvb2tpZSA9IGZ1bmN0aW9uKG9sZENvb2tpZSwgbmV3Q29va2llLCBjYikge1xuICAvLyB1cGRhdGVDb29raWUoKSBtYXkgYXZvaWQgdXBkYXRpbmcgY29va2llcyB0aGF0IGFyZSBpZGVudGljYWwuICBGb3IgZXhhbXBsZSxcbiAgLy8gbGFzdEFjY2Vzc2VkIG1heSBub3QgYmUgaW1wb3J0YW50IHRvIHNvbWUgc3RvcmVzIGFuZCBhbiBlcXVhbGl0eVxuICAvLyBjb21wYXJpc29uIGNvdWxkIGV4Y2x1ZGUgdGhhdCBmaWVsZC5cbiAgdGhpcy5wdXRDb29raWUobmV3Q29va2llLGNiKTtcbn07XG5cbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5yZW1vdmVDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgaWYgKHRoaXMuaWR4W2RvbWFpbl0gJiYgdGhpcy5pZHhbZG9tYWluXVtwYXRoXSAmJiB0aGlzLmlkeFtkb21haW5dW3BhdGhdW2tleV0pIHtcbiAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXVtwYXRoXVtrZXldO1xuICB9XG4gIGNiKG51bGwpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnJlbW92ZUNvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIGlmICh0aGlzLmlkeFtkb21haW5dKSB7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5pZHhbZG9tYWluXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNiKG51bGwpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLmdldEFsbENvb2tpZXMgPSBmdW5jdGlvbihjYikge1xuICB2YXIgY29va2llcyA9IFtdO1xuICB2YXIgaWR4ID0gdGhpcy5pZHg7XG5cbiAgdmFyIGRvbWFpbnMgPSBPYmplY3Qua2V5cyhpZHgpO1xuICBkb21haW5zLmZvckVhY2goZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgdmFyIHBhdGhzID0gT2JqZWN0LmtleXMoaWR4W2RvbWFpbl0pO1xuICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpZHhbZG9tYWluXVtwYXRoXSk7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb29raWVzLnB1c2goaWR4W2RvbWFpbl1bcGF0aF1ba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBTb3J0IGJ5IGNyZWF0aW9uSW5kZXggc28gZGVzZXJpYWxpemluZyByZXRhaW5zIHRoZSBjcmVhdGlvbiBvcmRlci5cbiAgLy8gV2hlbiBpbXBsZW1lbnRpbmcgeW91ciBvd24gc3RvcmUsIHRoaXMgU0hPVUxEIHJldGFpbiB0aGUgb3JkZXIgdG9vXG4gIGNvb2tpZXMuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICByZXR1cm4gKGEuY3JlYXRpb25JbmRleHx8MCkgLSAoYi5jcmVhdGlvbkluZGV4fHwwKTtcbiAgfSk7XG5cbiAgY2IobnVsbCwgY29va2llcyk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RvdWdoLWNvb2tpZS9saWIvbWVtc3RvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIFNhbGVzZm9yY2UuY29tLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIFNhbGVzZm9yY2UuY29tIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbiAqIGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbnZhciBwdWJzdWZmaXggPSByZXF1aXJlKCcuL3B1YnN1ZmZpeCcpO1xuXG4vLyBHaXZlcyB0aGUgcGVybXV0YXRpb24gb2YgYWxsIHBvc3NpYmxlIGRvbWFpbk1hdGNoKCllcyBvZiBhIGdpdmVuIGRvbWFpbi4gVGhlXG4vLyBhcnJheSBpcyBpbiBzaG9ydGVzdC10by1sb25nZXN0IG9yZGVyLiAgSGFuZHkgZm9yIGluZGV4aW5nLlxuZnVuY3Rpb24gcGVybXV0ZURvbWFpbiAoZG9tYWluKSB7XG4gIHZhciBwdWJTdWYgPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4KGRvbWFpbik7XG4gIGlmICghcHViU3VmKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHB1YlN1ZiA9PSBkb21haW4pIHtcbiAgICByZXR1cm4gW2RvbWFpbl07XG4gIH1cblxuICB2YXIgcHJlZml4ID0gZG9tYWluLnNsaWNlKDAsIC0ocHViU3VmLmxlbmd0aCArIDEpKTsgLy8gXCIuZXhhbXBsZS5jb21cIlxuICB2YXIgcGFydHMgPSBwcmVmaXguc3BsaXQoJy4nKS5yZXZlcnNlKCk7XG4gIHZhciBjdXIgPSBwdWJTdWY7XG4gIHZhciBwZXJtdXRhdGlvbnMgPSBbY3VyXTtcbiAgd2hpbGUgKHBhcnRzLmxlbmd0aCkge1xuICAgIGN1ciA9IHBhcnRzLnNoaWZ0KCkgKyAnLicgKyBjdXI7XG4gICAgcGVybXV0YXRpb25zLnB1c2goY3VyKTtcbiAgfVxuICByZXR1cm4gcGVybXV0YXRpb25zO1xufVxuXG5leHBvcnRzLnBlcm11dGVEb21haW4gPSBwZXJtdXRlRG9tYWluO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RvdWdoLWNvb2tpZS9saWIvcGVybXV0ZURvbWFpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuLypcbiAqIFwiQSByZXF1ZXN0LXBhdGggcGF0aC1tYXRjaGVzIGEgZ2l2ZW4gY29va2llLXBhdGggaWYgYXQgbGVhc3Qgb25lIG9mIHRoZVxuICogZm9sbG93aW5nIGNvbmRpdGlvbnMgaG9sZHM6XCJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoIChyZXFQYXRoLCBjb29raWVQYXRoKSB7XG4gIC8vIFwibyAgVGhlIGNvb2tpZS1wYXRoIGFuZCB0aGUgcmVxdWVzdC1wYXRoIGFyZSBpZGVudGljYWwuXCJcbiAgaWYgKGNvb2tpZVBhdGggPT09IHJlcVBhdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpZHggPSByZXFQYXRoLmluZGV4T2YoY29va2llUGF0aCk7XG4gIGlmIChpZHggPT09IDApIHtcbiAgICAvLyBcIm8gIFRoZSBjb29raWUtcGF0aCBpcyBhIHByZWZpeCBvZiB0aGUgcmVxdWVzdC1wYXRoLCBhbmQgdGhlIGxhc3RcbiAgICAvLyBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cIlxuICAgIGlmIChjb29raWVQYXRoLnN1YnN0cigtMSkgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBcIiBvICBUaGUgY29va2llLXBhdGggaXMgYSBwcmVmaXggb2YgdGhlIHJlcXVlc3QtcGF0aCwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIGNoYXJhY3RlciBvZiB0aGUgcmVxdWVzdC1wYXRoIHRoYXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBjb29raWUtIHBhdGhcbiAgICAvLyBpcyBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIuXCJcbiAgICBpZiAocmVxUGF0aC5zdWJzdHIoY29va2llUGF0aC5sZW5ndGgsIDEpID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLnBhdGhNYXRjaCA9IHBhdGhNYXRjaDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90b3VnaC1jb29raWUvbGliL3BhdGhNYXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdXRpbC91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIl9hcmdzXCI6IFtcblx0XHRbXG5cdFx0XHRcInRvdWdoLWNvb2tpZUA+PTAuMTIuMFwiLFxuXHRcdFx0XCJEOlxcXFxEQVBJU0RLXFxcXG5vZGVfbW9kdWxlc1xcXFxyZXF1ZXN0XCJcblx0XHRdXG5cdF0sXG5cdFwiX2Zyb21cIjogXCJ0b3VnaC1jb29raWVAPj0wLjEyLjBcIixcblx0XCJfaWRcIjogXCJ0b3VnaC1jb29raWVAMi4yLjJcIixcblx0XCJfaW5DYWNoZVwiOiB0cnVlLFxuXHRcIl9pbnN0YWxsYWJsZVwiOiB0cnVlLFxuXHRcIl9sb2NhdGlvblwiOiBcIi90b3VnaC1jb29raWVcIixcblx0XCJfbm9kZVZlcnNpb25cIjogXCI1LjEuMVwiLFxuXHRcIl9ucG1PcGVyYXRpb25hbEludGVybmFsXCI6IHtcblx0XHRcImhvc3RcIjogXCJwYWNrYWdlcy0xMy13ZXN0LmludGVybmFsLm5wbWpzLmNvbVwiLFxuXHRcdFwidG1wXCI6IFwidG1wL3RvdWdoLWNvb2tpZS0yLjIuMi50Z3pfMTQ1NzU2NDYzOTE4Ml8wLjUxMjkxODg2ODU2Nzc5NDZcIlxuXHR9LFxuXHRcIl9ucG1Vc2VyXCI6IHtcblx0XHRcImVtYWlsXCI6IFwianN0YXNoQGdtYWlsLmNvbVwiLFxuXHRcdFwibmFtZVwiOiBcImpzdGFzaFwiXG5cdH0sXG5cdFwiX25wbVZlcnNpb25cIjogXCIzLjMuMTJcIixcblx0XCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuXHRcIl9yZXF1ZXN0ZWRcIjoge1xuXHRcdFwibmFtZVwiOiBcInRvdWdoLWNvb2tpZVwiLFxuXHRcdFwicmF3XCI6IFwidG91Z2gtY29va2llQD49MC4xMi4wXCIsXG5cdFx0XCJyYXdTcGVjXCI6IFwiPj0wLjEyLjBcIixcblx0XHRcInNjb3BlXCI6IG51bGwsXG5cdFx0XCJzcGVjXCI6IFwiPj0wLjEyLjBcIixcblx0XHRcInR5cGVcIjogXCJyYW5nZVwiXG5cdH0sXG5cdFwiX3JlcXVpcmVkQnlcIjogW1xuXHRcdFwiL3JlcXVlc3RcIlxuXHRdLFxuXHRcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3RvdWdoLWNvb2tpZS8tL3RvdWdoLWNvb2tpZS0yLjIuMi50Z3pcIixcblx0XCJfc2hhc3VtXCI6IFwiYzgzYTE4MzBmNGU1ZWYwYjkzZWYyYTM0ODhlNzI0ZjhkZTAxNmFjN1wiLFxuXHRcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG5cdFwiX3NwZWNcIjogXCJ0b3VnaC1jb29raWVAPj0wLjEyLjBcIixcblx0XCJfd2hlcmVcIjogXCJEOlxcXFxEQVBJU0RLXFxcXG5vZGVfbW9kdWxlc1xcXFxyZXF1ZXN0XCIsXG5cdFwiYXV0aG9yXCI6IHtcblx0XHRcImVtYWlsXCI6IFwianN0YXNoZXdza3lAc2FsZXNmb3JjZS5jb21cIixcblx0XHRcIm5hbWVcIjogXCJKZXJlbXkgU3Rhc2hld3NreVwiXG5cdH0sXG5cdFwiYnVnc1wiOiB7XG5cdFx0XCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vU2FsZXNmb3JjZUVuZy90b3VnaC1jb29raWUvaXNzdWVzXCJcblx0fSxcblx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdHtcblx0XHRcdFwibmFtZVwiOiBcIkFsZXhhbmRlciBTYXZpblwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIm5hbWVcIjogXCJJYW4gTGl2aW5nc3RvbmVcIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiSXZhbiBOaWt1bGluXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwibmFtZVwiOiBcIkxhbGl0IEthcG9vclwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIm5hbWVcIjogXCJTYW0gVGhvbXBzb25cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiU2ViYXN0aWFuIE1heXJcIlxuXHRcdH1cblx0XSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge30sXG5cdFwiZGVzY3JpcHRpb25cIjogXCJSRkM2MjY1IENvb2tpZXMgYW5kIENvb2tpZSBKYXIgZm9yIG5vZGUuanNcIixcblx0XCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiYXN5bmNcIjogXCJeMS40LjJcIixcblx0XHRcInZvd3NcIjogXCJeMC44LjFcIlxuXHR9LFxuXHRcImRpcmVjdG9yaWVzXCI6IHt9LFxuXHRcImRpc3RcIjoge1xuXHRcdFwic2hhc3VtXCI6IFwiYzgzYTE4MzBmNGU1ZWYwYjkzZWYyYTM0ODhlNzI0ZjhkZTAxNmFjN1wiLFxuXHRcdFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3RvdWdoLWNvb2tpZS8tL3RvdWdoLWNvb2tpZS0yLjIuMi50Z3pcIlxuXHR9LFxuXHRcImVuZ2luZXNcIjoge1xuXHRcdFwibm9kZVwiOiBcIj49MC4xMC4wXCJcblx0fSxcblx0XCJmaWxlc1wiOiBbXG5cdFx0XCJsaWJcIlxuXHRdLFxuXHRcImdpdEhlYWRcIjogXCJjYzQ2NjI4YzRkN2QyZThjMzcyZWNiYTI5MjkzY2E4YTIwN2VjMTkyXCIsXG5cdFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vU2FsZXNmb3JjZUVuZy90b3VnaC1jb29raWVcIixcblx0XCJrZXl3b3Jkc1wiOiBbXG5cdFx0XCJIVFRQXCIsXG5cdFx0XCJjb29raWVcIixcblx0XHRcImNvb2tpZXNcIixcblx0XHRcInNldC1jb29raWVcIixcblx0XHRcImNvb2tpZWphclwiLFxuXHRcdFwiamFyXCIsXG5cdFx0XCJSRkM2MjY1XCIsXG5cdFx0XCJSRkMyOTY1XCJcblx0XSxcblx0XCJsaWNlbnNlXCI6IFwiQlNELTMtQ2xhdXNlXCIsXG5cdFwibWFpblwiOiBcIi4vbGliL2Nvb2tpZVwiLFxuXHRcIm1haW50YWluZXJzXCI6IFtcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwiamVyZW15QGdvaW5zdGFudC5jb21cIixcblx0XHRcdFwibmFtZVwiOiBcImpzdGFzaFwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcImVtYWlsXCI6IFwic2VydmljZXNAZ29pbnN0YW50LmNvbVwiLFxuXHRcdFx0XCJuYW1lXCI6IFwiZ29pbnN0YW50XCJcblx0XHR9XG5cdF0sXG5cdFwibmFtZVwiOiBcInRvdWdoLWNvb2tpZVwiLFxuXHRcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuXHRcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vU2FsZXNmb3JjZUVuZy90b3VnaC1jb29raWUuZ2l0XCJcblx0fSxcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcInN1ZmZpeHVwXCI6IFwiY3VybCAtbyBwdWJsaWNfc3VmZml4X2xpc3QuZGF0IGh0dHBzOi8vcHVibGljc3VmZml4Lm9yZy9saXN0L3B1YmxpY19zdWZmaXhfbGlzdC5kYXQgJiYgLi9nZW5lcmF0ZS1wdWJzdWZmaXguanNcIixcblx0XHRcInRlc3RcIjogXCJ2b3dzIHRlc3QvKl90ZXN0LmpzXCJcblx0fSxcblx0XCJ2ZXJzaW9uXCI6IFwiMi4yLjJcIlxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdG91Z2gtY29va2llL3BhY2thZ2UuanNvblxuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIGpzb25TYWZlU3RyaW5naWZ5ID0gcmVxdWlyZSgnanNvbi1zdHJpbmdpZnktc2FmZScpXG4gICwgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuZnVuY3Rpb24gZGVmZXJNZXRob2QoKSB7XG4gIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrXG4gIH1cblxuICByZXR1cm4gc2V0SW1tZWRpYXRlXG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBwYXJhbXNIYXZlUmVxdWVzdEJvZHkocGFyYW1zKSB7XG4gIHJldHVybiAoXG4gICAgcGFyYW1zLmJvZHkgfHxcbiAgICBwYXJhbXMucmVxdWVzdEJvZHlTdHJlYW0gfHxcbiAgICAocGFyYW1zLmpzb24gJiYgdHlwZW9mIHBhcmFtcy5qc29uICE9PSAnYm9vbGVhbicpIHx8XG4gICAgcGFyYW1zLm11bHRpcGFydFxuICApXG59XG5cbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkgKG9iaikge1xuICB2YXIgcmV0XG4gIHRyeSB7XG4gICAgcmV0ID0gSlNPTi5zdHJpbmdpZnkob2JqKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0ID0ganNvblNhZmVTdHJpbmdpZnkob2JqKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbWQ1IChzdHIpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2hleCcpXG59XG5cbmZ1bmN0aW9uIGlzUmVhZFN0cmVhbSAocnMpIHtcbiAgcmV0dXJuIHJzLnJlYWRhYmxlICYmIHJzLnBhdGggJiYgcnMubW9kZVxufVxuXG5mdW5jdGlvbiB0b0Jhc2U2NCAoc3RyKSB7XG4gIHJldHVybiAobmV3IEJ1ZmZlcihzdHIgfHwgJycsICd1dGY4JykpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjb3B5IChvYmopIHtcbiAgdmFyIG8gPSB7fVxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBvW2ldID0gb2JqW2ldXG4gIH0pXG4gIHJldHVybiBvXG59XG5cbmV4cG9ydHMuaXNGdW5jdGlvbiAgICAgICAgICAgID0gaXNGdW5jdGlvblxuZXhwb3J0cy5wYXJhbXNIYXZlUmVxdWVzdEJvZHkgPSBwYXJhbXNIYXZlUmVxdWVzdEJvZHlcbmV4cG9ydHMuc2FmZVN0cmluZ2lmeSAgICAgICAgID0gc2FmZVN0cmluZ2lmeVxuZXhwb3J0cy5tZDUgICAgICAgICAgICAgICAgICAgPSBtZDVcbmV4cG9ydHMuaXNSZWFkU3RyZWFtICAgICAgICAgID0gaXNSZWFkU3RyZWFtXG5leHBvcnRzLnRvQmFzZTY0ICAgICAgICAgICAgICA9IHRvQmFzZTY0XG5leHBvcnRzLmNvcHkgICAgICAgICAgICAgICAgICA9IGNvcHlcbmV4cG9ydHMuZGVmZXIgICAgICAgICAgICAgICAgID0gZGVmZXJNZXRob2QoKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlcXVlc3QvbGliL2hlbHBlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gU2FmYXJpIDUtNyBsYWNrcyBzdXBwb3J0IGZvciBjaGFuZ2luZyB0aGUgYE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHByb3BlcnR5XG4gKiAgICAgb24gb2JqZWN0cy5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIGZ1bmN0aW9uIEJhciAoKSB7fVxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gQmFyXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBCYXIgJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChhcmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAvLyBBdm9pZCBnb2luZyB0aHJvdWdoIGFuIEFyZ3VtZW50c0FkYXB0b3JUcmFtcG9saW5lIGluIHRoZSBjb21tb24gY2FzZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHJldHVybiBuZXcgQnVmZmVyKGFyZywgYXJndW1lbnRzWzFdKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZylcbiAgfVxuXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDBcbiAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBmcm9tVHlwZWRBcnJheSh0aGF0LCBvYmplY3QpXG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCBvYmplY3QpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdGhhdCA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tVHlwZWRBcnJheSh0aGF0LCBuZXcgVWludDhBcnJheShhcnJheSkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxufSBlbHNlIHtcbiAgLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbiAgQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbiAgQnVmZmVyLnByb3RvdHlwZS5wYXJlbnQgPSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gYWxsb2NhdGUgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhhdC5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgZnJvbVBvb2wgPSBsZW5ndGggIT09IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSA+Pj4gMVxuICBpZiAoZnJvbVBvb2wpIHRoYXQucGFyZW50ID0gcm9vdFBhcmVudFxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIHZhciBpID0gMFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgYnJlYWtcblxuICAgICsraVxuICB9XG5cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCB8IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID09PSBJbmZpbml0eSA/IHRoaXMubGVuZ3RoIDogZW5kIHwgMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gMFxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0KSB7XG4gIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgYnl0ZU9mZnNldCA+Pj0gMFxuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG4gIGlmIChieXRlT2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm4gLTFcblxuICAvLyBOZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoICsgYnl0ZU9mZnNldCwgMClcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xIC8vIHNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nIGFsd2F5cyBmYWlsc1xuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQpXG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0KSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAodmFyIGkgPSAwOyBieXRlT2Zmc2V0ICsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFycltieXRlT2Zmc2V0ICsgaV0gPT09IHZhbFtmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWwubGVuZ3RoKSByZXR1cm4gYnl0ZU9mZnNldCArIGZvdW5kSW5kZXhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbi8vIGBnZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIGlzIGRlcHJlY2F0ZWRcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGggfCAwXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmluZGV4T2YgPSBCUC5pbmRleE9mXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnRMRSA9IEJQLnJlYWRVSW50TEVcbiAgYXJyLnJlYWRVSW50QkUgPSBCUC5yZWFkVUludEJFXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludExFID0gQlAucmVhZEludExFXG4gIGFyci5yZWFkSW50QkUgPSBCUC5yZWFkSW50QkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50TEUgPSBCUC53cml0ZVVJbnRMRVxuICBhcnIud3JpdGVVSW50QkUgPSBCUC53cml0ZVVJbnRCRVxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50TEUgPSBCUC53cml0ZUludExFXG4gIGFyci53cml0ZUludEJFID0gQlAud3JpdGVJbnRCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2J1ZmZlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9iYXNlNjQtanMvbGliL2I2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9pZWVlNzU0L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2J1ZmZlci9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5leHBvcnRzLmdldFNlcmlhbGl6ZSA9IHNlcmlhbGl6ZXJcblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcywgY3ljbGVSZXBsYWNlcikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyKHJlcGxhY2VyLCBjeWNsZVJlcGxhY2VyKSwgc3BhY2VzKVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVyKHJlcGxhY2VyLCBjeWNsZVJlcGxhY2VyKSB7XG4gIHZhciBzdGFjayA9IFtdLCBrZXlzID0gW11cblxuICBpZiAoY3ljbGVSZXBsYWNlciA9PSBudWxsKSBjeWNsZVJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHJldHVybiBcIltDaXJjdWxhciB+XVwiXG4gICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiXG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcylcbiAgICAgIH50aGlzUG9zID8gc3RhY2suc3BsaWNlKHRoaXNQb3MgKyAxKSA6IHN0YWNrLnB1c2godGhpcylcbiAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KVxuICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkgdmFsdWUgPSBjeWNsZVJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSlcbiAgICB9XG4gICAgZWxzZSBzdGFjay5wdXNoKHZhbHVlKVxuXG4gICAgcmV0dXJuIHJlcGxhY2VyID09IG51bGwgPyB2YWx1ZSA6IHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSlcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2pzb24tc3RyaW5naWZ5LXNhZmUvc3RyaW5naWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSByZXF1aXJlKCcuL2NyZWF0ZS1oYXNoJylcblxuZXhwb3J0cy5jcmVhdGVIbWFjID0gcmVxdWlyZSgnLi9jcmVhdGUtaG1hYycpXG5cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihzaXplLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbCkge1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgbmV3IEJ1ZmZlcihybmcoc2l6ZSkpKVxuICAgIH0gY2F0Y2ggKGVycikgeyBjYWxsYmFjayhlcnIpIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaChhLCBmKSB7XG4gIGZvcih2YXIgaSBpbiBhKVxuICAgIGYoYVtpXSwgaSlcbn1cblxuZXhwb3J0cy5nZXRIYXNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbJ3NoYTEnLCAnc2hhMjU2JywgJ3NoYTUxMicsICdtZDUnLCAncm1kMTYwJ11cbn1cblxudmFyIHAgPSByZXF1aXJlKCcuL3Bia2RmMicpKGV4cG9ydHMpXG5leHBvcnRzLnBia2RmMiA9IHAucGJrZGYyXG5leHBvcnRzLnBia2RmMlN5bmMgPSBwLnBia2RmMlN5bmNcblxuXG4vLyB0aGUgbGVhc3QgSSBjYW4gZG8gaXMgbWFrZSBlcnJvciBtZXNzYWdlcyBmb3IgdGhlIHJlc3Qgb2YgdGhlIG5vZGUuanMvY3J5cHRvIGFwaS5cbmVhY2goWydjcmVhdGVDcmVkZW50aWFscydcbiwgJ2NyZWF0ZUNpcGhlcidcbiwgJ2NyZWF0ZUNpcGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURpZmZpZUhlbGxtYW4nXG5dLCBmdW5jdGlvbiAobmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdzb3JyeSwnLCBuYW1lLCAnaXMgbm90IGltcGxlbWVudGVkIHlldCcpXG4gIH1cbn0pXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgZyA9ICgndW5kZWZpbmVkJyA9PT0gdHlwZW9mIHdpbmRvdyA/IGdsb2JhbCA6IHdpbmRvdykgfHwge31cbiAgX2NyeXB0byA9IChcbiAgICBnLmNyeXB0byB8fCBnLm1zQ3J5cHRvIHx8IHJlcXVpcmUoJ2NyeXB0bycpXG4gIClcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgLy8gTW9kZXJuIEJyb3dzZXJzXG4gICAgaWYoX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBCdWZmZXIoc2l6ZSk7IC8vaW4gYnJvd3NlcmlmeSwgdGhpcyBpcyBhbiBleHRlbmRlZCBVaW50OEFycmF5XG4gICAgICAvKiBUaGlzIHdpbGwgbm90IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMuXG4gICAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAgKi9cbiAgICBcbiAgICAgIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2NyeXB0by5yYW5kb21CeXRlcykge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMoc2l6ZSlcbiAgICB9XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclxcbicrXG4gICAgICAgICd1c2UgY2hyb21lLCBGaXJlRm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExJ1xuICAgICAgKVxuICB9XG59KCkpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogY3J5cHRvIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ3NoYS5qcycpXG5cbnZhciBtZDUgPSB0b0NvbnN0cnVjdG9yKHJlcXVpcmUoJy4vbWQ1JykpXG52YXIgcm1kMTYwID0gdG9Db25zdHJ1Y3RvcihyZXF1aXJlKCdyaXBlbWQxNjAnKSlcblxuZnVuY3Rpb24gdG9Db25zdHJ1Y3RvciAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdXG4gICAgdmFyIG09IHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICAgICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKVxuICAgICAgICB2YXIgciA9IGZuKGJ1ZilcbiAgICAgICAgYnVmZmVycyA9IG51bGxcbiAgICAgICAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhbGcpIHtcbiAgaWYoJ21kNScgPT09IGFsZykgcmV0dXJuIG5ldyBtZDUoKVxuICBpZigncm1kMTYwJyA9PT0gYWxnKSByZXR1cm4gbmV3IHJtZDE2MCgpXG4gIHJldHVybiBjcmVhdGVIYXNoKGFsZylcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jcnlwdG8tYnJvd3NlcmlmeS9jcmVhdGUtaGFzaC5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFsZykge1xuICB2YXIgQWxnID0gZXhwb3J0c1thbGddXG4gIGlmKCFBbGcpIHRocm93IG5ldyBFcnJvcihhbGcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG4gIHJldHVybiBuZXcgQWxnKClcbn1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIEhhc2ggICA9IHJlcXVpcmUoJy4vaGFzaCcpKEJ1ZmZlcilcblxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJykoQnVmZmVyLCBIYXNoKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpKEJ1ZmZlciwgSGFzaClcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKShCdWZmZXIsIEhhc2gpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vc2hhLmpzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJ1ZmZlcikge1xuXG4gIC8vcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBIYXNoIChibG9ja1NpemUsIGZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX2Jsb2NrID0gbmV3IEJ1ZmZlcihibG9ja1NpemUpIC8vbmV3IFVpbnQzMkFycmF5KGJsb2NrU2l6ZS80KVxuICAgIHRoaXMuX2ZpbmFsU2l6ZSA9IGZpbmFsU2l6ZVxuICAgIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICAgIHRoaXMuX2xlbiA9IDBcbiAgICB0aGlzLl9zID0gMFxuICB9XG5cbiAgSGFzaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zID0gMFxuICAgIHRoaXMuX2xlbiA9IDBcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGVuYyA9IGVuYyB8fCBcInV0ZjhcIlxuICAgICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICAgIH1cblxuICAgIHZhciBsID0gdGhpcy5fbGVuICs9IGRhdGEubGVuZ3RoXG4gICAgdmFyIHMgPSB0aGlzLl9zID0gKHRoaXMuX3MgfHwgMClcbiAgICB2YXIgZiA9IDBcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5fYmxvY2tcblxuICAgIHdoaWxlIChzIDwgbCkge1xuICAgICAgdmFyIHQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgZiArIHRoaXMuX2Jsb2NrU2l6ZSAtIChzICUgdGhpcy5fYmxvY2tTaXplKSlcbiAgICAgIHZhciBjaCA9ICh0IC0gZilcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlclsocyAlIHRoaXMuX2Jsb2NrU2l6ZSkgKyBpXSA9IGRhdGFbaSArIGZdXG4gICAgICB9XG5cbiAgICAgIHMgKz0gY2hcbiAgICAgIGYgKz0gY2hcblxuICAgICAgaWYgKChzICUgdGhpcy5fYmxvY2tTaXplKSA9PT0gMCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoYnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zID0gc1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAvLyBTdXBwb3NlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UgTSwgaW4gYml0cywgaXMgbFxuICAgIHZhciBsID0gdGhpcy5fbGVuICogOFxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXQgMSB0byB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlXG4gICAgdGhpcy5fYmxvY2tbdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplXSA9IDB4ODBcblxuICAgIC8vIGFuZCB0aGVuIGsgemVybyBiaXRzLCB3aGVyZSBrIGlzIHRoZSBzbWFsbGVzdCBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsICsgMSArIGspID09PSBmaW5hbFNpemUgbW9kIGJsb2NrU2l6ZVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fbGVuICUgdGhpcy5fYmxvY2tTaXplICsgMSlcblxuICAgIGlmIChsICUgKHRoaXMuX2Jsb2NrU2l6ZSAqIDgpID49IHRoaXMuX2ZpbmFsU2l6ZSAqIDgpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgICB9XG5cbiAgICAvLyB0byB0aGlzIGFwcGVuZCB0aGUgYmxvY2sgd2hpY2ggaXMgZXF1YWwgdG8gdGhlIG51bWJlciBsIHdyaXR0ZW4gaW4gYmluYXJ5XG4gICAgLy8gVE9ETzogaGFuZGxlIGNhc2Ugd2hlcmUgbCBpcyA+IE1hdGgucG93KDIsIDI5KVxuICAgIHRoaXMuX2Jsb2NrLndyaXRlSW50MzJCRShsLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gICAgdmFyIGhhc2ggPSB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spIHx8IHRoaXMuX2hhc2goKVxuXG4gICAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbiAgfVxuXG4gIEhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxuICB9XG5cbiAgcmV0dXJuIEhhc2hcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zaGEuanMvaGFzaC5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQnVmZmVyLCBIYXNoKSB7XG5cbiAgdmFyIEEgPSAwfDBcbiAgdmFyIEIgPSA0fDBcbiAgdmFyIEMgPSA4fDBcbiAgdmFyIEQgPSAxMnwwXG4gIHZhciBFID0gMTZ8MFxuXG4gIHZhciBXID0gbmV3ICh0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEludDMyQXJyYXkpKDgwKVxuXG4gIHZhciBQT09MID0gW11cblxuICBmdW5jdGlvbiBTaGExICgpIHtcbiAgICBpZihQT09MLmxlbmd0aClcbiAgICAgIHJldHVybiBQT09MLnBvcCgpLmluaXQoKVxuXG4gICAgaWYoISh0aGlzIGluc3RhbmNlb2YgU2hhMSkpIHJldHVybiBuZXcgU2hhMSgpXG4gICAgdGhpcy5fdyA9IFdcbiAgICBIYXNoLmNhbGwodGhpcywgMTYqNCwgMTQqNClcblxuICAgIHRoaXMuX2ggPSBudWxsXG4gICAgdGhpcy5pbml0KClcbiAgfVxuXG4gIGluaGVyaXRzKFNoYTEsIEhhc2gpXG5cbiAgU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICAgIHRoaXMuX2IgPSAweGVmY2RhYjg5XG4gICAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICAgIHRoaXMuX2UgPSAweGMzZDJlMWYwXG5cbiAgICBIYXNoLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgU2hhMS5wcm90b3R5cGUuX1BPT0wgPSBQT09MXG4gIFNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoWCkge1xuXG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIF9hLCBfYiwgX2MsIF9kLCBfZVxuXG4gICAgYSA9IF9hID0gdGhpcy5fYVxuICAgIGIgPSBfYiA9IHRoaXMuX2JcbiAgICBjID0gX2MgPSB0aGlzLl9jXG4gICAgZCA9IF9kID0gdGhpcy5fZFxuICAgIGUgPSBfZSA9IHRoaXMuX2VcblxuICAgIHZhciB3ID0gdGhpcy5fd1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgIHZhciBXID0gd1tqXSA9IGogPCAxNiA/IFgucmVhZEludDMyQkUoaio0KVxuICAgICAgICA6IHJvbCh3W2ogLSAzXSBeIHdbaiAtICA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSlcblxuICAgICAgdmFyIHQgPSBhZGQoXG4gICAgICAgIGFkZChyb2woYSwgNSksIHNoYTFfZnQoaiwgYiwgYywgZCkpLFxuICAgICAgICBhZGQoYWRkKGUsIFcpLCBzaGExX2t0KGopKVxuICAgICAgKVxuXG4gICAgICBlID0gZFxuICAgICAgZCA9IGNcbiAgICAgIGMgPSByb2woYiwgMzApXG4gICAgICBiID0gYVxuICAgICAgYSA9IHRcbiAgICB9XG5cbiAgICB0aGlzLl9hID0gYWRkKGEsIF9hKVxuICAgIHRoaXMuX2IgPSBhZGQoYiwgX2IpXG4gICAgdGhpcy5fYyA9IGFkZChjLCBfYylcbiAgICB0aGlzLl9kID0gYWRkKGQsIF9kKVxuICAgIHRoaXMuX2UgPSBhZGQoZSwgX2UpXG4gIH1cblxuICBTaGExLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihQT09MLmxlbmd0aCA8IDEwMCkgUE9PTC5wdXNoKHRoaXMpXG4gICAgdmFyIEggPSBuZXcgQnVmZmVyKDIwKVxuICAgIC8vY29uc29sZS5sb2codGhpcy5fYXwwLCB0aGlzLl9ifDAsIHRoaXMuX2N8MCwgdGhpcy5fZHwwLCB0aGlzLl9lfDApXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYXwwLCBBKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2J8MCwgQilcbiAgICBILndyaXRlSW50MzJCRSh0aGlzLl9jfDAsIEMpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZHwwLCBEKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2V8MCwgRSlcbiAgICByZXR1cm4gSFxuICB9XG5cbiAgLypcbiAgICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAgICogaXRlcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpIHtcbiAgICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gICAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICAgIHJldHVybiBiIF4gYyBeIGQ7XG4gIH1cblxuICAvKlxuICAgKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHNoYTFfa3QodCkge1xuICAgIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xuICB9XG5cbiAgLypcbiAgICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICAgKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICAgKiAvL2RvbWluaWN0YXJyOiB0aGlzIGlzIDEwIHllYXJzIG9sZCwgc28gbWF5YmUgdGhpcyBjYW4gYmUgZHJvcHBlZD8pXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBhZGQoeCwgeSkge1xuICAgIHJldHVybiAoeCArIHkgKSB8IDBcbiAgLy9sZXRzIHNlZSBob3cgdGhpcyBnb2VzIG9uIHRlc3RsaW5nLlxuICAvLyAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgLy8gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgLy8gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xuICB9XG5cbiAgLypcbiAgICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICAgKi9cbiAgZnVuY3Rpb24gcm9sKG51bSwgY250KSB7XG4gICAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xuICB9XG5cbiAgcmV0dXJuIFNoYTFcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zaGEuanMvc2hhMS5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQnVmZmVyLCBIYXNoKSB7XG5cbiAgdmFyIEsgPSBbXG4gICAgICAweDQyOEEyRjk4LCAweDcxMzc0NDkxLCAweEI1QzBGQkNGLCAweEU5QjVEQkE1LFxuICAgICAgMHgzOTU2QzI1QiwgMHg1OUYxMTFGMSwgMHg5MjNGODJBNCwgMHhBQjFDNUVENSxcbiAgICAgIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gICAgICAweDcyQkU1RDc0LCAweDgwREVCMUZFLCAweDlCREMwNkE3LCAweEMxOUJGMTc0LFxuICAgICAgMHhFNDlCNjlDMSwgMHhFRkJFNDc4NiwgMHgwRkMxOURDNiwgMHgyNDBDQTFDQyxcbiAgICAgIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gICAgICAweDk4M0U1MTUyLCAweEE4MzFDNjZELCAweEIwMDMyN0M4LCAweEJGNTk3RkM3LFxuICAgICAgMHhDNkUwMEJGMywgMHhENUE3OTE0NywgMHgwNkNBNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAgIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gICAgICAweDY1MEE3MzU0LCAweDc2NkEwQUJCLCAweDgxQzJDOTJFLCAweDkyNzIyQzg1LFxuICAgICAgMHhBMkJGRThBMSwgMHhBODFBNjY0QiwgMHhDMjRCOEI3MCwgMHhDNzZDNTFBMyxcbiAgICAgIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gICAgICAweDE5QTRDMTE2LCAweDFFMzc2QzA4LCAweDI3NDg3NzRDLCAweDM0QjBCQ0I1LFxuICAgICAgMHgzOTFDMENCMywgMHg0RUQ4QUE0QSwgMHg1QjlDQ0E0RiwgMHg2ODJFNkZGMyxcbiAgICAgIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gICAgICAweDkwQkVGRkZBLCAweEE0NTA2Q0VCLCAweEJFRjlBM0Y3LCAweEM2NzE3OEYyXG4gICAgXVxuXG4gIHZhciBXID0gbmV3IEFycmF5KDY0KVxuXG4gIGZ1bmN0aW9uIFNoYTI1NigpIHtcbiAgICB0aGlzLmluaXQoKVxuXG4gICAgdGhpcy5fdyA9IFcgLy9uZXcgQXJyYXkoNjQpXG5cbiAgICBIYXNoLmNhbGwodGhpcywgMTYqNCwgMTQqNClcbiAgfVxuXG4gIGluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuICBTaGEyNTYucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9hID0gMHg2YTA5ZTY2N3wwXG4gICAgdGhpcy5fYiA9IDB4YmI2N2FlODV8MFxuICAgIHRoaXMuX2MgPSAweDNjNmVmMzcyfDBcbiAgICB0aGlzLl9kID0gMHhhNTRmZjUzYXwwXG4gICAgdGhpcy5fZSA9IDB4NTEwZTUyN2Z8MFxuICAgIHRoaXMuX2YgPSAweDliMDU2ODhjfDBcbiAgICB0aGlzLl9nID0gMHgxZjgzZDlhYnwwXG4gICAgdGhpcy5faCA9IDB4NWJlMGNkMTl8MFxuXG4gICAgdGhpcy5fbGVuID0gdGhpcy5fcyA9IDBcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmdW5jdGlvbiBTIChYLCBuKSB7XG4gICAgcmV0dXJuIChYID4+PiBuKSB8IChYIDw8ICgzMiAtIG4pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFIgKFgsIG4pIHtcbiAgICByZXR1cm4gKFggPj4+IG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1haiAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNpZ21hMDI1NiAoeCkge1xuICAgIHJldHVybiAoUyh4LCAyKSBeIFMoeCwgMTMpIF4gUyh4LCAyMikpO1xuICB9XG5cbiAgZnVuY3Rpb24gU2lnbWExMjU2ICh4KSB7XG4gICAgcmV0dXJuIChTKHgsIDYpIF4gUyh4LCAxMSkgXiBTKHgsIDI1KSk7XG4gIH1cblxuICBmdW5jdGlvbiBHYW1tYTAyNTYgKHgpIHtcbiAgICByZXR1cm4gKFMoeCwgNykgXiBTKHgsIDE4KSBeIFIoeCwgMykpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2FtbWExMjU2ICh4KSB7XG4gICAgcmV0dXJuIChTKHgsIDE3KSBeIFMoeCwgMTkpIF4gUih4LCAxMCkpO1xuICB9XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oTSkge1xuXG4gICAgdmFyIFcgPSB0aGlzLl93XG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGhcbiAgICB2YXIgVDEsIFQyXG5cbiAgICBhID0gdGhpcy5fYSB8IDBcbiAgICBiID0gdGhpcy5fYiB8IDBcbiAgICBjID0gdGhpcy5fYyB8IDBcbiAgICBkID0gdGhpcy5fZCB8IDBcbiAgICBlID0gdGhpcy5fZSB8IDBcbiAgICBmID0gdGhpcy5fZiB8IDBcbiAgICBnID0gdGhpcy5fZyB8IDBcbiAgICBoID0gdGhpcy5faCB8IDBcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgdmFyIHcgPSBXW2pdID0gaiA8IDE2XG4gICAgICAgID8gTS5yZWFkSW50MzJCRShqICogNClcbiAgICAgICAgOiBHYW1tYTEyNTYoV1tqIC0gMl0pICsgV1tqIC0gN10gKyBHYW1tYTAyNTYoV1tqIC0gMTVdKSArIFdbaiAtIDE2XVxuXG4gICAgICBUMSA9IGggKyBTaWdtYTEyNTYoZSkgKyBDaChlLCBmLCBnKSArIEtbal0gKyB3XG5cbiAgICAgIFQyID0gU2lnbWEwMjU2KGEpICsgTWFqKGEsIGIsIGMpO1xuICAgICAgaCA9IGc7IGcgPSBmOyBmID0gZTsgZSA9IGQgKyBUMTsgZCA9IGM7IGMgPSBiOyBiID0gYTsgYSA9IFQxICsgVDI7XG4gICAgfVxuXG4gICAgdGhpcy5fYSA9IChhICsgdGhpcy5fYSkgfCAwXG4gICAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gICAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gICAgdGhpcy5fZCA9IChkICsgdGhpcy5fZCkgfCAwXG4gICAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gICAgdGhpcy5fZiA9IChmICsgdGhpcy5fZikgfCAwXG4gICAgdGhpcy5fZyA9IChnICsgdGhpcy5fZykgfCAwXG4gICAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG5cbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBIID0gbmV3IEJ1ZmZlcigzMilcblxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsICAwKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsICA0KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsICA4KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2YsIDIwKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2gsIDI4KVxuXG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIHJldHVybiBTaGEyNTZcblxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3NoYS5qcy9zaGEyNTYuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJ1ZmZlciwgSGFzaCkge1xuICB2YXIgSyA9IFtcbiAgICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAgIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gICAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAgIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gICAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAgIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gICAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAgIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gICAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAgIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gICAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAgIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gICAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAgIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gICAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gICAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAgIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gICAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gICAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAgIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gICAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAgIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gICAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAgIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gICAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG4gIF1cblxuICB2YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbiAgZnVuY3Rpb24gU2hhNTEyKCkge1xuICAgIHRoaXMuaW5pdCgpXG4gICAgdGhpcy5fdyA9IFdcblxuICAgIEhhc2guY2FsbCh0aGlzLCAxMjgsIDExMilcbiAgfVxuXG4gIGluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuICBTaGE1MTIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9hID0gMHg2YTA5ZTY2N3wwXG4gICAgdGhpcy5fYiA9IDB4YmI2N2FlODV8MFxuICAgIHRoaXMuX2MgPSAweDNjNmVmMzcyfDBcbiAgICB0aGlzLl9kID0gMHhhNTRmZjUzYXwwXG4gICAgdGhpcy5fZSA9IDB4NTEwZTUyN2Z8MFxuICAgIHRoaXMuX2YgPSAweDliMDU2ODhjfDBcbiAgICB0aGlzLl9nID0gMHgxZjgzZDlhYnwwXG4gICAgdGhpcy5faCA9IDB4NWJlMGNkMTl8MFxuXG4gICAgdGhpcy5fYWwgPSAweGYzYmNjOTA4fDBcbiAgICB0aGlzLl9ibCA9IDB4ODRjYWE3M2J8MFxuICAgIHRoaXMuX2NsID0gMHhmZTk0ZjgyYnwwXG4gICAgdGhpcy5fZGwgPSAweDVmMWQzNmYxfDBcbiAgICB0aGlzLl9lbCA9IDB4YWRlNjgyZDF8MFxuICAgIHRoaXMuX2ZsID0gMHgyYjNlNmMxZnwwXG4gICAgdGhpcy5fZ2wgPSAweGZiNDFiZDZifDBcbiAgICB0aGlzLl9obCA9IDB4MTM3ZTIxNzl8MFxuXG4gICAgdGhpcy5fbGVuID0gdGhpcy5fcyA9IDBcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmdW5jdGlvbiBTIChYLCBYbCwgbikge1xuICAgIHJldHVybiAoWCA+Pj4gbikgfCAoWGwgPDwgKDMyIC0gbikpXG4gIH1cblxuICBmdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xuICB9XG5cbiAgZnVuY3Rpb24gTWFqICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xuICB9XG5cbiAgU2hhNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oTSkge1xuXG4gICAgdmFyIFcgPSB0aGlzLl93XG4gICAgdmFyIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGhcbiAgICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsLCBmbCwgZ2wsIGhsXG5cbiAgICBhID0gdGhpcy5fYSB8IDBcbiAgICBiID0gdGhpcy5fYiB8IDBcbiAgICBjID0gdGhpcy5fYyB8IDBcbiAgICBkID0gdGhpcy5fZCB8IDBcbiAgICBlID0gdGhpcy5fZSB8IDBcbiAgICBmID0gdGhpcy5fZiB8IDBcbiAgICBnID0gdGhpcy5fZyB8IDBcbiAgICBoID0gdGhpcy5faCB8IDBcblxuICAgIGFsID0gdGhpcy5fYWwgfCAwXG4gICAgYmwgPSB0aGlzLl9ibCB8IDBcbiAgICBjbCA9IHRoaXMuX2NsIHwgMFxuICAgIGRsID0gdGhpcy5fZGwgfCAwXG4gICAgZWwgPSB0aGlzLl9lbCB8IDBcbiAgICBmbCA9IHRoaXMuX2ZsIHwgMFxuICAgIGdsID0gdGhpcy5fZ2wgfCAwXG4gICAgaGwgPSB0aGlzLl9obCB8IDBcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgdmFyIGogPSBpICogMlxuXG4gICAgICB2YXIgV2ksIFdpbFxuXG4gICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIFdpID0gV1tqXSA9IE0ucmVhZEludDMyQkUoaiAqIDQpXG4gICAgICAgIFdpbCA9IFdbaiArIDFdID0gTS5yZWFkSW50MzJCRShqICogNCArIDQpXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB4ICA9IFdbaiAtIDE1KjJdXG4gICAgICAgIHZhciB4bCA9IFdbaiAtIDE1KjIgKyAxXVxuICAgICAgICB2YXIgZ2FtbWEwICA9IFMoeCwgeGwsIDEpIF4gUyh4LCB4bCwgOCkgXiAoeCA+Pj4gNylcbiAgICAgICAgdmFyIGdhbW1hMGwgPSBTKHhsLCB4LCAxKSBeIFMoeGwsIHgsIDgpIF4gUyh4bCwgeCwgNylcblxuICAgICAgICB4ICA9IFdbaiAtIDIqMl1cbiAgICAgICAgeGwgPSBXW2ogLSAyKjIgKyAxXVxuICAgICAgICB2YXIgZ2FtbWExICA9IFMoeCwgeGwsIDE5KSBeIFMoeGwsIHgsIDI5KSBeICh4ID4+PiA2KVxuICAgICAgICB2YXIgZ2FtbWExbCA9IFMoeGwsIHgsIDE5KSBeIFMoeCwgeGwsIDI5KSBeIFMoeGwsIHgsIDYpXG5cbiAgICAgICAgLy8gV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdXG4gICAgICAgIHZhciBXaTcgID0gV1tqIC0gNyoyXVxuICAgICAgICB2YXIgV2k3bCA9IFdbaiAtIDcqMiArIDFdXG5cbiAgICAgICAgdmFyIFdpMTYgID0gV1tqIC0gMTYqMl1cbiAgICAgICAgdmFyIFdpMTZsID0gV1tqIC0gMTYqMiArIDFdXG5cbiAgICAgICAgV2lsID0gZ2FtbWEwbCArIFdpN2xcbiAgICAgICAgV2kgID0gZ2FtbWEwICArIFdpNyArICgoV2lsID4+PiAwKSA8IChnYW1tYTBsID4+PiAwKSA/IDEgOiAwKVxuICAgICAgICBXaWwgPSBXaWwgKyBnYW1tYTFsXG4gICAgICAgIFdpICA9IFdpICArIGdhbW1hMSAgKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWExbCA+Pj4gMCkgPyAxIDogMClcbiAgICAgICAgV2lsID0gV2lsICsgV2kxNmxcbiAgICAgICAgV2kgID0gV2kgICsgV2kxNiArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMClcblxuICAgICAgICBXW2pdID0gV2lcbiAgICAgICAgV1tqICsgMV0gPSBXaWxcbiAgICAgIH1cblxuICAgICAgdmFyIG1haiA9IE1haihhLCBiLCBjKVxuICAgICAgdmFyIG1hamwgPSBNYWooYWwsIGJsLCBjbClcblxuICAgICAgdmFyIHNpZ21hMGggPSBTKGEsIGFsLCAyOCkgXiBTKGFsLCBhLCAyKSBeIFMoYWwsIGEsIDcpXG4gICAgICB2YXIgc2lnbWEwbCA9IFMoYWwsIGEsIDI4KSBeIFMoYSwgYWwsIDIpIF4gUyhhLCBhbCwgNylcbiAgICAgIHZhciBzaWdtYTFoID0gUyhlLCBlbCwgMTQpIF4gUyhlLCBlbCwgMTgpIF4gUyhlbCwgZSwgOSlcbiAgICAgIHZhciBzaWdtYTFsID0gUyhlbCwgZSwgMTQpIF4gUyhlbCwgZSwgMTgpIF4gUyhlLCBlbCwgOSlcblxuICAgICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuICAgICAgdmFyIEtpID0gS1tqXVxuICAgICAgdmFyIEtpbCA9IEtbaiArIDFdXG5cbiAgICAgIHZhciBjaCA9IENoKGUsIGYsIGcpXG4gICAgICB2YXIgY2hsID0gQ2goZWwsIGZsLCBnbClcblxuICAgICAgdmFyIHQxbCA9IGhsICsgc2lnbWExbFxuICAgICAgdmFyIHQxID0gaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApXG4gICAgICB0MWwgPSB0MWwgKyBjaGxcbiAgICAgIHQxID0gdDEgKyBjaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApXG4gICAgICB0MWwgPSB0MWwgKyBLaWxcbiAgICAgIHQxID0gdDEgKyBLaSArICgodDFsID4+PiAwKSA8IChLaWwgPj4+IDApID8gMSA6IDApXG4gICAgICB0MWwgPSB0MWwgKyBXaWxcbiAgICAgIHQxID0gdDEgKyBXaSArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApXG5cbiAgICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG4gICAgICB2YXIgdDJsID0gc2lnbWEwbCArIG1hamxcbiAgICAgIHZhciB0MiA9IHNpZ21hMGggKyBtYWogKyAoKHQybCA+Pj4gMCkgPCAoc2lnbWEwbCA+Pj4gMCkgPyAxIDogMClcblxuICAgICAgaCAgPSBnXG4gICAgICBobCA9IGdsXG4gICAgICBnICA9IGZcbiAgICAgIGdsID0gZmxcbiAgICAgIGYgID0gZVxuICAgICAgZmwgPSBlbFxuICAgICAgZWwgPSAoZGwgKyB0MWwpIHwgMFxuICAgICAgZSAgPSAoZCArIHQxICsgKChlbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICAgIGQgID0gY1xuICAgICAgZGwgPSBjbFxuICAgICAgYyAgPSBiXG4gICAgICBjbCA9IGJsXG4gICAgICBiICA9IGFcbiAgICAgIGJsID0gYWxcbiAgICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgICBhICA9ICh0MSArIHQyICsgKChhbCA+Pj4gMCkgPCAodDFsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgfVxuXG4gICAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gICAgdGhpcy5fYmwgPSAodGhpcy5fYmwgKyBibCkgfCAwXG4gICAgdGhpcy5fY2wgPSAodGhpcy5fY2wgKyBjbCkgfCAwXG4gICAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gICAgdGhpcy5fZWwgPSAodGhpcy5fZWwgKyBlbCkgfCAwXG4gICAgdGhpcy5fZmwgPSAodGhpcy5fZmwgKyBmbCkgfCAwXG4gICAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gICAgdGhpcy5faGwgPSAodGhpcy5faGwgKyBobCkgfCAwXG5cbiAgICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhICsgKCh0aGlzLl9hbCA+Pj4gMCkgPCAoYWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9iID0gKHRoaXMuX2IgKyBiICsgKCh0aGlzLl9ibCA+Pj4gMCkgPCAoYmwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9jID0gKHRoaXMuX2MgKyBjICsgKCh0aGlzLl9jbCA+Pj4gMCkgPCAoY2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkICsgKCh0aGlzLl9kbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9lID0gKHRoaXMuX2UgKyBlICsgKCh0aGlzLl9lbCA+Pj4gMCkgPCAoZWwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9mID0gKHRoaXMuX2YgKyBmICsgKCh0aGlzLl9mbCA+Pj4gMCkgPCAoZmwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9nID0gKHRoaXMuX2cgKyBnICsgKCh0aGlzLl9nbCA+Pj4gMCkgPCAoZ2wgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgICB0aGlzLl9oID0gKHRoaXMuX2ggKyBoICsgKCh0aGlzLl9obCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApKSB8IDBcbiAgfVxuXG4gIFNoYTUxMi5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEggPSBuZXcgQnVmZmVyKDY0KVxuXG4gICAgZnVuY3Rpb24gd3JpdGVJbnQ2NEJFKGgsIGwsIG9mZnNldCkge1xuICAgICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgICAgSC53cml0ZUludDMyQkUobCwgb2Zmc2V0ICsgNClcbiAgICB9XG5cbiAgICB3cml0ZUludDY0QkUodGhpcy5fYSwgdGhpcy5fYWwsIDApXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2IsIHRoaXMuX2JsLCA4KVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9jLCB0aGlzLl9jbCwgMTYpXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2QsIHRoaXMuX2RsLCAyNClcbiAgICB3cml0ZUludDY0QkUodGhpcy5fZSwgdGhpcy5fZWwsIDMyKVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9mLCB0aGlzLl9mbCwgNDApXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2csIHRoaXMuX2dsLCA0OClcbiAgICB3cml0ZUludDY0QkUodGhpcy5faCwgdGhpcy5faGwsIDU2KVxuXG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIHJldHVybiBTaGE1MTJcblxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3NoYS5qcy9zaGE1MTIuanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcblxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NyeXB0by1icm93c2VyaWZ5L21kNS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaW50U2l6ZSA9IDQ7XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoaW50U2l6ZSk7IHplcm9CdWZmZXIuZmlsbCgwKTtcbnZhciBjaHJzeiA9IDg7XG5cbmZ1bmN0aW9uIHRvQXJyYXkoYnVmLCBiaWdFbmRpYW4pIHtcbiAgaWYgKChidWYubGVuZ3RoICUgaW50U2l6ZSkgIT09IDApIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCArIChpbnRTaXplIC0gKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSk7XG4gICAgYnVmID0gQnVmZmVyLmNvbmNhdChbYnVmLCB6ZXJvQnVmZmVyXSwgbGVuKTtcbiAgfVxuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLnJlYWRJbnQzMkJFIDogYnVmLnJlYWRJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gaW50U2l6ZSkge1xuICAgIGFyci5wdXNoKGZuLmNhbGwoYnVmLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIoYXJyLCBzaXplLCBiaWdFbmRpYW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc2l6ZSk7XG4gIHZhciBmbiA9IGJpZ0VuZGlhbiA/IGJ1Zi53cml0ZUludDMyQkUgOiBidWYud3JpdGVJbnQzMkxFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGZuLmNhbGwoYnVmLCBhcnJbaV0sIGkgKiA0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5mdW5jdGlvbiBoYXNoKGJ1ZiwgZm4sIGhhc2hTaXplLCBiaWdFbmRpYW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gbmV3IEJ1ZmZlcihidWYpO1xuICB2YXIgYXJyID0gZm4odG9BcnJheShidWYsIGJpZ0VuZGlhbiksIGJ1Zi5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiB0b0J1ZmZlcihhcnIsIGhhc2hTaXplLCBiaWdFbmRpYW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgaGFzaDogaGFzaCB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NyeXB0by1icm93c2VyaWZ5L2hlbHBlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJpcGVtZDE2MFxuXG5cblxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKiogQHByZXNlcnZlXG4oYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8vIENvbnN0YW50cyB0YWJsZVxudmFyIHpsID0gW1xuICAgIDAsICAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gICAgNywgIDQsIDEzLCAgMSwgMTAsICA2LCAxNSwgIDMsIDEyLCAgMCwgIDksICA1LCAgMiwgMTQsIDExLCAgOCxcbiAgICAzLCAxMCwgMTQsICA0LCAgOSwgMTUsICA4LCAgMSwgIDIsICA3LCAgMCwgIDYsIDEzLCAxMSwgIDUsIDEyLFxuICAgIDEsICA5LCAxMSwgMTAsICAwLCAgOCwgMTIsICA0LCAxMywgIDMsICA3LCAxNSwgMTQsICA1LCAgNiwgIDIsXG4gICAgNCwgIDAsICA1LCAgOSwgIDcsIDEyLCAgMiwgMTAsIDE0LCAgMSwgIDMsICA4LCAxMSwgIDYsIDE1LCAxM107XG52YXIgenIgPSBbXG4gICAgNSwgMTQsICA3LCAgMCwgIDksICAyLCAxMSwgIDQsIDEzLCAgNiwgMTUsICA4LCAgMSwgMTAsICAzLCAxMixcbiAgICA2LCAxMSwgIDMsICA3LCAgMCwgMTMsICA1LCAxMCwgMTQsIDE1LCAgOCwgMTIsICA0LCAgOSwgIDEsICAyLFxuICAgIDE1LCAgNSwgIDEsICAzLCAgNywgMTQsICA2LCAgOSwgMTEsICA4LCAxMiwgIDIsIDEwLCAgMCwgIDQsIDEzLFxuICAgIDgsICA2LCAgNCwgIDEsICAzLCAxMSwgMTUsICAwLCAgNSwgMTIsICAyLCAxMywgIDksICA3LCAxMCwgMTQsXG4gICAgMTIsIDE1LCAxMCwgIDQsICAxLCAgNSwgIDgsICA3LCAgNiwgIDIsIDEzLCAxNCwgIDAsICAzLCAgOSwgMTFdO1xudmFyIHNsID0gW1xuICAgICAxMSwgMTQsIDE1LCAxMiwgIDUsICA4LCAgNywgIDksIDExLCAxMywgMTQsIDE1LCAgNiwgIDcsICA5LCAgOCxcbiAgICA3LCA2LCAgIDgsIDEzLCAxMSwgIDksICA3LCAxNSwgIDcsIDEyLCAxNSwgIDksIDExLCAgNywgMTMsIDEyLFxuICAgIDExLCAxMywgIDYsICA3LCAxNCwgIDksIDEzLCAxNSwgMTQsICA4LCAxMywgIDYsICA1LCAxMiwgIDcsICA1LFxuICAgICAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgIDksICA4LCAgOSwgMTQsICA1LCAgNiwgIDgsICA2LCAgNSwgMTIsXG4gICAgOSwgMTUsICA1LCAxMSwgIDYsICA4LCAxMywgMTIsICA1LCAxMiwgMTMsIDE0LCAxMSwgIDgsICA1LCAgNiBdO1xudmFyIHNyID0gW1xuICAgIDgsICA5LCAgOSwgMTEsIDEzLCAxNSwgMTUsICA1LCAgNywgIDcsICA4LCAxMSwgMTQsIDE0LCAxMiwgIDYsXG4gICAgOSwgMTMsIDE1LCAgNywgMTIsICA4LCAgOSwgMTEsICA3LCAgNywgMTIsICA3LCAgNiwgMTUsIDEzLCAxMSxcbiAgICA5LCAgNywgMTUsIDExLCAgOCwgIDYsICA2LCAxNCwgMTIsIDEzLCAgNSwgMTQsIDEzLCAxMywgIDcsICA1LFxuICAgIDE1LCAgNSwgIDgsIDExLCAxNCwgMTQsICA2LCAxNCwgIDYsICA5LCAxMiwgIDksIDEyLCAgNSwgMTUsICA4LFxuICAgIDgsICA1LCAxMiwgIDksIDEyLCAgNSwgMTQsICA2LCAgOCwgMTMsICA2LCAgNSwgMTUsIDEzLCAxMSwgMTEgXTtcblxudmFyIGhsID0gIFsgMHgwMDAwMDAwMCwgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSwgMHg4RjFCQkNEQywgMHhBOTUzRkQ0RV07XG52YXIgaHIgPSAgWyAweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXTtcblxudmFyIGJ5dGVzVG9Xb3JkcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICB2YXIgd29yZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOCkge1xuICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gIH1cbiAgcmV0dXJuIHdvcmRzO1xufTtcblxudmFyIHdvcmRzVG9CeXRlcyA9IGZ1bmN0aW9uICh3b3Jkcykge1xuICB2YXIgYnl0ZXMgPSBbXTtcbiAgZm9yICh2YXIgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KSB7XG4gICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRik7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxudmFyIHByb2Nlc3NCbG9jayA9IGZ1bmN0aW9uIChILCBNLCBvZmZzZXQpIHtcblxuICAvLyBTd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cbiAgICAvLyBTd2FwXG4gICAgTVtvZmZzZXRfaV0gPSAoXG4gICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuICAgICk7XG4gIH1cblxuICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsO1xuICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyO1xuXG4gIGFyID0gYWwgPSBIWzBdO1xuICBiciA9IGJsID0gSFsxXTtcbiAgY3IgPSBjbCA9IEhbMl07XG4gIGRyID0gZGwgPSBIWzNdO1xuICBlciA9IGVsID0gSFs0XTtcbiAgLy8gQ29tcHV0YXRpb25cbiAgdmFyIHQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgIHQgPSAoYWwgKyAgTVtvZmZzZXQremxbaV1dKXwwO1xuICAgIGlmIChpPDE2KXtcbiAgICAgICAgdCArPSAgZjEoYmwsY2wsZGwpICsgaGxbMF07XG4gICAgfSBlbHNlIGlmIChpPDMyKSB7XG4gICAgICAgIHQgKz0gIGYyKGJsLGNsLGRsKSArIGhsWzFdO1xuICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuICAgICAgICB0ICs9ICBmMyhibCxjbCxkbCkgKyBobFsyXTtcbiAgICB9IGVsc2UgaWYgKGk8NjQpIHtcbiAgICAgICAgdCArPSAgZjQoYmwsY2wsZGwpICsgaGxbM107XG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgICB0ICs9ICBmNShibCxjbCxkbCkgKyBobFs0XTtcbiAgICB9XG4gICAgdCA9IHR8MDtcbiAgICB0ID0gIHJvdGwodCxzbFtpXSk7XG4gICAgdCA9ICh0K2VsKXwwO1xuICAgIGFsID0gZWw7XG4gICAgZWwgPSBkbDtcbiAgICBkbCA9IHJvdGwoY2wsIDEwKTtcbiAgICBjbCA9IGJsO1xuICAgIGJsID0gdDtcblxuICAgIHQgPSAoYXIgKyBNW29mZnNldCt6cltpXV0pfDA7XG4gICAgaWYgKGk8MTYpe1xuICAgICAgICB0ICs9ICBmNShicixjcixkcikgKyBoclswXTtcbiAgICB9IGVsc2UgaWYgKGk8MzIpIHtcbiAgICAgICAgdCArPSAgZjQoYnIsY3IsZHIpICsgaHJbMV07XG4gICAgfSBlbHNlIGlmIChpPDQ4KSB7XG4gICAgICAgIHQgKz0gIGYzKGJyLGNyLGRyKSArIGhyWzJdO1xuICAgIH0gZWxzZSBpZiAoaTw2NCkge1xuICAgICAgICB0ICs9ICBmMihicixjcixkcikgKyBoclszXTtcbiAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG4gICAgICAgIHQgKz0gIGYxKGJyLGNyLGRyKSArIGhyWzRdO1xuICAgIH1cbiAgICB0ID0gdHwwO1xuICAgIHQgPSAgcm90bCh0LHNyW2ldKSA7XG4gICAgdCA9ICh0K2VyKXwwO1xuICAgIGFyID0gZXI7XG4gICAgZXIgPSBkcjtcbiAgICBkciA9IHJvdGwoY3IsIDEwKTtcbiAgICBjciA9IGJyO1xuICAgIGJyID0gdDtcbiAgfVxuICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICB0ICAgID0gKEhbMV0gKyBjbCArIGRyKXwwO1xuICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKXwwO1xuICBIWzJdID0gKEhbM10gKyBlbCArIGFyKXwwO1xuICBIWzNdID0gKEhbNF0gKyBhbCArIGJyKXwwO1xuICBIWzRdID0gKEhbMF0gKyBibCArIGNyKXwwO1xuICBIWzBdID0gIHQ7XG59O1xuXG5mdW5jdGlvbiBmMSh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKHkpIF4gKHopKTtcbn1cblxuZnVuY3Rpb24gZjIoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkmKHkpKSB8ICgofngpJih6KSkpO1xufVxuXG5mdW5jdGlvbiBmMyh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSB8ICh+KHkpKSkgXiAoeikpO1xufVxuXG5mdW5jdGlvbiBmNCh4LCB5LCB6KSB7XG4gIHJldHVybiAoKCh4KSAmICh6KSkgfCAoKHkpJih+KHopKSkpO1xufVxuXG5mdW5jdGlvbiBmNSh4LCB5LCB6KSB7XG4gIHJldHVybiAoKHgpIF4gKCh5KSB8KH4oeikpKSk7XG59XG5cbmZ1bmN0aW9uIHJvdGwoeCxuKSB7XG4gIHJldHVybiAoeDw8bikgfCAoeD4+PigzMi1uKSk7XG59XG5cbmZ1bmN0aW9uIHJpcGVtZDE2MChtZXNzYWdlKSB7XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4RUZDREFCODksIDB4OThCQURDRkUsIDB4MTAzMjU0NzYsIDB4QzNEMkUxRjBdO1xuXG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PSAnc3RyaW5nJylcbiAgICBtZXNzYWdlID0gbmV3IEJ1ZmZlcihtZXNzYWdlLCAndXRmOCcpO1xuXG4gIHZhciBtID0gYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpO1xuXG4gIHZhciBuQml0c0xlZnQgPSBtZXNzYWdlLmxlbmd0aCAqIDg7XG4gIHZhciBuQml0c1RvdGFsID0gbWVzc2FnZS5sZW5ndGggKiA4O1xuXG4gIC8vIEFkZCBwYWRkaW5nXG4gIG1bbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcbiAgbVsoKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICAgKCgobkJpdHNUb3RhbCA8PCA4KSAgfCAobkJpdHNUb3RhbCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcbiAgICAgICgoKG5CaXRzVG90YWwgPDwgMjQpIHwgKG5CaXRzVG90YWwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuICApO1xuXG4gIGZvciAodmFyIGk9MCA7IGk8bS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICBwcm9jZXNzQmxvY2soSCwgbSwgaSk7XG4gIH1cblxuICAvLyBTd2FwIGVuZGlhblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgLy8gU2hvcnRjdXRcbiAgICB2YXIgSF9pID0gSFtpXTtcblxuICAgIC8vIFN3YXBcbiAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcbiAgfVxuXG4gIHZhciBkaWdlc3RieXRlcyA9IHdvcmRzVG9CeXRlcyhIKTtcbiAgcmV0dXJuIG5ldyBCdWZmZXIoZGlnZXN0Ynl0ZXMpO1xufVxuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yaXBlbWQxNjAvbGliL3JpcGVtZDE2MC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJy4vY3JlYXRlLWhhc2gnKVxuXG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoMTI4KVxuemVyb0J1ZmZlci5maWxsKDApXG5cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSkgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxuICB0aGlzLl9vcGFkID0gb3BhZFxuICB0aGlzLl9hbGcgPSBhbGdcblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicpID8gMTI4IDogNjRcblxuICBrZXkgPSB0aGlzLl9rZXkgPSAhQnVmZmVyLmlzQnVmZmVyKGtleSkgPyBuZXcgQnVmZmVyKGtleSkgOiBrZXlcblxuICBpZihrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG4gIH0gZWxzZSBpZihrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCB6ZXJvQnVmZmVyXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSwgZW5jKVxuICByZXR1cm4gdGhpc1xufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICByZXR1cm4gY3JlYXRlSGFzaCh0aGlzLl9hbGcpLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KGVuYylcbn1cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NyeXB0by1icm93c2VyaWZ5L2NyZWF0ZS1obWFjLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwYmtkZjJFeHBvcnQgPSByZXF1aXJlKCdwYmtkZjItY29tcGF0L3Bia2RmMicpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNyeXB0bywgZXhwb3J0cykge1xuICBleHBvcnRzID0gZXhwb3J0cyB8fCB7fVxuXG4gIHZhciBleHBvcnRlZCA9IHBia2RmMkV4cG9ydChjcnlwdG8pXG5cbiAgZXhwb3J0cy5wYmtkZjIgPSBleHBvcnRlZC5wYmtkZjJcbiAgZXhwb3J0cy5wYmtkZjJTeW5jID0gZXhwb3J0ZWQucGJrZGYyU3luY1xuXG4gIHJldHVybiBleHBvcnRzXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3J5cHRvLWJyb3dzZXJpZnkvcGJrZGYyLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3J5cHRvKSB7XG4gIGZ1bmN0aW9uIHBia2RmMihwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBkaWdlc3QpIHtcbiAgICAgIGNhbGxiYWNrID0gZGlnZXN0XG4gICAgICBkaWdlc3QgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYWxsYmFjayBwcm92aWRlZCB0byBwYmtkZjInKVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gcGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayh1bmRlZmluZWQsIHJlc3VsdClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywga2V5bGVuLCBkaWdlc3QpIHtcbiAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBpdGVyYXRpb25zKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXRlcmF0aW9ucyBub3QgYSBudW1iZXInKVxuXG4gICAgaWYgKGl0ZXJhdGlvbnMgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGl0ZXJhdGlvbnMnKVxuXG4gICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2Yga2V5bGVuKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2V5IGxlbmd0aCBub3QgYSBudW1iZXInKVxuXG4gICAgaWYgKGtleWxlbiA8IDApXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCYWQga2V5IGxlbmd0aCcpXG5cbiAgICBkaWdlc3QgPSBkaWdlc3QgfHwgJ3NoYTEnXG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHBhc3N3b3JkID0gbmV3IEJ1ZmZlcihwYXNzd29yZClcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzYWx0KSkgc2FsdCA9IG5ldyBCdWZmZXIoc2FsdClcblxuICAgIHZhciBoTGVuLCBsID0gMSwgciwgVFxuICAgIHZhciBESyA9IG5ldyBCdWZmZXIoa2V5bGVuKVxuICAgIHZhciBibG9jazEgPSBuZXcgQnVmZmVyKHNhbHQubGVuZ3RoICsgNClcbiAgICBzYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgICAgYmxvY2sxLndyaXRlVUludDMyQkUoaSwgc2FsdC5sZW5ndGgpXG5cbiAgICAgIHZhciBVID0gY3J5cHRvLmNyZWF0ZUhtYWMoZGlnZXN0LCBwYXNzd29yZCkudXBkYXRlKGJsb2NrMSkuZGlnZXN0KClcblxuICAgICAgaWYgKCFoTGVuKSB7XG4gICAgICAgIGhMZW4gPSBVLmxlbmd0aFxuICAgICAgICBUID0gbmV3IEJ1ZmZlcihoTGVuKVxuICAgICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pXG4gICAgICAgIHIgPSBrZXlsZW4gLSAobCAtIDEpICogaExlblxuXG4gICAgICAgIGlmIChrZXlsZW4gPiAoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBoTGVuKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleWxlbiBleGNlZWRzIG1heGltdW0gbGVuZ3RoJylcbiAgICAgIH1cblxuICAgICAgVS5jb3B5KFQsIDAsIDAsIGhMZW4pXG5cbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgICAgIFUgPSBjcnlwdG8uY3JlYXRlSG1hYyhkaWdlc3QsIHBhc3N3b3JkKS51cGRhdGUoVSkuZGlnZXN0KClcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGhMZW47IGsrKykge1xuICAgICAgICAgIFRba10gXj0gVVtrXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXN0UG9zID0gKGkgLSAxKSAqIGhMZW5cbiAgICAgIHZhciBsZW4gPSAoaSA9PSBsID8gciA6IGhMZW4pXG4gICAgICBULmNvcHkoREssIGRlc3RQb3MsIDAsIGxlbilcbiAgICB9XG5cbiAgICByZXR1cm4gREtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGJrZGYyOiBwYmtkZjIsXG4gICAgcGJrZGYyU3luYzogcGJrZGYyU3luY1xuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcGJrZGYyLWNvbXBhdC9wYmtkZjIuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG4gICwgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG4gICwgdXJsID0gcmVxdWlyZSgndXJsJylcbiAgLCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG4gICwgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbiAgLCB6bGliID0gcmVxdWlyZSgnemxpYicpXG4gICwgYmwgPSByZXF1aXJlKCdibCcpXG4gICwgaGF3ayA9IHJlcXVpcmUoJ2hhd2snKVxuICAsIGF3cyA9IHJlcXVpcmUoJ2F3cy1zaWduMicpXG4gICwgaHR0cFNpZ25hdHVyZSA9IHJlcXVpcmUoJ2h0dHAtc2lnbmF0dXJlJylcbiAgLCBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpXG4gICwgc3RyaW5nc3RyZWFtID0gcmVxdWlyZSgnc3RyaW5nc3RyZWFtJylcbiAgLCBjYXNlbGVzcyA9IHJlcXVpcmUoJ2Nhc2VsZXNzJylcbiAgLCBGb3JldmVyQWdlbnQgPSByZXF1aXJlKCdmb3JldmVyLWFnZW50JylcbiAgLCBGb3JtRGF0YSA9IHJlcXVpcmUoJ2Zvcm0tZGF0YScpXG4gICwgaGVscGVycyA9IHJlcXVpcmUoJy4vbGliL2hlbHBlcnMnKVxuICAsIGNvb2tpZXMgPSByZXF1aXJlKCcuL2xpYi9jb29raWVzJylcbiAgLCBnZXRQcm94eUZyb21VUkkgPSByZXF1aXJlKCcuL2xpYi9nZXRQcm94eUZyb21VUkknKVxuICAsIFF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgnLi9saWIvcXVlcnlzdHJpbmcnKS5RdWVyeXN0cmluZ1xuICAsIEhhciA9IHJlcXVpcmUoJy4vbGliL2hhcicpLkhhclxuICAsIEF1dGggPSByZXF1aXJlKCcuL2xpYi9hdXRoJykuQXV0aFxuICAsIE9BdXRoID0gcmVxdWlyZSgnLi9saWIvb2F1dGgnKS5PQXV0aFxuICAsIE11bHRpcGFydCA9IHJlcXVpcmUoJy4vbGliL211bHRpcGFydCcpLk11bHRpcGFydFxuICAsIFJlZGlyZWN0ID0gcmVxdWlyZSgnLi9saWIvcmVkaXJlY3QnKS5SZWRpcmVjdFxuICAsIFR1bm5lbCA9IHJlcXVpcmUoJy4vbGliL3R1bm5lbCcpLlR1bm5lbFxuXG52YXIgc2FmZVN0cmluZ2lmeSA9IGhlbHBlcnMuc2FmZVN0cmluZ2lmeVxuICAsIGlzUmVhZFN0cmVhbSA9IGhlbHBlcnMuaXNSZWFkU3RyZWFtXG4gICwgdG9CYXNlNjQgPSBoZWxwZXJzLnRvQmFzZTY0XG4gICwgZGVmZXIgPSBoZWxwZXJzLmRlZmVyXG4gICwgY29weSA9IGhlbHBlcnMuY29weVxuICAsIGdsb2JhbENvb2tpZUphciA9IGNvb2tpZXMuamFyKClcblxuXG52YXIgZ2xvYmFsUG9vbCA9IHt9XG5cbmZ1bmN0aW9uIGZpbHRlckZvck5vblJlc2VydmVkKHJlc2VydmVkLCBvcHRpb25zKSB7XG4gIC8vIEZpbHRlciBvdXQgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgcmVzZXJ2ZWQuXG4gIC8vIFJlc2VydmVkIHZhbHVlcyBhcmUgcGFzc2VkIGluIGF0IGNhbGwgc2l0ZS5cblxuICB2YXIgb2JqZWN0ID0ge31cbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgdmFyIG5vdFJlc2VydmVkID0gKHJlc2VydmVkLmluZGV4T2YoaSkgPT09IC0xKVxuICAgIGlmIChub3RSZXNlcnZlZCkge1xuICAgICAgb2JqZWN0W2ldID0gb3B0aW9uc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0XG59XG5cbmZ1bmN0aW9uIGZpbHRlck91dFJlc2VydmVkRnVuY3Rpb25zKHJlc2VydmVkLCBvcHRpb25zKSB7XG4gIC8vIEZpbHRlciBvdXQgcHJvcGVydGllcyB0aGF0IGFyZSBmdW5jdGlvbnMgYW5kIGFyZSByZXNlcnZlZC5cbiAgLy8gUmVzZXJ2ZWQgdmFsdWVzIGFyZSBwYXNzZWQgaW4gYXQgY2FsbCBzaXRlLlxuXG4gIHZhciBvYmplY3QgPSB7fVxuICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICB2YXIgaXNSZXNlcnZlZCA9ICEocmVzZXJ2ZWQuaW5kZXhPZihpKSA9PT0gLTEpXG4gICAgdmFyIGlzRnVuY3Rpb24gPSAodHlwZW9mIG9wdGlvbnNbaV0gPT09ICdmdW5jdGlvbicpXG4gICAgaWYgKCEoaXNSZXNlcnZlZCAmJiBpc0Z1bmN0aW9uKSkge1xuICAgICAgb2JqZWN0W2ldID0gb3B0aW9uc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0XG5cbn1cblxuLy8gRnVuY3Rpb24gZm9yIHByb3Blcmx5IGhhbmRsaW5nIGEgY29ubmVjdGlvbiBlcnJvclxuZnVuY3Rpb24gY29ubmVjdGlvbkVycm9ySGFuZGxlcihlcnJvcikge1xuICB2YXIgc29ja2V0ID0gdGhpc1xuICBpZiAoc29ja2V0LnJlcykge1xuICAgIGlmIChzb2NrZXQucmVzLnJlcXVlc3QpIHtcbiAgICAgIHNvY2tldC5yZXMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQucmVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvY2tldC5faHR0cE1lc3NhZ2UuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgfVxufVxuXG4vLyBSZXR1cm4gYSBzaW1wbGVyIHJlcXVlc3Qgb2JqZWN0IHRvIGFsbG93IHNlcmlhbGl6YXRpb25cbmZ1bmN0aW9uIHJlcXVlc3RUb0pTT04oKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4ge1xuICAgIHVyaTogc2VsZi51cmksXG4gICAgbWV0aG9kOiBzZWxmLm1ldGhvZCxcbiAgICBoZWFkZXJzOiBzZWxmLmhlYWRlcnNcbiAgfVxufVxuXG4vLyBSZXR1cm4gYSBzaW1wbGVyIHJlc3BvbnNlIG9iamVjdCB0byBhbGxvdyBzZXJpYWxpemF0aW9uXG5mdW5jdGlvbiByZXNwb25zZVRvSlNPTigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogc2VsZi5zdGF0dXNDb2RlLFxuICAgIGJvZHk6IHNlbGYuYm9keSxcbiAgICBoZWFkZXJzOiBzZWxmLmhlYWRlcnMsXG4gICAgcmVxdWVzdDogcmVxdWVzdFRvSlNPTi5jYWxsKHNlbGYucmVxdWVzdClcbiAgfVxufVxuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRpb25zKSB7XG4gIC8vIGlmIGdpdmVuIHRoZSBtZXRob2QgcHJvcGVydHkgaW4gb3B0aW9ucywgc2V0IHByb3BlcnR5IGV4cGxpY2l0TWV0aG9kIHRvIHRydWVcblxuICAvLyBleHRlbmQgdGhlIFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBhbnkgbm9uLXJlc2VydmVkIHByb3BlcnRpZXNcbiAgLy8gcmVtb3ZlIGFueSByZXNlcnZlZCBmdW5jdGlvbnMgZnJvbSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgLy8gc2V0IFJlcXVlc3QgaW5zdGFuY2UgdG8gYmUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4gIC8vIGNhbGwgaW5pdFxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIHN0YXJ0IHdpdGggSEFSLCB0aGVuIG92ZXJyaWRlIHdpdGggYWRkaXRpb25hbCBvcHRpb25zXG4gIGlmIChvcHRpb25zLmhhcikge1xuICAgIHNlbGYuX2hhciA9IG5ldyBIYXIoc2VsZilcbiAgICBvcHRpb25zID0gc2VsZi5faGFyLm9wdGlvbnMob3B0aW9ucylcbiAgfVxuXG4gIHN0cmVhbS5TdHJlYW0uY2FsbChzZWxmKVxuICB2YXIgcmVzZXJ2ZWQgPSBPYmplY3Qua2V5cyhSZXF1ZXN0LnByb3RvdHlwZSlcbiAgdmFyIG5vblJlc2VydmVkID0gZmlsdGVyRm9yTm9uUmVzZXJ2ZWQocmVzZXJ2ZWQsIG9wdGlvbnMpXG5cbiAgc3RyZWFtLlN0cmVhbS5jYWxsKHNlbGYpXG4gIHV0aWwuX2V4dGVuZChzZWxmLCBub25SZXNlcnZlZClcbiAgb3B0aW9ucyA9IGZpbHRlck91dFJlc2VydmVkRnVuY3Rpb25zKHJlc2VydmVkLCBvcHRpb25zKVxuXG4gIHNlbGYucmVhZGFibGUgPSB0cnVlXG4gIHNlbGYud3JpdGFibGUgPSB0cnVlXG4gIGlmIChvcHRpb25zLm1ldGhvZCkge1xuICAgIHNlbGYuZXhwbGljaXRNZXRob2QgPSB0cnVlXG4gIH1cbiAgc2VsZi5fcXMgPSBuZXcgUXVlcnlzdHJpbmcoc2VsZilcbiAgc2VsZi5fYXV0aCA9IG5ldyBBdXRoKHNlbGYpXG4gIHNlbGYuX29hdXRoID0gbmV3IE9BdXRoKHNlbGYpXG4gIHNlbGYuX211bHRpcGFydCA9IG5ldyBNdWx0aXBhcnQoc2VsZilcbiAgc2VsZi5fcmVkaXJlY3QgPSBuZXcgUmVkaXJlY3Qoc2VsZilcbiAgc2VsZi5fdHVubmVsID0gbmV3IFR1bm5lbChzZWxmKVxuICBzZWxmLmluaXQob3B0aW9ucylcbn1cblxudXRpbC5pbmhlcml0cyhSZXF1ZXN0LCBzdHJlYW0uU3RyZWFtKVxuXG4vLyBEZWJ1Z2dpbmdcblJlcXVlc3QuZGVidWcgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmIC9cXGJyZXF1ZXN0XFxiLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG5mdW5jdGlvbiBkZWJ1ZygpIHtcbiAgaWYgKFJlcXVlc3QuZGVidWcpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSRVFVRVNUICVzJywgdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZGVidWcgPSBkZWJ1Z1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gaW5pdCgpIGNvbnRhaW5zIGFsbCB0aGUgY29kZSB0byBzZXR1cCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gIC8vIHRoZSBhY3R1YWwgb3V0Z29pbmcgcmVxdWVzdCBpcyBub3Qgc3RhcnRlZCB1bnRpbCBzdGFydCgpIGlzIGNhbGxlZFxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIGJvdGggdGhlIGNvbnN0cnVjdG9yIGFuZCBvbiByZWRpcmVjdC5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG4gIHNlbGYuaGVhZGVycyA9IHNlbGYuaGVhZGVycyA/IGNvcHkoc2VsZi5oZWFkZXJzKSA6IHt9XG5cbiAgLy8gRGVsZXRlIGhlYWRlcnMgd2l0aCB2YWx1ZSB1bmRlZmluZWQgc2luY2UgdGhleSBicmVha1xuICAvLyBDbGllbnRSZXF1ZXN0Lk91dGdvaW5nTWVzc2FnZS5zZXRIZWFkZXIgaW4gbm9kZSAwLjEyXG4gIGZvciAodmFyIGhlYWRlck5hbWUgaW4gc2VsZi5oZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmhlYWRlcnNbaGVhZGVyTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWxldGUgc2VsZi5oZWFkZXJzW2hlYWRlck5hbWVdXG4gICAgfVxuICB9XG5cbiAgY2FzZWxlc3MuaHR0cGlmeShzZWxmLCBzZWxmLmhlYWRlcnMpXG5cbiAgaWYgKCFzZWxmLm1ldGhvZCkge1xuICAgIHNlbGYubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCdcbiAgfVxuICBpZiAoIXNlbGYubG9jYWxBZGRyZXNzKSB7XG4gICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBvcHRpb25zLmxvY2FsQWRkcmVzc1xuICB9XG5cbiAgc2VsZi5fcXMuaW5pdChvcHRpb25zKVxuXG4gIGRlYnVnKG9wdGlvbnMpXG4gIGlmICghc2VsZi5wb29sICYmIHNlbGYucG9vbCAhPT0gZmFsc2UpIHtcbiAgICBzZWxmLnBvb2wgPSBnbG9iYWxQb29sXG4gIH1cbiAgc2VsZi5kZXN0cyA9IHNlbGYuZGVzdHMgfHwgW11cbiAgc2VsZi5fX2lzUmVxdWVzdFJlcXVlc3QgPSB0cnVlXG5cbiAgLy8gUHJvdGVjdCBhZ2FpbnN0IGRvdWJsZSBjYWxsYmFja1xuICBpZiAoIXNlbGYuX2NhbGxiYWNrICYmIHNlbGYuY2FsbGJhY2spIHtcbiAgICBzZWxmLl9jYWxsYmFjayA9IHNlbGYuY2FsbGJhY2tcbiAgICBzZWxmLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX2NhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgIHJldHVybiAvLyBQcmludCBhIHdhcm5pbmcgbWF5YmU/XG4gICAgICB9XG4gICAgICBzZWxmLl9jYWxsYmFja0NhbGxlZCA9IHRydWVcbiAgICAgIHNlbGYuX2NhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gICAgc2VsZi5vbignZXJyb3InLCBzZWxmLmNhbGxiYWNrLmJpbmQoKSlcbiAgICBzZWxmLm9uKCdjb21wbGV0ZScsIHNlbGYuY2FsbGJhY2suYmluZChzZWxmLCBudWxsKSlcbiAgfVxuXG4gIC8vIFBlb3BsZSB1c2UgdGhpcyBwcm9wZXJ0eSBpbnN0ZWFkIGFsbCB0aGUgdGltZSwgc28gc3VwcG9ydCBpdFxuICBpZiAoIXNlbGYudXJpICYmIHNlbGYudXJsKSB7XG4gICAgc2VsZi51cmkgPSBzZWxmLnVybFxuICAgIGRlbGV0ZSBzZWxmLnVybFxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBhIGJhc2VVcmwsIHRoZW4gdXNlIGl0IGFzIHRoZSBiYXNlIFVSTCAoaS5lLiB1cmkgbXVzdCBiZVxuICAvLyBzcGVjaWZpZWQgYXMgYSByZWxhdGl2ZSBwYXRoIGFuZCBpcyBhcHBlbmRlZCB0byBiYXNlVXJsKS5cbiAgaWYgKHNlbGYuYmFzZVVybCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZi5iYXNlVXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ29wdGlvbnMuYmFzZVVybCBtdXN0IGJlIGEgc3RyaW5nJykpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZWxmLnVyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvcHRpb25zLnVyaSBtdXN0IGJlIGEgc3RyaW5nIHdoZW4gdXNpbmcgb3B0aW9ucy5iYXNlVXJsJykpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYudXJpLmluZGV4T2YoJy8vJykgPT09IDAgfHwgc2VsZi51cmkuaW5kZXhPZignOi8vJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy51cmkgbXVzdCBiZSBhIHBhdGggd2hlbiB1c2luZyBvcHRpb25zLmJhc2VVcmwnKSlcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYWxsIGNhc2VzIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXJlJ3Mgb25seSBvbmUgc2xhc2ggYmV0d2VlblxuICAgIC8vIGJhc2VVcmwgYW5kIHVyaS5cbiAgICB2YXIgYmFzZVVybEVuZHNXaXRoU2xhc2ggPSBzZWxmLmJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSA9PT0gc2VsZi5iYXNlVXJsLmxlbmd0aCAtIDFcbiAgICB2YXIgdXJpU3RhcnRzV2l0aFNsYXNoID0gc2VsZi51cmkuaW5kZXhPZignLycpID09PSAwXG5cbiAgICBpZiAoYmFzZVVybEVuZHNXaXRoU2xhc2ggJiYgdXJpU3RhcnRzV2l0aFNsYXNoKSB7XG4gICAgICBzZWxmLnVyaSA9IHNlbGYuYmFzZVVybCArIHNlbGYudXJpLnNsaWNlKDEpXG4gICAgfSBlbHNlIGlmIChiYXNlVXJsRW5kc1dpdGhTbGFzaCB8fCB1cmlTdGFydHNXaXRoU2xhc2gpIHtcbiAgICAgIHNlbGYudXJpID0gc2VsZi5iYXNlVXJsICsgc2VsZi51cmlcbiAgICB9IGVsc2UgaWYgKHNlbGYudXJpID09PSAnJykge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmxcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmwgKyAnLycgKyBzZWxmLnVyaVxuICAgIH1cbiAgICBkZWxldGUgc2VsZi5iYXNlVXJsXG4gIH1cblxuICAvLyBBIFVSSSBpcyBuZWVkZWQgYnkgdGhpcyBwb2ludCwgZW1pdCBlcnJvciBpZiB3ZSBoYXZlbid0IGJlZW4gYWJsZSB0byBnZXQgb25lXG4gIGlmICghc2VsZi51cmkpIHtcbiAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy51cmkgaXMgYSByZXF1aXJlZCBhcmd1bWVudCcpKVxuICB9XG5cbiAgLy8gSWYgYSBzdHJpbmcgVVJJL1VSTCB3YXMgZ2l2ZW4sIHBhcnNlIGl0IGludG8gYSBVUkwgb2JqZWN0XG4gIGlmICh0eXBlb2Ygc2VsZi51cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi51cmkgPSB1cmwucGFyc2Uoc2VsZi51cmkpXG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBXYXJuaW5nIGZvciB1c2VycyBvZiB0aGUgb2xkIFVuaXggU29ja2V0cyBVUkwgU2NoZW1lXG4gIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ3VuaXg6Jykge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdgdW5peDovL2AgVVJMIHNjaGVtZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHRoZSBmb3JtYXQgYGh0dHA6Ly91bml4OlNPQ0tFVDpQQVRIYCcpKVxuICB9XG5cbiAgLy8gU3VwcG9ydCBVbml4IFNvY2tldHNcbiAgaWYgKHNlbGYudXJpLmhvc3QgPT09ICd1bml4Jykge1xuICAgIC8vIEdldCB0aGUgc29ja2V0ICYgcmVxdWVzdCBwYXRocyBmcm9tIHRoZSBVUkxcbiAgICB2YXIgdW5peFBhcnRzID0gc2VsZi51cmkucGF0aC5zcGxpdCgnOicpXG4gICAgICAsIGhvc3QgPSB1bml4UGFydHNbMF1cbiAgICAgICwgcGF0aCA9IHVuaXhQYXJ0c1sxXVxuICAgIC8vIEFwcGx5IHVuaXggcHJvcGVydGllcyB0byByZXF1ZXN0XG4gICAgc2VsZi5zb2NrZXRQYXRoID0gaG9zdFxuICAgIHNlbGYudXJpLnBhdGhuYW1lID0gcGF0aFxuICAgIHNlbGYudXJpLnBhdGggPSBwYXRoXG4gICAgc2VsZi51cmkuaG9zdCA9IGhvc3RcbiAgICBzZWxmLnVyaS5ob3N0bmFtZSA9IGhvc3RcbiAgICBzZWxmLnVyaS5pc1VuaXggPSB0cnVlXG4gIH1cblxuICBpZiAoc2VsZi5zdHJpY3RTU0wgPT09IGZhbHNlKSB7XG4gICAgc2VsZi5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaWYgKCFzZWxmLnVyaS5wYXRobmFtZSkge3NlbGYudXJpLnBhdGhuYW1lID0gJy8nfVxuXG4gIGlmICghKHNlbGYudXJpLmhvc3QgfHwgKHNlbGYudXJpLmhvc3RuYW1lICYmIHNlbGYudXJpLnBvcnQpKSAmJiAhc2VsZi51cmkuaXNVbml4KSB7XG4gICAgLy8gSW52YWxpZCBVUkk6IGl0IG1heSBnZW5lcmF0ZSBsb3Qgb2YgYmFkIGVycm9ycywgbGlrZSAnVHlwZUVycm9yOiBDYW5ub3QgY2FsbCBtZXRob2QgYGluZGV4T2ZgIG9mIHVuZGVmaW5lZCcgaW4gQ29va2llSmFyXG4gICAgLy8gRGV0ZWN0IGFuZCByZWplY3QgaXQgYXMgc29vbiBhcyBwb3NzaWJsZVxuICAgIHZhciBmYXVsdHlVcmkgPSB1cmwuZm9ybWF0KHNlbGYudXJpKVxuICAgIHZhciBtZXNzYWdlID0gJ0ludmFsaWQgVVJJIFwiJyArIGZhdWx0eVVyaSArICdcIidcbiAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBObyBvcHRpb24gPyBUaGlzIGNhbiBiZSB0aGUgc2lnbiBvZiBhIHJlZGlyZWN0XG4gICAgICAvLyBBcyB0aGlzIGlzIGEgY2FzZSB3aGVyZSB0aGUgdXNlciBjYW5ub3QgZG8gYW55dGhpbmcgKHRoZXkgZGlkbid0IGNhbGwgcmVxdWVzdCBkaXJlY3RseSB3aXRoIHRoaXMgVVJMKVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgd2FybmVkIHRoYXQgaXQgY2FuIGJlIGNhdXNlZCBieSBhIHJlZGlyZWN0aW9uIChjYW4gc2F2ZSBzb21lIGhhaXIpXG4gICAgICBtZXNzYWdlICs9ICcuIFRoaXMgY2FuIGJlIGNhdXNlZCBieSBhIGNyYXBweSByZWRpcmVjdGlvbi4nXG4gICAgfVxuICAgIC8vIFRoaXMgZXJyb3Igd2FzIGZhdGFsXG4gICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpXG4gIH1cblxuICBpZiAoIXNlbGYuaGFzT3duUHJvcGVydHkoJ3Byb3h5JykpIHtcbiAgICBzZWxmLnByb3h5ID0gZ2V0UHJveHlGcm9tVVJJKHNlbGYudXJpKVxuICB9XG5cbiAgc2VsZi50dW5uZWwgPSBzZWxmLl90dW5uZWwuaXNFbmFibGVkKG9wdGlvbnMpXG4gIGlmIChzZWxmLnByb3h5KSB7XG4gICAgc2VsZi5fdHVubmVsLnNldHVwKG9wdGlvbnMpXG4gIH1cblxuICBzZWxmLl9yZWRpcmVjdC5vblJlcXVlc3Qob3B0aW9ucylcblxuICBzZWxmLnNldEhvc3QgPSBmYWxzZVxuICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdob3N0JykpIHtcbiAgICB2YXIgaG9zdEhlYWRlck5hbWUgPSBzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUgfHwgJ2hvc3QnXG4gICAgc2VsZi5zZXRIZWFkZXIoaG9zdEhlYWRlck5hbWUsIHNlbGYudXJpLmhvc3RuYW1lKVxuICAgIGlmIChzZWxmLnVyaS5wb3J0KSB7XG4gICAgICBpZiAoICEoc2VsZi51cmkucG9ydCA9PT0gODAgJiYgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwOicpICYmXG4gICAgICAgICAgICEoc2VsZi51cmkucG9ydCA9PT0gNDQzICYmIHNlbGYudXJpLnByb3RvY29sID09PSAnaHR0cHM6JykgKSB7XG4gICAgICAgIHNlbGYuc2V0SGVhZGVyKGhvc3RIZWFkZXJOYW1lLCBzZWxmLmdldEhlYWRlcignaG9zdCcpICsgKCc6JyArIHNlbGYudXJpLnBvcnQpIClcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5zZXRIb3N0ID0gdHJ1ZVxuICB9XG5cbiAgc2VsZi5qYXIoc2VsZi5famFyIHx8IG9wdGlvbnMuamFyKVxuXG4gIGlmICghc2VsZi51cmkucG9ydCkge1xuICAgIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge3NlbGYudXJpLnBvcnQgPSA4MH1cbiAgICBlbHNlIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtzZWxmLnVyaS5wb3J0ID0gNDQzfVxuICB9XG5cbiAgaWYgKHNlbGYucHJveHkgJiYgIXNlbGYudHVubmVsKSB7XG4gICAgc2VsZi5wb3J0ID0gc2VsZi5wcm94eS5wb3J0XG4gICAgc2VsZi5ob3N0ID0gc2VsZi5wcm94eS5ob3N0bmFtZVxuICB9IGVsc2Uge1xuICAgIHNlbGYucG9ydCA9IHNlbGYudXJpLnBvcnRcbiAgICBzZWxmLmhvc3QgPSBzZWxmLnVyaS5ob3N0bmFtZVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgIHNlbGYuZm9ybShvcHRpb25zLmZvcm0pXG4gIH1cblxuICBpZiAob3B0aW9ucy5mb3JtRGF0YSkge1xuICAgIHZhciBmb3JtRGF0YSA9IG9wdGlvbnMuZm9ybURhdGFcbiAgICB2YXIgcmVxdWVzdEZvcm0gPSBzZWxmLmZvcm0oKVxuICAgIHZhciBhcHBlbmRGb3JtVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCd2YWx1ZScpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcbiAgICAgICAgcmVxdWVzdEZvcm0uYXBwZW5kKGtleSwgdmFsdWUudmFsdWUsIHZhbHVlLm9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0Rm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZm9ybUtleSBpbiBmb3JtRGF0YSkge1xuICAgICAgaWYgKGZvcm1EYXRhLmhhc093blByb3BlcnR5KGZvcm1LZXkpKSB7XG4gICAgICAgIHZhciBmb3JtVmFsdWUgPSBmb3JtRGF0YVtmb3JtS2V5XVxuICAgICAgICBpZiAoZm9ybVZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcm1WYWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgYXBwZW5kRm9ybVZhbHVlKGZvcm1LZXksIGZvcm1WYWx1ZVtqXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kRm9ybVZhbHVlKGZvcm1LZXksIGZvcm1WYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnFzKSB7XG4gICAgc2VsZi5xcyhvcHRpb25zLnFzKVxuICB9XG5cbiAgaWYgKHNlbGYudXJpLnBhdGgpIHtcbiAgICBzZWxmLnBhdGggPSBzZWxmLnVyaS5wYXRoXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wYXRoID0gc2VsZi51cmkucGF0aG5hbWUgKyAoc2VsZi51cmkuc2VhcmNoIHx8ICcnKVxuICB9XG5cbiAgaWYgKHNlbGYucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBzZWxmLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIEF1dGggbXVzdCBoYXBwZW4gbGFzdCBpbiBjYXNlIHNpZ25pbmcgaXMgZGVwZW5kZW50IG9uIG90aGVyIGhlYWRlcnNcbiAgaWYgKG9wdGlvbnMuYXdzKSB7XG4gICAgc2VsZi5hd3Mob3B0aW9ucy5hd3MpXG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXdrKSB7XG4gICAgc2VsZi5oYXdrKG9wdGlvbnMuaGF3aylcbiAgfVxuXG4gIGlmIChvcHRpb25zLmh0dHBTaWduYXR1cmUpIHtcbiAgICBzZWxmLmh0dHBTaWduYXR1cmUob3B0aW9ucy5odHRwU2lnbmF0dXJlKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXV0aCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5hdXRoLCAndXNlcm5hbWUnKSkge1xuICAgICAgb3B0aW9ucy5hdXRoLnVzZXIgPSBvcHRpb25zLmF1dGgudXNlcm5hbWVcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLmF1dGgsICdwYXNzd29yZCcpKSB7XG4gICAgICBvcHRpb25zLmF1dGgucGFzcyA9IG9wdGlvbnMuYXV0aC5wYXNzd29yZFxuICAgIH1cblxuICAgIHNlbGYuYXV0aChcbiAgICAgIG9wdGlvbnMuYXV0aC51c2VyLFxuICAgICAgb3B0aW9ucy5hdXRoLnBhc3MsXG4gICAgICBvcHRpb25zLmF1dGguc2VuZEltbWVkaWF0ZWx5LFxuICAgICAgb3B0aW9ucy5hdXRoLmJlYXJlclxuICAgIClcbiAgfVxuXG4gIGlmIChzZWxmLmd6aXAgJiYgIXNlbGYuaGFzSGVhZGVyKCdhY2NlcHQtZW5jb2RpbmcnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCcpXG4gIH1cblxuICBpZiAoc2VsZi51cmkuYXV0aCAmJiAhc2VsZi5oYXNIZWFkZXIoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgIHZhciB1cmlBdXRoUGllY2VzID0gc2VsZi51cmkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbihpdGVtKSB7cmV0dXJuIHNlbGYuX3FzLnVuZXNjYXBlKGl0ZW0pfSlcbiAgICBzZWxmLmF1dGgodXJpQXV0aFBpZWNlc1swXSwgdXJpQXV0aFBpZWNlcy5zbGljZSgxKS5qb2luKCc6JyksIHRydWUpXG4gIH1cblxuICBpZiAoIXNlbGYudHVubmVsICYmIHNlbGYucHJveHkgJiYgc2VsZi5wcm94eS5hdXRoICYmICFzZWxmLmhhc0hlYWRlcigncHJveHktYXV0aG9yaXphdGlvbicpKSB7XG4gICAgdmFyIHByb3h5QXV0aFBpZWNlcyA9IHNlbGYucHJveHkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbihpdGVtKSB7cmV0dXJuIHNlbGYuX3FzLnVuZXNjYXBlKGl0ZW0pfSlcbiAgICB2YXIgYXV0aEhlYWRlciA9ICdCYXNpYyAnICsgdG9CYXNlNjQocHJveHlBdXRoUGllY2VzLmpvaW4oJzonKSlcbiAgICBzZWxmLnNldEhlYWRlcigncHJveHktYXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXIpXG4gIH1cblxuICBpZiAoc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwpIHtcbiAgICBzZWxmLnBhdGggPSAoc2VsZi51cmkucHJvdG9jb2wgKyAnLy8nICsgc2VsZi51cmkuaG9zdCArIHNlbGYucGF0aClcbiAgfVxuXG4gIGlmIChvcHRpb25zLmpzb24pIHtcbiAgICBzZWxmLmpzb24ob3B0aW9ucy5qc29uKVxuICB9XG4gIGlmIChvcHRpb25zLm11bHRpcGFydCkge1xuICAgIHNlbGYubXVsdGlwYXJ0KG9wdGlvbnMubXVsdGlwYXJ0KVxuICB9XG5cbiAgaWYgKG9wdGlvbnMudGltZSkge1xuICAgIHNlbGYudGltaW5nID0gdHJ1ZVxuICAgIHNlbGYuZWxhcHNlZFRpbWUgPSBzZWxmLmVsYXBzZWRUaW1lIHx8IDBcbiAgfVxuXG4gIGlmIChzZWxmLmJvZHkpIHtcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlbGYuYm9keSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYuYm9keSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2VsZi5ib2R5W2ldLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmJvZHkgPSBuZXcgQnVmZmVyKHNlbGYuYm9keSlcbiAgICAgICAgbGVuZ3RoID0gc2VsZi5ib2R5Lmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBzZWxmLmJvZHkubGVuZ3RoXG4gICAgfVxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgbGVuZ3RoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvciwgb3B0aW9ucy5ib2R5LicpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLm9hdXRoKSB7XG4gICAgc2VsZi5vYXV0aChvcHRpb25zLm9hdXRoKVxuICB9IGVsc2UgaWYgKHNlbGYuX29hdXRoLnBhcmFtcyAmJiBzZWxmLmhhc0hlYWRlcignYXV0aG9yaXphdGlvbicpKSB7XG4gICAgc2VsZi5vYXV0aChzZWxmLl9vYXV0aC5wYXJhbXMpXG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSBzZWxmLnByb3h5ICYmICFzZWxmLnR1bm5lbCA/IHNlbGYucHJveHkucHJvdG9jb2wgOiBzZWxmLnVyaS5wcm90b2NvbFxuICAgICwgZGVmYXVsdE1vZHVsZXMgPSB7J2h0dHA6JzpodHRwLCAnaHR0cHM6JzpodHRwc31cbiAgICAsIGh0dHBNb2R1bGVzID0gc2VsZi5odHRwTW9kdWxlcyB8fCB7fVxuXG4gIHNlbGYuaHR0cE1vZHVsZSA9IGh0dHBNb2R1bGVzW3Byb3RvY29sXSB8fCBkZWZhdWx0TW9kdWxlc1twcm90b2NvbF1cblxuICBpZiAoIXNlbGYuaHR0cE1vZHVsZSkge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sOiAnICsgcHJvdG9jb2wpKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2EpIHtcbiAgICBzZWxmLmNhID0gb3B0aW9ucy5jYVxuICB9XG5cbiAgaWYgKCFzZWxmLmFnZW50KSB7XG4gICAgaWYgKG9wdGlvbnMuYWdlbnRPcHRpb25zKSB7XG4gICAgICBzZWxmLmFnZW50T3B0aW9ucyA9IG9wdGlvbnMuYWdlbnRPcHRpb25zXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWdlbnRDbGFzcykge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gb3B0aW9ucy5hZ2VudENsYXNzXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcmV2ZXIpIHtcbiAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IHByb3RvY29sID09PSAnaHR0cDonID8gRm9yZXZlckFnZW50IDogRm9yZXZlckFnZW50LlNTTFxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFnZW50Q2xhc3MgPSBzZWxmLmh0dHBNb2R1bGUuQWdlbnRcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5wb29sID09PSBmYWxzZSkge1xuICAgIHNlbGYuYWdlbnQgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHNlbGYuYWdlbnQgPSBzZWxmLmFnZW50IHx8IHNlbGYuZ2V0TmV3QWdlbnQoKVxuICB9XG5cbiAgc2VsZi5vbigncGlwZScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICBpZiAoc2VsZi5udGljayAmJiBzZWxmLl9zdGFydGVkKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBpcGUgdG8gdGhpcyBzdHJlYW0gYWZ0ZXIgdGhlIG91dGJvdW5kIHJlcXVlc3QgaGFzIHN0YXJ0ZWQuJykpXG4gICAgfVxuICAgIHNlbGYuc3JjID0gc3JjXG4gICAgaWYgKGlzUmVhZFN0cmVhbShzcmMpKSB7XG4gICAgICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgbWltZS5sb29rdXAoc3JjLnBhdGgpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjLmhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzcmMuaGVhZGVycykge1xuICAgICAgICAgIGlmICghc2VsZi5oYXNIZWFkZXIoaSkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0SGVhZGVyKGksIHNyYy5oZWFkZXJzW2ldKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuX2pzb24gJiYgIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgICAgfVxuICAgICAgaWYgKHNyYy5tZXRob2QgJiYgIXNlbGYuZXhwbGljaXRNZXRob2QpIHtcbiAgICAgICAgc2VsZi5tZXRob2QgPSBzcmMubWV0aG9kXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2VsZi5vbigncGlwZScsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgcGlwZWQgdG8gdGhpcyBzdHJlYW0uIFBpcGVpbmcgdHdpY2UgaXMgbGlrZWx5IHRvIGJyZWFrIHRoZSByZXF1ZXN0LicpXG4gICAgLy8gfSlcbiAgfSlcblxuICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2Fib3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fZm9ybSkge1xuICAgICAgICBpZiAoIXNlbGYuX2F1dGguaGFzQXV0aCkge1xuICAgICAgICAgIHNlbGYuX2Zvcm0ucGlwZShzZWxmKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGYuX2F1dGguaGFzQXV0aCAmJiBzZWxmLl9hdXRoLnNlbnRBdXRoKSB7XG4gICAgICAgICAgc2VsZi5fZm9ybS5waXBlKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl9tdWx0aXBhcnQgJiYgc2VsZi5fbXVsdGlwYXJ0LmNodW5rZWQpIHtcbiAgICAgICAgc2VsZi5fbXVsdGlwYXJ0LmJvZHkucGlwZShzZWxmKVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuYm9keSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLmJvZHkpKSB7XG4gICAgICAgICAgc2VsZi5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgIHNlbGYud3JpdGUocGFydClcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYud3JpdGUoc2VsZi5ib2R5KVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW5kKClcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5yZXF1ZXN0Qm9keVN0cmVhbSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ29wdGlvbnMucmVxdWVzdEJvZHlTdHJlYW0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHBhc3MgdGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHN0cmVhbS5waXBlLicpXG4gICAgICAgIHNlbGYucmVxdWVzdEJvZHlTdHJlYW0ucGlwZShzZWxmKVxuICAgICAgfSBlbHNlIGlmICghc2VsZi5zcmMpIHtcbiAgICAgICAgaWYgKHNlbGYuX2F1dGguaGFzQXV0aCAmJiAhc2VsZi5fYXV0aC5zZW50QXV0aCkge1xuICAgICAgICAgIHNlbGYuZW5kKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5tZXRob2QgIT09ICdHRVQnICYmIHR5cGVvZiBzZWxmLm1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCAwKVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW5kKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZm9ybSAmJiAhc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIC8vIEJlZm9yZSBlbmRpbmcgdGhlIHJlcXVlc3QsIHdlIGhhZCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHdob2xlIGZvcm0sIGFzeW5jbHlcbiAgICAgIHNlbGYuc2V0SGVhZGVyKHNlbGYuX2Zvcm0uZ2V0SGVhZGVycygpKVxuICAgICAgc2VsZi5fZm9ybS5nZXRMZW5ndGgoZnVuY3Rpb24gKGVyciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgbGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIGVuZCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmQoKVxuICAgIH1cblxuICAgIHNlbGYubnRpY2sgPSB0cnVlXG4gIH0pXG5cbn1cblxuLy8gTXVzdCBjYWxsIHRoaXMgd2hlbiBmb2xsb3dpbmcgYSByZWRpcmVjdCBmcm9tIGh0dHBzIHRvIGh0dHAgb3IgdmljZSB2ZXJzYVxuLy8gQXR0ZW1wdHMgdG8ga2VlcCBldmVyeXRoaW5nIGFzIGlkZW50aWNhbCBhcyBwb3NzaWJsZSwgYnV0IHVwZGF0ZSB0aGVcbi8vIGh0dHBNb2R1bGUsIFR1bm5lbGluZyBhZ2VudCwgYW5kL29yIEZvcmV2ZXIgQWdlbnQgaW4gdXNlLlxuUmVxdWVzdC5wcm90b3R5cGUuX3VwZGF0ZVByb3RvY29sID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHByb3RvY29sID0gc2VsZi51cmkucHJvdG9jb2xcblxuICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonIHx8IHNlbGYudHVubmVsKSB7XG4gICAgLy8gcHJldmlvdXNseSB3YXMgZG9pbmcgaHR0cCwgbm93IGRvaW5nIGh0dHBzXG4gICAgLy8gaWYgaXQncyBodHRwcywgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIHR1bm5lbCBub3cuXG4gICAgaWYgKHNlbGYucHJveHkpIHtcbiAgICAgIGlmIChzZWxmLl90dW5uZWwuc2V0dXAoKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmh0dHBNb2R1bGUgPSBodHRwc1xuICAgIHN3aXRjaCAoc2VsZi5hZ2VudENsYXNzKSB7XG4gICAgICBjYXNlIEZvcmV2ZXJBZ2VudDpcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gRm9yZXZlckFnZW50LlNTTFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBodHRwLkFnZW50OlxuICAgICAgICBzZWxmLmFnZW50Q2xhc3MgPSBodHRwcy5BZ2VudFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbm90aGluZyB3ZSBjYW4gZG8uICBKdXN0IGhvcGUgZm9yIHRoZSBiZXN0LlxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSdzIGFuIGFnZW50LCB3ZSBuZWVkIHRvIGdldCBhIG5ldyBvbmUuXG4gICAgaWYgKHNlbGYuYWdlbnQpIHtcbiAgICAgIHNlbGYuYWdlbnQgPSBzZWxmLmdldE5ld0FnZW50KClcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBwcmV2aW91c2x5IHdhcyBkb2luZyBodHRwcywgbm93IGRvaW5nIGh0dHBcbiAgICBzZWxmLmh0dHBNb2R1bGUgPSBodHRwXG4gICAgc3dpdGNoIChzZWxmLmFnZW50Q2xhc3MpIHtcbiAgICAgIGNhc2UgRm9yZXZlckFnZW50LlNTTDpcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gRm9yZXZlckFnZW50XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGh0dHBzLkFnZW50OlxuICAgICAgICBzZWxmLmFnZW50Q2xhc3MgPSBodHRwLkFnZW50XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBub3RoaW5nIHdlIGNhbiBkby4gIGp1c3QgaG9wZSBmb3IgdGhlIGJlc3RcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBhbiBhZ2VudCwgdGhlbiBnZXQgYSBuZXcgb25lLlxuICAgIGlmIChzZWxmLmFnZW50KSB7XG4gICAgICBzZWxmLmFnZW50ID0gbnVsbFxuICAgICAgc2VsZi5hZ2VudCA9IHNlbGYuZ2V0TmV3QWdlbnQoKVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXROZXdBZ2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBBZ2VudCA9IHNlbGYuYWdlbnRDbGFzc1xuICB2YXIgb3B0aW9ucyA9IHt9XG4gIGlmIChzZWxmLmFnZW50T3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgaW4gc2VsZi5hZ2VudE9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnNbaV0gPSBzZWxmLmFnZW50T3B0aW9uc1tpXVxuICAgIH1cbiAgfVxuICBpZiAoc2VsZi5jYSkge1xuICAgIG9wdGlvbnMuY2EgPSBzZWxmLmNhXG4gIH1cbiAgaWYgKHNlbGYuY2lwaGVycykge1xuICAgIG9wdGlvbnMuY2lwaGVycyA9IHNlbGYuY2lwaGVyc1xuICB9XG4gIGlmIChzZWxmLnNlY3VyZVByb3RvY29sKSB7XG4gICAgb3B0aW9ucy5zZWN1cmVQcm90b2NvbCA9IHNlbGYuc2VjdXJlUHJvdG9jb2xcbiAgfVxuICBpZiAoc2VsZi5zZWN1cmVPcHRpb25zKSB7XG4gICAgb3B0aW9ucy5zZWN1cmVPcHRpb25zID0gc2VsZi5zZWN1cmVPcHRpb25zXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IHNlbGYucmVqZWN0VW5hdXRob3JpemVkXG4gIH1cblxuICBpZiAoc2VsZi5jZXJ0ICYmIHNlbGYua2V5KSB7XG4gICAgb3B0aW9ucy5rZXkgPSBzZWxmLmtleVxuICAgIG9wdGlvbnMuY2VydCA9IHNlbGYuY2VydFxuICB9XG5cbiAgaWYgKHNlbGYucGZ4KSB7XG4gICAgb3B0aW9ucy5wZnggPSBzZWxmLnBmeFxuICB9XG5cbiAgaWYgKHNlbGYucGFzc3BocmFzZSkge1xuICAgIG9wdGlvbnMucGFzc3BocmFzZSA9IHNlbGYucGFzc3BocmFzZVxuICB9XG5cbiAgdmFyIHBvb2xLZXkgPSAnJ1xuXG4gIC8vIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMgYXJlIGluIGRpZmZlcmVudCBwb29sc1xuICBpZiAoQWdlbnQgIT09IHNlbGYuaHR0cE1vZHVsZS5BZ2VudCkge1xuICAgIHBvb2xLZXkgKz0gQWdlbnQubmFtZVxuICB9XG5cbiAgLy8gY2Egb3B0aW9uIGlzIG9ubHkgcmVsZXZhbnQgaWYgcHJveHkgb3IgZGVzdGluYXRpb24gYXJlIGh0dHBzXG4gIHZhciBwcm94eSA9IHNlbGYucHJveHlcbiAgaWYgKHR5cGVvZiBwcm94eSA9PT0gJ3N0cmluZycpIHtcbiAgICBwcm94eSA9IHVybC5wYXJzZShwcm94eSlcbiAgfVxuICB2YXIgaXNIdHRwcyA9IChwcm94eSAmJiBwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHx8IHRoaXMudXJpLnByb3RvY29sID09PSAnaHR0cHM6J1xuXG4gIGlmIChpc0h0dHBzKSB7XG4gICAgaWYgKG9wdGlvbnMuY2EpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2FcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWRcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jZXJ0KSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLmNlcnQudG9TdHJpbmcoJ2FzY2lpJykgKyBvcHRpb25zLmtleS50b1N0cmluZygnYXNjaWknKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBmeCkge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5wZngudG9TdHJpbmcoJ2FzY2lpJylcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jaXBoZXJzKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLmNpcGhlcnNcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVQcm90b2NvbCkge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5zZWN1cmVQcm90b2NvbFxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNlY3VyZU9wdGlvbnMpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuc2VjdXJlT3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxmLnBvb2wgPT09IGdsb2JhbFBvb2wgJiYgIXBvb2xLZXkgJiYgT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoID09PSAwICYmIHNlbGYuaHR0cE1vZHVsZS5nbG9iYWxBZ2VudCkge1xuICAgIC8vIG5vdCBkb2luZyBhbnl0aGluZyBzcGVjaWFsLiAgVXNlIHRoZSBnbG9iYWxBZ2VudFxuICAgIHJldHVybiBzZWxmLmh0dHBNb2R1bGUuZ2xvYmFsQWdlbnRcbiAgfVxuXG4gIC8vIHdlJ3JlIHVzaW5nIGEgc3RvcmVkIGFnZW50LiAgTWFrZSBzdXJlIGl0J3MgcHJvdG9jb2wtc3BlY2lmaWNcbiAgcG9vbEtleSA9IHNlbGYudXJpLnByb3RvY29sICsgcG9vbEtleVxuXG4gIC8vIGdlbmVyYXRlIGEgbmV3IGFnZW50IGZvciB0aGlzIHNldHRpbmcgaWYgbm9uZSB5ZXQgZXhpc3RzXG4gIGlmICghc2VsZi5wb29sW3Bvb2xLZXldKSB7XG4gICAgc2VsZi5wb29sW3Bvb2xLZXldID0gbmV3IEFnZW50KG9wdGlvbnMpXG4gICAgLy8gcHJvcGVybHkgc2V0IG1heFNvY2tldHMgb24gbmV3IGFnZW50c1xuICAgIGlmIChzZWxmLnBvb2wubWF4U29ja2V0cykge1xuICAgICAgc2VsZi5wb29sW3Bvb2xLZXldLm1heFNvY2tldHMgPSBzZWxmLnBvb2wubWF4U29ja2V0c1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmLnBvb2xbcG9vbEtleV1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHN0YXJ0KCkgaXMgY2FsbGVkIG9uY2Ugd2UgYXJlIHJlYWR5IHRvIHNlbmQgdGhlIG91dGdvaW5nIEhUVFAgcmVxdWVzdC5cbiAgLy8gdGhpcyBpcyB1c3VhbGx5IGNhbGxlZCBvbiB0aGUgZmlyc3Qgd3JpdGUoKSwgZW5kKCkgb3Igb24gbmV4dFRpY2soKVxuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2VsZi5fc3RhcnRlZCA9IHRydWVcbiAgc2VsZi5tZXRob2QgPSBzZWxmLm1ldGhvZCB8fCAnR0VUJ1xuICBzZWxmLmhyZWYgPSBzZWxmLnVyaS5ocmVmXG5cbiAgaWYgKHNlbGYuc3JjICYmIHNlbGYuc3JjLnN0YXQgJiYgc2VsZi5zcmMuc3RhdC5zaXplICYmICFzZWxmLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIHNlbGYuc3JjLnN0YXQuc2l6ZSlcbiAgfVxuICBpZiAoc2VsZi5fYXdzKSB7XG4gICAgc2VsZi5hd3Moc2VsZi5fYXdzLCB0cnVlKVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIG1ldGhvZCBuYW1lZCBhdXRoLCB3aGljaCBpcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBmcm9tIHRoZSBodHRwLnJlcXVlc3RcbiAgLy8gYXV0aCBvcHRpb24uICBJZiB3ZSBkb24ndCByZW1vdmUgaXQsIHdlJ3JlIGdvbm5hIGhhdmUgYSBiYWQgdGltZS5cbiAgdmFyIHJlcU9wdGlvbnMgPSBjb3B5KHNlbGYpXG4gIGRlbGV0ZSByZXFPcHRpb25zLmF1dGhcblxuICBkZWJ1ZygnbWFrZSByZXF1ZXN0Jywgc2VsZi51cmkuaHJlZilcblxuICBzZWxmLnJlcSA9IHNlbGYuaHR0cE1vZHVsZS5yZXF1ZXN0KHJlcU9wdGlvbnMpXG5cbiAgaWYgKHNlbGYudGltaW5nKSB7XG4gICAgc2VsZi5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICB9XG5cbiAgaWYgKHNlbGYudGltZW91dCAmJiAhc2VsZi50aW1lb3V0VGltZXIpIHtcbiAgICB2YXIgdGltZW91dCA9IHNlbGYudGltZW91dCA8IDAgPyAwIDogc2VsZi50aW1lb3V0XG4gICAgc2VsZi50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuYWJvcnQoKVxuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ0VUSU1FRE9VVCcpXG4gICAgICBlLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgfSwgdGltZW91dClcblxuICAgIC8vIFNldCBhZGRpdGlvbmFsIHRpbWVvdXQgb24gc29ja2V0IC0gaW4gY2FzZSBpZiByZW1vdGVcbiAgICAvLyBzZXJ2ZXIgZnJlZXplIGFmdGVyIHNlbmRpbmcgaGVhZGVyc1xuICAgIGlmIChzZWxmLnJlcS5zZXRUaW1lb3V0KSB7IC8vIG9ubHkgd29ya3Mgb24gbm9kZSAwLjYrXG4gICAgICBzZWxmLnJlcS5zZXRUaW1lb3V0KHRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYucmVxKSB7XG4gICAgICAgICAgc2VsZi5yZXEuYWJvcnQoKVxuICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdFU09DS0VUVElNRURPVVQnKVxuICAgICAgICAgIGUuY29kZSA9ICdFU09DS0VUVElNRURPVVQnXG4gICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc2VsZi5yZXEub24oJ3Jlc3BvbnNlJywgc2VsZi5vblJlcXVlc3RSZXNwb25zZS5iaW5kKHNlbGYpKVxuICBzZWxmLnJlcS5vbignZXJyb3InLCBzZWxmLm9uUmVxdWVzdEVycm9yLmJpbmQoc2VsZikpXG4gIHNlbGYucmVxLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKVxuICB9KVxuICBzZWxmLnJlcS5vbignc29ja2V0JywgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgc2VsZi5lbWl0KCdzb2NrZXQnLCBzb2NrZXQpXG4gIH0pXG5cbiAgc2VsZi5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCBzZWxmLnJlcS5jb25uZWN0aW9uICkge1xuICAgICAgc2VsZi5yZXEuY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBjb25uZWN0aW9uRXJyb3JIYW5kbGVyKVxuICAgIH1cbiAgfSlcbiAgc2VsZi5lbWl0KCdyZXF1ZXN0Jywgc2VsZi5yZXEpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLm9uUmVxdWVzdEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChzZWxmLnJlcSAmJiBzZWxmLnJlcS5fcmV1c2VkU29ja2V0ICYmIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJ1xuICAgICAgJiYgc2VsZi5hZ2VudC5hZGRSZXF1ZXN0Tm9yZXVzZSkge1xuICAgIHNlbGYuYWdlbnQgPSB7IGFkZFJlcXVlc3Q6IHNlbGYuYWdlbnQuYWRkUmVxdWVzdE5vcmV1c2UuYmluZChzZWxmLmFnZW50KSB9XG4gICAgc2VsZi5zdGFydCgpXG4gICAgc2VsZi5yZXEuZW5kKClcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoc2VsZi50aW1lb3V0ICYmIHNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dFRpbWVyKVxuICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcilcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUub25SZXF1ZXN0UmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGRlYnVnKCdvblJlcXVlc3RSZXNwb25zZScsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi50aW1pbmcpIHtcbiAgICAgIHNlbGYuZWxhcHNlZFRpbWUgKz0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc2VsZi5zdGFydFRpbWUpXG4gICAgICBkZWJ1ZygnZWxhcHNlZCB0aW1lJywgc2VsZi5lbGFwc2VkVGltZSlcbiAgICAgIHJlc3BvbnNlLmVsYXBzZWRUaW1lID0gc2VsZi5lbGFwc2VkVGltZVxuICAgIH1cbiAgICBkZWJ1ZygncmVzcG9uc2UgZW5kJywgc2VsZi51cmkuaHJlZiwgcmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycylcbiAgfSlcblxuICAvLyBUaGUgY2hlY2sgb24gcmVzcG9uc2UuY29ubmVjdGlvbiBpcyBhIHdvcmthcm91bmQgZm9yIGJyb3dzZXJpZnkuXG4gIGlmIChyZXNwb25zZS5jb25uZWN0aW9uICYmIHJlc3BvbnNlLmNvbm5lY3Rpb24ubGlzdGVuZXJzKCdlcnJvcicpLmluZGV4T2YoY29ubmVjdGlvbkVycm9ySGFuZGxlcikgPT09IC0xKSB7XG4gICAgcmVzcG9uc2UuY29ubmVjdGlvbi5zZXRNYXhMaXN0ZW5lcnMoMClcbiAgICByZXNwb25zZS5jb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgY29ubmVjdGlvbkVycm9ySGFuZGxlcilcbiAgfVxuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICByZXNwb25zZS5yZXN1bWUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgc2VsZi5yZXNwb25zZSA9IHJlc3BvbnNlXG4gIHJlc3BvbnNlLnJlcXVlc3QgPSBzZWxmXG4gIHJlc3BvbnNlLnRvSlNPTiA9IHJlc3BvbnNlVG9KU09OXG5cbiAgLy8gWFhYIFRoaXMgaXMgZGlmZmVyZW50IG9uIDAuMTAsIGJlY2F1c2UgU1NMIGlzIHN0cmljdCBieSBkZWZhdWx0XG4gIGlmIChzZWxmLmh0dHBNb2R1bGUgPT09IGh0dHBzICYmXG4gICAgICBzZWxmLnN0cmljdFNTTCAmJiAoIXJlc3BvbnNlLmhhc093blByb3BlcnR5KCdzb2NrZXQnKSB8fFxuICAgICAgIXJlc3BvbnNlLnNvY2tldC5hdXRob3JpemVkKSkge1xuICAgIGRlYnVnKCdzdHJpY3Qgc3NsIGVycm9yJywgc2VsZi51cmkuaHJlZilcbiAgICB2YXIgc3NsRXJyID0gcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3NvY2tldCcpID8gcmVzcG9uc2Uuc29ja2V0LmF1dGhvcml6YXRpb25FcnJvciA6IHNlbGYudXJpLmhyZWYgKyAnIGRvZXMgbm90IHN1cHBvcnQgU1NMJ1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1NTTCBFcnJvcjogJyArIHNzbEVycikpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBTYXZlIHRoZSBvcmlnaW5hbCBob3N0IGJlZm9yZSBhbnkgcmVkaXJlY3QgKGlmIGl0IGNoYW5nZXMsIHdlIG5lZWQgdG9cbiAgLy8gcmVtb3ZlIGFueSBhdXRob3JpemF0aW9uIGhlYWRlcnMpLiAgQWxzbyByZW1lbWJlciB0aGUgY2FzZSBvZiB0aGUgaGVhZGVyXG4gIC8vIG5hbWUgYmVjYXVzZSBsb3RzIG9mIGJyb2tlbiBzZXJ2ZXJzIGV4cGVjdCBIb3N0IGluc3RlYWQgb2YgaG9zdCBhbmQgd2VcbiAgLy8gd2FudCB0aGUgY2FsbGVyIHRvIGJlIGFibGUgdG8gc3BlY2lmeSB0aGlzLlxuICBzZWxmLm9yaWdpbmFsSG9zdCA9IHNlbGYuZ2V0SGVhZGVyKCdob3N0JylcbiAgaWYgKCFzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUpIHtcbiAgICBzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUgPSBzZWxmLmhhc0hlYWRlcignaG9zdCcpXG4gIH1cbiAgaWYgKHNlbGYuc2V0SG9zdCkge1xuICAgIHNlbGYucmVtb3ZlSGVhZGVyKCdob3N0JylcbiAgfVxuICBpZiAoc2VsZi50aW1lb3V0ICYmIHNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dFRpbWVyKVxuICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgdmFyIHRhcmdldENvb2tpZUphciA9IChzZWxmLl9qYXIgJiYgc2VsZi5famFyLnNldENvb2tpZSkgPyBzZWxmLl9qYXIgOiBnbG9iYWxDb29raWVKYXJcbiAgdmFyIGFkZENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICAvL3NldCB0aGUgY29va2llIGlmIGl0J3MgZG9tYWluIGluIHRoZSBocmVmJ3MgZG9tYWluLlxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRDb29raWVKYXIuc2V0Q29va2llKGNvb2tpZSwgc2VsZi51cmkuaHJlZiwge2lnbm9yZUVycm9yOiB0cnVlfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSlcbiAgICB9XG4gIH1cblxuICByZXNwb25zZS5jYXNlbGVzcyA9IGNhc2VsZXNzKHJlc3BvbnNlLmhlYWRlcnMpXG5cbiAgaWYgKHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnc2V0LWNvb2tpZScpICYmICghc2VsZi5fZGlzYWJsZUNvb2tpZXMpKSB7XG4gICAgdmFyIGhlYWRlck5hbWUgPSByZXNwb25zZS5jYXNlbGVzcy5oYXMoJ3NldC1jb29raWUnKVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyTmFtZV0pKSB7XG4gICAgICByZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdLmZvckVhY2goYWRkQ29va2llKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDb29raWUocmVzcG9uc2UuaGVhZGVyc1toZWFkZXJOYW1lXSlcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5fcmVkaXJlY3Qub25SZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICByZXR1cm4gLy8gSWdub3JlIHRoZSByZXN0IG9mIHRoZSByZXNwb25zZVxuICB9IGVsc2Uge1xuICAgIC8vIEJlIGEgZ29vZCBzdHJlYW0gYW5kIGVtaXQgZW5kIHdoZW4gdGhlIHJlc3BvbnNlIGlzIGZpbmlzaGVkLlxuICAgIC8vIEhhY2sgdG8gZW1pdCBlbmQgb24gY2xvc2UgYmVjYXVzZSBvZiBhIGNvcmUgYnVnIHRoYXQgbmV2ZXIgZmlyZXMgZW5kXG4gICAgcmVzcG9uc2Uub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzZWxmLl9lbmRlZCkge1xuICAgICAgICBzZWxmLnJlc3BvbnNlLmVtaXQoJ2VuZCcpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgdmFyIHJlc3BvbnNlQ29udGVudFxuICAgIGlmIChzZWxmLmd6aXApIHtcbiAgICAgIHZhciBjb250ZW50RW5jb2RpbmcgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gfHwgJ2lkZW50aXR5J1xuICAgICAgY29udGVudEVuY29kaW5nID0gY29udGVudEVuY29kaW5nLnRyaW0oKS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGlmIChjb250ZW50RW5jb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICByZXNwb25zZUNvbnRlbnQgPSB6bGliLmNyZWF0ZUd1bnppcCgpXG4gICAgICAgIHJlc3BvbnNlLnBpcGUocmVzcG9uc2VDb250ZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luY2UgcHJldmlvdXMgdmVyc2lvbnMgZGlkbid0IGNoZWNrIGZvciBDb250ZW50LUVuY29kaW5nIGhlYWRlcixcbiAgICAgICAgLy8gaWdub3JlIGFueSBpbnZhbGlkIHZhbHVlcyB0byBwcmVzZXJ2ZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAoY29udGVudEVuY29kaW5nICE9PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHVucmVjb2duaXplZCBDb250ZW50LUVuY29kaW5nICcgKyBjb250ZW50RW5jb2RpbmcpXG4gICAgICAgIH1cbiAgICAgICAgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2VcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2VcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5lbmNvZGluZykge1xuICAgICAgaWYgKHNlbGYuZGVzdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0lnbm9yaW5nIGVuY29kaW5nIHBhcmFtZXRlciBhcyB0aGlzIHN0cmVhbSBpcyBiZWluZyBwaXBlZCB0byBhbm90aGVyIHN0cmVhbSB3aGljaCBtYWtlcyB0aGUgZW5jb2Rpbmcgb3B0aW9uIGludmFsaWQuJylcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2VDb250ZW50LnNldEVuY29kaW5nKSB7XG4gICAgICAgIHJlc3BvbnNlQ29udGVudC5zZXRFbmNvZGluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2hvdWxkIG9ubHkgb2NjdXIgb24gbm9kZSBwcmUtdjAuOS40IChqb3llbnQvbm9kZUA5YjVhYmU1KSB3aXRoXG4gICAgICAgIC8vIHpsaWIgc3RyZWFtcy5cbiAgICAgICAgLy8gSWYvV2hlbiBzdXBwb3J0IGZvciAwLjkuNCBpcyBkcm9wcGVkLCB0aGlzIHNob3VsZCBiZSB1bm5lY2Vzc2FyeS5cbiAgICAgICAgcmVzcG9uc2VDb250ZW50ID0gcmVzcG9uc2VDb250ZW50LnBpcGUoc3RyaW5nc3RyZWFtKHNlbGYuZW5jb2RpbmcpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9wYXVzZWQpIHtcbiAgICAgIHJlc3BvbnNlQ29udGVudC5wYXVzZSgpXG4gICAgfVxuXG4gICAgc2VsZi5yZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZUNvbnRlbnRcblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSlcblxuICAgIHNlbGYuZGVzdHMuZm9yRWFjaChmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgc2VsZi5waXBlRGVzdChkZXN0KVxuICAgIH0pXG5cbiAgICByZXNwb25zZUNvbnRlbnQub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHNlbGYuX2Rlc3RkYXRhID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgfSlcbiAgICByZXNwb25zZUNvbnRlbnQub24oJ2VuZCcsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgc2VsZi5lbWl0KCdlbmQnLCBjaHVuaylcbiAgICB9KVxuICAgIHJlc3BvbnNlQ29udGVudC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICB9KVxuICAgIHJlc3BvbnNlQ29udGVudC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7c2VsZi5lbWl0KCdjbG9zZScpfSlcblxuICAgIGlmIChzZWxmLmNhbGxiYWNrKSB7XG4gICAgICB2YXIgYnVmZmVyID0gYmwoKVxuICAgICAgICAsIHN0cmluZ3MgPSBbXVxuXG4gICAgICBzZWxmLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAgICAgYnVmZmVyLmFwcGVuZChjaHVuaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmdzLnB1c2goY2h1bmspXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdlbmQgZXZlbnQnLCBzZWxmLnVyaS5ocmVmKVxuICAgICAgICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgICAgICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgZGVidWcoJ2hhcyBib2R5Jywgc2VsZi51cmkuaHJlZiwgYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICBpZiAoc2VsZi5lbmNvZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gcmVzcG9uc2UuYm9keSA9IGJ1ZmZlclxuICAgICAgICAgICAgLy8gY2FuJ3QgbW92ZSB0byB0aGlzIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9ydmFnZy9ibC9pc3N1ZXMvMTNcbiAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBidWZmZXIuc2xpY2UoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gYnVmZmVyLnRvU3RyaW5nKHNlbGYuZW5jb2RpbmcpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlIFVURjggQk9NIFsweEVGLDB4QkIsMHhCRl0gaXMgY29udmVydGVkIHRvIFsweEZFLDB4RkZdIGluIHRoZSBKUyBVVEMxNi9VQ1MyIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgIC8vIFN0cmlwIHRoaXMgdmFsdWUgb3V0IHdoZW4gdGhlIGVuY29kaW5nIGlzIHNldCB0byAndXRmOCcsIGFzIHVwc3RyZWFtIGNvbnN1bWVycyB3b24ndCBleHBlY3QgaXQgYW5kIGl0IGJyZWFrcyBKU09OLnBhcnNlKCkuXG4gICAgICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBzdHJpbmdzWzBdLmxlbmd0aCA+IDAgJiYgc3RyaW5nc1swXVswXSA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICBzdHJpbmdzWzBdID0gc3RyaW5nc1swXS5zdWJzdHJpbmcoMSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2UuYm9keSA9IHN0cmluZ3Muam9pbignJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9qc29uKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHksIHNlbGYuX2pzb25SZXZpdmVyKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdlbWl0dGluZyBjb21wbGV0ZScsIHNlbGYudXJpLmhyZWYpXG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYm9keSA9PT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuX2pzb24pIHtcbiAgICAgICAgICByZXNwb25zZS5ib2R5ID0gc2VsZi5lbmNvZGluZyA9PT0gbnVsbCA/IG5ldyBCdWZmZXIoMCkgOiAnJ1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW1pdCgnY29tcGxldGUnLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vaWYgbm8gY2FsbGJhY2tcbiAgICBlbHNlIHtcbiAgICAgIHNlbGYub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2Fib3J0ZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYWJvcnRlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lbWl0KCdjb21wbGV0ZScsIHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbiAgZGVidWcoJ2ZpbmlzaCBpbml0IGZ1bmN0aW9uJywgc2VsZi51cmkuaHJlZilcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLl9hYm9ydGVkID0gdHJ1ZVxuXG4gIGlmIChzZWxmLnJlcSkge1xuICAgIHNlbGYucmVxLmFib3J0KClcbiAgfVxuICBlbHNlIGlmIChzZWxmLnJlc3BvbnNlKSB7XG4gICAgc2VsZi5yZXNwb25zZS5hYm9ydCgpXG4gIH1cblxuICBzZWxmLmVtaXQoJ2Fib3J0Jylcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUucGlwZURlc3QgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlc3BvbnNlID0gc2VsZi5yZXNwb25zZVxuICAvLyBDYWxsZWQgYWZ0ZXIgdGhlIHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gIGlmIChkZXN0LmhlYWRlcnMgJiYgIWRlc3QuaGVhZGVyc1NlbnQpIHtcbiAgICBpZiAocmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgdmFyIGN0bmFtZSA9IHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnY29udGVudC10eXBlJylcbiAgICAgIGlmIChkZXN0LnNldEhlYWRlcikge1xuICAgICAgICBkZXN0LnNldEhlYWRlcihjdG5hbWUsIHJlc3BvbnNlLmhlYWRlcnNbY3RuYW1lXSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZXN0LmhlYWRlcnNbY3RuYW1lXSA9IHJlc3BvbnNlLmhlYWRlcnNbY3RuYW1lXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5jYXNlbGVzcy5oYXMoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIHZhciBjbG5hbWUgPSByZXNwb25zZS5jYXNlbGVzcy5oYXMoJ2NvbnRlbnQtbGVuZ3RoJylcbiAgICAgIGlmIChkZXN0LnNldEhlYWRlcikge1xuICAgICAgICBkZXN0LnNldEhlYWRlcihjbG5hbWUsIHJlc3BvbnNlLmhlYWRlcnNbY2xuYW1lXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QuaGVhZGVyc1tjbG5hbWVdID0gcmVzcG9uc2UuaGVhZGVyc1tjbG5hbWVdXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkZXN0LnNldEhlYWRlciAmJiAhZGVzdC5oZWFkZXJzU2VudCkge1xuICAgIGZvciAodmFyIGkgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGNvbnRlbnQgaXMgYmVpbmcgZGVjb2RlZCwgdGhlIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyXG4gICAgICAvLyBvZiB0aGUgcmVzcG9uc2UgZG9lc24ndCByZXByZXNlbnQgdGhlIHBpcGVkIGNvbnRlbnQsIHNvIGRvbid0IHBhc3MgaXQuXG4gICAgICBpZiAoIXNlbGYuZ3ppcCB8fCBpICE9PSAnY29udGVudC1lbmNvZGluZycpIHtcbiAgICAgICAgZGVzdC5zZXRIZWFkZXIoaSwgcmVzcG9uc2UuaGVhZGVyc1tpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgZGVzdC5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZVxuICB9XG4gIGlmIChzZWxmLnBpcGVmaWx0ZXIpIHtcbiAgICBzZWxmLnBpcGVmaWx0ZXIocmVzcG9uc2UsIGRlc3QpXG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUucXMgPSBmdW5jdGlvbiAocSwgY2xvYmJlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIGJhc2VcbiAgaWYgKCFjbG9iYmVyICYmIHNlbGYudXJpLnF1ZXJ5KSB7XG4gICAgYmFzZSA9IHNlbGYuX3FzLnBhcnNlKHNlbGYudXJpLnF1ZXJ5KVxuICB9IGVsc2Uge1xuICAgIGJhc2UgPSB7fVxuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBxKSB7XG4gICAgYmFzZVtpXSA9IHFbaV1cbiAgfVxuXG4gIGlmIChzZWxmLl9xcy5zdHJpbmdpZnkoYmFzZSkgPT09ICcnKSB7XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHZhciBxcyA9IHNlbGYuX3FzLnN0cmluZ2lmeShiYXNlKVxuXG4gIHNlbGYudXJpID0gdXJsLnBhcnNlKHNlbGYudXJpLmhyZWYuc3BsaXQoJz8nKVswXSArICc/JyArIHFzKVxuICBzZWxmLnVybCA9IHNlbGYudXJpXG4gIHNlbGYucGF0aCA9IHNlbGYudXJpLnBhdGhcblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuZm9ybSA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoZm9ybSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcbiAgICBzZWxmLmJvZHkgPSAodHlwZW9mIGZvcm0gPT09ICdzdHJpbmcnKVxuICAgICAgPyBzZWxmLl9xcy5yZmMzOTg2KGZvcm0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICAgIDogc2VsZi5fcXMuc3RyaW5naWZ5KGZvcm0pLnRvU3RyaW5nKCd1dGY4JylcbiAgICByZXR1cm4gc2VsZlxuICB9XG4gIC8vIGNyZWF0ZSBmb3JtLWRhdGEgb2JqZWN0XG4gIHNlbGYuX2Zvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBzZWxmLl9mb3JtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gJ2Zvcm0tZGF0YTogJyArIGVyci5tZXNzYWdlXG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmFib3J0KClcbiAgfSlcbiAgcmV0dXJuIHNlbGYuX2Zvcm1cbn1cblJlcXVlc3QucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIChtdWx0aXBhcnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fbXVsdGlwYXJ0Lm9uUmVxdWVzdChtdWx0aXBhcnQpXG5cbiAgaWYgKCFzZWxmLl9tdWx0aXBhcnQuY2h1bmtlZCkge1xuICAgIHNlbGYuYm9keSA9IHNlbGYuX211bHRpcGFydC5ib2R5XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKCFzZWxmLmhhc0hlYWRlcignYWNjZXB0JykpIHtcbiAgICBzZWxmLnNldEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICB9XG5cbiAgc2VsZi5fanNvbiA9IHRydWVcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIGlmIChzZWxmLmJvZHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCEvXmFwcGxpY2F0aW9uXFwveC13d3ctZm9ybS11cmxlbmNvZGVkXFxiLy50ZXN0KHNlbGYuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSkpIHtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2FmZVN0cmluZ2lmeShzZWxmLmJvZHkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLl9xcy5yZmMzOTg2KHNlbGYuYm9keSlcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGYuYm9keSA9IHNhZmVTdHJpbmdpZnkodmFsKVxuICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZi5qc29uUmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX2pzb25SZXZpdmVyID0gc2VsZi5qc29uUmV2aXZlclxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCBoZWFkZXJzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVzdWx0LCByZSwgbWF0Y2hcbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgaGVhZGVycyA9IHNlbGYuaGVhZGVyc1xuICB9XG4gIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkubGVuZ3RoICE9PSBuYW1lLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJlID0gbmV3IFJlZ0V4cChuYW1lLCAnaScpXG4gICAgbWF0Y2ggPSBrZXkubWF0Y2gocmUpXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXN1bHQgPSBoZWFkZXJzW2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHksIGJlYXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLl9hdXRoLm9uUmVxdWVzdCh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHksIGJlYXJlcilcblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuYXdzID0gZnVuY3Rpb24gKG9wdHMsIG5vdykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIW5vdykge1xuICAgIHNlbGYuX2F3cyA9IG9wdHNcbiAgICByZXR1cm4gc2VsZlxuICB9XG4gIHZhciBkYXRlID0gbmV3IERhdGUoKVxuICBzZWxmLnNldEhlYWRlcignZGF0ZScsIGRhdGUudG9VVENTdHJpbmcoKSlcbiAgdmFyIGF1dGggPVxuICAgIHsga2V5OiBvcHRzLmtleVxuICAgICwgc2VjcmV0OiBvcHRzLnNlY3JldFxuICAgICwgdmVyYjogc2VsZi5tZXRob2QudG9VcHBlckNhc2UoKVxuICAgICwgZGF0ZTogZGF0ZVxuICAgICwgY29udGVudFR5cGU6IHNlbGYuZ2V0SGVhZGVyKCdjb250ZW50LXR5cGUnKSB8fCAnJ1xuICAgICwgbWQ1OiBzZWxmLmdldEhlYWRlcignY29udGVudC1tZDUnKSB8fCAnJ1xuICAgICwgYW1hem9uSGVhZGVyczogYXdzLmNhbm9uaWNhbGl6ZUhlYWRlcnMoc2VsZi5oZWFkZXJzKVxuICAgIH1cbiAgdmFyIHBhdGggPSBzZWxmLnVyaS5wYXRoXG4gIGlmIChvcHRzLmJ1Y2tldCAmJiBwYXRoKSB7XG4gICAgYXV0aC5yZXNvdXJjZSA9ICcvJyArIG9wdHMuYnVja2V0ICsgcGF0aFxuICB9IGVsc2UgaWYgKG9wdHMuYnVja2V0ICYmICFwYXRoKSB7XG4gICAgYXV0aC5yZXNvdXJjZSA9ICcvJyArIG9wdHMuYnVja2V0XG4gIH0gZWxzZSBpZiAoIW9wdHMuYnVja2V0ICYmIHBhdGgpIHtcbiAgICBhdXRoLnJlc291cmNlID0gcGF0aFxuICB9IGVsc2UgaWYgKCFvcHRzLmJ1Y2tldCAmJiAhcGF0aCkge1xuICAgIGF1dGgucmVzb3VyY2UgPSAnLydcbiAgfVxuICBhdXRoLnJlc291cmNlID0gYXdzLmNhbm9uaWNhbGl6ZVJlc291cmNlKGF1dGgucmVzb3VyY2UpXG4gIHNlbGYuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXdzLmF1dGhvcml6YXRpb24oYXV0aCkpXG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmh0dHBTaWduYXR1cmUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaHR0cFNpZ25hdHVyZS5zaWduUmVxdWVzdCh7XG4gICAgZ2V0SGVhZGVyOiBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBzZWxmLmdldEhlYWRlcihoZWFkZXIsIHNlbGYuaGVhZGVycylcbiAgICB9LFxuICAgIHNldEhlYWRlcjogZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSlcbiAgICB9LFxuICAgIG1ldGhvZDogc2VsZi5tZXRob2QsXG4gICAgcGF0aDogc2VsZi5wYXRoXG4gIH0sIG9wdHMpXG4gIGRlYnVnKCdodHRwU2lnbmF0dXJlIGF1dGhvcml6YXRpb24nLCBzZWxmLmdldEhlYWRlcignYXV0aG9yaXphdGlvbicpKVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5oYXdrID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgaGF3ay5jbGllbnQuaGVhZGVyKHNlbGYudXJpLCBzZWxmLm1ldGhvZCwgb3B0cykuZmllbGQpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5vYXV0aCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fb2F1dGgub25SZXF1ZXN0KF9vYXV0aClcblxuICByZXR1cm4gc2VsZlxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5qYXIgPSBmdW5jdGlvbiAoamFyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgY29va2llc1xuXG4gIGlmIChzZWxmLl9yZWRpcmVjdC5yZWRpcmVjdHNGb2xsb3dlZCA9PT0gMCkge1xuICAgIHNlbGYub3JpZ2luYWxDb29raWVIZWFkZXIgPSBzZWxmLmdldEhlYWRlcignY29va2llJylcbiAgfVxuXG4gIGlmICghamFyKSB7XG4gICAgLy8gZGlzYWJsZSBjb29raWVzXG4gICAgY29va2llcyA9IGZhbHNlXG4gICAgc2VsZi5fZGlzYWJsZUNvb2tpZXMgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldENvb2tpZUphciA9IChqYXIgJiYgamFyLmdldENvb2tpZVN0cmluZykgPyBqYXIgOiBnbG9iYWxDb29raWVKYXJcbiAgICB2YXIgdXJpaHJlZiA9IHNlbGYudXJpLmhyZWZcbiAgICAvL2ZldGNoIGNvb2tpZSBpbiB0aGUgU3BlY2lmaWVkIGhvc3RcbiAgICBpZiAodGFyZ2V0Q29va2llSmFyKSB7XG4gICAgICBjb29raWVzID0gdGFyZ2V0Q29va2llSmFyLmdldENvb2tpZVN0cmluZyh1cmlocmVmKVxuICAgIH1cbiAgfVxuXG4gIC8vaWYgbmVlZCBjb29raWUgYW5kIGNvb2tpZSBpcyBub3QgZW1wdHlcbiAgaWYgKGNvb2tpZXMgJiYgY29va2llcy5sZW5ndGgpIHtcbiAgICBpZiAoc2VsZi5vcmlnaW5hbENvb2tpZUhlYWRlcikge1xuICAgICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIENvb2tpZSBoZWFkZXJcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb29raWUnLCBzZWxmLm9yaWdpbmFsQ29va2llSGVhZGVyICsgJzsgJyArIGNvb2tpZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb29raWUnLCBjb29raWVzKVxuICAgIH1cbiAgfVxuICBzZWxmLl9qYXIgPSBqYXJcbiAgcmV0dXJuIHNlbGZcbn1cblxuXG4vLyBTdHJlYW0gQVBJXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYucmVzcG9uc2UpIHtcbiAgICBpZiAoc2VsZi5fZGVzdGRhdGEpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcGlwZSBhZnRlciBkYXRhIGhhcyBiZWVuIGVtaXR0ZWQgZnJvbSB0aGUgcmVzcG9uc2UuJykpXG4gICAgfSBlbHNlIGlmIChzZWxmLl9lbmRlZCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWW91IGNhbm5vdCBwaXBlIGFmdGVyIHRoZSByZXNwb25zZSBoYXMgYmVlbiBlbmRlZC4nKSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLlN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHNlbGYsIGRlc3QsIG9wdHMpXG4gICAgICBzZWxmLnBpcGVEZXN0KGRlc3QpXG4gICAgICByZXR1cm4gZGVzdFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRlc3RzLnB1c2goZGVzdClcbiAgICBzdHJlYW0uU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwoc2VsZiwgZGVzdCwgb3B0cylcbiAgICByZXR1cm4gZGVzdFxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5fc3RhcnRlZCkge1xuICAgIHNlbGYuc3RhcnQoKVxuICB9XG4gIHJldHVybiBzZWxmLnJlcS53cml0ZS5hcHBseShzZWxmLnJlcSwgYXJndW1lbnRzKVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoY2h1bmspIHtcbiAgICBzZWxmLndyaXRlKGNodW5rKVxuICB9XG4gIGlmICghc2VsZi5fc3RhcnRlZCkge1xuICAgIHNlbGYuc3RhcnQoKVxuICB9XG4gIHNlbGYucmVxLmVuZCgpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5yZXNwb25zZUNvbnRlbnQpIHtcbiAgICBzZWxmLl9wYXVzZWQgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZXNwb25zZUNvbnRlbnQucGF1c2UuYXBwbHkoc2VsZi5yZXNwb25zZUNvbnRlbnQsIGFyZ3VtZW50cylcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLnJlc3BvbnNlQ29udGVudCkge1xuICAgIHNlbGYuX3BhdXNlZCA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZXNwb25zZUNvbnRlbnQucmVzdW1lLmFwcGx5KHNlbGYucmVzcG9uc2VDb250ZW50LCBhcmd1bWVudHMpXG4gIH1cbn1cblJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYuX2VuZGVkKSB7XG4gICAgc2VsZi5lbmQoKVxuICB9IGVsc2UgaWYgKHNlbGYucmVzcG9uc2UpIHtcbiAgICBzZWxmLnJlc3BvbnNlLmRlc3Ryb3koKVxuICB9XG59XG5cblJlcXVlc3QuZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0ID1cbiAgVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdC5zbGljZSgpXG5cblJlcXVlc3QuZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9XG4gIFR1bm5lbC5kZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LnNsaWNlKClcblxuLy8gRXhwb3J0c1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50b0pTT04gPSByZXF1ZXN0VG9KU09OXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZXF1ZXN0L3JlcXVlc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wcm90b2NvbCkge1xuICAgICAgICBpZiAocGFyYW1zLnNjaGVtZSkge1xuICAgICAgICAgICAgcGFyYW1zLnByb3RvY29sID0gcGFyYW1zLnNjaGVtZSArICc6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmhvc3QpIHtcbiAgICAgICAgcGFyYW1zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgfHwgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChwYXJhbXMuaG9zdCkpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMucG9ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5ob3N0ID0gcGFyYW1zLmhvc3Quc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMucG9ydCkgcGFyYW1zLnBvcnQgPSBwYXJhbXMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICBcbiAgICB2YXIgcmVxID0gbmV3IFJlcXVlc3QobmV3IHhockh0dHAsIHBhcmFtcyk7XG4gICAgaWYgKGNiKSByZXEub24oJ3Jlc3BvbnNlJywgY2IpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgcGFyYW1zLm1ldGhvZCA9ICdHRVQnO1xuICAgIHZhciByZXEgPSBodHRwLnJlcXVlc3QocGFyYW1zLCBjYik7XG4gICAgcmVxLmVuZCgpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge307XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDtcblxudmFyIHhockh0dHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdpbmRvdyBvYmplY3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgdmFyIGF4cyA9IFtcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC42LjAnLFxuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjMuMCcsXG4gICAgICAgICAgICAnTWljcm9zb2Z0LlhNTEhUVFAnXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBheCA9IG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheF8gPSBheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG59KSgpO1xuXG5odHRwLlNUQVRVU19DT0RFUyA9IHtcbiAgICAxMDAgOiAnQ29udGludWUnLFxuICAgIDEwMSA6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAxMDIgOiAnUHJvY2Vzc2luZycsICAgICAgICAgICAgICAgICAvLyBSRkMgMjUxOCwgb2Jzb2xldGVkIGJ5IFJGQyA0OTE4XG4gICAgMjAwIDogJ09LJyxcbiAgICAyMDEgOiAnQ3JlYXRlZCcsXG4gICAgMjAyIDogJ0FjY2VwdGVkJyxcbiAgICAyMDMgOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAgIDIwNCA6ICdObyBDb250ZW50JyxcbiAgICAyMDUgOiAnUmVzZXQgQ29udGVudCcsXG4gICAgMjA2IDogJ1BhcnRpYWwgQ29udGVudCcsXG4gICAgMjA3IDogJ011bHRpLVN0YXR1cycsICAgICAgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICAzMDAgOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxIDogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDIgOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAgIDMwMyA6ICdTZWUgT3RoZXInLFxuICAgIDMwNCA6ICdOb3QgTW9kaWZpZWQnLFxuICAgIDMwNSA6ICdVc2UgUHJveHknLFxuICAgIDMwNyA6ICdUZW1wb3JhcnkgUmVkaXJlY3QnLFxuICAgIDQwMCA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxIDogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyIDogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMyA6ICdGb3JiaWRkZW4nLFxuICAgIDQwNCA6ICdOb3QgRm91bmQnLFxuICAgIDQwNSA6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgIDQwNiA6ICdOb3QgQWNjZXB0YWJsZScsXG4gICAgNDA3IDogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDggOiAnUmVxdWVzdCBUaW1lLW91dCcsXG4gICAgNDA5IDogJ0NvbmZsaWN0JyxcbiAgICA0MTAgOiAnR29uZScsXG4gICAgNDExIDogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gICAgNDEyIDogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgIDQxMyA6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuICAgIDQxNCA6ICdSZXF1ZXN0LVVSSSBUb28gTGFyZ2UnLFxuICAgIDQxNSA6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTYgOiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gICAgNDE3IDogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gICAgNDE4IDogJ0lcXCdtIGEgdGVhcG90JywgICAgICAgICAgICAgIC8vIFJGQyAyMzI0XG4gICAgNDIyIDogJ1VucHJvY2Vzc2FibGUgRW50aXR5JywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjMgOiAnTG9ja2VkJywgICAgICAgICAgICAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNCA6ICdGYWlsZWQgRGVwZW5kZW5jeScsICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI1IDogJ1Vub3JkZXJlZCBDb2xsZWN0aW9uJywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjYgOiAnVXBncmFkZSBSZXF1aXJlZCcsICAgICAgICAgICAvLyBSRkMgMjgxN1xuICAgIDQyOCA6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLCAgICAgIC8vIFJGQyA2NTg1XG4gICAgNDI5IDogJ1RvbyBNYW55IFJlcXVlc3RzJywgICAgICAgICAgLy8gUkZDIDY1ODVcbiAgICA0MzEgOiAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZScsLy8gUkZDIDY1ODVcbiAgICA1MDAgOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICA1MDEgOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDIgOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMyA6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICA1MDQgOiAnR2F0ZXdheSBUaW1lLW91dCcsXG4gICAgNTA1IDogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICA1MDYgOiAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnLCAgICAvLyBSRkMgMjI5NVxuICAgIDUwNyA6ICdJbnN1ZmZpY2llbnQgU3RvcmFnZScsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNTA5IDogJ0JhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZCcsXG4gICAgNTEwIDogJ05vdCBFeHRlbmRlZCcsICAgICAgICAgICAgICAgLy8gUkZDIDI3NzRcbiAgICA1MTEgOiAnTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcgLy8gUkZDIDY1ODVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vZXZlbnRzL2V2ZW50cy5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG52YXIgQmFzZTY0ID0gcmVxdWlyZSgnQmFzZTY0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IFtdO1xuICAgIFxuICAgIHNlbGYudXJpID0gKHBhcmFtcy5wcm90b2NvbCB8fCAnaHR0cDonKSArICcvLydcbiAgICAgICAgKyBwYXJhbXMuaG9zdFxuICAgICAgICArIChwYXJhbXMucG9ydCA/ICc6JyArIHBhcmFtcy5wb3J0IDogJycpXG4gICAgICAgICsgKHBhcmFtcy5wYXRoIHx8ICcvJylcbiAgICA7XG4gICAgXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMud2l0aENyZWRlbnRpYWxzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkgeyB4aHIud2l0aENyZWRlbnRpYWxzID0gcGFyYW1zLndpdGhDcmVkZW50aWFscyB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5yZXNwb25zZVR5cGUpIHRyeSB7IHhoci5yZXNwb25zZVR5cGUgPSBwYXJhbXMucmVzcG9uc2VUeXBlIH1cbiAgICBjYXRjaCAoZSkge31cbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgc2VsZi51cmksXG4gICAgICAgIHRydWVcbiAgICApO1xuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOZXR3b3JrIGVycm9yJykpO1xuICAgIH07XG5cbiAgICBzZWxmLl9oZWFkZXJzID0ge307XG4gICAgXG4gICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTYWZlUmVxdWVzdEhlYWRlcihrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtcy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICBzZWxmLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAocGFyYW1zLmF1dGgpIHtcbiAgICAgICAgLy9iYXNpYyBhdXRoXG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCYXNlNjQuYnRvYShwYXJhbXMuYXV0aCkpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBuZXcgUmVzcG9uc2U7XG4gICAgcmVzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIFxuICAgIHJlcy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgIH0pO1xuXG4gICAgcmVzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG4gICAgXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRml4IGZvciBJRTkgYnVnXG4gICAgICAgIC8vIFNDUklQVDU3NTogQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXG4gICAgICAgIC8vIEl0IGhhcHBlbnMgd2hlbiBhIHJlcXVlc3QgaXMgYWJvcnRlZCwgY2FsbGluZyB0aGUgc3VjY2VzcyBjYWxsYmFjayBhbnl3YXkgd2l0aCByZWFkeVN0YXRlID09PSA0XG4gICAgICAgIGlmICh4aHIuX19hYm9ydGVkKSByZXR1cm47XG4gICAgICAgIHJlcy5oYW5kbGUoeGhyKTtcbiAgICB9O1xufTtcblxuaW5oZXJpdHMoUmVxdWVzdCwgU3RyZWFtKTtcblxuUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldXG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy5ib2R5LnB1c2gocyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKHMpIHtcbiAgICB0aGlzLnhoci5fX2Fib3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB0aGlzLmJvZHkucHVzaChzKTtcblxuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyh0aGlzLl9oZWFkZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2hlYWRlcnNba2V5XTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnhoci5zZW5kKCcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuYm9keVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkuam9pbignJykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHRoaXMuYm9keVswXSkpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkucHVzaC5hcHBseShib2R5LCB0aGlzLmJvZHlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9BcnJheS8udGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5ib2R5WzBdKSkpIHtcbiAgICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5ib2R5W2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9IG5ldyh0aGlzLmJvZHlbMF0uY29uc3RydWN0b3IpKGxlbik7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuYm9keVtpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGJvZHlbaysrXSA9IGJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNYSFIyQ29tcGF0aWJsZSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5WzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBib2R5ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5ICs9IHRoaXMuYm9keVtpXS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxufTtcblxuLy8gVGFrZW4gZnJvbSBodHRwOi8vZHhyLm1vemlsbGEub3JnL21vemlsbGEvbW96aWxsYS1jZW50cmFsL2NvbnRlbnQvYmFzZS9zcmMvbnNYTUxIdHRwUmVxdWVzdC5jcHAuaHRtbFxuUmVxdWVzdC51bnNhZmVIZWFkZXJzID0gW1xuICAgIFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBcImFjY2VwdC1lbmNvZGluZ1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZFwiLFxuICAgIFwiY29ubmVjdGlvblwiLFxuICAgIFwiY29udGVudC1sZW5ndGhcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llMlwiLFxuICAgIFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiZXhwZWN0XCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgXCJvcmlnaW5cIixcbiAgICBcInJlZmVyZXJcIixcbiAgICBcInRlXCIsXG4gICAgXCJ0cmFpbGVyXCIsXG4gICAgXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwidXBncmFkZVwiLFxuICAgIFwidXNlci1hZ2VudFwiLFxuICAgIFwidmlhXCJcbl07XG5cblJlcXVlc3QucHJvdG90eXBlLmlzU2FmZVJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyTmFtZSkge1xuICAgIGlmICghaGVhZGVyTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBpbmRleE9mKFJlcXVlc3QudW5zYWZlSGVhZGVycywgaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTE7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG52YXIgaXNYSFIyQ29tcGF0aWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBGb3JtRGF0YSkgcmV0dXJuIHRydWU7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2h0dHAtYnJvd3NlcmlmeS9saWIvcmVxdWVzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7IC8vIGhhY2sgdG8gZml4IGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSB3aGVuIHVzZWQgd2l0aCBicm93c2VyaWZ5XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5pZiAoIXByb2Nlc3MuYnJvd3NlciAmJiBwcm9jZXNzLmVudi5SRUFEQUJMRV9TVFJFQU0gPT09ICdkaXNhYmxlJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IGZhbHNlO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBJbiBzdHJlYW1zIHRoYXQgbmV2ZXIgaGF2ZSBhbnkgZGF0YSwgYW5kIGRvIHB1c2gobnVsbCkgcmlnaHQgYXdheSxcbiAgLy8gdGhlIGNvbnN1bWVyIGNhbiBtaXNzIHRoZSAnZW5kJyBldmVudCBpZiB0aGV5IGRvIHNvbWUgSS9PIGJlZm9yZVxuICAvLyBjb25zdW1pbmcgdGhlIHN0cmVhbS4gIFNvLCB3ZSBkb24ndCBlbWl0KCdlbmQnKSB1bnRpbCBzb21lIHJlYWRpbmdcbiAgLy8gaGFwcGVucy5cbiAgdGhpcy5jYWxsZWRSZWFkID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUuY2FsbGVkUmVhZCA9IHRydWU7XG4gIHZhciBuT3JpZyA9IG47XG4gIHZhciByZXQ7XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIHJldCA9IG51bGw7XG5cbiAgICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgZGVjb2RlciBkaWQgbm90IHJlY2VpdmUgZW5vdWdoIGRhdGFcbiAgICAvLyB0byBwcm9kdWNlIGEgZnVsbCBjaHVuaywgdGhlbiBpbW1lZGlhdGVseSByZWNlaXZlZCBhblxuICAgIC8vIEVPRiwgc3RhdGUuYnVmZmVyIHdpbGwgY29udGFpbiBbPEJ1ZmZlciA+LCA8QnVmZmVyIDAwIC4uLj5dLlxuICAgIC8vIGhvd011Y2hUb1JlYWQgd2lsbCBzZWUgdGhpcyBhbmQgY29lcmNlIHRoZSBhbW91bnQgdG9cbiAgICAvLyByZWFkIHRvIHplcm8gKGJlY2F1c2UgaXQncyBsb29raW5nIGF0IHRoZSBsZW5ndGggb2YgdGhlXG4gICAgLy8gZmlyc3QgPEJ1ZmZlciA+IGluIHN0YXRlLmJ1ZmZlciksIGFuZCB3ZSdsbCBlbmQgdXAgaGVyZS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIHZpYSBzdGF0ZS5kZWNvZGVyIC0tIG5vIG90aGVyIHZlbnVlXG4gICAgLy8gZXhpc3RzIGZvciBwdXNoaW5nIGEgemVyby1sZW5ndGggY2h1bmsgaW50byBzdGF0ZS5idWZmZXJcbiAgICAvLyBhbmQgdHJpZ2dlcmluZyB0aGlzIGJlaGF2aW9yLiBJbiB0aGlzIGNhc2UsIHdlIHJldHVybiBvdXJcbiAgICAvLyByZW1haW5pbmcgZGF0YSBhbmQgZW5kIHRoZSBzdHJlYW0sIGlmIGFwcHJvcHJpYXRlLlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPiAwICYmIHN0YXRlLmRlY29kZXIpIHtcbiAgICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSByZXQubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCAtIG4gPD0gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBkb1JlYWQgPSB0cnVlO1xuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpXG4gICAgZG9SZWFkID0gZmFsc2U7XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgY2FsbGVkIGl0cyBjYWxsYmFjayBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYFxuICAvLyB3aWxsIGJlIGZhbHNlLCBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlXG4gIC8vIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgaGFwcGVuZWQgdG8gcmVhZCgpIGV4YWN0bHkgdGhlIHJlbWFpbmluZyBhbW91bnQgaW4gdGhlXG4gIC8vIGJ1ZmZlciwgYW5kIHRoZSBFT0YgaGFzIGJlZW4gc2VlbiBhdCB0aGlzIHBvaW50LCB0aGVuIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHdlIGVtaXQgJ2VuZCcgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuICBpZiAoc3RhdGUuZW5kZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIC8vIHRoZSBoYW5kbGVyIHRoYXQgd2FpdHMgZm9yIHJlYWRhYmxlIGV2ZW50cyBhZnRlciBhbGxcbiAgICAvLyB0aGUgZGF0YSBnZXRzIHN1Y2tlZCBvdXQgaW4gZmxvdy5cbiAgICAvLyBUaGlzIHdvdWxkIGJlIGVhc2llciB0byBmb2xsb3cgd2l0aCBhIC5vbmNlKCkgaGFuZGxlclxuICAgIC8vIGluIGZsb3coKSwgYnV0IHRoYXQgaXMgdG9vIHNsb3cuXG4gICAgdGhpcy5vbigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwKVxuICAgICAgZmxvdyhzcmMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG93KHNyYykge1xuICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBjaHVuaztcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG5cbiAgZnVuY3Rpb24gd3JpdGUoZGVzdCwgaSwgbGlzdCkge1xuICAgIHZhciB3cml0dGVuID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSB3cml0dGVuKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBpcGVzQ291bnQgJiYgbnVsbCAhPT0gKGNodW5rID0gc3JjLnJlYWQoKSkpIHtcblxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgICAgd3JpdGUoc3RhdGUucGlwZXMsIDAsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIGZvckVhY2goc3RhdGUucGlwZXMsIHdyaXRlKTtcblxuICAgIHNyYy5lbWl0KCdkYXRhJywgY2h1bmspO1xuXG4gICAgLy8gaWYgYW55b25lIG5lZWRzIGEgZHJhaW4sIHRoZW4gd2UgaGF2ZSB0byB3YWl0IGZvciB0aGF0LlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID4gMClcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGV2ZXJ5IGRlc3RpbmF0aW9uIHdhcyB1bnBpcGVkLCBlaXRoZXIgYmVmb3JlIGVudGVyaW5nIHRoaXNcbiAgLy8gZnVuY3Rpb24sIG9yIGluIHRoZSB3aGlsZSBsb29wLCB0aGVuIHN0b3AgZmxvd2luZy5cbiAgLy9cbiAgLy8gTkI6IFRoaXMgaXMgYSBwcmV0dHkgcmFyZSBlZGdlIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlcmUgd2VyZSBkYXRhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCwgdGhlbiBzd2l0Y2ggdG8gb2xkIG1vZGUuXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpID4gMClcbiAgICAgIGVtaXREYXRhRXZlbnRzKHNyYyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbm8gb25lIG5lZWRlZCBhIGRyYWluLCBzbyB3ZSBqdXN0IHJhbiBvdXQgb2YgZGF0YVxuICAvLyBvbiB0aGUgbmV4dCByZWFkYWJsZSBldmVudCwgc3RhcnQgaXQgb3ZlciBhZ2Fpbi5cbiAgc3RhdGUucmFuT3V0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGlwZU9uUmVhZGFibGUoKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0ID0gZmFsc2U7XG4gICAgZmxvdyh0aGlzKTtcbiAgfVxufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpXG4gICAgZW1pdERhdGFFdmVudHModGhpcyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB0aGlzLnJlYWQoMCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuICB0aGlzLnJlYWQoMCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcywgdHJ1ZSk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXREYXRhRXZlbnRzKHN0cmVhbSwgc3RhcnRQYXVzZWQpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzE2XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIHRvIG9sZCBtb2RlIG5vdy4nKTtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBzdGFydFBhdXNlZCB8fCBmYWxzZTtcbiAgdmFyIHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gY29udmVydCB0byBhbiBvbGQtc3R5bGUgc3RyZWFtLlxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgc3RyZWFtLm9uID0gc3RyZWFtLmFkZExpc3RlbmVyID0gU3RyZWFtLnByb3RvdHlwZS5vbjtcblxuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgcmVhZGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIGM7XG4gICAgd2hpbGUgKCFwYXVzZWQgJiYgKG51bGwgIT09IChjID0gc3RyZWFtLnJlYWQoKSkpKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjKTtcblxuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfTtcblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHJlYWRhYmxlKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICAvL2lmIChzdGF0ZS5vYmplY3RNb2RlICYmIHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSlcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUuY2FsbGVkUmVhZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2lzYXJyYXkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGNiKGVyKTtcbiAgICB9KTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIGlmIChzeW5jKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpXG4gICAgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBjYigpO1xuICBpZiAoZmluaXNoZWQpXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuXG4gIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKSB7XG4gICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgIGMrKztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgaWYgKGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgIHN0YXRlLmJ1ZmZlciA9IHN0YXRlLmJ1ZmZlci5zbGljZShjKTtcbiAgZWxzZVxuICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGggPSAwO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2h1bmsgIT09ICd1bmRlZmluZWQnICYmIGNodW5rICE9PSBudWxsKVxuICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5lbmRpbmcgJiZcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAhc3RhdGUuZmluaXNoZWQgJiZcbiAgICAgICAgICAhc3RhdGUud3JpdGluZyk7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXG4gKiogbW9kdWxlIGlkID0gNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlc3BvbnNlLCBTdHJlYW0pO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaHR0cC1icm93c2VyaWZ5L2xpYi9yZXNwb25zZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCI7KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpczsgLy8gIzg6IHdlYiB3b3JrZXJzXG4gIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENoYXJhY3RlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG4gIC8vIGVuY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5OTE2Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9uaWduYWddXG4gIG9iamVjdC5idG9hIHx8IChcbiAgb2JqZWN0LmJ0b2EgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGlucHV0IGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIGlucHV0LmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgICApIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIididG9hJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbiAgLy8gZGVjb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAyMDM5Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9hdGtdXG4gIG9iamVjdC5hdG9iIHx8IChcbiAgb2JqZWN0LmF0b2IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoaW5wdXQubGVuZ3RoICUgNCA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlcnNcbiAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgICBidWZmZXIgPSBpbnB1dC5jaGFyQXQoaWR4KyspO1xuICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xuICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICApIHtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGNoYXJhY3RlciBpbiB0YWJsZSAoMC02Mywgbm90IGZvdW5kID0+IC0xKVxuICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxufSgpKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9CYXNlNjQvYmFzZTY0LmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0cztcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldO1xufTtcblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcy5zY2hlbWUgPSAnaHR0cHMnO1xuICAgIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9odHRwcy1icm93c2VyaWZ5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxudmFyIGJpbmRpbmcgPSByZXF1aXJlKCcuL2JpbmRpbmcnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpLm9rO1xuXG4vLyB6bGliIGRvZXNuJ3QgcHJvdmlkZSB0aGVzZSwgc28ga2x1ZGdlIHRoZW0gaW4gZm9sbG93aW5nIHRoZSBzYW1lXG4vLyBjb25zdCBuYW1pbmcgc2NoZW1lIHpsaWIgdXNlcy5cbmJpbmRpbmcuWl9NSU5fV0lORE9XQklUUyA9IDg7XG5iaW5kaW5nLlpfTUFYX1dJTkRPV0JJVFMgPSAxNTtcbmJpbmRpbmcuWl9ERUZBVUxUX1dJTkRPV0JJVFMgPSAxNTtcblxuLy8gZmV3ZXIgdGhhbiA2NCBieXRlcyBwZXIgY2h1bmsgaXMgc3R1cGlkLlxuLy8gdGVjaG5pY2FsbHkgaXQgY291bGQgd29yayB3aXRoIGFzIGZldyBhcyA4LCBidXQgZXZlbiA2NCBieXRlc1xuLy8gaXMgYWJzdXJkbHkgbG93LiAgVXN1YWxseSBhIE1CIG9yIG1vcmUgaXMgYmVzdC5cbmJpbmRpbmcuWl9NSU5fQ0hVTksgPSA2NDtcbmJpbmRpbmcuWl9NQVhfQ0hVTksgPSBJbmZpbml0eTtcbmJpbmRpbmcuWl9ERUZBVUxUX0NIVU5LID0gKDE2ICogMTAyNCk7XG5cbmJpbmRpbmcuWl9NSU5fTUVNTEVWRUwgPSAxO1xuYmluZGluZy5aX01BWF9NRU1MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9NRU1MRVZFTCA9IDg7XG5cbmJpbmRpbmcuWl9NSU5fTEVWRUwgPSAtMTtcbmJpbmRpbmcuWl9NQVhfTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTEVWRUwgPSBiaW5kaW5nLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcblxuLy8gZXhwb3NlIGFsbCB0aGUgemxpYiBjb25zdGFudHNcbk9iamVjdC5rZXlzKGJpbmRpbmcpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBpZiAoay5tYXRjaCgvXlovKSkgZXhwb3J0c1trXSA9IGJpbmRpbmdba107XG59KTtcblxuLy8gdHJhbnNsYXRpb24gdGFibGUgZm9yIHJldHVybiBjb2Rlcy5cbmV4cG9ydHMuY29kZXMgPSB7XG4gIFpfT0s6IGJpbmRpbmcuWl9PSyxcbiAgWl9TVFJFQU1fRU5EOiBiaW5kaW5nLlpfU1RSRUFNX0VORCxcbiAgWl9ORUVEX0RJQ1Q6IGJpbmRpbmcuWl9ORUVEX0RJQ1QsXG4gIFpfRVJSTk86IGJpbmRpbmcuWl9FUlJOTyxcbiAgWl9TVFJFQU1fRVJST1I6IGJpbmRpbmcuWl9TVFJFQU1fRVJST1IsXG4gIFpfREFUQV9FUlJPUjogYmluZGluZy5aX0RBVEFfRVJST1IsXG4gIFpfTUVNX0VSUk9SOiBiaW5kaW5nLlpfTUVNX0VSUk9SLFxuICBaX0JVRl9FUlJPUjogYmluZGluZy5aX0JVRl9FUlJPUixcbiAgWl9WRVJTSU9OX0VSUk9SOiBiaW5kaW5nLlpfVkVSU0lPTl9FUlJPUlxufTtcblxuT2JqZWN0LmtleXMoZXhwb3J0cy5jb2RlcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGV4cG9ydHMuY29kZXNbZXhwb3J0cy5jb2Rlc1trXV0gPSBrO1xufSk7XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwO1xuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhdztcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXc7XG5leHBvcnRzLlVuemlwID0gVW56aXA7XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBEZWZsYXRlKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVJbmZsYXRlID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IEluZmxhdGUobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGVSYXcgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZVJhdyA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlUmF3KG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVHemlwID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IEd6aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUd1bnppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBHdW56aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVVuemlwID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IFVuemlwKG8pO1xufTtcblxuXG4vLyBDb252ZW5pZW5jZSBtZXRob2RzLlxuLy8gY29tcHJlc3MvZGVjb21wcmVzcyBhIHN0cmluZyBvciBidWZmZXIgaW4gb25lIHN0ZXAuXG5leHBvcnRzLmRlZmxhdGUgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmd6aXAgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEd6aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5nemlwU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd6aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXcgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IERlZmxhdGVSYXcob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLnVuemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLnVuemlwU3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IFVuemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5ndW56aXAgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmd1bnppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmluZmxhdGVSYXcgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5mdW5jdGlvbiB6bGliQnVmZmVyKGVuZ2luZSwgYnVmZmVyLCBjYWxsYmFjaykge1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgbnJlYWQgPSAwO1xuXG4gIGVuZ2luZS5vbignZXJyb3InLCBvbkVycm9yKTtcbiAgZW5naW5lLm9uKCdlbmQnLCBvbkVuZCk7XG5cbiAgZW5naW5lLmVuZChidWZmZXIpO1xuICBmbG93KCk7XG5cbiAgZnVuY3Rpb24gZmxvdygpIHtcbiAgICB2YXIgY2h1bms7XG4gICAgd2hpbGUgKG51bGwgIT09IChjaHVuayA9IGVuZ2luZS5yZWFkKCkpKSB7XG4gICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgICBlbmdpbmUub25jZSgncmVhZGFibGUnLCBmbG93KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGZsb3cpO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCk7XG4gICAgYnVmZmVycyA9IFtdO1xuICAgIGNhbGxiYWNrKG51bGwsIGJ1Zik7XG4gICAgZW5naW5lLmNsb3NlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gemxpYkJ1ZmZlclN5bmMoZW5naW5lLCBidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG5cbiAgcmV0dXJuIGVuZ2luZS5fcHJvY2Vzc0NodW5rKGJ1ZmZlciwgZmx1c2hGbGFnKTtcbn1cblxuLy8gZ2VuZXJpYyB6bGliXG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURSk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGUob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURSk7XG59XG5cblxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5mdW5jdGlvbiBHemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd6aXApKSByZXR1cm4gbmV3IEd6aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdaSVApO1xufVxuXG5mdW5jdGlvbiBHdW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3VuemlwKSkgcmV0dXJuIG5ldyBHdW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdVTlpJUCk7XG59XG5cblxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmZ1bmN0aW9uIERlZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZVJhdykpIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuREVGTEFURVJBVyk7XG59XG5cbmZ1bmN0aW9uIEluZmxhdGVSYXcob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZVJhdykpIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuSU5GTEFURVJBVyk7XG59XG5cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuZnVuY3Rpb24gVW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXApKSByZXR1cm4gbmV3IFVuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5VTlpJUCk7XG59XG5cblxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cblxuZnVuY3Rpb24gWmxpYihvcHRzLCBtb2RlKSB7XG4gIHRoaXMuX29wdHMgPSBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5fY2h1bmtTaXplID0gb3B0cy5jaHVua1NpemUgfHwgZXhwb3J0cy5aX0RFRkFVTFRfQ0hVTks7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKG9wdHMuZmx1c2gpIHtcbiAgICBpZiAob3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX05PX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9TWU5DX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9GVUxMX0ZMVVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9GSU5JU0ggJiZcbiAgICAgICAgb3B0cy5mbHVzaCAhPT0gYmluZGluZy5aX0JMT0NLKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmx1c2ggZmxhZzogJyArIG9wdHMuZmx1c2gpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9mbHVzaEZsYWcgPSBvcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcblxuICBpZiAob3B0cy5jaHVua1NpemUpIHtcbiAgICBpZiAob3B0cy5jaHVua1NpemUgPCBleHBvcnRzLlpfTUlOX0NIVU5LIHx8XG4gICAgICAgIG9wdHMuY2h1bmtTaXplID4gZXhwb3J0cy5aX01BWF9DSFVOSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNodW5rIHNpemU6ICcgKyBvcHRzLmNodW5rU2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMud2luZG93Qml0cykge1xuICAgIGlmIChvcHRzLndpbmRvd0JpdHMgPCBleHBvcnRzLlpfTUlOX1dJTkRPV0JJVFMgfHxcbiAgICAgICAgb3B0cy53aW5kb3dCaXRzID4gZXhwb3J0cy5aX01BWF9XSU5ET1dCSVRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgd2luZG93Qml0czogJyArIG9wdHMud2luZG93Qml0cyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubGV2ZWwpIHtcbiAgICBpZiAob3B0cy5sZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHxcbiAgICAgICAgb3B0cy5sZXZlbCA+IGV4cG9ydHMuWl9NQVhfTEVWRUwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb21wcmVzc2lvbiBsZXZlbDogJyArIG9wdHMubGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLm1lbUxldmVsKSB7XG4gICAgaWYgKG9wdHMubWVtTGV2ZWwgPCBleHBvcnRzLlpfTUlOX01FTUxFVkVMIHx8XG4gICAgICAgIG9wdHMubWVtTGV2ZWwgPiBleHBvcnRzLlpfTUFYX01FTUxFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVtTGV2ZWw6ICcgKyBvcHRzLm1lbUxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5zdHJhdGVneSkge1xuICAgIGlmIChvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfUkxFICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIG9wdHMuc3RyYXRlZ3kpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmRpY3Rpb25hcnkpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRzLmRpY3Rpb25hcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGljdGlvbmFyeTogaXQgc2hvdWxkIGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fYmluZGluZyA9IG5ldyBiaW5kaW5nLlpsaWIobW9kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9iaW5kaW5nLm9uZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBlcnJubykge1xuICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgIHNlbGYuX2JpbmRpbmcgPSBudWxsO1xuICAgIHNlbGYuX2hhZEVycm9yID0gdHJ1ZTtcblxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5lcnJubyA9IGVycm5vO1xuICAgIGVycm9yLmNvZGUgPSBleHBvcnRzLmNvZGVzW2Vycm5vXTtcbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB9O1xuXG4gIHZhciBsZXZlbCA9IGV4cG9ydHMuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuICBpZiAodHlwZW9mIG9wdHMubGV2ZWwgPT09ICdudW1iZXInKSBsZXZlbCA9IG9wdHMubGV2ZWw7XG5cbiAgdmFyIHN0cmF0ZWd5ID0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1k7XG4gIGlmICh0eXBlb2Ygb3B0cy5zdHJhdGVneSA9PT0gJ251bWJlcicpIHN0cmF0ZWd5ID0gb3B0cy5zdHJhdGVneTtcblxuICB0aGlzLl9iaW5kaW5nLmluaXQob3B0cy53aW5kb3dCaXRzIHx8IGV4cG9ydHMuWl9ERUZBVUxUX1dJTkRPV0JJVFMsXG4gICAgICAgICAgICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgIG9wdHMubWVtTGV2ZWwgfHwgZXhwb3J0cy5aX0RFRkFVTFRfTUVNTEVWRUwsXG4gICAgICAgICAgICAgICAgICAgICBzdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgIG9wdHMuZGljdGlvbmFyeSk7XG5cbiAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcih0aGlzLl9jaHVua1NpemUpO1xuICB0aGlzLl9vZmZzZXQgPSAwO1xuICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIHRoaXMuY2xvc2UpO1xufVxuXG51dGlsLmluaGVyaXRzKFpsaWIsIFRyYW5zZm9ybSk7XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKGxldmVsLCBzdHJhdGVneSwgY2FsbGJhY2spIHtcbiAgaWYgKGxldmVsIDwgZXhwb3J0cy5aX01JTl9MRVZFTCB8fFxuICAgICAgbGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBsZXZlbCk7XG4gIH1cbiAgaWYgKHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmXG4gICAgICBzdHJhdGVneSAhPSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBzdHJhdGVneSk7XG4gIH1cblxuICBpZiAodGhpcy5fbGV2ZWwgIT09IGxldmVsIHx8IHRoaXMuX3N0cmF0ZWd5ICE9PSBzdHJhdGVneSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZsdXNoKGJpbmRpbmcuWl9TWU5DX0ZMVVNILCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2JpbmRpbmcucGFyYW1zKGxldmVsLCBzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGYuX2hhZEVycm9yKSB7XG4gICAgICAgIHNlbGYuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2JpbmRpbmcucmVzZXQoKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIF9mbHVzaCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRyYW5zZm9ybSBjbGFzcyxcbi8vIGludGVybmFsbHksIHdoZW4gdGhlIGxhc3QgY2h1bmsgaGFzIGJlZW4gd3JpdHRlbi5cblpsaWIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3RyYW5zZm9ybShuZXcgQnVmZmVyKDApLCAnJywgY2FsbGJhY2spO1xufTtcblxuWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihraW5kLCBjYWxsYmFjaykge1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2Yga2luZCA9PT0gJ2Z1bmN0aW9uJyB8fCAoa2luZCA9PT0gdm9pZCAwICYmICFjYWxsYmFjaykpIHtcbiAgICBjYWxsYmFjayA9IGtpbmQ7XG4gICAga2luZCA9IGJpbmRpbmcuWl9GVUxMX0ZMVVNIO1xuICB9XG5cbiAgaWYgKHdzLmVuZGVkKSB7XG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MuZW5kaW5nKSB7XG4gICAgaWYgKGNhbGxiYWNrKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MubmVlZERyYWluKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZmx1c2goY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2ZsdXNoRmxhZyA9IGtpbmQ7XG4gICAgdGhpcy53cml0ZShuZXcgQnVmZmVyKDApLCAnJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcblxuICBpZiAodGhpcy5fY2xvc2VkKVxuICAgIHJldHVybjtcblxuICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG4gIHRoaXMuX2JpbmRpbmcuY2xvc2UoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cblpsaWIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBmbHVzaEZsYWc7XG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBlbmRpbmcgPSB3cy5lbmRpbmcgfHwgd3MuZW5kZWQ7XG4gIHZhciBsYXN0ID0gZW5kaW5nICYmICghY2h1bmsgfHwgd3MubGVuZ3RoID09PSBjaHVuay5sZW5ndGgpO1xuXG4gIGlmICghY2h1bmsgPT09IG51bGwgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCcpKTtcblxuICAvLyBJZiBpdCdzIHRoZSBsYXN0IGNodW5rLCBvciBhIGZpbmFsIGZsdXNoLCB3ZSB1c2UgdGhlIFpfRklOSVNIIGZsdXNoIGZsYWcuXG4gIC8vIElmIGl0J3MgZXhwbGljaXRseSBmbHVzaGluZyBhdCBzb21lIG90aGVyIHRpbWUsIHRoZW4gd2UgdXNlXG4gIC8vIFpfRlVMTF9GTFVTSC4gT3RoZXJ3aXNlLCB1c2UgWl9OT19GTFVTSCBmb3IgbWF4aW11bSBjb21wcmVzc2lvblxuICAvLyBnb29kbmVzcy5cbiAgaWYgKGxhc3QpXG4gICAgZmx1c2hGbGFnID0gYmluZGluZy5aX0ZJTklTSDtcbiAgZWxzZSB7XG4gICAgZmx1c2hGbGFnID0gdGhpcy5fZmx1c2hGbGFnO1xuICAgIC8vIG9uY2Ugd2UndmUgZmx1c2hlZCB0aGUgbGFzdCBvZiB0aGUgcXVldWUsIHN0b3AgZmx1c2hpbmcgYW5kXG4gICAgLy8gZ28gYmFjayB0byB0aGUgbm9ybWFsIGJlaGF2aW9yLlxuICAgIGlmIChjaHVuay5sZW5ndGggPj0gd3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9mbHVzaEZsYWcgPSB0aGlzLl9vcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3Byb2Nlc3NDaHVuayhjaHVuaywgZmx1c2hGbGFnLCBjYik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fcHJvY2Vzc0NodW5rID0gZnVuY3Rpb24oY2h1bmssIGZsdXNoRmxhZywgY2IpIHtcbiAgdmFyIGF2YWlsSW5CZWZvcmUgPSBjaHVuayAmJiBjaHVuay5sZW5ndGg7XG4gIHZhciBhdmFpbE91dEJlZm9yZSA9IHRoaXMuX2NodW5rU2l6ZSAtIHRoaXMuX29mZnNldDtcbiAgdmFyIGluT2ZmID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGFzeW5jID0gdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICghYXN5bmMpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIHZhciBucmVhZCA9IDA7XG5cbiAgICB2YXIgZXJyb3I7XG4gICAgdGhpcy5vbignZXJyb3InLCBmdW5jdGlvbihlcikge1xuICAgICAgZXJyb3IgPSBlcjtcbiAgICB9KTtcblxuICAgIGRvIHtcbiAgICAgIHZhciByZXMgPSB0aGlzLl9iaW5kaW5nLndyaXRlU3luYyhmbHVzaEZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssIC8vIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LCAvL291dF9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cbiAgICB9IHdoaWxlICghdGhpcy5faGFkRXJyb3IgJiYgY2FsbGJhY2socmVzWzBdLCByZXNbMV0pKTtcblxuICAgIGlmICh0aGlzLl9oYWRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIHRoaXMuY2xvc2UoKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICB2YXIgcmVxID0gdGhpcy5fYmluZGluZy53cml0ZShmbHVzaEZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk9mZiwgLy8gaW5fb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQsIC8vb3V0X29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cblxuICByZXEuYnVmZmVyID0gY2h1bms7XG4gIHJlcS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIGZ1bmN0aW9uIGNhbGxiYWNrKGF2YWlsSW5BZnRlciwgYXZhaWxPdXRBZnRlcikge1xuICAgIGlmIChzZWxmLl9oYWRFcnJvcilcbiAgICAgIHJldHVybjtcblxuICAgIHZhciBoYXZlID0gYXZhaWxPdXRCZWZvcmUgLSBhdmFpbE91dEFmdGVyO1xuICAgIGFzc2VydChoYXZlID49IDAsICdoYXZlIHNob3VsZCBub3QgZ28gZG93bicpO1xuXG4gICAgaWYgKGhhdmUgPiAwKSB7XG4gICAgICB2YXIgb3V0ID0gc2VsZi5fYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldCwgc2VsZi5fb2Zmc2V0ICsgaGF2ZSk7XG4gICAgICBzZWxmLl9vZmZzZXQgKz0gaGF2ZTtcbiAgICAgIC8vIHNlcnZlIHNvbWUgb3V0cHV0IHRvIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICBzZWxmLnB1c2gob3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChvdXQpO1xuICAgICAgICBucmVhZCArPSBvdXQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4aGF1c3RlZCB0aGUgb3V0cHV0IGJ1ZmZlciwgb3IgdXNlZCBhbGwgdGhlIGlucHV0IGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDAgfHwgc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2NodW5rU2l6ZSkge1xuICAgICAgYXZhaWxPdXRCZWZvcmUgPSBzZWxmLl9jaHVua1NpemU7XG4gICAgICBzZWxmLl9vZmZzZXQgPSAwO1xuICAgICAgc2VsZi5fYnVmZmVyID0gbmV3IEJ1ZmZlcihzZWxmLl9jaHVua1NpemUpO1xuICAgIH1cblxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwKSB7XG4gICAgICAvLyBOb3QgYWN0dWFsbHkgZG9uZS4gIE5lZWQgdG8gcmVwcm9jZXNzLlxuICAgICAgLy8gQWxzbywgdXBkYXRlIHRoZSBhdmFpbEluQmVmb3JlIHRvIHRoZSBhdmFpbEluQWZ0ZXIgdmFsdWUsXG4gICAgICAvLyBzbyB0aGF0IGlmIHdlIGhhdmUgdG8gaGl0IGl0IGEgdGhpcmQgKGZvdXJ0aCwgZXRjLikgdGltZSxcbiAgICAgIC8vIGl0J2xsIGhhdmUgdGhlIGNvcnJlY3QgYnl0ZSBjb3VudHMuXG4gICAgICBpbk9mZiArPSAoYXZhaWxJbkJlZm9yZSAtIGF2YWlsSW5BZnRlcik7XG4gICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuXG4gICAgICBpZiAoIWFzeW5jKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIG5ld1JlcSA9IHNlbGYuX2JpbmRpbmcud3JpdGUoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbk9mZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsSW5CZWZvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jaHVua1NpemUpO1xuICAgICAgbmV3UmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7IC8vIHRoaXMgc2FtZSBmdW5jdGlvblxuICAgICAgbmV3UmVxLmJ1ZmZlciA9IGNodW5rO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghYXN5bmMpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBmaW5pc2hlZCB3aXRoIHRoZSBjaHVuay5cbiAgICBjYigpO1xuICB9XG59O1xuXG51dGlsLmluaGVyaXRzKERlZmxhdGUsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhJbmZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoR3ppcCwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd1bnppcCwgWmxpYik7XG51dGlsLmluaGVyaXRzKERlZmxhdGVSYXcsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhJbmZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoVW56aXAsIFpsaWIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2Jyb3dzZXJpZnktemxpYi9zcmMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGRhdGEpKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbih0aGlzLl9mbHVzaCkpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHRzLndyaXRlY2h1bmspICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbmZvckVhY2gob2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pXG4gICAgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59KTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3MubmV4dFRpY2sodGhpcy5lbmQuYmluZCh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnID0gcmVxdWlyZSgndXRpbCcpO1xuaWYgKGRlYnVnICYmIGRlYnVnLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWcuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IG9wdGlvbnMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udClcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKGFkZFRvRnJvbnQpXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgdXRpbC5pc051bGwobikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICghdXRpbC5pc051bWJlcihuKSB8fCBuID4gMClcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgJiZcbiAgICAgIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH1cblxuICBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgaWYgKGRvUmVhZCAmJiAhc3RhdGUucmVhZGluZylcbiAgICBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMClcbiAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gIGVsc2VcbiAgICByZXQgPSBudWxsO1xuXG4gIGlmICh1dGlsLmlzTnVsbChyZXQpKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmICghdXRpbC5pc051bGwocmV0KSlcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghdXRpbC5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzU3RyaW5nKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJlxuICAgICAgICAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCkge1xuICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsXG4gICAgICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBicnV0YWxseSB1Z2x5IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXJcbiAgLy8gaXMgYXR0YWNoZWQgYmVmb3JlIGFueSB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy5cbiAgaWYgKCFkZXN0Ll9ldmVudHMgfHwgIWRlc3QuX2V2ZW50cy5lcnJvcilcbiAgICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBlbHNlIGlmIChpc0FycmF5KGRlc3QuX2V2ZW50cy5lcnJvcikpXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yLnVuc2hpZnQob25lcnJvcik7XG4gIGVsc2VcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IgPSBbb25lcnJvciwgZGVzdC5fZXZlbnRzLmVycm9yXTtcblxuXG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKVxuICAgICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcylcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KVxuICAgICAgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdClcbiAgICAgIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSlcbiAgICByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpXG4gICAgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgLy8gSWYgbGlzdGVuaW5nIHRvIGRhdGEsIGFuZCBpdCBoYXMgbm90IGV4cGxpY2l0bHkgYmVlbiBwYXVzZWQsXG4gIC8vIHRoZW4gY2FsbCByZXN1bWUgdG8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YSBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiBmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgdGhpcy5yZXN1bWUoKTtcbiAgfVxuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgICAgICAgICBzZWxmLnJlYWQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIH1cbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICByZXN1bWVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIGRvIHtcbiAgICAgIHZhciBjaHVuayA9IHN0cmVhbS5yZWFkKCk7XG4gICAgfSB3aGlsZSAobnVsbCAhPT0gY2h1bmsgJiYgc3RhdGUuZmxvd2luZyk7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgIGlmICghY2h1bmsgfHwgIXN0YXRlLm9iamVjdE1vZGUgJiYgIWNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh1dGlsLmlzRnVuY3Rpb24oc3RyZWFtW2ldKSAmJiB1dGlsLmlzVW5kZWZpbmVkKHRoaXNbaV0pKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24obikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHV0aWwgKGlnbm9yZWQpXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNiKSlcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdXRpbC5pc1N0cmluZyhjaHVuaykpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpXG4gICAgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO1xuICBlbHNlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcik7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGNicyA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKVxuICAgICAgY2JzLnB1c2goc3RhdGUuYnVmZmVyW2NdLmNhbGxiYWNrKTtcblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5idWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICAgIHN0YXRlLmJ1ZmZlciA9IFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYysrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gICAgZWxzZVxuICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuXG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihjaHVuaykpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZVxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1zZyA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvbWVzc2FnZXMnKTtcbnZhciB6c3RyZWFtID0gcmVxdWlyZSgncGFrby9saWIvemxpYi96c3RyZWFtJyk7XG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlLmpzJyk7XG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9pbmZsYXRlLmpzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9jb25zdGFudHMnKTtcblxuZm9yICh2YXIga2V5IGluIGNvbnN0YW50cykge1xuICBleHBvcnRzW2tleV0gPSBjb25zdGFudHNba2V5XTtcbn1cblxuLy8gemxpYiBtb2Rlc1xuZXhwb3J0cy5OT05FID0gMDtcbmV4cG9ydHMuREVGTEFURSA9IDE7XG5leHBvcnRzLklORkxBVEUgPSAyO1xuZXhwb3J0cy5HWklQID0gMztcbmV4cG9ydHMuR1VOWklQID0gNDtcbmV4cG9ydHMuREVGTEFURVJBVyA9IDU7XG5leHBvcnRzLklORkxBVEVSQVcgPSA2O1xuZXhwb3J0cy5VTlpJUCA9IDc7XG5cbi8qKlxuICogRW11bGF0ZSBOb2RlJ3MgemxpYiBDKysgbGF5ZXIgZm9yIHVzZSBieSB0aGUgSlMgbGF5ZXIgaW4gaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gWmxpYihtb2RlKSB7XG4gIGlmIChtb2RlIDwgZXhwb3J0cy5ERUZMQVRFIHx8IG1vZGUgPiBleHBvcnRzLlVOWklQKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCYWQgYXJndW1lbnRcIik7XG4gICAgXG4gIHRoaXMubW9kZSA9IG1vZGU7XG4gIHRoaXMuaW5pdF9kb25lID0gZmFsc2U7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gZmFsc2U7XG4gIHRoaXMud2luZG93Qml0cyA9IDA7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLm1lbUxldmVsID0gMDtcbiAgdGhpcy5zdHJhdGVneSA9IDA7XG4gIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG59XG5cblpsaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KSB7XG4gIHRoaXMud2luZG93Qml0cyA9IHdpbmRvd0JpdHM7XG4gIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5tZW1MZXZlbCA9IG1lbUxldmVsO1xuICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIC8vIGRpY3Rpb25hcnkgbm90IHN1cHBvcnRlZC5cbiAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQKVxuICAgIHRoaXMud2luZG93Qml0cyArPSAxNjtcbiAgICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUClcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMzI7XG4gICAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVyB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURVJBVylcbiAgICB0aGlzLndpbmRvd0JpdHMgPSAtdGhpcy53aW5kb3dCaXRzO1xuICAgIFxuICB0aGlzLnN0cm0gPSBuZXcgenN0cmVhbSgpO1xuICBcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1pJUDpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgICAgICB0aGlzLnN0cm0sXG4gICAgICAgIHRoaXMubGV2ZWwsXG4gICAgICAgIGV4cG9ydHMuWl9ERUZMQVRFRCxcbiAgICAgICAgdGhpcy53aW5kb3dCaXRzLFxuICAgICAgICB0aGlzLm1lbUxldmVsLFxuICAgICAgICB0aGlzLnN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuVU5aSVA6XG4gICAgICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgICAgIHRoaXMuc3RybSxcbiAgICAgICAgdGhpcy53aW5kb3dCaXRzXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZSBcIiArIHRoaXMubW9kZSk7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKHN0YXR1cyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHRoaXMuaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZsYXRlUGFyYW1zIE5vdCBzdXBwb3J0ZWRcIik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fd3JpdGVDaGVjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaW5pdF9kb25lKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlIGJlZm9yZSBpbml0XCIpO1xuICAgIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLk5PTkUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgXG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIik7XG4gICAgXG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2xvc2UgaXMgcGVuZGluZ1wiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7ICAgIFxuICB0aGlzLl93cml0ZUNoZWNrKCk7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICBcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB2YXIgcmVzID0gc2VsZi5fd3JpdGUoZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbiAgICBzZWxmLmNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKTtcbiAgICBcbiAgICBpZiAoc2VsZi5wZW5kaW5nX2Nsb3NlKVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IG1ldGhvZCBmb3IgTm9kZSBidWZmZXJzLCB1c2VkIGJ5IHBha29cbmZ1bmN0aW9uIGJ1ZmZlclNldChkYXRhLCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IGRhdGFbaV07XG4gIH1cbn1cblxuWmxpYi5wcm90b3R5cGUud3JpdGVTeW5jID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIHRoaXMuX3dyaXRlQ2hlY2soKTtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG4gIFxuICBpZiAoZmx1c2ggIT09IGV4cG9ydHMuWl9OT19GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX1NZTkNfRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9GSU5JU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfQkxPQ0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZsdXNoIHZhbHVlXCIpO1xuICB9XG4gIFxuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIGlucHV0ID0gbmV3IEJ1ZmZlcigwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cbiAgXG4gIGlmIChvdXQuX3NldClcbiAgICBvdXQuc2V0ID0gb3V0Ll9zZXQ7XG4gIGVsc2VcbiAgICBvdXQuc2V0ID0gYnVmZmVyU2V0O1xuICBcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHN0cm0uYXZhaWxfaW4gPSBpbl9sZW47XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5uZXh0X2luID0gaW5fb2ZmO1xuICBzdHJtLmF2YWlsX291dCA9IG91dF9sZW47XG4gIHN0cm0ub3V0cHV0ID0gb3V0O1xuICBzdHJtLm5leHRfb3V0ID0gb3V0X29mZjtcbiAgXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZSBcIiArIHRoaXMubW9kZSk7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gZXhwb3J0cy5aX09LKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgfVxuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICByZXR1cm4gW3N0cm0uYXZhaWxfaW4sIHN0cm0uYXZhaWxfb3V0XTtcbn07XG5cblpsaWIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKSB7XG4gICAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIHtcbiAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICB9XG4gIFxuICB0aGlzLm1vZGUgPSBleHBvcnRzLk5PTkU7XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgdGhpcy5vbmVycm9yKG1zZ1tzdGF0dXNdICsgJzogJyArIHRoaXMuc3RybS5tc2csIHN0YXR1cyk7XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhpcy5jbG9zZSgpO1xufTtcblxuZXhwb3J0cy5abGliID0gWmxpYjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9icm93c2VyaWZ5LXpsaWIvc3JjL2JpbmRpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJzInOiAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gICcxJzogICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAnMCc6ICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcGFrby9saWIvemxpYi9tZXNzYWdlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Bha28vbGliL3psaWIvenN0cmVhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIqTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkgKHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0gtMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSC0xKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gtMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplLU1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSC0xO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMS0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGgtMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0gtMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSC0xID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSC0xO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG52YXIgQ29uZmlnID0gZnVuY3Rpb24gKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn07XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIqRF9DT0RFUysxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIqQkxfQ09ERVMrMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMrMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMipMX0NPREVTKzEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIqTF9DT0RFUysxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIHMuZF9idWYgPSBzLmxpdF9idWZzaXplID4+IDE7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBFWFRSQV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSAvLyBERUZMQVRFIGhlYWRlclxuICAgIHtcbiAgICAgIHZhciBoZWFkZXIgPSAoWl9ERUZMQVRFRCArICgocy53X2JpdHMgLSA4KSA8PCA0KSkgPDwgODtcbiAgICAgIHZhciBsZXZlbF9mbGFncyA9IC0xO1xuXG4gICAgICBpZiAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPCA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA9PT0gNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDM7XG4gICAgICB9XG4gICAgICBoZWFkZXIgfD0gKGxldmVsX2ZsYWdzIDw8IDYpO1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHsgaGVhZGVyIHw9IFBSRVNFVF9ESUNUOyB9XG4gICAgICBoZWFkZXIgKz0gMzEgLSAoaGVhZGVyICUgMzEpO1xuXG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICBwdXRTaG9ydE1TQihzLCBoZWFkZXIpO1xuXG4gICAgICAvKiBTYXZlIHRoZSBhZGxlcjMyIG9mIHRoZSBwcmVzZXQgZGljdGlvbmFyeTogKi9cbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gMTsgLy8gYWRsZXIzMigwTCwgWl9OVUxMLCAwKTtcbiAgICB9XG4gIH1cblxuLy8jaWZkZWYgR1pJUFxuICBpZiAocy5zdGF0dXMgPT09IEVYVFJBX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmV4dHJhLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cblxuICAgICAgd2hpbGUgKHMuZ3ppbmRleCA8IChzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmZmYpKSB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3ppbmRleCA9PT0gcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gTkFNRV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5uYW1lLyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQubmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5uYW1lLmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLmNvbW1lbnQuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IEhDUkNfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgaWYgKHMucGVuZGluZyArIDIgPiBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyIDw9IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgICAgIHN0cm0uYWRsZXIgPSAwOyAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgIH1cbiAgfVxuLy8jZW5kaWZcblxuICAvKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlICovXG4gIGlmIChzLnBlbmRpbmcgIT09IDApIHtcbiAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgLyogU2luY2UgYXZhaWxfb3V0IGlzIDAsIGRlZmxhdGUgd2lsbCBiZSBjYWxsZWQgYWdhaW4gd2l0aFxuICAgICAgICogbW9yZSBvdXRwdXQgc3BhY2UsIGJ1dCBwb3NzaWJseSB3aXRoIGJvdGggcGVuZGluZyBhbmRcbiAgICAgICAqIGF2YWlsX2luIGVxdWFsIHRvIHplcm8uIFRoZXJlIHdvbid0IGJlIGFueXRoaW5nIHRvIGRvLFxuICAgICAgICogYnV0IHRoaXMgaXMgbm90IGFuIGVycm9yIHNpdHVhdGlvbiBzbyBtYWtlIHN1cmUgd2VcbiAgICAgICAqIHJldHVybiBPSyBpbnN0ZWFkIG9mIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwgb2YgZGVmbGF0ZTpcbiAgICAgICAqL1xuICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogVXNlciBtdXN0IG5vdCBwcm92aWRlIG1vcmUgaW5wdXQgYWZ0ZXIgdGhlIGZpcnN0IEZJTklTSDogKi9cbiAgaWYgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9CVUZfRVJST1IpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0ggJiYgcy5zdGF0dXMgIT09IEZJTklTSF9TVEFURSkpIHtcbiAgICB2YXIgYnN0YXRlID0gKHMuc3RyYXRlZ3kgPT09IFpfSFVGRk1BTl9PTkxZKSA/IGRlZmxhdGVfaHVmZihzLCBmbHVzaCkgOlxuICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfUkxFID8gZGVmbGF0ZV9ybGUocywgZmx1c2gpIDpcbiAgICAgICAgY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5mdW5jKHMsIGZsdXNoKSk7XG5cbiAgICBpZiAoYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9ET05FKSB7XG4gICAgICBzLnN0YXR1cyA9IEZJTklTSF9TVEFURTtcbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfTkVFRF9NT1JFIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgICAgLyogYXZvaWQgQlVGX0VSUk9SIG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICB9XG4gICAgICByZXR1cm4gWl9PSztcbiAgICAgIC8qIElmIGZsdXNoICE9IFpfTk9fRkxVU0ggJiYgYXZhaWxfb3V0ID09IDAsIHRoZSBuZXh0IGNhbGxcbiAgICAgICAqIG9mIGRlZmxhdGUgc2hvdWxkIHVzZSB0aGUgc2FtZSBmbHVzaCBwYXJhbWV0ZXIgdG8gbWFrZSBzdXJlXG4gICAgICAgKiB0aGF0IHRoZSBmbHVzaCBpcyBjb21wbGV0ZS4gU28gd2UgZG9uJ3QgaGF2ZSB0byBvdXRwdXQgYW5cbiAgICAgICAqIGVtcHR5IGJsb2NrIGhlcmUsIHRoaXMgd2lsbCBiZSBkb25lIGF0IG5leHQgY2FsbC4gVGhpcyBhbHNvXG4gICAgICAgKiBlbnN1cmVzIHRoYXQgZm9yIGEgdmVyeSBzbWFsbCBvdXRwdXQgYnVmZmVyLCB3ZSBlbWl0IGF0IG1vc3RcbiAgICAgICAqIG9uZSBlbXB0eSBibG9jay5cbiAgICAgICAqL1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19CTE9DS19ET05FKSB7XG4gICAgICBpZiAoZmx1c2ggPT09IFpfUEFSVElBTF9GTFVTSCkge1xuICAgICAgICB0cmVlcy5fdHJfYWxpZ24ocyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmbHVzaCAhPT0gWl9CTE9DSykgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICB0cmVlcy5fdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIKSB7XG4gICAgICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovICAgICAgICAgICAgIC8qIGZvcmdldCBoaXN0b3J5ICovXG4gICAgICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gICAgICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5pbnNlcnQgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICBzLmxhc3RfZmx1c2ggPSAtMTsgLyogYXZvaWQgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCwgc2VlIGFib3ZlICovXG4gICAgICAgIHJldHVybiBaX09LO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0Fzc2VydChzdHJtLT5hdmFpbF9vdXQgPiAwLCBcImJ1ZzJcIik7XG4gIC8vaWYgKHN0cm0uYXZhaWxfb3V0IDw9IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiYnVnMlwiKTt9XG5cbiAgaWYgKGZsdXNoICE9PSBaX0ZJTklTSCkgeyByZXR1cm4gWl9PSzsgfVxuICBpZiAocy53cmFwIDw9IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VORDsgfVxuXG4gIC8qIFdyaXRlIHRoZSB0cmFpbGVyICovXG4gIGlmIChzLndyYXAgPT09IDIpIHtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLmFkbGVyICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiAyNCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCBzdHJtLnRvdGFsX2luICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gOCkgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAxNikgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiAyNCkgJiAweGZmKTtcbiAgfVxuICBlbHNlXG4gIHtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciAmIDB4ZmZmZik7XG4gIH1cblxuICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAvKiBJZiBhdmFpbF9vdXQgaXMgemVybywgdGhlIGFwcGxpY2F0aW9uIHdpbGwgY2FsbCBkZWZsYXRlIGFnYWluXG4gICAqIHRvIGZsdXNoIHRoZSByZXN0LlxuICAgKi9cbiAgaWYgKHMud3JhcCA+IDApIHsgcy53cmFwID0gLXMud3JhcDsgfVxuICAvKiB3cml0ZSB0aGUgdHJhaWxlciBvbmx5IG9uY2UhICovXG4gIHJldHVybiBzLnBlbmRpbmcgIT09IDAgPyBaX09LIDogWl9TVFJFQU1fRU5EO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlRW5kKHN0cm0pIHtcbiAgdmFyIHN0YXR1cztcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXR1cyA9IHN0cm0uc3RhdGUuc3RhdHVzO1xuICBpZiAoc3RhdHVzICE9PSBJTklUX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBFWFRSQV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gTkFNRV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQ09NTUVOVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gSENSQ19TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gQlVTWV9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRklOSVNIX1NUQVRFXG4gICkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IpIDogWl9PSztcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB0aGUgc291cmNlIHN0YXRlIHRvIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZVxuICovXG4vL2Z1bmN0aW9uIGRlZmxhdGVDb3B5KGRlc3QsIHNvdXJjZSkge1xuLy9cbi8vfVxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVTZXREaWN0aW9uYXJ5ID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Bha28vbGliL3psaWIvZGVmbGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzK2xlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpPTAsIGw9Y2h1bmtzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaT0wLCBsPWNodW5rcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24oY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Bha28vbGliL3V0aWxzL2NvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIqTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnNkZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTKzIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENILU1JTl9NQVRDSCsxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbnZhciBTdGF0aWNUcmVlRGVzYyA9IGZ1bmN0aW9uIChzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59O1xuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxudmFyIFRyZWVEZXNjID0gZnVuY3Rpb24oZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufTtcblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQgKHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyoyXS8qLkNvZGUqLywgdHJlZVtjKjIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0qMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCsxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbioyICsxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24qMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24tYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24qMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoLTE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cysxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSoyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20qMiArIDFdLyouTGVuKi8pKnRyZWVbbSoyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttKjIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUysxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cy0xXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuKjIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbioyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUysxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMtMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxPDxleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoLTFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDAgOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxPDxleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMTw8KGV4dHJhX2RiaXRzW2NvZGVdLTcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24qMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMrMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24qMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuKjJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUysxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9bmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24qMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24qMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuKjJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyoyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4qMjtcbiAgdmFyIF9tMiA9IG0qMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaisxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCoyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCoyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlK0xJVEVSQUxTKzEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24qMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSoyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbioyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSoyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAqMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlKzEpKjIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4rMSkqMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYqMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAqMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzgqMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAqMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4rMSkqMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudC0zLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQtMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50LTExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTLTE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSoyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzKihtYXhfYmxpbmRleCsxKSArIDUrNSs0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2Rlcy0yNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2Rlcy0xLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2Rlcy00LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSoyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2Rlcy0xKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzLTEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24qMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLPDwxKSsobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVM8PDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4rMys3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4rMys3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4rNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVM8PDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTPDwxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSsxLCBzLmRfZGVzYy5tYXhfY29kZSsxLCBtYXhfYmxpbmRleCsxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjKjJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10rTElURVJBTFMrMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUtMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9wYWtvL2xpYi96bGliL3RyZWVzLmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgZG9lc24ndCB3b3J0aCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9uYSBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9wYWtvL2xpYi96bGliL2FkbGVyMzIuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9MDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9MDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyYxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyA9IGNyYyBeICgtMSk7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Bha28vbGliL3psaWIvY3JjMzIuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIFpTV0FQMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7Yml0czogOX0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHtiaXRzOiA1fSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICBjYXNlIEhFQUQ6XG4gICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cblxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGTEFHUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVElNRTpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAvLz09PVxuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBPUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWExFTjpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhUUkE6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbmQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBOQU1FOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT01NRU5UOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEhDUkM6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDAgLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJQ1RJRDpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IFpTV0FQMzIoaG9sZCk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElDVDpcbiAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFOlxuICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRURPOlxuICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgYml0cyAtPSAxO1xuICAgICAgLy8tLS0vL1xuXG4gICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICBiaXRzIC09IDI7XG4gICAgICAvLy0tLS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUT1JFRDpcbiAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgIC8vLS0tLy9cbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFlfOlxuICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZOlxuICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVEFCTEU6XG4gICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgIG9wdHMgPSB7Yml0czogc3RhdGUubGVuYml0c307XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0ge2JpdHM6IHN0YXRlLmxlbmJpdHN9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgb3B0cyA9IHtiaXRzOiBzdGF0ZS5kaXN0Yml0c307XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTl86XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOOlxuICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgLy8tLS1cblxuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0xKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLTEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNUOlxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLTEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLTEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTUFUQ0g6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICB9XG4gICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgIGRvIHtcbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIExJVDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGxlZnQtLTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICBicmVhaztcbiAgICBjYXNlIENIRUNLOlxuICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIC8vIFVzZSAnfCcgaW5zZGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICB9XG4gICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCBaU1dBUDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IFpTV0FQMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5HVEg6XG4gICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBET05FOlxuICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgQkFEOlxuICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgTUVNOlxuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIGNhc2UgU1lOQzpcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9wYWtvL2xpYi96bGliL2luZmxhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9wYWtvL2xpYi96bGliL2luZmZhc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMrMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTKzEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgaT0wO1xuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Bha28vbGliL3psaWIvaW5mdHJlZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9hc3NlcnQvYXNzZXJ0LmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4JylcbiAgLCB1dGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJylcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCAoY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyTGlzdChjYWxsYmFjaylcblxuICB0aGlzLl9idWZzICA9IFtdXG4gIHRoaXMubGVuZ3RoID0gMFxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcblxuICAgIHZhciBwaXBlciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayhlcnIpXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbFxuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5vbigncGlwZScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgIHNyYy5vbignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICAgIHRoaXMub24oJ3VucGlwZScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICB9XG4gIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjYWxsYmFjaykpXG4gICAgdGhpcy5hcHBlbmQoY2FsbGJhY2spXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2suZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgICAgQnVmZmVyLmlzQnVmZmVyKGIpICYmIHRoaXMuYXBwZW5kKGIpXG4gICAgfS5iaW5kKHRoaXMpKVxuICB9XG5cbiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcylcbn1cblxudXRpbC5pbmhlcml0cyhCdWZmZXJMaXN0LCBEdXBsZXhTdHJlYW0pXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9vZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIHZhciB0b3QgPSAwLCBpID0gMCwgX3RcbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgX3QgPSB0b3QgKyB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIGlmIChvZmZzZXQgPCBfdClcbiAgICAgIHJldHVybiBbIGksIG9mZnNldCAtIHRvdCBdXG4gICAgdG90ID0gX3RcbiAgfVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHZhciBpc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihidWYpIHx8XG4gICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3RcblxuICAvLyBjb2VyY2UgbnVtYmVyIGFyZ3VtZW50cyB0byBzdHJpbmdzLCBzaW5jZSBCdWZmZXIobnVtYmVyKSBkb2VzXG4gIC8vIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IGFsbG9jYXRpb25cbiAgaWYgKHR5cGVvZiBidWYgPT0gJ251bWJlcicpXG4gICAgYnVmID0gYnVmLnRvU3RyaW5nKClcblxuICB0aGlzLl9idWZzLnB1c2goaXNCdWZmZXIgPyBidWYgOiBuZXcgQnVmZmVyKGJ1ZikpXG4gIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuYXBwZW5kKGJ1ZilcbiAgaWYgKGNhbGxiYWNrKVxuICAgIGNhbGxiYWNrKClcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAoIXRoaXMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLnB1c2gobnVsbClcbiAgc2l6ZSA9IE1hdGgubWluKHNpemUsIHRoaXMubGVuZ3RoKVxuICB0aGlzLnB1c2godGhpcy5zbGljZSgwLCBzaXplKSlcbiAgdGhpcy5jb25zdW1lKHNpemUpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBEdXBsZXhTdHJlYW0ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rKVxuXG4gIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgIHRoaXMuX2NhbGxiYWNrKG51bGwsIHRoaXMuc2xpY2UoKSlcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgfVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuc2xpY2UoaW5kZXgsIGluZGV4ICsgMSlbMF1cbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoZHN0LCBkc3RTdGFydCwgc3JjU3RhcnQsIHNyY0VuZCkge1xuICBpZiAodHlwZW9mIHNyY1N0YXJ0ICE9ICdudW1iZXInIHx8IHNyY1N0YXJ0IDwgMClcbiAgICBzcmNTdGFydCA9IDBcbiAgaWYgKHR5cGVvZiBzcmNFbmQgIT0gJ251bWJlcicgfHwgc3JjRW5kID4gdGhpcy5sZW5ndGgpXG4gICAgc3JjRW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHNyY1N0YXJ0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVybiBkc3QgfHwgbmV3IEJ1ZmZlcigwKVxuICBpZiAoc3JjRW5kIDw9IDApXG4gICAgcmV0dXJuIGRzdCB8fCBuZXcgQnVmZmVyKDApXG5cbiAgdmFyIGNvcHkgICA9ICEhZHN0XG4gICAgLCBvZmYgICAgPSB0aGlzLl9vZmZzZXQoc3JjU3RhcnQpXG4gICAgLCBsZW4gICAgPSBzcmNFbmQgLSBzcmNTdGFydFxuICAgICwgYnl0ZXMgID0gbGVuXG4gICAgLCBidWZvZmYgPSAoY29weSAmJiBkc3RTdGFydCkgfHwgMFxuICAgICwgc3RhcnQgID0gb2ZmWzFdXG4gICAgLCBsXG4gICAgLCBpXG5cbiAgLy8gY29weS9zbGljZSBldmVyeXRoaW5nXG4gIGlmIChzcmNTdGFydCA9PT0gMCAmJiBzcmNFbmQgPT0gdGhpcy5sZW5ndGgpIHtcbiAgICBpZiAoIWNvcHkpIC8vIHNsaWNlLCBqdXN0IHJldHVybiBhIGZ1bGwgY29uY2F0XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdCh0aGlzLl9idWZzKVxuXG4gICAgLy8gY29weSwgbmVlZCB0byBjb3B5IGluZGl2aWR1YWwgYnVmZmVyc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYpXG4gICAgICBidWZvZmYgKz0gdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gZHN0XG4gIH1cblxuICAvLyBlYXN5LCBjaGVhcCBjYXNlIHdoZXJlIGl0J3MgYSBzdWJzZXQgb2Ygb25lIG9mIHRoZSBidWZmZXJzXG4gIGlmIChieXRlcyA8PSB0aGlzLl9idWZzW29mZlswXV0ubGVuZ3RoIC0gc3RhcnQpIHtcbiAgICByZXR1cm4gY29weVxuICAgICAgPyB0aGlzLl9idWZzW29mZlswXV0uY29weShkc3QsIGRzdFN0YXJ0LCBzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgICAgIDogdGhpcy5fYnVmc1tvZmZbMF1dLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICB9XG5cbiAgaWYgKCFjb3B5KSAvLyBhIHNsaWNlLCB3ZSBuZWVkIHNvbWV0aGluZyB0byBjb3B5IGluIHRvXG4gICAgZHN0ID0gbmV3IEJ1ZmZlcihsZW4pXG5cbiAgZm9yIChpID0gb2ZmWzBdOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGwgPSB0aGlzLl9idWZzW2ldLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICBpZiAoYnl0ZXMgPiBsKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBidWZvZmYgKz0gbFxuICAgIGJ5dGVzIC09IGxcblxuICAgIGlmIChzdGFydClcbiAgICAgIHN0YXJ0ID0gMFxuICB9XG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICB3aGlsZSAodGhpcy5fYnVmcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMgPiB0aGlzLl9idWZzWzBdLmxlbmd0aCkge1xuICAgICAgYnl0ZXMgLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMubGVuZ3RoIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLl9idWZzLnNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYnVmc1swXSA9IHRoaXMuX2J1ZnNbMF0uc2xpY2UoYnl0ZXMpXG4gICAgICB0aGlzLmxlbmd0aCAtPSBieXRlc1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZHVwbGljYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSA9IDBcbiAgICAsIGNvcHkgPSBuZXcgQnVmZmVyTGlzdCgpXG5cbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKVxuICAgIGNvcHkuYXBwZW5kKHRoaXMuX2J1ZnNbaV0pXG5cbiAgcmV0dXJuIGNvcHlcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYnVmcy5sZW5ndGggPSAwO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucHVzaChudWxsKTtcbn1cblxuOyhmdW5jdGlvbiAoKSB7XG4gIHZhciBtZXRob2RzID0ge1xuICAgICAgJ3JlYWREb3VibGVCRScgOiA4XG4gICAgLCAncmVhZERvdWJsZUxFJyA6IDhcbiAgICAsICdyZWFkRmxvYXRCRScgIDogNFxuICAgICwgJ3JlYWRGbG9hdExFJyAgOiA0XG4gICAgLCAncmVhZEludDMyQkUnICA6IDRcbiAgICAsICdyZWFkSW50MzJMRScgIDogNFxuICAgICwgJ3JlYWRVSW50MzJCRScgOiA0XG4gICAgLCAncmVhZFVJbnQzMkxFJyA6IDRcbiAgICAsICdyZWFkSW50MTZCRScgIDogMlxuICAgICwgJ3JlYWRJbnQxNkxFJyAgOiAyXG4gICAgLCAncmVhZFVJbnQxNkJFJyA6IDJcbiAgICAsICdyZWFkVUludDE2TEUnIDogMlxuICAgICwgJ3JlYWRJbnQ4JyAgICAgOiAxXG4gICAgLCAncmVhZFVJbnQ4JyAgICA6IDFcbiAgfVxuXG4gIGZvciAodmFyIG0gaW4gbWV0aG9kcykge1xuICAgIChmdW5jdGlvbiAobSkge1xuICAgICAgQnVmZmVyTGlzdC5wcm90b3R5cGVbbV0gPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0aG9kc1ttXSlbbV0oMClcbiAgICAgIH1cbiAgICB9KG0pKVxuICB9XG59KCkpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyTGlzdFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2JsL2JsLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gICAgSFRUUCBIYXdrIEF1dGhlbnRpY2F0aW9uIFNjaGVtZVxuICAgIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBFcmFuIEhhbW1lciA8ZXJhbkBoYW1tZXIuaW8+XG4gICAgQlNEIExpY2Vuc2VkXG4qL1xuXG5cbi8vIERlY2xhcmUgbmFtZXNwYWNlXG5cbnZhciBoYXdrID0ge1xuICAgIGludGVybmFsczoge31cbn07XG5cblxuaGF3ay5jbGllbnQgPSB7XG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBBdXRob3JpemF0aW9uIGhlYWRlciBmb3IgYSBnaXZlbiByZXF1ZXN0XG5cbiAgICAvKlxuICAgICAgICB1cmk6ICdodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/YT1iJyBvciBvYmplY3QgZ2VuZXJhdGVkIGJ5IGhhd2sudXRpbHMucGFyc2VVcmkoKVxuICAgICAgICBtZXRob2Q6IEhUVFAgdmVyYiAoZS5nLiAnR0VUJywgJ1BPU1QnKVxuICAgICAgICBvcHRpb25zOiB7XG5cbiAgICAgICAgICAgIC8vIFJlcXVpcmVkXG5cbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICAgICAgaWQ6ICdkaDM3ZmdqNDkyamUnLFxuICAgICAgICAgICAgICAgIGtleTogJ2FvaWplZG9haWpzZGxha3NqZGwnLFxuICAgICAgICAgICAgICAgIGFsZ29yaXRobTogJ3NoYTI1NicgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc2hhMScsICdzaGEyNTYnXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBPcHRpb25hbFxuXG4gICAgICAgICAgICBleHQ6ICdhcHBsaWNhdGlvbi1zcGVjaWZpYycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YSBzZW50IHZpYSB0aGUgZXh0IGF0dHJpYnV0ZVxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpIC8gMTAwMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgcHJlLWNhbGN1bGF0ZWQgdGltZXN0YW1wIGluIHNlY29uZHNcbiAgICAgICAgICAgIG5vbmNlOiAnMjMzNGYzNGYnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHByZS1nZW5lcmF0ZWQgbm9uY2VcbiAgICAgICAgICAgIGxvY2FsdGltZU9mZnNldE1zZWM6IDQwMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaW1lIG9mZnNldCB0byBzeW5jIHdpdGggc2VydmVyIHRpbWUgKGlnbm9yZWQgaWYgdGltZXN0YW1wIHByb3ZpZGVkKVxuICAgICAgICAgICAgcGF5bG9hZDogJ3tcInNvbWVcIjpcInBheWxvYWRcIn0nLCAgICAgICAgICAgICAgICAgICAgICAvLyBVVEYtOCBlbmNvZGVkIHN0cmluZyBmb3IgYm9keSBoYXNoIGdlbmVyYXRpb24gKGlnbm9yZWQgaWYgaGFzaCBwcm92aWRlZClcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsICAgICAgICAgICAgICAgICAgICAvLyBQYXlsb2FkIGNvbnRlbnQtdHlwZSAoaWdub3JlZCBpZiBoYXNoIHByb3ZpZGVkKVxuICAgICAgICAgICAgaGFzaDogJ1U0TUtLU21pVnhrMzdKQ0NyQVZJalY9JywgICAgICAgICAgICAgICAgICAgIC8vIFByZS1jYWxjdWxhdGVkIHBheWxvYWQgaGFzaFxuICAgICAgICAgICAgYXBwOiAnMjRzMjM0MjNmMzRkeCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE96IGFwcGxpY2F0aW9uIGlkXG4gICAgICAgICAgICBkbGc6ICcyMzRzejM0dHd3M3NkJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ogZGVsZWdhdGVkLWJ5IGFwcGxpY2F0aW9uIGlkXG4gICAgICAgIH1cbiAgICAqL1xuXG4gICAgaGVhZGVyOiBmdW5jdGlvbiAodXJpLCBtZXRob2QsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZmllbGQ6ICcnLFxuICAgICAgICAgICAgYXJ0aWZhY3RzOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0c1xuXG4gICAgICAgIGlmICghdXJpIHx8ICh0eXBlb2YgdXJpICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdXJpICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAgICFtZXRob2QgfHwgdHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICByZXN1bHQuZXJyID0gJ0ludmFsaWQgYXJndW1lbnQgdHlwZSc7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbGljYXRpb24gdGltZVxuXG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcCB8fCBoYXdrLnV0aWxzLm5vdyhvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGNyZWRlbnRpYWxzXG5cbiAgICAgICAgdmFyIGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscyB8fFxuICAgICAgICAgICAgIWNyZWRlbnRpYWxzLmlkIHx8XG4gICAgICAgICAgICAhY3JlZGVudGlhbHMua2V5IHx8XG4gICAgICAgICAgICAhY3JlZGVudGlhbHMuYWxnb3JpdGhtKSB7XG5cbiAgICAgICAgICAgIHJlc3VsdC5lcnIgPSAnSW52YWxpZCBjcmVkZW50aWFscyBvYmplY3QnO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXdrLmNyeXB0by5hbGdvcml0aG1zLmluZGV4T2YoY3JlZGVudGlhbHMuYWxnb3JpdGhtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnIgPSAnVW5rbm93biBhbGdvcml0aG0nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIFVSSVxuXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXJpID0gaGF3ay51dGlscy5wYXJzZVVyaSh1cmkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNpZ25hdHVyZVxuXG4gICAgICAgIHZhciBhcnRpZmFjdHMgPSB7XG4gICAgICAgICAgICB0czogdGltZXN0YW1wLFxuICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgfHwgaGF3ay51dGlscy5yYW5kb21TdHJpbmcoNiksXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlc291cmNlOiB1cmkucmVsYXRpdmUsXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB1cmkucG9ydCxcbiAgICAgICAgICAgIGhhc2g6IG9wdGlvbnMuaGFzaCxcbiAgICAgICAgICAgIGV4dDogb3B0aW9ucy5leHQsXG4gICAgICAgICAgICBhcHA6IG9wdGlvbnMuYXBwLFxuICAgICAgICAgICAgZGxnOiBvcHRpb25zLmRsZ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlc3VsdC5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBheWxvYWQgaGFzaFxuXG4gICAgICAgIGlmICghYXJ0aWZhY3RzLmhhc2ggJiZcbiAgICAgICAgICAgIChvcHRpb25zLnBheWxvYWQgfHwgb3B0aW9ucy5wYXlsb2FkID09PSAnJykpIHtcblxuICAgICAgICAgICAgYXJ0aWZhY3RzLmhhc2ggPSBoYXdrLmNyeXB0by5jYWxjdWxhdGVQYXlsb2FkSGFzaChvcHRpb25zLnBheWxvYWQsIGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgb3B0aW9ucy5jb250ZW50VHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFjID0gaGF3ay5jcnlwdG8uY2FsY3VsYXRlTWFjKCdoZWFkZXInLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgaGVhZGVyXG5cbiAgICAgICAgdmFyIGhhc0V4dCA9IGFydGlmYWN0cy5leHQgIT09IG51bGwgJiYgYXJ0aWZhY3RzLmV4dCAhPT0gdW5kZWZpbmVkICYmIGFydGlmYWN0cy5leHQgIT09ICcnOyAgICAgICAvLyBPdGhlciBmYWxzZXkgdmFsdWVzIGFsbG93ZWRcbiAgICAgICAgdmFyIGhlYWRlciA9ICdIYXdrIGlkPVwiJyArIGNyZWRlbnRpYWxzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICdcIiwgdHM9XCInICsgYXJ0aWZhY3RzLnRzICtcbiAgICAgICAgICAgICAgICAgICAgICdcIiwgbm9uY2U9XCInICsgYXJ0aWZhY3RzLm5vbmNlICtcbiAgICAgICAgICAgICAgICAgICAgIChhcnRpZmFjdHMuaGFzaCA/ICdcIiwgaGFzaD1cIicgKyBhcnRpZmFjdHMuaGFzaCA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzRXh0ID8gJ1wiLCBleHQ9XCInICsgaGF3ay51dGlscy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUoYXJ0aWZhY3RzLmV4dCkgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgJ1wiLCBtYWM9XCInICsgbWFjICsgJ1wiJztcblxuICAgICAgICBpZiAoYXJ0aWZhY3RzLmFwcCkge1xuICAgICAgICAgICAgaGVhZGVyICs9ICcsIGFwcD1cIicgKyBhcnRpZmFjdHMuYXBwICtcbiAgICAgICAgICAgICAgICAgICAgICAoYXJ0aWZhY3RzLmRsZyA/ICdcIiwgZGxnPVwiJyArIGFydGlmYWN0cy5kbGcgOiAnJykgKyAnXCInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmZpZWxkID0gaGVhZGVyO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGEgYmV3aXQgdmFsdWUgZm9yIGEgZ2l2ZW4gVVJJXG5cbiAgICAvKlxuICAgICAgICB1cmk6ICdodHRwOi8vZXhhbXBsZS5jb20vcmVzb3VyY2U/YT1iJ1xuICAgICAgICBvcHRpb25zOiB7XG5cbiAgICAgICAgICAgIC8vIFJlcXVpcmVkXG5cbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgICBpZDogJ2RoMzdmZ2o0OTJqZScsXG4gICAgICAgICAgICBrZXk6ICdhb2lqZWRvYWlqc2RsYWtzamRsJyxcbiAgICAgICAgICAgIGFsZ29yaXRobTogJ3NoYTI1NicgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzaGExJywgJ3NoYTI1NidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0dGxTZWM6IDYwICogNjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVFRMIGluIHNlY29uZHNcblxuICAgICAgICAgICAgLy8gT3B0aW9uYWxcblxuICAgICAgICAgICAgZXh0OiAnYXBwbGljYXRpb24tc3BlY2lmaWMnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9uIHNwZWNpZmljIGRhdGEgc2VudCB2aWEgdGhlIGV4dCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGxvY2FsdGltZU9mZnNldE1zZWM6IDQwMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaW1lIG9mZnNldCB0byBzeW5jIHdpdGggc2VydmVyIHRpbWVcbiAgICAgICAgIH07XG4gICAgKi9cblxuICAgIGJld2l0OiBmdW5jdGlvbiAodXJpLCBvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgaW5wdXRzXG5cbiAgICAgICAgaWYgKCF1cmkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdXJpICE9PSAnc3RyaW5nJykgfHxcbiAgICAgICAgICAgICFvcHRpb25zIHx8XG4gICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICFvcHRpb25zLnR0bFNlYykge1xuXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zLmV4dCA9IChvcHRpb25zLmV4dCA9PT0gbnVsbCB8fCBvcHRpb25zLmV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLmV4dCk7ICAgICAgIC8vIFplcm8gaXMgdmFsaWQgdmFsdWVcblxuICAgICAgICAvLyBBcHBsaWNhdGlvbiB0aW1lXG5cbiAgICAgICAgdmFyIG5vdyA9IGhhd2sudXRpbHMubm93KG9wdGlvbnMubG9jYWx0aW1lT2Zmc2V0TXNlYyk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgY3JlZGVudGlhbHNcblxuICAgICAgICB2YXIgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzIHx8XG4gICAgICAgICAgICAhY3JlZGVudGlhbHMuaWQgfHxcbiAgICAgICAgICAgICFjcmVkZW50aWFscy5rZXkgfHxcbiAgICAgICAgICAgICFjcmVkZW50aWFscy5hbGdvcml0aG0pIHtcblxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhd2suY3J5cHRvLmFsZ29yaXRobXMuaW5kZXhPZihjcmVkZW50aWFscy5hbGdvcml0aG0pID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgVVJJXG5cbiAgICAgICAgdXJpID0gaGF3ay51dGlscy5wYXJzZVVyaSh1cmkpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzaWduYXR1cmVcblxuICAgICAgICB2YXIgZXhwID0gbm93ICsgb3B0aW9ucy50dGxTZWM7XG4gICAgICAgIHZhciBtYWMgPSBoYXdrLmNyeXB0by5jYWxjdWxhdGVNYWMoJ2Jld2l0JywgY3JlZGVudGlhbHMsIHtcbiAgICAgICAgICAgIHRzOiBleHAsXG4gICAgICAgICAgICBub25jZTogJycsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzb3VyY2U6IHVyaS5yZWxhdGl2ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFpbnRhaW4gdHJhaWxpbmcgJz8nIGFuZCBxdWVyeSBwYXJhbXNcbiAgICAgICAgICAgIGhvc3Q6IHVyaS5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHVyaS5wb3J0LFxuICAgICAgICAgICAgZXh0OiBvcHRpb25zLmV4dFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb25zdHJ1Y3QgYmV3aXQ6IGlkXFxleHBcXG1hY1xcZXh0XG5cbiAgICAgICAgdmFyIGJld2l0ID0gY3JlZGVudGlhbHMuaWQgKyAnXFxcXCcgKyBleHAgKyAnXFxcXCcgKyBtYWMgKyAnXFxcXCcgKyBvcHRpb25zLmV4dDtcbiAgICAgICAgcmV0dXJuIGhhd2sudXRpbHMuYmFzZTY0dXJsRW5jb2RlKGJld2l0KTtcbiAgICB9LFxuXG4gICAgLy8gVmFsaWRhdGUgc2VydmVyIHJlc3BvbnNlXG5cbiAgICAvKlxuICAgICAgICByZXF1ZXN0OiAgICBvYmplY3QgY3JlYXRlZCB2aWEgJ25ldyBYTUxIdHRwUmVxdWVzdCgpJyBhZnRlciByZXNwb25zZSByZWNlaXZlZFxuICAgICAgICBhcnRpZmFjdHM6ICBvYmplY3QgcmVjZWl2ZWQgZnJvbSBoZWFkZXIoKS5hcnRpZmFjdHNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcGF5bG9hZDogICAgb3B0aW9uYWwgcGF5bG9hZCByZWNlaXZlZFxuICAgICAgICAgICAgcmVxdWlyZWQ6ICAgc3BlY2lmaWVzIGlmIGEgU2VydmVyLUF1dGhvcml6YXRpb24gaGVhZGVyIGlzIHJlcXVpcmVkLiBEZWZhdWx0cyB0byAnZmFsc2UnXG4gICAgICAgIH1cbiAgICAqL1xuXG4gICAgYXV0aGVudGljYXRlOiBmdW5jdGlvbiAocmVxdWVzdCwgY3JlZGVudGlhbHMsIGFydGlmYWN0cywgb3B0aW9ucykge1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHZhciBnZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciA/IHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSkgOiByZXF1ZXN0LmdldEhlYWRlcihuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgd3d3QXV0aGVudGljYXRlID0gZ2V0SGVhZGVyKCd3d3ctYXV0aGVudGljYXRlJyk7XG4gICAgICAgIGlmICh3d3dBdXRoZW50aWNhdGUpIHtcblxuICAgICAgICAgICAgLy8gUGFyc2UgSFRUUCBXV1ctQXV0aGVudGljYXRlIGhlYWRlclxuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGhhd2sudXRpbHMucGFyc2VBdXRob3JpemF0aW9uSGVhZGVyKHd3d0F1dGhlbnRpY2F0ZSwgWyd0cycsICd0c20nLCAnZXJyb3InXSk7XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzbSA9IGhhd2suY3J5cHRvLmNhbGN1bGF0ZVRzTWFjKGF0dHJpYnV0ZXMudHMsIGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBpZiAodHNtICE9PSBhdHRyaWJ1dGVzLnRzbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGF3ay51dGlscy5zZXROdHBPZmZzZXQoYXR0cmlidXRlcy50cyAtIE1hdGguZmxvb3IoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDApKTsgICAgIC8vIEtlZXAgb2Zmc2V0IGF0IDEgc2Vjb25kIHByZWNpc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgSFRUUCBTZXJ2ZXItQXV0aG9yaXphdGlvbiBoZWFkZXJcblxuICAgICAgICB2YXIgc2VydmVyQXV0aG9yaXphdGlvbiA9IGdldEhlYWRlcignc2VydmVyLWF1dGhvcml6YXRpb24nKTtcbiAgICAgICAgaWYgKCFzZXJ2ZXJBdXRob3JpemF0aW9uICYmXG4gICAgICAgICAgICAhb3B0aW9ucy5yZXF1aXJlZCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gaGF3ay51dGlscy5wYXJzZUF1dGhvcml6YXRpb25IZWFkZXIoc2VydmVyQXV0aG9yaXphdGlvbiwgWydtYWMnLCAnZXh0JywgJ2hhc2gnXSk7XG4gICAgICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZEFydGlmYWN0cyA9IHtcbiAgICAgICAgICAgIHRzOiBhcnRpZmFjdHMudHMsXG4gICAgICAgICAgICBub25jZTogYXJ0aWZhY3RzLm5vbmNlLFxuICAgICAgICAgICAgbWV0aG9kOiBhcnRpZmFjdHMubWV0aG9kLFxuICAgICAgICAgICAgcmVzb3VyY2U6IGFydGlmYWN0cy5yZXNvdXJjZSxcbiAgICAgICAgICAgIGhvc3Q6IGFydGlmYWN0cy5ob3N0LFxuICAgICAgICAgICAgcG9ydDogYXJ0aWZhY3RzLnBvcnQsXG4gICAgICAgICAgICBoYXNoOiBhdHRyaWJ1dGVzLmhhc2gsXG4gICAgICAgICAgICBleHQ6IGF0dHJpYnV0ZXMuZXh0LFxuICAgICAgICAgICAgYXBwOiBhcnRpZmFjdHMuYXBwLFxuICAgICAgICAgICAgZGxnOiBhcnRpZmFjdHMuZGxnXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1hYyA9IGhhd2suY3J5cHRvLmNhbGN1bGF0ZU1hYygncmVzcG9uc2UnLCBjcmVkZW50aWFscywgbW9kQXJ0aWZhY3RzKTtcbiAgICAgICAgaWYgKG1hYyAhPT0gYXR0cmlidXRlcy5tYWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5wYXlsb2FkICYmXG4gICAgICAgICAgICBvcHRpb25zLnBheWxvYWQgIT09ICcnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxjdWxhdGVkSGFzaCA9IGhhd2suY3J5cHRvLmNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdGlvbnMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBnZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKTtcbiAgICAgICAgcmV0dXJuIChjYWxjdWxhdGVkSGFzaCA9PT0gYXR0cmlidXRlcy5oYXNoKTtcbiAgICB9LFxuXG4gICAgbWVzc2FnZTogZnVuY3Rpb24gKGhvc3QsIHBvcnQsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBpbnB1dHNcblxuICAgICAgICBpZiAoIWhvc3QgfHwgdHlwZW9mIGhvc3QgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhcG9ydCB8fCB0eXBlb2YgcG9ydCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbGljYXRpb24gdGltZVxuXG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBvcHRpb25zLnRpbWVzdGFtcCB8fCBoYXdrLnV0aWxzLm5vdyhvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGNyZWRlbnRpYWxzXG5cbiAgICAgICAgdmFyIGNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscztcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscyB8fFxuICAgICAgICAgICAgIWNyZWRlbnRpYWxzLmlkIHx8XG4gICAgICAgICAgICAhY3JlZGVudGlhbHMua2V5IHx8XG4gICAgICAgICAgICAhY3JlZGVudGlhbHMuYWxnb3JpdGhtKSB7XG5cbiAgICAgICAgICAgIC8vIEludmFsaWQgY3JlZGVudGlhbCBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhd2suY3J5cHRvLmFsZ29yaXRobXMuaW5kZXhPZihjcmVkZW50aWFscy5hbGdvcml0aG0pID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2lnbmF0dXJlXG5cbiAgICAgICAgdmFyIGFydGlmYWN0cyA9IHtcbiAgICAgICAgICAgIHRzOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSB8fCBoYXdrLnV0aWxzLnJhbmRvbVN0cmluZyg2KSxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICBwb3J0OiBwb3J0LFxuICAgICAgICAgICAgaGFzaDogaGF3ay5jcnlwdG8uY2FsY3VsYXRlUGF5bG9hZEhhc2gobWVzc2FnZSwgY3JlZGVudGlhbHMuYWxnb3JpdGhtKVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBhdXRob3JpemF0aW9uXG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGlkOiBjcmVkZW50aWFscy5pZCxcbiAgICAgICAgICAgIHRzOiBhcnRpZmFjdHMudHMsXG4gICAgICAgICAgICBub25jZTogYXJ0aWZhY3RzLm5vbmNlLFxuICAgICAgICAgICAgaGFzaDogYXJ0aWZhY3RzLmhhc2gsXG4gICAgICAgICAgICBtYWM6IGhhd2suY3J5cHRvLmNhbGN1bGF0ZU1hYygnbWVzc2FnZScsIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXV0aGVudGljYXRlVGltZXN0YW1wOiBmdW5jdGlvbiAobWVzc2FnZSwgY3JlZGVudGlhbHMsIHVwZGF0ZUNsb2NrKSB7ICAgICAgICAgICAvLyB1cGRhdGVDbG9jayBkZWZhdWx0cyB0byB0cnVlXG5cbiAgICAgICAgdmFyIHRzbSA9IGhhd2suY3J5cHRvLmNhbGN1bGF0ZVRzTWFjKG1lc3NhZ2UudHMsIGNyZWRlbnRpYWxzKTtcbiAgICAgICAgaWYgKHRzbSAhPT0gbWVzc2FnZS50c20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVDbG9jayAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhhd2sudXRpbHMuc2V0TnRwT2Zmc2V0KG1lc3NhZ2UudHMgLSBNYXRoLmZsb29yKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwKSk7ICAgIC8vIEtlZXAgb2Zmc2V0IGF0IDEgc2Vjb25kIHByZWNpc2lvblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuXG5oYXdrLmNyeXB0byA9IHtcblxuICAgIGhlYWRlclZlcnNpb246ICcxJyxcblxuICAgIGFsZ29yaXRobXM6IFsnc2hhMScsICdzaGEyNTYnXSxcblxuICAgIGNhbGN1bGF0ZU1hYzogZnVuY3Rpb24gKHR5cGUsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBoYXdrLmNyeXB0by5nZW5lcmF0ZU5vcm1hbGl6ZWRTdHJpbmcodHlwZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIGhtYWMgPSBDcnlwdG9KU1snSG1hYycgKyBjcmVkZW50aWFscy5hbGdvcml0aG0udG9VcHBlckNhc2UoKV0obm9ybWFsaXplZCwgY3JlZGVudGlhbHMua2V5KTtcbiAgICAgICAgcmV0dXJuIGhtYWMudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLkJhc2U2NCk7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlTm9ybWFsaXplZFN0cmluZzogZnVuY3Rpb24gKHR5cGUsIG9wdGlvbnMpIHtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9ICdoYXdrLicgKyBoYXdrLmNyeXB0by5oZWFkZXJWZXJzaW9uICsgJy4nICsgdHlwZSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRzICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm9uY2UgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMubWV0aG9kIHx8ICcnKS50b1VwcGVyQ2FzZSgpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLnJlc291cmNlIHx8ICcnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhvc3QudG9Mb3dlckNhc2UoKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBvcnQgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMuaGFzaCB8fCAnJykgKyAnXFxuJztcblxuICAgICAgICBpZiAob3B0aW9ucy5leHQpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgKz0gb3B0aW9ucy5leHQucmVwbGFjZSgnXFxcXCcsICdcXFxcXFxcXCcpLnJlcGxhY2UoJ1xcbicsICdcXFxcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZCArPSAnXFxuJztcblxuICAgICAgICBpZiAob3B0aW9ucy5hcHApIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgKz0gb3B0aW9ucy5hcHAgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLmRsZyB8fCAnJykgKyAnXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH0sXG5cbiAgICBjYWxjdWxhdGVQYXlsb2FkSGFzaDogZnVuY3Rpb24gKHBheWxvYWQsIGFsZ29yaXRobSwgY29udGVudFR5cGUpIHtcblxuICAgICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLmFsZ29bYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCldLmNyZWF0ZSgpO1xuICAgICAgICBoYXNoLnVwZGF0ZSgnaGF3ay4nICsgaGF3ay5jcnlwdG8uaGVhZGVyVmVyc2lvbiArICcucGF5bG9hZFxcbicpO1xuICAgICAgICBoYXNoLnVwZGF0ZShoYXdrLnV0aWxzLnBhcnNlQ29udGVudFR5cGUoY29udGVudFR5cGUpICsgJ1xcbicpO1xuICAgICAgICBoYXNoLnVwZGF0ZShwYXlsb2FkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoJ1xcbicpO1xuICAgICAgICByZXR1cm4gaGFzaC5maW5hbGl6ZSgpLnRvU3RyaW5nKENyeXB0b0pTLmVuYy5CYXNlNjQpO1xuICAgIH0sXG5cbiAgICBjYWxjdWxhdGVUc01hYzogZnVuY3Rpb24gKHRzLCBjcmVkZW50aWFscykge1xuXG4gICAgICAgIHZhciBoYXNoID0gQ3J5cHRvSlNbJ0htYWMnICsgY3JlZGVudGlhbHMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCldKCdoYXdrLicgKyBoYXdrLmNyeXB0by5oZWFkZXJWZXJzaW9uICsgJy50c1xcbicgKyB0cyArICdcXG4nLCBjcmVkZW50aWFscy5rZXkpO1xuICAgICAgICByZXR1cm4gaGFzaC50b1N0cmluZyhDcnlwdG9KUy5lbmMuQmFzZTY0KTtcbiAgICB9XG59O1xuXG5cbi8vIGxvY2FsU3RvcmFnZSBjb21wYXRpYmxlIGludGVyZmFjZVxuXG5oYXdrLmludGVybmFscy5Mb2NhbFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/IFN0cmluZyh0aGlzLl9jYWNoZVtrZXldKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gT2JqZWN0LmtleXModGhpcy5fY2FjaGUpLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVtrZXldO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IE9iamVjdC5rZXlzKHRoaXMuX2NhY2hlKS5sZW5ndGg7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICB0aGlzLmtleSA9IGZ1bmN0aW9uIChpKSB7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2NhY2hlKVtpIHx8IDBdO1xuICAgIH07XG59O1xuXG5cbmhhd2sudXRpbHMgPSB7XG5cbiAgICBzdG9yYWdlOiBuZXcgaGF3ay5pbnRlcm5hbHMuTG9jYWxTdG9yYWdlKCksXG5cbiAgICBzZXRTdG9yYWdlOiBmdW5jdGlvbiAoc3RvcmFnZSkge1xuXG4gICAgICAgIHZhciBudHBPZmZzZXQgPSBoYXdrLnV0aWxzLnN0b3JhZ2UuZ2V0SXRlbSgnaGF3a19udHBfb2Zmc2V0Jyk7XG4gICAgICAgIGhhd2sudXRpbHMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgICAgIGlmIChudHBPZmZzZXQpIHtcbiAgICAgICAgICAgIGhhd2sudXRpbHMuc2V0TnRwT2Zmc2V0KG50cE9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0TnRwT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhd2sudXRpbHMuc3RvcmFnZS5zZXRJdGVtKCdoYXdrX250cF9vZmZzZXQnLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1toYXdrXSBjb3VsZCBub3Qgd3JpdGUgdG8gc3RvcmFnZS4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXROdHBPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gaGF3ay51dGlscy5zdG9yYWdlLmdldEl0ZW0oJ2hhd2tfbnRwX29mZnNldCcpO1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VJbnQob2Zmc2V0LCAxMCk7XG4gICAgfSxcblxuICAgIG5vdzogZnVuY3Rpb24gKGxvY2FsdGltZU9mZnNldE1zZWMpIHtcblxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSArIChsb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApKSAvIDEwMDApICsgaGF3ay51dGlscy5nZXROdHBPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgZXNjYXBlSGVhZGVyQXR0cmlidXRlOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpO1xuICAgIH0sXG5cbiAgICBwYXJzZUNvbnRlbnRUeXBlOiBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWFkZXIuc3BsaXQoJzsnKVswXS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgcGFyc2VBdXRob3JpemF0aW9uSGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyLCBrZXlzKSB7XG5cbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlYWRlclBhcnRzID0gaGVhZGVyLm1hdGNoKC9eKFxcdyspKD86XFxzKyguKikpPyQvKTsgICAgICAgLy8gSGVhZGVyOiBzY2hlbWVbIHNvbWV0aGluZ11cbiAgICAgICAgaWYgKCFoZWFkZXJQYXJ0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NoZW1lID0gaGVhZGVyUGFydHNbMV07XG4gICAgICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2hhd2snKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzU3RyaW5nID0gaGVhZGVyUGFydHNbMl07XG4gICAgICAgIGlmICghYXR0cmlidXRlc1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB2YXIgdmVyaWZ5ID0gYXR0cmlidXRlc1N0cmluZy5yZXBsYWNlKC8oXFx3Kyk9XCIoW15cIlxcXFxdKilcIlxccyooPzosXFxzKnwkKS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuXG4gICAgICAgICAgICAvLyBDaGVjayB2YWxpZCBhdHRyaWJ1dGUgbmFtZXNcblxuICAgICAgICAgICAgaWYgKGtleXMuaW5kZXhPZigkMSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGxvd2VkIGF0dHJpYnV0ZSB2YWx1ZSBjaGFyYWN0ZXJzOiAhIyQlJicoKSorLC0uLzo7PD0+P0BbXV5fYHt8fX4gYW5kIHNwYWNlLCBhLXosIEEtWiwgMC05XG5cbiAgICAgICAgICAgIGlmICgkMi5tYXRjaCgvXlsgXFx3XFwhI1xcJCUmJ1xcKFxcKVxcKlxcKyxcXC1cXC5cXC9cXDo7PFxcPT5cXD9AXFxbXFxdXFxeYFxce1xcfFxcfX5dKyQvKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXNcblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRyaWJ1dGVzWyQxXSA9ICQyO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodmVyaWZ5ICE9PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgcmFuZG9tU3RyaW5nOiBmdW5jdGlvbiAoc2l6ZSkge1xuXG4gICAgICAgIHZhciByYW5kb21Tb3VyY2UgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknO1xuICAgICAgICB2YXIgbGVuID0gcmFuZG9tU291cmNlLmxlbmd0aDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSByYW5kb21Tb3VyY2VbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBwYXJzZVVyaTogZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgICAgICAgLy8gQmFzZWQgb246IHBhcnNlVVJJIDEuMi4yXG4gICAgICAgIC8vIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9wYXJzZXVyaVxuICAgICAgICAvLyAoYykgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gICAgICAgIC8vIE1JVCBMaWNlbnNlXG5cbiAgICAgICAgdmFyIGtleXMgPSBbJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0bmFtZScsICdwb3J0JywgJ3Jlc291cmNlJywgJ3JlbGF0aXZlJywgJ3BhdGhuYW1lJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2ZyYWdtZW50J107XG5cbiAgICAgICAgdmFyIHVyaVJlZ2V4ID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8pKD86IyguKikpPykvO1xuICAgICAgICB2YXIgdXJpQnlOdW1iZXIgPSBpbnB1dC5tYXRjaCh1cmlSZWdleCk7XG4gICAgICAgIHZhciB1cmkgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgIHVyaVtrZXlzW2ldXSA9IHVyaUJ5TnVtYmVyW2ldIHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVyaS5wb3J0ID09PSAnJykge1xuICAgICAgICAgICAgdXJpLnBvcnQgPSAodXJpLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwJyA/ICc4MCcgOiAodXJpLnByb3RvY29sLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwcycgPyAnNDQzJyA6ICcnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH0sXG5cbiAgICBiYXNlNjR1cmxFbmNvZGU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHZhciBlbmNvZGVkID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFw9L2csICcnKTtcbiAgICB9XG59O1xuXG5cbi8vICRsYWI6Y292ZXJhZ2U6b2ZmJFxuXG4vLyBCYXNlZCBvbjogQ3J5cHRvLUpTIHYzLjEuMlxuLy8gQ29weXJpZ2h0IChjKSAyMDA5LTIwMTMsIEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvXG4vLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuXG52YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCBmdW5jdGlvbiAoaCwgcikgeyB2YXIgayA9IHt9LCBsID0gay5saWIgPSB7fSwgbiA9IGZ1bmN0aW9uICgpIHsgfSwgZiA9IGwuQmFzZSA9IHsgZXh0ZW5kOiBmdW5jdGlvbiAoYSkgeyBuLnByb3RvdHlwZSA9IHRoaXM7IHZhciBiID0gbmV3IG47IGEgJiYgYi5taXhJbihhKTsgYi5oYXNPd25Qcm9wZXJ0eShcImluaXRcIikgfHwgKGIuaW5pdCA9IGZ1bmN0aW9uICgpIHsgYi4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0pOyBiLmluaXQucHJvdG90eXBlID0gYjsgYi4kc3VwZXIgPSB0aGlzOyByZXR1cm4gYiB9LCBjcmVhdGU6IGZ1bmN0aW9uICgpIHsgdmFyIGEgPSB0aGlzLmV4dGVuZCgpOyBhLmluaXQuYXBwbHkoYSwgYXJndW1lbnRzKTsgcmV0dXJuIGEgfSwgaW5pdDogZnVuY3Rpb24gKCkgeyB9LCBtaXhJbjogZnVuY3Rpb24gKGEpIHsgZm9yICh2YXIgYiBpbiBhKSBhLmhhc093blByb3BlcnR5KGIpICYmICh0aGlzW2JdID0gYVtiXSk7IGEuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSAmJiAodGhpcy50b1N0cmluZyA9IGEudG9TdHJpbmcpIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKSB9IH0sIGogPSBsLldvcmRBcnJheSA9IGYuZXh0ZW5kKHsgaW5pdDogZnVuY3Rpb24gKGEsIGIpIHsgYSA9IHRoaXMud29yZHMgPSBhIHx8IFtdOyB0aGlzLnNpZ0J5dGVzID0gYiAhPSByID8gYiA6IDQgKiBhLmxlbmd0aCB9LCB0b1N0cmluZzogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChhIHx8IHMpLnN0cmluZ2lmeSh0aGlzKSB9LCBjb25jYXQ6IGZ1bmN0aW9uIChhKSB7IHZhciBiID0gdGhpcy53b3JkcywgZCA9IGEud29yZHMsIGMgPSB0aGlzLnNpZ0J5dGVzOyBhID0gYS5zaWdCeXRlczsgdGhpcy5jbGFtcCgpOyBpZiAoYyAlIDQpIGZvciAodmFyIGUgPSAwOyBlIDwgYTsgZSsrKSBiW2MgKyBlID4+PiAyXSB8PSAoZFtlID4+PiAyXSA+Pj4gMjQgLSA4ICogKGUgJSA0KSAmIDI1NSkgPDwgMjQgLSA4ICogKChjICsgZSkgJSA0KTsgZWxzZSBpZiAoNjU1MzUgPCBkLmxlbmd0aCkgZm9yIChlID0gMDsgZSA8IGE7IGUgKz0gNCkgYltjICsgZSA+Pj4gMl0gPSBkW2UgPj4+IDJdOyBlbHNlIGIucHVzaC5hcHBseShiLCBkKTsgdGhpcy5zaWdCeXRlcyArPSBhOyByZXR1cm4gdGhpcyB9LCBjbGFtcDogZnVuY3Rpb24gKCkgeyB2YXIgYSA9IHRoaXMud29yZHMsIGIgPSB0aGlzLnNpZ0J5dGVzOyBhW2IgPj4+IDJdICY9IDQyOTQ5NjcyOTUgPDwgMzIgLSA4ICogKGIgJSA0KTsgYS5sZW5ndGggPSBoLmNlaWwoYiAvIDQpIH0sIGNsb25lOiBmdW5jdGlvbiAoKSB7IHZhciBhID0gZi5jbG9uZS5jYWxsKHRoaXMpOyBhLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTsgcmV0dXJuIGEgfSwgcmFuZG9tOiBmdW5jdGlvbiAoYSkgeyBmb3IgKHZhciBiID0gW10sIGQgPSAwOyBkIDwgYTsgZCArPSA0KSBiLnB1c2goNDI5NDk2NzI5NiAqIGgucmFuZG9tKCkgfCAwKTsgcmV0dXJuIG5ldyBqLmluaXQoYiwgYSkgfSB9KSwgbSA9IGsuZW5jID0ge30sIHMgPSBtLkhleCA9IHsgc3RyaW5naWZ5OiBmdW5jdGlvbiAoYSkgeyB2YXIgYiA9IGEud29yZHM7IGEgPSBhLnNpZ0J5dGVzOyBmb3IgKHZhciBkID0gW10sIGMgPSAwOyBjIDwgYTsgYysrKSB7IHZhciBlID0gYltjID4+PiAyXSA+Pj4gMjQgLSA4ICogKGMgJSA0KSAmIDI1NTsgZC5wdXNoKChlID4+PiA0KS50b1N0cmluZygxNikpOyBkLnB1c2goKGUgJiAxNSkudG9TdHJpbmcoMTYpKSB9IHJldHVybiBkLmpvaW4oXCJcIikgfSwgcGFyc2U6IGZ1bmN0aW9uIChhKSB7IGZvciAodmFyIGIgPSBhLmxlbmd0aCwgZCA9IFtdLCBjID0gMDsgYyA8IGI7IGMgKz0gMikgZFtjID4+PiAzXSB8PSBwYXJzZUludChhLnN1YnN0cihjLCAyKSwgMTYpIDw8IDI0IC0gNCAqIChjICUgOCk7IHJldHVybiBuZXcgai5pbml0KGQsIGIgLyAyKSB9IH0sIHAgPSBtLkxhdGluMSA9IHsgc3RyaW5naWZ5OiBmdW5jdGlvbiAoYSkgeyB2YXIgYiA9IGEud29yZHM7IGEgPSBhLnNpZ0J5dGVzOyBmb3IgKHZhciBkID0gW10sIGMgPSAwOyBjIDwgYTsgYysrKSBkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiW2MgPj4+IDJdID4+PiAyNCAtIDggKiAoYyAlIDQpICYgMjU1KSk7IHJldHVybiBkLmpvaW4oXCJcIikgfSwgcGFyc2U6IGZ1bmN0aW9uIChhKSB7IGZvciAodmFyIGIgPSBhLmxlbmd0aCwgZCA9IFtdLCBjID0gMDsgYyA8IGI7IGMrKykgZFtjID4+PiAyXSB8PSAoYS5jaGFyQ29kZUF0KGMpICYgMjU1KSA8PCAyNCAtIDggKiAoYyAlIDQpOyByZXR1cm4gbmV3IGouaW5pdChkLCBiKSB9IH0sIHQgPSBtLlV0ZjggPSB7IHN0cmluZ2lmeTogZnVuY3Rpb24gKGEpIHsgdHJ5IHsgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocC5zdHJpbmdpZnkoYSkpKSB9IGNhdGNoIChiKSB7IHRocm93IEVycm9yKFwiTWFsZm9ybWVkIFVURi04IGRhdGFcIik7IH0gfSwgcGFyc2U6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBwLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChhKSkpIH0gfSwgcSA9IGwuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IGYuZXh0ZW5kKHsgcmVzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGF0YSA9IG5ldyBqLmluaXQ7IHRoaXMuX25EYXRhQnl0ZXMgPSAwIH0sIF9hcHBlbmQ6IGZ1bmN0aW9uIChhKSB7IFwic3RyaW5nXCIgPT0gdHlwZW9mIGEgJiYgKGEgPSB0LnBhcnNlKGEpKTsgdGhpcy5fZGF0YS5jb25jYXQoYSk7IHRoaXMuX25EYXRhQnl0ZXMgKz0gYS5zaWdCeXRlcyB9LCBfcHJvY2VzczogZnVuY3Rpb24gKGEpIHsgdmFyIGIgPSB0aGlzLl9kYXRhLCBkID0gYi53b3JkcywgYyA9IGIuc2lnQnl0ZXMsIGUgPSB0aGlzLmJsb2NrU2l6ZSwgZiA9IGMgLyAoNCAqIGUpLCBmID0gYSA/IGguY2VpbChmKSA6IGgubWF4KChmIHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTsgYSA9IGYgKiBlOyBjID0gaC5taW4oNCAqIGEsIGMpOyBpZiAoYSkgeyBmb3IgKHZhciBnID0gMDsgZyA8IGE7IGcgKz0gZSkgdGhpcy5fZG9Qcm9jZXNzQmxvY2soZCwgZyk7IGcgPSBkLnNwbGljZSgwLCBhKTsgYi5zaWdCeXRlcyAtPSBjIH0gcmV0dXJuIG5ldyBqLmluaXQoZywgYykgfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHsgdmFyIGEgPSBmLmNsb25lLmNhbGwodGhpcyk7IGEuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7IHJldHVybiBhIH0sIF9taW5CdWZmZXJTaXplOiAwIH0pOyBsLkhhc2hlciA9IHEuZXh0ZW5kKHsgY2ZnOiBmLmV4dGVuZCgpLCBpbml0OiBmdW5jdGlvbiAoYSkgeyB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChhKTsgdGhpcy5yZXNldCgpIH0sIHJlc2V0OiBmdW5jdGlvbiAoKSB7IHEucmVzZXQuY2FsbCh0aGlzKTsgdGhpcy5fZG9SZXNldCgpIH0sIHVwZGF0ZTogZnVuY3Rpb24gKGEpIHsgdGhpcy5fYXBwZW5kKGEpOyB0aGlzLl9wcm9jZXNzKCk7IHJldHVybiB0aGlzIH0sIGZpbmFsaXplOiBmdW5jdGlvbiAoYSkgeyBhICYmIHRoaXMuX2FwcGVuZChhKTsgcmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKSB9LCBibG9ja1NpemU6IDE2LCBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIsIGQpIHsgcmV0dXJuIChuZXcgYS5pbml0KGQpKS5maW5hbGl6ZShiKSB9IH0sIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gZnVuY3Rpb24gKGIsIGQpIHsgcmV0dXJuIChuZXcgdS5ITUFDLmluaXQoYSwgZCkpLmZpbmFsaXplKGIpIH0gfSB9KTsgdmFyIHUgPSBrLmFsZ28gPSB7fTsgcmV0dXJuIGsgfShNYXRoKTtcbihmdW5jdGlvbiAoKSB7IHZhciBrID0gQ3J5cHRvSlMsIGIgPSBrLmxpYiwgbSA9IGIuV29yZEFycmF5LCBsID0gYi5IYXNoZXIsIGQgPSBbXSwgYiA9IGsuYWxnby5TSEExID0gbC5leHRlbmQoeyBfZG9SZXNldDogZnVuY3Rpb24gKCkgeyB0aGlzLl9oYXNoID0gbmV3IG0uaW5pdChbMTczMjU4NDE5MywgNDAyMzIzMzQxNywgMjU2MjM4MzEwMiwgMjcxNzMzODc4LCAzMjg1Mzc3NTIwXSkgfSwgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAobiwgcCkgeyBmb3IgKHZhciBhID0gdGhpcy5faGFzaC53b3JkcywgZSA9IGFbMF0sIGYgPSBhWzFdLCBoID0gYVsyXSwgaiA9IGFbM10sIGIgPSBhWzRdLCBjID0gMDsgODAgPiBjOyBjKyspIHsgaWYgKDE2ID4gYykgZFtjXSA9IG5bcCArIGNdIHwgMDsgZWxzZSB7IHZhciBnID0gZFtjIC0gM10gXiBkW2MgLSA4XSBeIGRbYyAtIDE0XSBeIGRbYyAtIDE2XTsgZFtjXSA9IGcgPDwgMSB8IGcgPj4+IDMxIH0gZyA9IChlIDw8IDUgfCBlID4+PiAyNykgKyBiICsgZFtjXTsgZyA9IDIwID4gYyA/IGcgKyAoKGYgJiBoIHwgfmYgJiBqKSArIDE1MTg1MDAyNDkpIDogNDAgPiBjID8gZyArICgoZiBeIGggXiBqKSArIDE4NTk3NzUzOTMpIDogNjAgPiBjID8gZyArICgoZiAmIGggfCBmICYgaiB8IGggJiBqKSAtIDE4OTQwMDc1ODgpIDogZyArICgoZiBeIGggXiBqKSAtIDg5OTQ5NzUxNCk7IGIgPSBqOyBqID0gaDsgaCA9IGYgPDwgMzAgfCBmID4+PiAyOyBmID0gZTsgZSA9IGcgfSBhWzBdID0gYVswXSArIGUgfCAwOyBhWzFdID0gYVsxXSArIGYgfCAwOyBhWzJdID0gYVsyXSArIGggfCAwOyBhWzNdID0gYVszXSArIGogfCAwOyBhWzRdID0gYVs0XSArIGIgfCAwIH0sIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IHZhciBiID0gdGhpcy5fZGF0YSwgZCA9IGIud29yZHMsIGEgPSA4ICogdGhpcy5fbkRhdGFCeXRlcywgZSA9IDggKiBiLnNpZ0J5dGVzOyBkW2UgPj4+IDVdIHw9IDEyOCA8PCAyNCAtIGUgJSAzMjsgZFsoZSArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihhIC8gNDI5NDk2NzI5Nik7IGRbKGUgKyA2NCA+Pj4gOSA8PCA0KSArIDE1XSA9IGE7IGIuc2lnQnl0ZXMgPSA0ICogZC5sZW5ndGg7IHRoaXMuX3Byb2Nlc3MoKTsgcmV0dXJuIHRoaXMuX2hhc2ggfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHsgdmFyIGIgPSBsLmNsb25lLmNhbGwodGhpcyk7IGIuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7IHJldHVybiBiIH0gfSk7IGsuU0hBMSA9IGwuX2NyZWF0ZUhlbHBlcihiKTsgay5IbWFjU0hBMSA9IGwuX2NyZWF0ZUhtYWNIZWxwZXIoYikgfSkoKTtcbihmdW5jdGlvbiAoaykgeyBmb3IgKHZhciBnID0gQ3J5cHRvSlMsIGggPSBnLmxpYiwgdiA9IGguV29yZEFycmF5LCBqID0gaC5IYXNoZXIsIGggPSBnLmFsZ28sIHMgPSBbXSwgdCA9IFtdLCB1ID0gZnVuY3Rpb24gKHEpIHsgcmV0dXJuIDQyOTQ5NjcyOTYgKiAocSAtIChxIHwgMCkpIHwgMCB9LCBsID0gMiwgYiA9IDA7IDY0ID4gYjspIHsgdmFyIGQ7IGE6IHsgZCA9IGw7IGZvciAodmFyIHcgPSBrLnNxcnQoZCksIHIgPSAyOyByIDw9IHc7IHIrKykgaWYgKCEoZCAlIHIpKSB7IGQgPSAhMTsgYnJlYWsgYSB9IGQgPSAhMCB9IGQgJiYgKDggPiBiICYmIChzW2JdID0gdShrLnBvdyhsLCAwLjUpKSksIHRbYl0gPSB1KGsucG93KGwsIDEgLyAzKSksIGIrKyk7IGwrKyB9IHZhciBuID0gW10sIGggPSBoLlNIQTI1NiA9IGouZXh0ZW5kKHsgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5faGFzaCA9IG5ldyB2LmluaXQocy5zbGljZSgwKSkgfSwgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAocSwgaCkgeyBmb3IgKHZhciBhID0gdGhpcy5faGFzaC53b3JkcywgYyA9IGFbMF0sIGQgPSBhWzFdLCBiID0gYVsyXSwgayA9IGFbM10sIGYgPSBhWzRdLCBnID0gYVs1XSwgaiA9IGFbNl0sIGwgPSBhWzddLCBlID0gMDsgNjQgPiBlOyBlKyspIHsgaWYgKDE2ID4gZSkgbltlXSA9IHFbaCArIGVdIHwgMDsgZWxzZSB7IHZhciBtID0gbltlIC0gMTVdLCBwID0gbltlIC0gMl07IG5bZV0gPSAoKG0gPDwgMjUgfCBtID4+PiA3KSBeIChtIDw8IDE0IHwgbSA+Pj4gMTgpIF4gbSA+Pj4gMykgKyBuW2UgLSA3XSArICgocCA8PCAxNSB8IHAgPj4+IDE3KSBeIChwIDw8IDEzIHwgcCA+Pj4gMTkpIF4gcCA+Pj4gMTApICsgbltlIC0gMTZdIH0gbSA9IGwgKyAoKGYgPDwgMjYgfCBmID4+PiA2KSBeIChmIDw8IDIxIHwgZiA+Pj4gMTEpIF4gKGYgPDwgNyB8IGYgPj4+IDI1KSkgKyAoZiAmIGcgXiB+ZiAmIGopICsgdFtlXSArIG5bZV07IHAgPSAoKGMgPDwgMzAgfCBjID4+PiAyKSBeIChjIDw8IDE5IHwgYyA+Pj4gMTMpIF4gKGMgPDwgMTAgfCBjID4+PiAyMikpICsgKGMgJiBkIF4gYyAmIGIgXiBkICYgYik7IGwgPSBqOyBqID0gZzsgZyA9IGY7IGYgPSBrICsgbSB8IDA7IGsgPSBiOyBiID0gZDsgZCA9IGM7IGMgPSBtICsgcCB8IDAgfSBhWzBdID0gYVswXSArIGMgfCAwOyBhWzFdID0gYVsxXSArIGQgfCAwOyBhWzJdID0gYVsyXSArIGIgfCAwOyBhWzNdID0gYVszXSArIGsgfCAwOyBhWzRdID0gYVs0XSArIGYgfCAwOyBhWzVdID0gYVs1XSArIGcgfCAwOyBhWzZdID0gYVs2XSArIGogfCAwOyBhWzddID0gYVs3XSArIGwgfCAwIH0sIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IHZhciBkID0gdGhpcy5fZGF0YSwgYiA9IGQud29yZHMsIGEgPSA4ICogdGhpcy5fbkRhdGFCeXRlcywgYyA9IDggKiBkLnNpZ0J5dGVzOyBiW2MgPj4+IDVdIHw9IDEyOCA8PCAyNCAtIGMgJSAzMjsgYlsoYyArIDY0ID4+PiA5IDw8IDQpICsgMTRdID0gay5mbG9vcihhIC8gNDI5NDk2NzI5Nik7IGJbKGMgKyA2NCA+Pj4gOSA8PCA0KSArIDE1XSA9IGE7IGQuc2lnQnl0ZXMgPSA0ICogYi5sZW5ndGg7IHRoaXMuX3Byb2Nlc3MoKTsgcmV0dXJuIHRoaXMuX2hhc2ggfSwgY2xvbmU6IGZ1bmN0aW9uICgpIHsgdmFyIGIgPSBqLmNsb25lLmNhbGwodGhpcyk7IGIuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7IHJldHVybiBiIH0gfSk7IGcuU0hBMjU2ID0gai5fY3JlYXRlSGVscGVyKGgpOyBnLkhtYWNTSEEyNTYgPSBqLl9jcmVhdGVIbWFjSGVscGVyKGgpIH0pKE1hdGgpO1xuKGZ1bmN0aW9uICgpIHsgdmFyIGMgPSBDcnlwdG9KUywgayA9IGMuZW5jLlV0Zjg7IGMuYWxnby5ITUFDID0gYy5saWIuQmFzZS5leHRlbmQoeyBpbml0OiBmdW5jdGlvbiAoYSwgYikgeyBhID0gdGhpcy5faGFzaGVyID0gbmV3IGEuaW5pdDsgXCJzdHJpbmdcIiA9PSB0eXBlb2YgYiAmJiAoYiA9IGsucGFyc2UoYikpOyB2YXIgYyA9IGEuYmxvY2tTaXplLCBlID0gNCAqIGM7IGIuc2lnQnl0ZXMgPiBlICYmIChiID0gYS5maW5hbGl6ZShiKSk7IGIuY2xhbXAoKTsgZm9yICh2YXIgZiA9IHRoaXMuX29LZXkgPSBiLmNsb25lKCksIGcgPSB0aGlzLl9pS2V5ID0gYi5jbG9uZSgpLCBoID0gZi53b3JkcywgaiA9IGcud29yZHMsIGQgPSAwOyBkIDwgYzsgZCsrKSBoW2RdIF49IDE1NDk1NTY4MjgsIGpbZF0gXj0gOTA5NTIyNDg2OyBmLnNpZ0J5dGVzID0gZy5zaWdCeXRlcyA9IGU7IHRoaXMucmVzZXQoKSB9LCByZXNldDogZnVuY3Rpb24gKCkgeyB2YXIgYSA9IHRoaXMuX2hhc2hlcjsgYS5yZXNldCgpOyBhLnVwZGF0ZSh0aGlzLl9pS2V5KSB9LCB1cGRhdGU6IGZ1bmN0aW9uIChhKSB7IHRoaXMuX2hhc2hlci51cGRhdGUoYSk7IHJldHVybiB0aGlzIH0sIGZpbmFsaXplOiBmdW5jdGlvbiAoYSkgeyB2YXIgYiA9IHRoaXMuX2hhc2hlcjsgYSA9IGIuZmluYWxpemUoYSk7IGIucmVzZXQoKTsgcmV0dXJuIGIuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChhKSkgfSB9KSB9KSgpO1xuKGZ1bmN0aW9uICgpIHsgdmFyIGggPSBDcnlwdG9KUywgaiA9IGgubGliLldvcmRBcnJheTsgaC5lbmMuQmFzZTY0ID0geyBzdHJpbmdpZnk6IGZ1bmN0aW9uIChiKSB7IHZhciBlID0gYi53b3JkcywgZiA9IGIuc2lnQnl0ZXMsIGMgPSB0aGlzLl9tYXA7IGIuY2xhbXAoKTsgYiA9IFtdOyBmb3IgKHZhciBhID0gMDsgYSA8IGY7IGEgKz0gMykgZm9yICh2YXIgZCA9IChlW2EgPj4+IDJdID4+PiAyNCAtIDggKiAoYSAlIDQpICYgMjU1KSA8PCAxNiB8IChlW2EgKyAxID4+PiAyXSA+Pj4gMjQgLSA4ICogKChhICsgMSkgJSA0KSAmIDI1NSkgPDwgOCB8IGVbYSArIDIgPj4+IDJdID4+PiAyNCAtIDggKiAoKGEgKyAyKSAlIDQpICYgMjU1LCBnID0gMDsgNCA+IGcgJiYgYSArIDAuNzUgKiBnIDwgZjsgZysrKSBiLnB1c2goYy5jaGFyQXQoZCA+Pj4gNiAqICgzIC0gZykgJiA2MykpOyBpZiAoZSA9IGMuY2hhckF0KDY0KSkgZm9yICg7IGIubGVuZ3RoICUgNDspIGIucHVzaChlKTsgcmV0dXJuIGIuam9pbihcIlwiKSB9LCBwYXJzZTogZnVuY3Rpb24gKGIpIHsgdmFyIGUgPSBiLmxlbmd0aCwgZiA9IHRoaXMuX21hcCwgYyA9IGYuY2hhckF0KDY0KTsgYyAmJiAoYyA9IGIuaW5kZXhPZihjKSwgLTEgIT0gYyAmJiAoZSA9IGMpKTsgZm9yICh2YXIgYyA9IFtdLCBhID0gMCwgZCA9IDA7IGQgPCBlOyBkKyspIGlmIChkICUgNCkgeyB2YXIgZyA9IGYuaW5kZXhPZihiLmNoYXJBdChkIC0gMSkpIDw8IDIgKiAoZCAlIDQpLCBoID0gZi5pbmRleE9mKGIuY2hhckF0KGQpKSA+Pj4gNiAtIDIgKiAoZCAlIDQpOyBjW2EgPj4+IDJdIHw9IChnIHwgaCkgPDwgMjQgLSA4ICogKGEgJSA0KTsgYSsrIH0gcmV0dXJuIGouY3JlYXRlKGMsIGEpIH0sIF9tYXA6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIiB9IH0pKCk7XG5cbmhhd2suY3J5cHRvLmludGVybmFscyA9IENyeXB0b0pTO1xuXG5cbi8vIEV4cG9ydCBpZiB1c2VkIGFzIGEgbW9kdWxlXG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaGF3aztcbn1cblxuLy8gJGxhYjpjb3ZlcmFnZTpvbiRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXdrL2xpYi9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyohXG4gKiBrbm94IC0gYXV0aFxuICogQ29weXJpZ2h0KGMpIDIwMTAgTGVhcm5Cb29zdCA8ZGV2QGxlYXJuYm9vc3QuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuICAsIHBhcnNlID0gcmVxdWlyZSgndXJsJykucGFyc2VcbiAgO1xuXG4vKipcbiAqIFZhbGlkIGtleXMuXG4gKi9cblxudmFyIGtleXMgPSBcbiAgWyAnYWNsJ1xuICAsICdsb2NhdGlvbidcbiAgLCAnbG9nZ2luZydcbiAgLCAnbm90aWZpY2F0aW9uJ1xuICAsICdwYXJ0TnVtYmVyJ1xuICAsICdwb2xpY3knXG4gICwgJ3JlcXVlc3RQYXltZW50J1xuICAsICd0b3JyZW50J1xuICAsICd1cGxvYWRJZCdcbiAgLCAndXBsb2FkcydcbiAgLCAndmVyc2lvbklkJ1xuICAsICd2ZXJzaW9uaW5nJ1xuICAsICd2ZXJzaW9ucydcbiAgLCAnd2Vic2l0ZSdcbiAgXVxuXG4vKipcbiAqIFJldHVybiBhbiBcIkF1dGhvcml6YXRpb25cIiBoZWFkZXIgdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgXG4gKiBpbiB0aGUgZm9ybSBvZiBcIkFXUyA8a2V5Pjo8c2lnbmF0dXJlPlwiXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGF1dGhvcml6YXRpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuICdBV1MgJyArIG9wdGlvbnMua2V5ICsgJzonICsgc2lnbihvcHRpb25zKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGF1dGhvcml6YXRpb25cbm1vZHVsZS5leHBvcnRzLmF1dGhvcml6YXRpb24gPSBhdXRob3JpemF0aW9uXG5cbi8qKlxuICogU2ltcGxlIEhNQUMtU0hBMSBXcmFwcGVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovIFxuXG5mdW5jdGlvbiBobWFjU2hhMSAob3B0aW9ucykge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTEnLCBvcHRpb25zLnNlY3JldCkudXBkYXRlKG9wdGlvbnMubWVzc2FnZSkuZGlnZXN0KCdiYXNlNjQnKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5obWFjU2hhMSA9IGhtYWNTaGExXG5cbi8qKlxuICogQ3JlYXRlIGEgYmFzZTY0IHNoYTEgSE1BQyBmb3IgYG9wdGlvbnNgLiBcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNpZ24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5tZXNzYWdlID0gc3RyaW5nVG9TaWduKG9wdGlvbnMpXG4gIHJldHVybiBobWFjU2hhMShvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMuc2lnbiA9IHNpZ25cblxuLyoqXG4gKiBDcmVhdGUgYSBiYXNlNjQgc2hhMSBITUFDIGZvciBgb3B0aW9uc2AuIFxuICpcbiAqIFNwZWNpZmljYWxseSB0byBiZSB1c2VkIHdpdGggUzMgcHJlc2lnbmVkIFVSTHNcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNpZ25RdWVyeSAob3B0aW9ucykge1xuICBvcHRpb25zLm1lc3NhZ2UgPSBxdWVyeVN0cmluZ1RvU2lnbihvcHRpb25zKVxuICByZXR1cm4gaG1hY1NoYTEob3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzLnNpZ25RdWVyeT0gc2lnblF1ZXJ5XG5cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIGZvciBzaWduKCkgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICpcbiAqIFNwZWM6XG4gKiBcbiAqICAgIDx2ZXJiPlxcblxuICogICAgPG1kNT5cXG5cbiAqICAgIDxjb250ZW50LXR5cGU+XFxuXG4gKiAgICA8ZGF0ZT5cXG5cbiAqICAgIFtoZWFkZXJzXFxuXVxuICogICAgPHJlc291cmNlPlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb1NpZ24gKG9wdGlvbnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmFtYXpvbkhlYWRlcnMgfHwgJydcbiAgaWYgKGhlYWRlcnMpIGhlYWRlcnMgKz0gJ1xcbidcbiAgdmFyIHIgPSBcbiAgICBbIG9wdGlvbnMudmVyYlxuICAgICwgb3B0aW9ucy5tZDVcbiAgICAsIG9wdGlvbnMuY29udGVudFR5cGVcbiAgICAsIG9wdGlvbnMuZGF0ZSA/IG9wdGlvbnMuZGF0ZS50b1VUQ1N0cmluZygpIDogJydcbiAgICAsIGhlYWRlcnMgKyBvcHRpb25zLnJlc291cmNlXG4gICAgXVxuICByZXR1cm4gci5qb2luKCdcXG4nKVxufVxubW9kdWxlLmV4cG9ydHMucXVlcnlTdHJpbmdUb1NpZ24gPSBzdHJpbmdUb1NpZ25cblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgZm9yIHNpZ24oKSB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AsIGJ1dCBpcyBtZWFudCBleGNsdXNpdmVseVxuICogZm9yIFMzIHByZXNpZ25lZCBVUkxzXG4gKlxuICogU3BlYzpcbiAqIFxuICogICAgPGRhdGU+XFxuXG4gKiAgICA8cmVzb3VyY2U+XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5nVG9TaWduIChvcHRpb25zKXtcbiAgcmV0dXJuICdHRVRcXG5cXG5cXG4nICsgb3B0aW9ucy5kYXRlICsgJ1xcbicgKyBvcHRpb25zLnJlc291cmNlXG59XG5tb2R1bGUuZXhwb3J0cy5xdWVyeVN0cmluZ1RvU2lnbiA9IHF1ZXJ5U3RyaW5nVG9TaWduXG5cbi8qKlxuICogUGVyZm9ybSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlnbm9yZSBub24tYW1hem9uIGhlYWRlcnNcbiAqICAtIGxvd2VyY2FzZSBmaWVsZHNcbiAqICAtIHNvcnQgbGV4aWNvZ3JhcGhpY2FsbHlcbiAqICAtIHRyaW0gd2hpdGVzcGFjZSBiZXR3ZWVuIFwiOlwiXG4gKiAgLSBqb2luIHdpdGggbmV3bGluZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVIZWFkZXJzIChoZWFkZXJzKSB7XG4gIHZhciBidWYgPSBbXVxuICAgICwgZmllbGRzID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV1cbiAgICAgICwgdmFsID0gaGVhZGVyc1tmaWVsZF1cbiAgICAgICwgZmllbGQgPSBmaWVsZC50b0xvd2VyQ2FzZSgpXG4gICAgICA7XG4gICAgaWYgKDAgIT09IGZpZWxkLmluZGV4T2YoJ3gtYW16JykpIGNvbnRpbnVlXG4gICAgYnVmLnB1c2goZmllbGQgKyAnOicgKyB2YWwpXG4gIH1cbiAgcmV0dXJuIGJ1Zi5zb3J0KCkuam9pbignXFxuJylcbn1cbm1vZHVsZS5leHBvcnRzLmNhbm9uaWNhbGl6ZUhlYWRlcnMgPSBjYW5vbmljYWxpemVIZWFkZXJzXG5cbi8qKlxuICogUGVyZm9ybSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlnbm9yZSBub24gc3ViLXJlc291cmNlc1xuICogIC0gc29ydCBsZXhpY29ncmFwaGljYWxseVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNvdXJjZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2Fub25pY2FsaXplUmVzb3VyY2UgKHJlc291cmNlKSB7XG4gIHZhciB1cmwgPSBwYXJzZShyZXNvdXJjZSwgdHJ1ZSlcbiAgICAsIHBhdGggPSB1cmwucGF0aG5hbWVcbiAgICAsIGJ1ZiA9IFtdXG4gICAgO1xuXG4gIE9iamVjdC5rZXlzKHVybC5xdWVyeSkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgIGlmICghfmtleXMuaW5kZXhPZihrZXkpKSByZXR1cm5cbiAgICB2YXIgdmFsID0gJycgPT0gdXJsLnF1ZXJ5W2tleV0gPyAnJyA6ICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwucXVlcnlba2V5XSlcbiAgICBidWYucHVzaChrZXkgKyB2YWwpXG4gIH0pXG5cbiAgcmV0dXJuIHBhdGggKyAoYnVmLmxlbmd0aCA/ICc/JyArIGJ1Zi5zb3J0KCkuam9pbignJicpIDogJycpXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5vbmljYWxpemVSZXNvdXJjZSA9IGNhbm9uaWNhbGl6ZVJlc291cmNlXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vYXdzLXNpZ24yL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciBzaWduZXIgPSByZXF1aXJlKCcuL3NpZ25lcicpO1xudmFyIHZlcmlmeSA9IHJlcXVpcmUoJy4vdmVyaWZ5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5cblxuLy8vLS0tIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwYXJzZTogcGFyc2VyLnBhcnNlUmVxdWVzdCxcbiAgcGFyc2VSZXF1ZXN0OiBwYXJzZXIucGFyc2VSZXF1ZXN0LFxuXG4gIHNpZ246IHNpZ25lci5zaWduUmVxdWVzdCxcbiAgc2lnblJlcXVlc3Q6IHNpZ25lci5zaWduUmVxdWVzdCxcblxuICBzc2hLZXlUb1BFTTogdXRpbC5zc2hLZXlUb1BFTSxcbiAgc3NoS2V5RmluZ2VycHJpbnQ6IHV0aWwuZmluZ2VycHJpbnQsXG4gIHBlbVRvUnNhU1NIS2V5OiB1dGlsLnBlbVRvUnNhU1NIS2V5LFxuXG4gIHZlcmlmeTogdmVyaWZ5LnZlcmlmeVNpZ25hdHVyZSxcbiAgdmVyaWZ5U2lnbmF0dXJlOiB2ZXJpZnkudmVyaWZ5U2lnbmF0dXJlLFxuICB2ZXJpZnlITUFDOiB2ZXJpZnkudmVyaWZ5SE1BQ1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9odHRwLXNpZ25hdHVyZS9saWIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IDIwMTIgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIEFsZ29yaXRobXMgPSB7XG4gICdyc2Etc2hhMSc6IHRydWUsXG4gICdyc2Etc2hhMjU2JzogdHJ1ZSxcbiAgJ3JzYS1zaGE1MTInOiB0cnVlLFxuICAnZHNhLXNoYTEnOiB0cnVlLFxuICAnaG1hYy1zaGExJzogdHJ1ZSxcbiAgJ2htYWMtc2hhMjU2JzogdHJ1ZSxcbiAgJ2htYWMtc2hhNTEyJzogdHJ1ZVxufTtcblxudmFyIFN0YXRlID0ge1xuICBOZXc6IDAsXG4gIFBhcmFtczogMVxufTtcblxudmFyIFBhcmFtc1N0YXRlID0ge1xuICBOYW1lOiAwLFxuICBRdW90ZTogMSxcbiAgVmFsdWU6IDIsXG4gIENvbW1hOiAzXG59O1xuXG5cblxuLy8vLS0tIFNwZWNpZmljIEVycm9yc1xuXG5mdW5jdGlvbiBIdHRwU2lnbmF0dXJlRXJyb3IobWVzc2FnZSwgY2FsbGVyKSB7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBjYWxsZXIgfHwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSBjYWxsZXIubmFtZTtcbn1cbnV0aWwuaW5oZXJpdHMoSHR0cFNpZ25hdHVyZUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIEV4cGlyZWRSZXF1ZXN0RXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBFeHBpcmVkUmVxdWVzdEVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoRXhwaXJlZFJlcXVlc3RFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBJbnZhbGlkSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gSW52YWxpZFBhcmFtc0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgSW52YWxpZFBhcmFtc0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZFBhcmFtc0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIE1pc3NpbmdIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIE1pc3NpbmdIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKE1pc3NpbmdIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgJ0F1dGhvcml6YXRpb24nIGhlYWRlciBvdXQgb2YgYW4gaHR0cC5TZXJ2ZXJSZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgQVBJIHdpbGwgZnVsbHkgdmFsaWRhdGUgdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyLCBhbmQgdGhyb3dcbiAgICogb24gYW55IGVycm9yLiAgSXQgd2lsbCBub3QgaG93ZXZlciBjaGVjayB0aGUgc2lnbmF0dXJlLCBvciB0aGUga2V5SWQgZm9ybWF0XG4gICAqIGFzIHRob3NlIGFyZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50LiAgWW91IGNhbiB1c2UgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAqIHRvIHBhc3MgaW4gZXh0cmEgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEFzIGEgcmVzcG9uc2Ugb2JqZWN0IHlvdSBjYW4gZXhwZWN0IHRoaXM6XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIFwic2NoZW1lXCI6IFwiU2lnbmF0dXJlXCIsXG4gICAqICAgICAgIFwicGFyYW1zXCI6IHtcbiAgICogICAgICAgICBcImtleUlkXCI6IFwiZm9vXCIsXG4gICAqICAgICAgICAgXCJhbGdvcml0aG1cIjogXCJyc2Etc2hhMjU2XCIsXG4gICAqICAgICAgICAgXCJoZWFkZXJzXCI6IFtcbiAgICogICAgICAgICAgIFwiZGF0ZVwiIG9yIFwieC1kYXRlXCIsXG4gICAqICAgICAgICAgICBcImNvbnRlbnQtbWQ1XCJcbiAgICogICAgICAgICBdLFxuICAgKiAgICAgICAgIFwic2lnbmF0dXJlXCI6IFwiYmFzZTY0XCJcbiAgICogICAgICAgfSxcbiAgICogICAgICAgXCJzaWduaW5nU3RyaW5nXCI6IFwicmVhZHkgdG8gYmUgcGFzc2VkIHRvIGNyeXB0by52ZXJpZnkoKVwiXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGFuIGh0dHAuU2VydmVyUmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3Qgd2l0aDpcbiAgICogICAgICAgICAgICAgICAgICAgLSBjbG9ja1NrZXc6IGFsbG93ZWQgY2xvY2sgc2tldyBpbiBzZWNvbmRzIChkZWZhdWx0IDMwMCkuXG4gICAqICAgICAgICAgICAgICAgICAgIC0gaGVhZGVyczogcmVxdWlyZWQgaGVhZGVyIG5hbWVzIChkZWY6IGRhdGUgb3IgeC1kYXRlKVxuICAgKiAgICAgICAgICAgICAgICAgICAtIGFsZ29yaXRobXM6IGFsZ29yaXRobXMgdG8gc3VwcG9ydCAoZGVmYXVsdDogYWxsKS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBwYXJzZWQgb3V0IG9iamVjdCAoc2VlIGFib3ZlKS5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBpbnZhbGlkIGlucHV0LlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkSGVhZGVyRXJyb3J9IG9uIGFuIGludmFsaWQgQXV0aG9yaXphdGlvbiBoZWFkZXIgZXJyb3IuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRQYXJhbXNFcnJvcn0gaWYgdGhlIHBhcmFtcyBpbiB0aGUgc2NoZW1lIGFyZSBpbnZhbGlkLlxuICAgKiBAdGhyb3dzIHtNaXNzaW5nSGVhZGVyRXJyb3J9IGlmIHRoZSBwYXJhbXMgaW5kaWNhdGUgYSBoZWFkZXIgbm90IHByZXNlbnQsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyIGluIHRoZSByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGUgcGFyYW1zLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIG5vdCBpbiB0aGUgcGFyYW1zIGZyb20gYSByZXF1aXJlZCBoZWFkZXJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiBvcHRpb25zLlxuICAgKiBAdGhyb3dzIHtFeHBpcmVkUmVxdWVzdEVycm9yfSBpZiB0aGUgdmFsdWUgb2YgZGF0ZSBvciB4LWRhdGUgZXhjZWVkcyBza2V3LlxuICAgKi9cbiAgcGFyc2VSZXF1ZXN0OiBmdW5jdGlvbiBwYXJzZVJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdCwgJ3JlcXVlc3QnKTtcbiAgICBhc3NlcnQub2JqZWN0KHJlcXVlc3QuaGVhZGVycywgJ3JlcXVlc3QuaGVhZGVycycpO1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBbcmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSA/ICd4LWRhdGUnIDogJ2RhdGUnXTtcbiAgICB9XG4gICAgYXNzZXJ0Lm9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuICAgIGFzc2VydC5hcnJheU9mU3RyaW5nKG9wdGlvbnMuaGVhZGVycywgJ29wdGlvbnMuaGVhZGVycycpO1xuICAgIGFzc2VydC5vcHRpb25hbE51bWJlcihvcHRpb25zLmNsb2NrU2tldywgJ29wdGlvbnMuY2xvY2tTa2V3Jyk7XG5cbiAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uKVxuICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcignbm8gYXV0aG9yaXphdGlvbiBoZWFkZXIgcHJlc2VudCBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSByZXF1ZXN0Jyk7XG5cbiAgICBvcHRpb25zLmNsb2NrU2tldyA9IG9wdGlvbnMuY2xvY2tTa2V3IHx8IDMwMDtcblxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBzdGF0ZSA9IFN0YXRlLk5ldztcbiAgICB2YXIgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5OYW1lO1xuICAgIHZhciB0bXBOYW1lID0gJyc7XG4gICAgdmFyIHRtcFZhbHVlID0gJyc7XG5cbiAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgc2NoZW1lOiAnJyxcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBzaWduaW5nU3RyaW5nOiAnJyxcblxuICAgICAgZ2V0IGFsZ29yaXRobSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSxcblxuICAgICAgZ2V0IGtleUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMua2V5SWQ7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIGF1dGh6ID0gcmVxdWVzdC5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgZm9yIChpID0gMDsgaSA8IGF1dGh6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGF1dGh6LmNoYXJBdChpKTtcblxuICAgICAgc3dpdGNoIChOdW1iZXIoc3RhdGUpKSB7XG5cbiAgICAgIGNhc2UgU3RhdGUuTmV3OlxuICAgICAgICBpZiAoYyAhPT0gJyAnKSBwYXJzZWQuc2NoZW1lICs9IGM7XG4gICAgICAgIGVsc2Ugc3RhdGUgPSBTdGF0ZS5QYXJhbXM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0YXRlLlBhcmFtczpcbiAgICAgICAgc3dpdGNoIChOdW1iZXIoc3Vic3RhdGUpKSB7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5OYW1lOlxuICAgICAgICAgIHZhciBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIC8vIHJlc3RyaWN0ZWQgbmFtZSBvZiBBLVogLyBhLXpcbiAgICAgICAgICBpZiAoKGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NWEpIHx8IC8vIEEtWlxuICAgICAgICAgICAgICAoY29kZSA+PSAweDYxICYmIGNvZGUgPD0gMHg3YSkpIHsgLy8gYS16XG4gICAgICAgICAgICB0bXBOYW1lICs9IGM7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIGlmICh0bXBOYW1lLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5RdW90ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLlF1b3RlOlxuICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICB0bXBWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5WYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLlZhbHVlOlxuICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICBwYXJzZWQucGFyYW1zW3RtcE5hbWVdID0gdG1wVmFsdWU7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLkNvbW1hO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBWYWx1ZSArPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLkNvbW1hOlxuICAgICAgICAgIGlmIChjID09PSAnLCcpIHtcbiAgICAgICAgICAgIHRtcE5hbWUgPSAnJztcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuTmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzdGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic3RhdGUnKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5oZWFkZXJzIHx8IHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9PT0gJycpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IFsneC1kYXRlJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBbJ2RhdGUnXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gcGFyc2VkLnBhcmFtcy5oZWFkZXJzLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgLy8gTWluaW1hbGx5IHZhbGlkYXRlIHRoZSBwYXJzZWQgb2JqZWN0XG4gICAgaWYgKCFwYXJzZWQuc2NoZW1lIHx8IHBhcnNlZC5zY2hlbWUgIT09ICdTaWduYXR1cmUnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignc2NoZW1lIHdhcyBub3QgXCJTaWduYXR1cmVcIicpO1xuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLmtleUlkKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcigna2V5SWQgd2FzIG5vdCBzcGVjaWZpZWQnKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0pXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdhbGdvcml0aG0gd2FzIG5vdCBzcGVjaWZpZWQnKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5zaWduYXR1cmUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdzaWduYXR1cmUgd2FzIG5vdCBzcGVjaWZpZWQnKTtcblxuICAgIC8vIENoZWNrIHRoZSBhbGdvcml0aG0gYWdhaW5zdCB0aGUgb2ZmaWNpYWwgbGlzdFxuICAgIHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtID0gcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIUFsZ29yaXRobXNbcGFyc2VkLnBhcmFtcy5hbGdvcml0aG1dKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbXNFcnJvcihwYXJzZWQucGFyYW1zLmFsZ29yaXRobSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgLy8gQnVpbGQgdGhlIHNpZ25pbmdTdHJpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaCA9IHBhcnNlZC5wYXJhbXMuaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzW2ldID0gaDtcblxuICAgICAgaWYgKGggIT09ICdyZXF1ZXN0LWxpbmUnKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVlc3QuaGVhZGVyc1toXTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGggKyAnIHdhcyBub3QgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz0gaCArICc6ICcgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9XG4gICAgICAgICAgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnVybCArICcgSFRUUC8nICsgcmVxdWVzdC5odHRwVmVyc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKChpICsgMSkgPCBwYXJzZWQucGFyYW1zLmhlYWRlcnMubGVuZ3RoKVxuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBhZ2FpbnN0IHRoZSBjb25zdHJhaW50c1xuICAgIHZhciBkYXRlO1xuICAgIGlmIChyZXF1ZXN0LmhlYWRlcnMuZGF0ZSB8fCByZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShyZXF1ZXN0LmhlYWRlcnMuZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHNrZXcgPSBNYXRoLmFicyhub3cuZ2V0VGltZSgpIC0gZGF0ZS5nZXRUaW1lKCkpO1xuXG4gICAgICBpZiAoc2tldyA+IG9wdGlvbnMuY2xvY2tTa2V3ICogMTAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXhwaXJlZFJlcXVlc3RFcnJvcignY2xvY2sgc2tldyBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNrZXcgLyAxMDAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzIHdhcyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2xvY2tTa2V3ICsgJ3MnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGRyKSB7XG4gICAgICAvLyBSZW1lbWJlciB0aGF0IHdlIGFscmVhZHkgY2hlY2tlZCBhbnkgaGVhZGVycyBpbiB0aGUgcGFyYW1zXG4gICAgICAvLyB3ZXJlIGluIHRoZSByZXF1ZXN0LCBzbyBpZiB0aGlzIHBhc3NlcyB3ZSdyZSBnb29kLlxuICAgICAgaWYgKHBhcnNlZC5wYXJhbXMuaGVhZGVycy5pbmRleE9mKGhkcikgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGhkciArICcgd2FzIG5vdCBhIHNpZ25lZCBoZWFkZXInKTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmFsZ29yaXRobXMpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsZ29yaXRobXMuaW5kZXhPZihwYXJzZWQucGFyYW1zLmFsZ29yaXRobSkgPT09IC0xKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtc0Vycm9yKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGlzIG5vdCBhIHN1cHBvcnRlZCBhbGdvcml0aG0nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaHR0cC1zaWduYXR1cmUvbGliL3BhcnNlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTIsIE1hcmsgQ2F2YWdlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgTkRFQlVHID0gcHJvY2Vzcy5lbnYuTk9ERV9OREVCVUcgfHwgZmFsc2U7XG52YXIgVVVJRF9SRUdFWFAgPSAvXlthLWZBLUYwLTldezh9LVthLWZBLUYwLTldezR9LVthLWZBLUYwLTldezR9LVthLWZBLUYwLTldezR9LVthLWZBLUYwLTldezEyfSQvO1xuXG5cblxuLy8vLS0tIE1lc3NhZ2VzXG5cbnZhciBBUlJBWV9UWVBFX1JFUVVJUkVEID0gJyVzIChbJXNdKSByZXF1aXJlZCc7XG52YXIgVFlQRV9SRVFVSVJFRCA9ICclcyAoJXMpIGlzIHJlcXVpcmVkJztcblxuXG5cbi8vLy0tLSBJbnRlcm5hbFxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gKHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIHVuY2FwaXRhbGl6ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIChzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSkpO1xufVxuXG5mdW5jdGlvbiBfKCkge1xuICAgICAgICByZXR1cm4gKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykpO1xufVxuXG5cbmZ1bmN0aW9uIF9hc3NlcnQoYXJnLCB0eXBlLCBuYW1lLCBzdGFja0Z1bmMpIHtcbiAgICAgICAgaWYgKCFOREVCVUcpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCB0eXBlO1xuICAgICAgICAgICAgICAgIHN0YWNrRnVuYyA9IHN0YWNrRnVuYyB8fCBfYXNzZXJ0LmNhbGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHR5cGVvZiAoYXJnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXyhUWVBFX1JFUVVJUkVELCBuYW1lLCB0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc9PT0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrRnVuY1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG59XG5cblxuZnVuY3Rpb24gX2luc3RhbmNlb2YoYXJnLCB0eXBlLCBuYW1lLCBzdGFja0Z1bmMpIHtcbiAgICAgICAgaWYgKCFOREVCVUcpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZSB8fCB0eXBlO1xuICAgICAgICAgICAgICAgIHN0YWNrRnVuYyA9IHN0YWNrRnVuYyB8fCBfaW5zdGFuY2VvZi5jYWxsZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8oVFlQRV9SRVFVSVJFRCwgbmFtZSwgdHlwZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBfZ2V0Q2xhc3MoYXJnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHR5cGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdpbnN0YW5jZW9mJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja0Z1bmNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0Q2xhc3Mob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkuc2xpY2UoOCwgLTEpKTtcbn07XG5cblxuXG4vLy8tLS0gQVBJXG5cbmZ1bmN0aW9uIGFycmF5KGFyciwgdHlwZSwgbmFtZSkge1xuICAgICAgICBpZiAoIU5ERUJVRykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHR5cGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8oQVJSQVlfVFlQRV9SRVFVSVJFRCwgbmFtZSwgdHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdHlwZW9mIChhcnIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdBcnJheS5pc0FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBhcnJheS5jYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0KGFycltpXSwgdHlwZSwgbmFtZSwgYXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxufVxuXG5cbmZ1bmN0aW9uIGJvb2woYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnYm9vbGVhbicsIG5hbWUsIGJvb2wpO1xufVxuXG5cbmZ1bmN0aW9uIGJ1ZmZlcihhcmcsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYXJnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXyhUWVBFX1JFUVVJUkVELCBuYW1lIHx8ICcnLCAnQnVmZmVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHR5cGVvZiAoYXJnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYnVmZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnQnVmZmVyLmlzQnVmZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogYnVmZmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbn1cblxuXG5mdW5jdGlvbiBmdW5jKGFyZywgbmFtZSkge1xuICAgICAgICBfYXNzZXJ0KGFyZywgJ2Z1bmN0aW9uJywgbmFtZSk7XG59XG5cblxuZnVuY3Rpb24gbnVtYmVyKGFyZywgbmFtZSkge1xuICAgICAgICBfYXNzZXJ0KGFyZywgJ251bWJlcicsIG5hbWUpO1xuICAgICAgICBpZiAoIU5ERUJVRyAmJiAoaXNOYU4oYXJnKSB8fCAhaXNGaW5pdGUoYXJnKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF8oVFlQRV9SRVFVSVJFRCwgbmFtZSwgJ251bWJlcicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2lzTmFOJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogbnVtYmVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbn1cblxuXG5mdW5jdGlvbiBvYmplY3QoYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnb2JqZWN0JywgbmFtZSk7XG59XG5cblxuZnVuY3Rpb24gc3RyZWFtKGFyZywgbmFtZSkge1xuICAgICAgICBfaW5zdGFuY2VvZihhcmcsIFN0cmVhbSwgbmFtZSk7XG59XG5cblxuZnVuY3Rpb24gZGF0ZShhcmcsIG5hbWUpIHtcbiAgICAgICAgX2luc3RhbmNlb2YoYXJnLCBEYXRlLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhwKGFyZywgbmFtZSkge1xuICAgICAgICBfaW5zdGFuY2VvZihhcmcsIFJlZ0V4cCwgbmFtZSk7XG59XG5cblxuZnVuY3Rpb24gc3RyaW5nKGFyZywgbmFtZSkge1xuICAgICAgICBfYXNzZXJ0KGFyZywgJ3N0cmluZycsIG5hbWUpO1xufVxuXG5cbmZ1bmN0aW9uIHV1aWQoYXJnLCBuYW1lKSB7XG4gICAgICAgIHN0cmluZyhhcmcsIG5hbWUpO1xuICAgICAgICBpZiAoIU5ERUJVRyAmJiAhVVVJRF9SRUdFWFAudGVzdChhcmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfKFRZUEVfUkVRVUlSRUQsIG5hbWUsICd1dWlkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICd1dWlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHV1aWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxufVxuXG5cbi8vLy0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBib29sOiBib29sLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICByZWdleHA6IHJlZ2V4cCxcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgICB1dWlkOiB1dWlkXG59O1xuXG5cbk9iamVjdC5rZXlzKG1vZHVsZS5leHBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrID09PSAnYnVmZmVyJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIG5hbWUgPSAnYXJyYXlPZicgKyBjYXBpdGFsaXplKGspO1xuXG4gICAgICAgIGlmIChrID09PSAnYm9vbCcpXG4gICAgICAgICAgICAgICAgayA9ICdib29sZWFuJztcbiAgICAgICAgaWYgKGsgPT09ICdmdW5jJylcbiAgICAgICAgICAgICAgICBrID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkoYXJnLCBrLCBuYW1lKTtcbiAgICAgICAgfTtcbn0pO1xuXG5PYmplY3Qua2V5cyhtb2R1bGUuZXhwb3J0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgX25hbWUgPSAnb3B0aW9uYWwnICsgY2FwaXRhbGl6ZShrKTtcbiAgICAgICAgdmFyIHMgPSB1bmNhcGl0YWxpemUoay5yZXBsYWNlKCdhcnJheU9mJywgJycpKTtcbiAgICAgICAgaWYgKHMgPT09ICdib29sJylcbiAgICAgICAgICAgICAgICBzID0gJ2Jvb2xlYW4nO1xuICAgICAgICBpZiAocyA9PT0gJ2Z1bmMnKVxuICAgICAgICAgICAgICAgIHMgPSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIGlmIChrLmluZGV4T2YoJ2FycmF5T2YnKSAhPT0gLTEpIHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0c1tfbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIU5ERUJVRyAmJiBhcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheShhcmcsIHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kdWxlLmV4cG9ydHNbX25hbWVdID0gZnVuY3Rpb24gKGFyZywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFOREVCVUcgJiYgYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2Fzc2VydChhcmcsIHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbn0pO1xuXG5cbi8vIFJlZXhwb3J0IGJ1aWx0LWluIGFzc2VydGlvbnNcbk9iamVjdC5rZXlzKGFzc2VydCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayA9PT0gJ0Fzc2VydGlvbkVycm9yJykge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzW2tdID0gYXNzZXJ0W2tdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzW2tdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghTkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRba10uYXBwbHkoYXNzZXJ0W2tdLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2Fzc2VydC1wbHVzL2Fzc2VydC5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbnZhciBzcHJpbnRmID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxuXG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBBbGdvcml0aG1zID0ge1xuICAncnNhLXNoYTEnOiB0cnVlLFxuICAncnNhLXNoYTI1Nic6IHRydWUsXG4gICdyc2Etc2hhNTEyJzogdHJ1ZSxcbiAgJ2RzYS1zaGExJzogdHJ1ZSxcbiAgJ2htYWMtc2hhMSc6IHRydWUsXG4gICdobWFjLXNoYTI1Nic6IHRydWUsXG4gICdobWFjLXNoYTUxMic6IHRydWVcbn07XG5cbnZhciBBdXRob3JpemF0aW9uID1cbiAgJ1NpZ25hdHVyZSBrZXlJZD1cIiVzXCIsYWxnb3JpdGhtPVwiJXNcIixoZWFkZXJzPVwiJXNcIixzaWduYXR1cmU9XCIlc1wiJztcblxuXG5cbi8vLy0tLSBTcGVjaWZpYyBFcnJvcnNcblxuZnVuY3Rpb24gTWlzc2luZ0hlYWRlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ0hlYWRlckVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xufVxuTWlzc2luZ0hlYWRlckVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG5cbmZ1bmN0aW9uIEludmFsaWRBbGdvcml0aG1FcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBbGdvcml0aG1FcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbn1cbkludmFsaWRBbGdvcml0aG1FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuXG5cbi8vLy0tLSBJbnRlcm5hbCBGdW5jdGlvbnNcblxuZnVuY3Rpb24gX3BhZCh2YWwpIHtcbiAgaWYgKHBhcnNlSW50KHZhbCwgMTApIDwgMTApIHtcbiAgICB2YWwgPSAnMCcgKyB2YWw7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5mdW5jdGlvbiBfcmZjMTEyMygpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBtb250aHMgPSBbJ0phbicsXG4gICAgICAgICAgICAgICAgJ0ZlYicsXG4gICAgICAgICAgICAgICAgJ01hcicsXG4gICAgICAgICAgICAgICAgJ0FwcicsXG4gICAgICAgICAgICAgICAgJ01heScsXG4gICAgICAgICAgICAgICAgJ0p1bicsXG4gICAgICAgICAgICAgICAgJ0p1bCcsXG4gICAgICAgICAgICAgICAgJ0F1ZycsXG4gICAgICAgICAgICAgICAgJ1NlcCcsXG4gICAgICAgICAgICAgICAgJ09jdCcsXG4gICAgICAgICAgICAgICAgJ05vdicsXG4gICAgICAgICAgICAgICAgJ0RlYyddO1xuICB2YXIgZGF5cyA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J107XG4gIHJldHVybiBkYXlzW2RhdGUuZ2V0VVRDRGF5KCldICsgJywgJyArXG4gICAgX3BhZChkYXRlLmdldFVUQ0RhdGUoKSkgKyAnICcgK1xuICAgIG1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldICsgJyAnICtcbiAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyAnICcgK1xuICAgIF9wYWQoZGF0ZS5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgX3BhZChkYXRlLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xuICAgIF9wYWQoZGF0ZS5nZXRVVENTZWNvbmRzKCkpICtcbiAgICAnIEdNVCc7XG59XG5cblxuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuICdBdXRob3JpemF0aW9uJyBoZWFkZXIgdG8gYW4gaHR0cC5DbGllbnRSZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgQVBJIHdpbGwgYWRkIGEgRGF0ZSBoZWFkZXIgaWYgaXQncyBub3QgYWxyZWFkeSBzZXQuIEFueVxuICAgKiBvdGhlciBoZWFkZXJzIGluIHRoZSBvcHRpb25zLmhlYWRlcnMgYXJyYXkgTVVTVCBiZSBwcmVzZW50LCBvciB0aGlzXG4gICAqIHdpbGwgdGhyb3cuXG4gICAqXG4gICAqIFlvdSBzaG91bGRuJ3QgbmVlZCB0byBjaGVjayB0aGUgcmV0dXJuIHR5cGU7IGl0J3MganVzdCB0aGVyZSBpZiB5b3Ugd2FudFxuICAgKiB0byBiZSBwZWRhbnRpYy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgYW4gaW5zdGFuY2Ugb2YgaHR0cC5DbGllbnRSZXF1ZXN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBzaWduaW5nIHBhcmFtZXRlcnMgb2JqZWN0OlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGtleUlkIHJlcXVpcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGtleSByZXF1aXJlZCAoZWl0aGVyIGEgUEVNIG9yIEhNQUMga2V5KS5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7QXJyYXl9IGhlYWRlcnMgb3B0aW9uYWw7IGRlZmF1bHRzIHRvIFsnZGF0ZSddLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGFsZ29yaXRobSBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJ3JzYS1zaGEyNTYnLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGh0dHBWZXJzaW9uIG9wdGlvbmFsOyBkZWZhdWx0cyB0byAnMS4xJy5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBBdXRob3JpemF0aW9uIChhbmQgb3B0aW9uYWxseSBEYXRlKSB3ZXJlIGFkZGVkLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBwYXJhbWV0ZXIgdHlwZXMgKGlucHV0KS5cbiAgICogQHRocm93cyB7SW52YWxpZEFsZ29yaXRobUVycm9yfSBpZiBhbGdvcml0aG0gd2FzIGJhZC5cbiAgICogQHRocm93cyB7TWlzc2luZ0hlYWRlckVycm9yfSBpZiBhIGhlYWRlciB0byBiZSBzaWduZWQgd2FzIHNwZWNpZmllZCBidXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBzaWduUmVxdWVzdDogZnVuY3Rpb24gc2lnblJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdCwgJ3JlcXVlc3QnKTtcbiAgICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuYWxnb3JpdGhtLCAnb3B0aW9ucy5hbGdvcml0aG0nKTtcbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhvcHRpb25zLmhlYWRlcnMsICdvcHRpb25zLmhlYWRlcnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5odHRwVmVyc2lvbiwgJ29wdGlvbnMuaHR0cFZlcnNpb24nKTtcblxuICAgIGlmICghcmVxdWVzdC5nZXRIZWFkZXIoJ0RhdGUnKSlcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdEYXRlJywgX3JmYzExMjMoKSk7XG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpXG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBbJ2RhdGUnXTtcbiAgICBpZiAoIW9wdGlvbnMuYWxnb3JpdGhtKVxuICAgICAgb3B0aW9ucy5hbGdvcml0aG0gPSAncnNhLXNoYTI1Nic7XG4gICAgaWYgKCFvcHRpb25zLmh0dHBWZXJzaW9uKVxuICAgICAgb3B0aW9ucy5odHRwVmVyc2lvbiA9ICcxLjEnO1xuXG4gICAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFBbGdvcml0aG1zW29wdGlvbnMuYWxnb3JpdGhtXSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Iob3B0aW9ucy5hbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIHZhciBpO1xuICAgIHZhciBzdHJpbmdUb1NpZ24gPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5oZWFkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIChvcHRpb25zLmhlYWRlcnNbaV0pICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5oZWFkZXJzIG11c3QgYmUgYW4gYXJyYXkgb2YgU3RyaW5ncycpO1xuXG4gICAgICB2YXIgaCA9IG9wdGlvbnMuaGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoaCAhPT0gJ3JlcXVlc3QtbGluZScpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVxdWVzdC5nZXRIZWFkZXIoaCk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGggKyAnIHdhcyBub3QgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz0gaCArICc6ICcgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZ1RvU2lnbiArPVxuICAgICAgICAgIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC5wYXRoICsgJyBIVFRQLycgKyBvcHRpb25zLmh0dHBWZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGkgKyAxKSA8IG9wdGlvbnMuaGVhZGVycy5sZW5ndGgpXG4gICAgICAgIHN0cmluZ1RvU2lnbiArPSAnXFxuJztcbiAgICB9XG5cbiAgICB2YXIgYWxnID0gb3B0aW9ucy5hbGdvcml0aG0ubWF0Y2goLyhobWFjfHJzYSktKFxcdyspLyk7XG4gICAgdmFyIHNpZ25hdHVyZTtcbiAgICBpZiAoYWxnWzFdID09PSAnaG1hYycpIHtcbiAgICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoYWxnWzJdLnRvVXBwZXJDYXNlKCksIG9wdGlvbnMua2V5KTtcbiAgICAgIGhtYWMudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgICBzaWduYXR1cmUgPSBobWFjLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihvcHRpb25zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIHNpZ25lci51cGRhdGUoc3RyaW5nVG9TaWduKTtcbiAgICAgIHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMua2V5LCAnYmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBzcHJpbnRmKEF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua2V5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUpKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cblxuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVmVyaWZ5IFJTQS9EU0Egc2lnbmF0dXJlIGFnYWluc3QgcHVibGljIGtleS4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcGFzcyBpblxuICAgKiBhbiBvYmplY3QgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSBgcGFyc2UoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWRTaWduYXR1cmUgdGhlIG9iamVjdCB5b3UgZ290IGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YmtleSBSU0EvRFNBIHByaXZhdGUga2V5IFBFTS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmU6IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShwYXJzZWRTaWduYXR1cmUsIHB1YmtleSkge1xuICAgIGFzc2VydC5vYmplY3QocGFyc2VkU2lnbmF0dXJlLCAncGFyc2VkU2lnbmF0dXJlJyk7XG4gICAgYXNzZXJ0LnN0cmluZyhwdWJrZXksICdwdWJrZXknKTtcblxuICAgIHZhciBhbGcgPSBwYXJzZWRTaWduYXR1cmUuYWxnb3JpdGhtLm1hdGNoKC9eKFJTQXxEU0EpLShcXHcrKS8pO1xuICAgIGlmICghYWxnIHx8IGFsZy5sZW5ndGggIT09IDMpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZWRTaWduYXR1cmU6IHVuc3VwcG9ydGVkIGFsZ29yaXRobSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkU2lnbmF0dXJlLmFsZ29yaXRobSk7XG5cbiAgICB2YXIgdmVyaWZ5ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShhbGdbMF0pO1xuICAgIHZlcmlmeS51cGRhdGUocGFyc2VkU2lnbmF0dXJlLnNpZ25pbmdTdHJpbmcpO1xuICAgIHJldHVybiB2ZXJpZnkudmVyaWZ5KHB1YmtleSwgcGFyc2VkU2lnbmF0dXJlLnBhcmFtcy5zaWduYXR1cmUsICdiYXNlNjQnKTtcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IEhNQUMgYWdhaW5zdCBzaGFyZWQgc2VjcmV0LiAgWW91IGFyZSBleHBlY3RlZCB0byBwYXNzIGluIGFuIG9iamVjdFxuICAgKiB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIGBwYXJzZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFNpZ25hdHVyZSB0aGUgb2JqZWN0IHlvdSBnb3QgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VjcmV0IEhNQUMgc2hhcmVkIHNlY3JldC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqL1xuICB2ZXJpZnlITUFDOiBmdW5jdGlvbiB2ZXJpZnlITUFDKHBhcnNlZFNpZ25hdHVyZSwgc2VjcmV0KSB7XG4gICAgYXNzZXJ0Lm9iamVjdChwYXJzZWRTaWduYXR1cmUsICdwYXJzZWRITUFDJyk7XG4gICAgYXNzZXJ0LnN0cmluZyhzZWNyZXQsICdzZWNyZXQnKTtcblxuICAgIHZhciBhbGcgPSBwYXJzZWRTaWduYXR1cmUuYWxnb3JpdGhtLm1hdGNoKC9eSE1BQy0oXFx3KykvKTtcbiAgICBpZiAoIWFsZyB8fCBhbGcubGVuZ3RoICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VkU2lnbmF0dXJlOiB1bnN1cHBvcnRlZCBhbGdvcml0aG0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuXG4gICAgdmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhhbGdbMV0udG9VcHBlckNhc2UoKSwgc2VjcmV0KTtcbiAgICBobWFjLnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG4gICAgcmV0dXJuIChobWFjLmRpZ2VzdCgnYmFzZTY0JykgPT09IHBhcnNlZFNpZ25hdHVyZS5wYXJhbXMuc2lnbmF0dXJlKTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9odHRwLXNpZ25hdHVyZS9saWIvdmVyaWZ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBjdHlwZSA9IHJlcXVpcmUoJ2N0eXBlJyk7XG5cblxuXG4vLy8tLS0gSGVscGVyc1xuXG5mdW5jdGlvbiByZWFkTmV4dChidWZmZXIsIG9mZnNldCkge1xuICB2YXIgbGVuID0gY3R5cGUucnVpbnQzMihidWZmZXIsICdiaWcnLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcblxuICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgbGVuO1xuXG4gIHJldHVybiB7XG4gICAgZGF0YTogYnVmZmVyLnNsaWNlKG9mZnNldCwgbmV3T2Zmc2V0KSxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHdyaXRlSW50KHdyaXRlciwgYnVmZmVyKSB7XG4gIHdyaXRlci53cml0ZUJ5dGUoMHgwMik7IC8vIEFTTjEuSW50ZWdlclxuICB3cml0ZXIud3JpdGVMZW5ndGgoYnVmZmVyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgd3JpdGVyLndyaXRlQnl0ZShidWZmZXJbaV0pO1xuXG4gIHJldHVybiB3cml0ZXI7XG59XG5cblxuZnVuY3Rpb24gcnNhVG9QRU0oa2V5KSB7XG4gIHZhciBidWZmZXI7XG4gIHZhciBkZXI7XG4gIHZhciBleHBvbmVudDtcbiAgdmFyIGk7XG4gIHZhciBtb2R1bHVzO1xuICB2YXIgbmV3S2V5ID0gJyc7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgdHlwZTtcbiAgdmFyIHRtcDtcblxuICB0cnkge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoa2V5LnNwbGl0KCcgJylbMV0sICdiYXNlNjQnKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB0eXBlID0gdG1wLmRhdGEudG9TdHJpbmcoKTtcbiAgICBvZmZzZXQgPSB0bXAub2Zmc2V0O1xuXG4gICAgaWYgKHR5cGUgIT09ICdzc2gtcnNhJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzc2gga2V5IHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBleHBvbmVudCA9IHRtcC5kYXRhO1xuICAgIG9mZnNldCA9IHRtcC5vZmZzZXQ7XG5cbiAgICB0bXAgPSByZWFkTmV4dChidWZmZXIsIG9mZnNldCk7XG4gICAgbW9kdWx1cyA9IHRtcC5kYXRhO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNzaCBrZXk6ICcgKyBrZXkpO1xuICB9XG5cbiAgLy8gREVSIGlzIGEgc3Vic2V0IG9mIEJFUlxuICBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblxuICBkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG4gIGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMTM1NDkuMS4xLjEnKTtcbiAgZGVyLndyaXRlTnVsbCgpO1xuICBkZXIuZW5kU2VxdWVuY2UoKTtcblxuICBkZXIuc3RhcnRTZXF1ZW5jZSgweDAzKTsgLy8gYml0IHN0cmluZ1xuICBkZXIud3JpdGVCeXRlKDB4MDApO1xuXG4gIC8vIEFjdHVhbCBrZXlcbiAgZGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgd3JpdGVJbnQoZGVyLCBtb2R1bHVzKTtcbiAgd3JpdGVJbnQoZGVyLCBleHBvbmVudCk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIC8vIGJpdCBzdHJpbmdcbiAgZGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgZGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgdG1wID0gZGVyLmJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgJSA2NCkgPT09IDApXG4gICAgICBuZXdLZXkgKz0gJ1xcbic7XG4gICAgbmV3S2V5ICs9IHRtcC5jaGFyQXQoaSk7XG4gIH1cblxuICBpZiAoIS9cXFxcbiQvLnRlc3QobmV3S2V5KSlcbiAgICBuZXdLZXkgKz0gJ1xcbic7XG5cbiAgcmV0dXJuICctLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLScgKyBuZXdLZXkgKyAnLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXFxuJztcbn1cblxuXG5mdW5jdGlvbiBkc2FUb1BFTShrZXkpIHtcbiAgdmFyIGJ1ZmZlcjtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciB0bXA7XG4gIHZhciBkZXI7XG4gIHZhciBuZXdLZXkgPSAnJztcblxuICB2YXIgdHlwZTtcbiAgdmFyIHA7XG4gIHZhciBxO1xuICB2YXIgZztcbiAgdmFyIHk7XG5cbiAgdHJ5IHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGtleS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0Jyk7XG5cbiAgICB0bXAgPSByZWFkTmV4dChidWZmZXIsIG9mZnNldCk7XG4gICAgdHlwZSA9IHRtcC5kYXRhLnRvU3RyaW5nKCk7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKCEvXnNzaC1kc1thc10uKi8udGVzdCh0eXBlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzc2gga2V5IHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBwID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBxID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBnID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB5ID0gdG1wLmRhdGE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3NoIGtleTogJyArIGtleSk7XG4gIH1cblxuICAvLyBERVIgaXMgYSBzdWJzZXQgb2YgQkVSXG4gIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG5cbiAgZGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQwLjQuMScpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG4gIHdyaXRlSW50KGRlciwgcCk7XG4gIHdyaXRlSW50KGRlciwgcSk7XG4gIHdyaXRlSW50KGRlciwgZyk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKDB4MDMpOyAvLyBiaXQgc3RyaW5nXG4gIGRlci53cml0ZUJ5dGUoMHgwMCk7XG4gIHdyaXRlSW50KGRlciwgeSk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIHRtcCA9IGRlci5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSAlIDY0KSA9PT0gMClcbiAgICAgIG5ld0tleSArPSAnXFxuJztcbiAgICBuZXdLZXkgKz0gdG1wLmNoYXJBdChpKTtcbiAgfVxuXG4gIGlmICghL1xcXFxuJC8udGVzdChuZXdLZXkpKVxuICAgIG5ld0tleSArPSAnXFxuJztcblxuICByZXR1cm4gJy0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tJyArIG5ld0tleSArICctLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cXG4nO1xufVxuXG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIE9wZW5TU0ggcHVibGljIGtleSAocnNhIG9ubHkpIHRvIGEgUEtDUyM4IFBFTSBmaWxlLlxuICAgKlxuICAgKiBUaGUgaW50ZW50IG9mIHRoaXMgbW9kdWxlIGlzIHRvIGludGVyb3BlcmF0ZSB3aXRoIE9wZW5TU0wgb25seSxcbiAgICogc3BlY2lmaWNhbGx5IHRoZSBub2RlIGNyeXB0byBtb2R1bGUncyBgdmVyaWZ5YCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBFTSBlbmNvZGVkIGZvcm0gb2YgdGhlIFJTQSBwdWJsaWMga2V5LlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBpbnB1dC5cbiAgICogQHRocm93cyB7RXJyb3J9IG9uIGludmFsaWQgc3NoIGtleSBmb3JtYXR0ZWQgZGF0YS5cbiAgICovXG4gIHNzaEtleVRvUEVNOiBmdW5jdGlvbiBzc2hLZXlUb1BFTShrZXkpIHtcbiAgICBhc3NlcnQuc3RyaW5nKGtleSwgJ3NzaF9rZXknKTtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKC9ec3NoLXJzYS4qLy50ZXN0KGtleSkpXG4gICAgICByZXR1cm4gcnNhVG9QRU0oa2V5KTtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKC9ec3NoLWRzW2FzXS4qLy50ZXN0KGtleSkpXG4gICAgICByZXR1cm4gZHNhVG9QRU0oa2V5KTtcblxuICAgIHRocm93IG5ldyBFcnJvcignT25seSBSU0EgYW5kIERTQSBwdWJsaWMga2V5cyBhcmUgYWxsb3dlZCcpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBPcGVuU1NIIGZpbmdlcnByaW50IGZyb20gYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGtleSBmaW5nZXJwcmludC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB3aGF0IHlvdSBwYXNzZWQgZG9lc24ndCBsb29rIGxpa2UgYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqL1xuICBmaW5nZXJwcmludDogZnVuY3Rpb24gZmluZ2VycHJpbnQoa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KCcgJyk7XG4gICAgaWYgKCFwaWVjZXMgfHwgIXBpZWNlcy5sZW5ndGggfHwgcGllY2VzLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3NoIGtleScpO1xuXG4gICAgdmFyIGRhdGEgPSBuZXcgQnVmZmVyKHBpZWNlc1sxXSwgJ2Jhc2U2NCcpO1xuXG4gICAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1Jyk7XG4gICAgaGFzaC51cGRhdGUoZGF0YSk7XG4gICAgdmFyIGRpZ2VzdCA9IGhhc2guZGlnZXN0KCdoZXgnKTtcblxuICAgIHZhciBmcCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAmJiBpICUgMiA9PT0gMClcbiAgICAgICAgZnAgKz0gJzonO1xuXG4gICAgICBmcCArPSBkaWdlc3RbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFBLR0NTIzggUEVNIGZpbGUgdG8gYW4gT3BlblNTSCBwdWJsaWMga2V5IChyc2EpXG4gICAqXG4gICAqIFRoZSByZXZlcnNlIG9mIHRoZSBhYm92ZSBmdW5jdGlvbi5cbiAgICovXG4gIHBlbVRvUnNhU1NIS2V5OiBmdW5jdGlvbiBwZW1Ub1JzYVNTSEtleShwZW0sIGNvbW1lbnQpIHtcbiAgICBhc3NlcnQuZXF1YWwoJ3N0cmluZycsIHR5cGVvZiAocGVtKSwgJ3R5cGVvZiBwZW0nKTtcblxuICAgIC8vIGNob3Agb2ZmIHRoZSBCRUdJTiBQVUJMSUMgS0VZIGFuZCBFTkQgUFVCTElDIEtFWSBwb3J0aW9uXG4gICAgdmFyIGNsZWFuZWQgPSBwZW0uc3BsaXQoJ1xcbicpLnNsaWNlKDEsIC0yKS5qb2luKCcnKTtcblxuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKGNsZWFuZWQsICdiYXNlNjQnKTtcblxuICAgIHZhciBkZXIgPSBuZXcgYXNuMS5CZXJSZWFkZXIoYnVmKTtcblxuICAgIGRlci5yZWFkU2VxdWVuY2UoKTtcbiAgICBkZXIucmVhZFNlcXVlbmNlKCk7XG5cbiAgICB2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcbiAgICBhc3NlcnQuZXF1YWwob2lkLCAnMS4yLjg0MC4xMTM1NDkuMS4xLjEnLCAncGVtIG5vdCBpbiBSU0EgZm9ybWF0Jyk7XG5cbiAgICAvLyBOdWxsIC0tIFhYWCB0aGlzIHByb2JhYmx5IGlzbid0IGdvb2QgcHJhY3RpY2VcbiAgICBkZXIucmVhZEJ5dGUoKTtcbiAgICBkZXIucmVhZEJ5dGUoKTtcblxuICAgIC8vIGJpdCBzdHJpbmcgc2VxdWVuY2VcbiAgICBkZXIucmVhZFNlcXVlbmNlKDB4MDMpO1xuICAgIGRlci5yZWFkQnl0ZSgpO1xuICAgIGRlci5yZWFkU2VxdWVuY2UoKTtcblxuICAgIC8vIG1vZHVsdXNcbiAgICBhc3NlcnQuZXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlciwgJ21vZHVsdXMgbm90IGFuIGludGVnZXInKTtcbiAgICBkZXIuX29mZnNldCA9IGRlci5yZWFkTGVuZ3RoKGRlci5vZmZzZXQgKyAxKTtcbiAgICB2YXIgbW9kdWx1cyA9IGRlci5fYnVmLnNsaWNlKGRlci5vZmZzZXQsIGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoKTtcbiAgICBkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXG4gICAgLy8gZXhwb25lbnRcbiAgICBhc3NlcnQuZXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlciwgJ2V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyJyk7XG4gICAgZGVyLl9vZmZzZXQgPSBkZXIucmVhZExlbmd0aChkZXIub2Zmc2V0ICsgMSk7XG4gICAgdmFyIGV4cG9uZW50ID0gZGVyLl9idWYuc2xpY2UoZGVyLm9mZnNldCwgZGVyLm9mZnNldCArIGRlci5sZW5ndGgpO1xuICAgIGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cbiAgICAvLyBub3csIG1ha2UgdGhlIGtleVxuICAgIHZhciB0eXBlID0gbmV3IEJ1ZmZlcignc3NoLXJzYScpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKDQgKyB0eXBlLmxlbmd0aCArIDQgKyBtb2R1bHVzLmxlbmd0aCArXG4gICAgICA0ICsgZXhwb25lbnQubGVuZ3RoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUodHlwZS5sZW5ndGgsIGkpOyAgICAgaSArPSA0O1xuICAgIHR5cGUuY29weShidWZmZXIsIGkpOyAgICAgICAgICAgICAgICAgICAgIGkgKz0gdHlwZS5sZW5ndGg7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUoZXhwb25lbnQubGVuZ3RoLCBpKTsgaSArPSA0O1xuICAgIGV4cG9uZW50LmNvcHkoYnVmZmVyLCBpKTsgICAgICAgICAgICAgICAgIGkgKz0gZXhwb25lbnQubGVuZ3RoO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG1vZHVsdXMubGVuZ3RoLCBpKTsgIGkgKz0gNDtcbiAgICBtb2R1bHVzLmNvcHkoYnVmZmVyLCBpKTsgICAgICAgICAgICAgICAgICBpICs9IG1vZHVsdXMubGVuZ3RoO1xuXG4gICAgdmFyIHMgPSAodHlwZS50b1N0cmluZygpICsgJyAnICsgYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKSArICcgJyArXG4gICAgICAoY29tbWVudCB8fCAnJykpO1xuICAgIHJldHVybiBzO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2h0dHAtc2lnbmF0dXJlL2xpYi91dGlsLmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbi8vIElmIHlvdSBoYXZlIG5vIGlkZWEgd2hhdCBBU04uMSBvciBCRVIgaXMsIHNlZSB0aGlzOlxuLy8gZnRwOi8vZnRwLnJzYS5jb20vcHViL3BrY3MvYXNjaWkvbGF5bWFuLmFzY1xuXG52YXIgQmVyID0gcmVxdWlyZSgnLi9iZXIvaW5kZXgnKTtcblxuXG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgQmVyOiBCZXIsXG5cbiAgQmVyUmVhZGVyOiBCZXIuUmVhZGVyLFxuXG4gIEJlcldyaXRlcjogQmVyLldyaXRlclxuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2FzbjEvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG52YXIgUmVhZGVyID0gcmVxdWlyZSgnLi9yZWFkZXInKTtcbnZhciBXcml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpO1xuXG5cbi8vLy0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIFJlYWRlcjogUmVhZGVyLFxuXG4gIFdyaXRlcjogV3JpdGVyXG5cbn07XG5cbmZvciAodmFyIHQgaW4gdHlwZXMpIHtcbiAgaWYgKHR5cGVzLmhhc093blByb3BlcnR5KHQpKVxuICAgIG1vZHVsZS5leHBvcnRzW3RdID0gdHlwZXNbdF07XG59XG5mb3IgKHZhciBlIGluIGVycm9ycykge1xuICBpZiAoZXJyb3JzLmhhc093blByb3BlcnR5KGUpKVxuICAgIG1vZHVsZS5leHBvcnRzW2VdID0gZXJyb3JzW2VdO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2FzbjEvbGliL2Jlci9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIG5ld0ludmFsaWRBc24xRXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBlID0gbmV3IEVycm9yKCk7XG4gICAgZS5uYW1lID0gJ0ludmFsaWRBc24xRXJyb3InO1xuICAgIGUubWVzc2FnZSA9IG1zZyB8fCAnJztcbiAgICByZXR1cm4gZTtcbiAgfVxuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2FzbjEvbGliL2Jlci9lcnJvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRU9DOiAwLFxuICBCb29sZWFuOiAxLFxuICBJbnRlZ2VyOiAyLFxuICBCaXRTdHJpbmc6IDMsXG4gIE9jdGV0U3RyaW5nOiA0LFxuICBOdWxsOiA1LFxuICBPSUQ6IDYsXG4gIE9iamVjdERlc2NyaXB0b3I6IDcsXG4gIEV4dGVybmFsOiA4LFxuICBSZWFsOiA5LCAvLyBmbG9hdFxuICBFbnVtZXJhdGlvbjogMTAsXG4gIFBEVjogMTEsXG4gIFV0ZjhTdHJpbmc6IDEyLFxuICBSZWxhdGl2ZU9JRDogMTMsXG4gIFNlcXVlbmNlOiAxNixcbiAgU2V0OiAxNyxcbiAgTnVtZXJpY1N0cmluZzogMTgsXG4gIFByaW50YWJsZVN0cmluZzogMTksXG4gIFQ2MVN0cmluZzogMjAsXG4gIFZpZGVvdGV4U3RyaW5nOiAyMSxcbiAgSUE1U3RyaW5nOiAyMixcbiAgVVRDVGltZTogMjMsXG4gIEdlbmVyYWxpemVkVGltZTogMjQsXG4gIEdyYXBoaWNTdHJpbmc6IDI1LFxuICBWaXNpYmxlU3RyaW5nOiAyNixcbiAgR2VuZXJhbFN0cmluZzogMjgsXG4gIFVuaXZlcnNhbFN0cmluZzogMjksXG4gIENoYXJhY3RlclN0cmluZzogMzAsXG4gIEJNUFN0cmluZzogMzEsXG4gIENvbnN0cnVjdG9yOiAzMixcbiAgQ29udGV4dDogMTI4XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2FzbjEvbGliL2Jlci90eXBlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBBU04xID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIG5ld0ludmFsaWRBc24xRXJyb3IgPSBlcnJvcnMubmV3SW52YWxpZEFzbjFFcnJvcjtcblxuXG5cbi8vLy0tLSBBUElcblxuZnVuY3Rpb24gUmVhZGVyKGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGEgbm9kZSBCdWZmZXInKTtcblxuICB0aGlzLl9idWYgPSBkYXRhO1xuICB0aGlzLl9zaXplID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gVGhlc2UgaG9sZCB0aGUgXCJjdXJyZW50XCIgc3RhdGVcbiAgdGhpcy5fbGVuID0gMDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnbGVuZ3RoJywgZnVuY3Rpb24oKSB7IHJldHVybiBzZWxmLl9sZW47IH0pO1xuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ29mZnNldCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5fb2Zmc2V0OyB9KTtcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdyZW1haW4nLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5fc2l6ZSAtIHNlbGYuX29mZnNldDtcbiAgfSk7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnYnVmZmVyJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuX2J1Zi5zbGljZShzZWxmLl9vZmZzZXQpO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJlYWRzIGEgc2luZ2xlIGJ5dGUgYW5kIGFkdmFuY2VzIG9mZnNldDsgeW91IGNhbiBwYXNzIGluIGB0cnVlYCB0byBtYWtlIHRoaXNcbiAqIGEgXCJwZWVrXCIgb3BlcmF0aW9uIChpLmUuLCBnZXQgdGhlIGJ5dGUsIGJ1dCBkb24ndCBhZHZhbmNlIHRoZSBvZmZzZXQpLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVlayB0cnVlIG1lYW5zIGRvbid0IG1vdmUgb2Zmc2V0LlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgbmV4dCBieXRlLCBudWxsIGlmIG5vdCBlbm91Z2ggZGF0YS5cbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5yZWFkQnl0ZSA9IGZ1bmN0aW9uKHBlZWspIHtcbiAgaWYgKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQgPCAxKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBiID0gdGhpcy5fYnVmW3RoaXMuX29mZnNldF0gJiAweGZmO1xuXG4gIGlmICghcGVlaylcbiAgICB0aGlzLl9vZmZzZXQgKz0gMTtcblxuICByZXR1cm4gYjtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJlYWRCeXRlKHRydWUpO1xufTtcblxuXG4vKipcbiAqIFJlYWRzIGEgKHBvdGVudGlhbGx5KSB2YXJpYWJsZSBsZW5ndGggb2ZmIHRoZSBCRVIgYnVmZmVyLiAgVGhpcyBjYWxsIGlzXG4gKiBub3QgcmVhbGx5IG1lYW50IHRvIGJlIGNhbGxlZCBkaXJlY3RseSwgYXMgY2FsbGVycyBoYXZlIHRvIG1hbmlwdWxhdGVcbiAqIHRoZSBpbnRlcm5hbCBidWZmZXIgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBBcyBhIHJlc3VsdCBvZiB0aGlzIGNhbGwsIHlvdSBjYW4gY2FsbCBgUmVhZGVyLmxlbmd0aGAsIHVudGlsIHRoZVxuICogbmV4dCB0aGluZyBjYWxsZWQgdGhhdCBkb2VzIGEgcmVhZExlbmd0aC5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBhbW91bnQgb2Ygb2Zmc2V0IHRvIGFkdmFuY2UgdGhlIGJ1ZmZlci5cbiAqIEB0aHJvd3Mge0ludmFsaWRBc24xRXJyb3J9IG9uIGJhZCBBU04uMVxuICovXG5SZWFkZXIucHJvdG90eXBlLnJlYWRMZW5ndGggPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuICAgIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuICBpZiAob2Zmc2V0ID49IHRoaXMuX3NpemUpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbkIgPSB0aGlzLl9idWZbb2Zmc2V0KytdICYgMHhmZjtcbiAgaWYgKGxlbkIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKChsZW5CICYgMHg4MCkgPT0gMHg4MCkge1xuICAgIGxlbkIgJj0gMHg3ZjtcblxuICAgIGlmIChsZW5CID09IDApXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdJbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBpZiAobGVuQiA+IDQpXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdlbmNvZGluZyB0b28gbG9uZycpO1xuXG4gICAgaWYgKHRoaXMuX3NpemUgLSBvZmZzZXQgPCBsZW5CKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB0aGlzLl9sZW4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuQjsgaSsrKVxuICAgICAgdGhpcy5fbGVuID0gKHRoaXMuX2xlbiA8PCA4KSArICh0aGlzLl9idWZbb2Zmc2V0KytdICYgMHhmZik7XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBXYXNuJ3QgYSB2YXJpYWJsZSBsZW5ndGhcbiAgICB0aGlzLl9sZW4gPSBsZW5CO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn07XG5cblxuLyoqXG4gKiBQYXJzZXMgdGhlIG5leHQgc2VxdWVuY2UgaW4gdGhpcyBCRVIgYnVmZmVyLlxuICpcbiAqIFRvIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBzZXF1ZW5jZSwgY2FsbCBgUmVhZGVyLmxlbmd0aGAuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgc2VxdWVuY2UncyB0YWcuXG4gKi9cblJlYWRlci5wcm90b3R5cGUucmVhZFNlcXVlbmNlID0gZnVuY3Rpb24odGFnKSB7XG4gIHZhciBzZXEgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKHNlcSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkICYmIHRhZyAhPT0gc2VxKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIHNlcS50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcbiAgcmV0dXJuIHNlcTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkVGFnKEFTTjEuSW50ZWdlcik7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZEJvb2xlYW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9yZWFkVGFnKEFTTjEuQm9vbGVhbikgPT09IDAgPyBmYWxzZSA6IHRydWUpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZFRhZyhBU04xLkVudW1lcmF0aW9uKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24odGFnLCByZXRidWYpIHtcbiAgaWYgKCF0YWcpXG4gICAgdGFnID0gQVNOMS5PY3RldFN0cmluZztcblxuICB2YXIgYiA9IHRoaXMucGVlaygpO1xuICBpZiAoYiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoYiAhPT0gdGFnKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIGIudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG5cbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5fc2l6ZSAtIG8pXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuICcnO1xuXG4gIHZhciBzdHIgPSB0aGlzLl9idWYuc2xpY2UodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gIHRoaXMuX29mZnNldCArPSB0aGlzLmxlbmd0aDtcblxuICByZXR1cm4gcmV0YnVmID8gc3RyIDogc3RyLnRvU3RyaW5nKCd1dGY4Jyk7XG59O1xuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRPSUQgPSBmdW5jdGlvbih0YWcpIHtcbiAgaWYgKCF0YWcpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgdmFyIGIgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKGIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGIgIT09IHRhZylcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBiLnRvU3RyaW5nKDE2KSk7XG5cbiAgdmFyIG8gPSB0aGlzLnJlYWRMZW5ndGgodGhpcy5fb2Zmc2V0ICsgMSk7IC8vIHN0b3JlZCBpbiBgbGVuZ3RoYFxuICBpZiAobyA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLl9zaXplIC0gbylcbiAgICByZXR1cm4gbnVsbDtcblxuICB0aGlzLl9vZmZzZXQgPSBvO1xuXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIHZhbHVlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gJiAweGZmO1xuXG4gICAgdmFsdWUgPDw9IDc7XG4gICAgdmFsdWUgKz0gYnl0ZSAmIDB4N2Y7XG4gICAgaWYgKChieXRlICYgMHg4MCkgPT0gMCkge1xuICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHZhbHVlID0gdmFsdWVzLnNoaWZ0KCk7XG4gIHZhbHVlcy51bnNoaWZ0KHZhbHVlICUgNDApO1xuICB2YWx1ZXMudW5zaGlmdCgodmFsdWUgLyA0MCkgPj4gMCk7XG5cbiAgcmV0dXJuIHZhbHVlcy5qb2luKCcuJyk7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUuX3JlYWRUYWcgPSBmdW5jdGlvbih0YWcpIHtcbiAgYXNzZXJ0Lm9rKHRhZyAhPT0gdW5kZWZpbmVkKTtcblxuICB2YXIgYiA9IHRoaXMucGVlaygpO1xuXG4gIGlmIChiID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChiICE9PSB0YWcpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignRXhwZWN0ZWQgMHgnICsgdGFnLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiBnb3QgMHgnICsgYi50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gNClcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdJbnRlZ2VyIHRvbyBsb25nOiAnICsgdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMuX3NpemUgLSBvKVxuICAgIHJldHVybiBudWxsO1xuICB0aGlzLl9vZmZzZXQgPSBvO1xuXG4gIHZhciBmYiA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK107XG4gIHZhciB2YWx1ZSA9IDA7XG5cbiAgdmFsdWUgPSBmYiAmIDB4N0Y7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhbHVlIDw8PSA4O1xuICAgIHZhbHVlIHw9ICh0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdICYgMHhmZik7XG4gIH1cblxuICBpZiAoKGZiICYgMHg4MCkgPT0gMHg4MClcbiAgICB2YWx1ZSA9IC12YWx1ZTtcblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5cblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9hc24xL2xpYi9iZXIvcmVhZGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBBU04xID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLy8vLS0tIEdsb2JhbHNcblxudmFyIG5ld0ludmFsaWRBc24xRXJyb3IgPSBlcnJvcnMubmV3SW52YWxpZEFzbjFFcnJvcjtcblxudmFyIERFRkFVTFRfT1BUUyA9IHtcbiAgc2l6ZTogMTAyNCxcbiAgZ3Jvd3RoRmFjdG9yOiA4XG59O1xuXG5cbi8vLy0tLSBIZWxwZXJzXG5cbmZ1bmN0aW9uIG1lcmdlKGZyb20sIHRvKSB7XG4gIGFzc2VydC5vayhmcm9tKTtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZihmcm9tKSwgJ29iamVjdCcpO1xuICBhc3NlcnQub2sodG8pO1xuICBhc3NlcnQuZXF1YWwodHlwZW9mKHRvKSwgJ29iamVjdCcpO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZnJvbSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAodG9ba2V5XSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwga2V5KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gdG87XG59XG5cblxuXG4vLy8tLS0gQVBJXG5cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBtZXJnZShERUZBVUxUX09QVFMsIG9wdGlvbnMgfHwge30pO1xuXG4gIHRoaXMuX2J1ZiA9IG5ldyBCdWZmZXIob3B0aW9ucy5zaXplIHx8IDEwMjQpO1xuICB0aGlzLl9zaXplID0gdGhpcy5fYnVmLmxlbmd0aDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgLy8gQSBsaXN0IG9mIG9mZnNldHMgaW4gdGhlIGJ1ZmZlciB3aGVyZSB3ZSBuZWVkIHRvIGluc2VydFxuICAvLyBzZXF1ZW5jZSB0YWcvbGVuIHBhaXJzLlxuICB0aGlzLl9zZXEgPSBbXTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnYnVmZmVyJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYuX3NlcS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFzbjFFcnJvcihzZWxmLl9zZXEubGVuZ3RoICsgJyB1bmVuZGVkIHNlcXVlbmNlKHMpJyk7XG5cbiAgICByZXR1cm4gc2VsZi5fYnVmLnNsaWNlKDAsIHNlbGYuX29mZnNldCk7XG4gIH0pO1xufVxuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24oYikge1xuICBpZiAodHlwZW9mKGIpICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDEpO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gYjtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUludCA9IGZ1bmN0aW9uKGksIHRhZykge1xuICBpZiAodHlwZW9mKGkpICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5JbnRlZ2VyO1xuXG4gIHZhciBzeiA9IDQ7XG5cbiAgd2hpbGUgKCgoKGkgJiAweGZmODAwMDAwKSA9PT0gMCkgfHwgKChpICYgMHhmZjgwMDAwMCkgPT09IDB4ZmY4MDAwMDApKSAmJlxuICAgICAgICAgKHN6ID4gMSkpIHtcbiAgICBzei0tO1xuICAgIGkgPDw9IDg7XG4gIH1cblxuICBpZiAoc3ogPiA0KVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXNuMUVycm9yKCdCRVIgaW50cyBjYW5ub3QgYmUgPiAweGZmZmZmZmZmJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDIgKyBzeik7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSB0YWc7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBzejtcblxuICB3aGlsZSAoc3otLSA+IDApIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gKChpICYgMHhmZjAwMDAwMCkgPj4gMjQpO1xuICAgIGkgPDw9IDg7XG4gIH1cblxufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlTnVsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRlQnl0ZShBU04xLk51bGwpO1xuICB0aGlzLndyaXRlQnl0ZSgweDAwKTtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUVudW1lcmF0aW9uID0gZnVuY3Rpb24oaSwgdGFnKSB7XG4gIGlmICh0eXBlb2YoaSkgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgaWYgKHR5cGVvZih0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkVudW1lcmF0aW9uO1xuXG4gIHJldHVybiB0aGlzLndyaXRlSW50KGksIHRhZyk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCb29sZWFuID0gZnVuY3Rpb24oYiwgdGFnKSB7XG4gIGlmICh0eXBlb2YoYikgIT09ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgQm9vbGVhbicpO1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuQm9vbGVhbjtcblxuICB0aGlzLl9lbnN1cmUoMyk7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSB0YWc7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSAweDAxO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gYiA/IDB4ZmYgOiAweDAwO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24ocywgdGFnKSB7XG4gIGlmICh0eXBlb2YocykgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcgKHdhczogJyArIHR5cGVvZihzKSArICcpJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5PY3RldFN0cmluZztcblxuICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgocyk7XG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgobGVuKTtcbiAgaWYgKGxlbikge1xuICAgIHRoaXMuX2Vuc3VyZShsZW4pO1xuICAgIHRoaXMuX2J1Zi53cml0ZShzLCB0aGlzLl9vZmZzZXQpO1xuICAgIHRoaXMuX29mZnNldCArPSBsZW47XG4gIH1cbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZiwgdGFnKSB7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFnIG11c3QgYmUgYSBudW1iZXInKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgYnVmZmVyJyk7XG5cbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChidWYubGVuZ3RoKTtcbiAgdGhpcy5fZW5zdXJlKGJ1Zi5sZW5ndGgpO1xuICBidWYuY29weSh0aGlzLl9idWYsIHRoaXMuX29mZnNldCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMuX29mZnNldCArPSBidWYubGVuZ3RoO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nQXJyYXkgPSBmdW5jdGlvbihzdHJpbmdzKSB7XG4gIGlmICgoIXN0cmluZ3MgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheVtTdHJpbmddJyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHNlbGYud3JpdGVTdHJpbmcocyk7XG4gIH0pO1xufTtcblxuLy8gVGhpcyBpcyByZWFsbHkgdG8gc29sdmUgREVSIGNhc2VzLCBidXQgd2hhdGV2ZXIgZm9yIG5vd1xuV3JpdGVyLnByb3RvdHlwZS53cml0ZU9JRCA9IGZ1bmN0aW9uKHMsIHRhZykge1xuICBpZiAodHlwZW9mKHMpICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5PSUQ7XG5cbiAgaWYgKCEvXihbMC05XStcXC4pezMsfVswLTldKyQvLnRlc3QocykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdhcmd1bWVudCBpcyBub3QgYSB2YWxpZCBPSUQgc3RyaW5nJyk7XG5cbiAgZnVuY3Rpb24gZW5jb2RlT2N0ZXQoYnl0ZXMsIG9jdGV0KSB7XG4gICAgaWYgKG9jdGV0IDwgMTI4KSB7XG4gICAgICAgIGJ5dGVzLnB1c2gob2N0ZXQpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAxNjM4NCkge1xuICAgICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gNykgfCAweDgwKTtcbiAgICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAyMDk3MTUyKSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMTQpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2UgaWYgKG9jdGV0IDwgMjY4NDM1NDU2KSB7XG4gICAgICBieXRlcy5wdXNoKChvY3RldCA+Pj4gMjEpIHwgMHg4MCk7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDE0KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyOCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAyMSkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAxNCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiA3KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRtcCA9IHMuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gW107XG4gIGJ5dGVzLnB1c2gocGFyc2VJbnQodG1wWzBdLCAxMCkgKiA0MCArIHBhcnNlSW50KHRtcFsxXSwgMTApKTtcbiAgdG1wLnNsaWNlKDIpLmZvckVhY2goZnVuY3Rpb24oYikge1xuICAgIGVuY29kZU9jdGV0KGJ5dGVzLCBwYXJzZUludChiLCAxMCkpO1xuICB9KTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2Vuc3VyZSgyICsgYnl0ZXMubGVuZ3RoKTtcbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChieXRlcy5sZW5ndGgpO1xuICBieXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICBzZWxmLndyaXRlQnl0ZShiKTtcbiAgfSk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVMZW5ndGggPSBmdW5jdGlvbihsZW4pIHtcbiAgaWYgKHR5cGVvZihsZW4pICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDQpO1xuXG4gIGlmIChsZW4gPD0gMHg3Zikge1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICB0aGlzLl9zaGlmdChzdGFydCwgbGVuLCAxKTtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MztcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDE2O1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXNuMUVScm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbiAgfVxufTtcblxuV3JpdGVyLnByb3RvdHlwZS5zdGFydFNlcXVlbmNlID0gZnVuY3Rpb24odGFnKSB7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5TZXF1ZW5jZSB8IEFTTjEuQ29uc3RydWN0b3I7XG5cbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy5fc2VxLnB1c2godGhpcy5fb2Zmc2V0KTtcbiAgdGhpcy5fZW5zdXJlKDMpO1xuICB0aGlzLl9vZmZzZXQgKz0gMztcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS5lbmRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VxID0gdGhpcy5fc2VxLnBvcCgpO1xuICB2YXIgc3RhcnQgPSBzZXEgKyAzO1xuICB2YXIgbGVuID0gdGhpcy5fb2Zmc2V0IC0gc3RhcnQ7XG5cbiAgaWYgKGxlbiA8PSAweDdmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTIpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgLTEpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZikge1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgMSk7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSAweDgzO1xuICAgIHRoaXMuX2J1ZltzZXEgKyAxXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbc2VxICsgMl0gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbc2VxICsgM10gPSBsZW47XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBc24xRXJyb3IoJ1NlcXVlbmNlIHRvbyBsb25nJyk7XG4gIH1cbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS5fc2hpZnQgPSBmdW5jdGlvbihzdGFydCwgbGVuLCBzaGlmdCkge1xuICBhc3NlcnQub2soc3RhcnQgIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhsZW4gIT09IHVuZGVmaW5lZCk7XG4gIGFzc2VydC5vayhzaGlmdCk7XG5cbiAgdGhpcy5fYnVmLmNvcHkodGhpcy5fYnVmLCBzdGFydCArIHNoaWZ0LCBzdGFydCwgc3RhcnQgKyBsZW4pO1xuICB0aGlzLl9vZmZzZXQgKz0gc2hpZnQ7XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLl9lbnN1cmUgPSBmdW5jdGlvbihsZW4pIHtcbiAgYXNzZXJ0Lm9rKGxlbik7XG5cbiAgaWYgKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQgPCBsZW4pIHtcbiAgICB2YXIgc3ogPSB0aGlzLl9zaXplICogdGhpcy5fb3B0aW9ucy5ncm93dGhGYWN0b3I7XG4gICAgaWYgKHN6IC0gdGhpcy5fb2Zmc2V0IDwgbGVuKVxuICAgICAgc3ogKz0gbGVuO1xuXG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3opO1xuXG4gICAgdGhpcy5fYnVmLmNvcHkoYnVmLCAwLCAwLCB0aGlzLl9vZmZzZXQpO1xuICAgIHRoaXMuX2J1ZiA9IGJ1ZjtcbiAgICB0aGlzLl9zaXplID0gc3o7XG4gIH1cbn07XG5cblxuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2FzbjEvbGliL2Jlci93cml0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBybSAtIEZlYiAyMDExXG4gKiBjdHlwZS5qc1xuICpcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgc2ltcGxlIGFic3RyYWN0aW9uIHRvd2FyZHMgcmVhZGluZyBhbmQgd3JpdGluZ1xuICogZGlmZmVyZW50IHR5cGVzIG9mIGJpbmFyeSBkYXRhLiBJdCBpcyBkZXNpZ25lZCB0byB1c2UgY3Rpby5qcyBhbmQgcHJvdmlkZSBhXG4gKiByaWNoZXIgYW5kIG1vcmUgZXhwcmVzc2l2ZSBBUEkgb24gdG9wIG9mIGl0LlxuICpcbiAqIEJ5IGRlZmF1bHQgd2Ugc3VwcG9ydCB0aGUgZm9sbG93aW5nIGFzIGJ1aWx0IGluIGJhc2ljIHR5cGVzOlxuICpcdGludDhfdFxuICpcdGludDE2X3RcbiAqXHRpbnQzMl90XG4gKlx0dWludDhfdFxuICpcdHVpbnQxNl90XG4gKlx0dWludDMyX3RcbiAqXHR1aW50NjRfdFxuICpcdGZsb2F0XG4gKlx0ZG91YmxlXG4gKlx0Y2hhclxuICpcdGNoYXJbXVxuICpcbiAqIEVhY2ggdHlwZSBpcyByZXR1cm5lZCBhcyBhIE51bWJlciwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNoYXIgYW5kIGNoYXJbXVxuICogd2hpY2ggYXJlIHJldHVybmVkIGFzIE5vZGUgQnVmZmVycy4gQSBjaGFyIGlzIGNvbnNpZGVyZWQgYSB1aW50OF90LlxuICpcbiAqIFJlcXVlc3RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgYXJlIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBKU09OIG9iamVjdHMuXG4gKiBUaGlzIGlzIGFsc28gdGhlIHNhbWUgd2F5IHRoYXQgb25lIGRlY2xhcmVzIHN0cnVjdHMuIEV2ZW4gaWYganVzdCBhIHNpbmdsZVxuICogdmFsdWUgaXMgcmVxdWVzdGVkLCBpdCBtdXN0IGJlIGRvbmUgYXMgYSBzdHJ1Y3QuIFRoZSBhcnJheSBvcmRlciBkZXRlcm1pbmVzXG4gKiB0aGUgb3JkZXIgdGhhdCB3ZSB0cnkgYW5kIHJlYWQgdmFsdWVzLiBFYWNoIGVudHJ5IGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdFxuICogd2l0aCB2YWx1ZXMgbWFya2VkIHdpdGggYSAqIGJlaW5nIG9wdGlvbmFsLlxuICpcbiAqIHsga2V5OiB7IHR5cGU6IC90eXBlLywgdmFsdWUqOiAvdmFsdWUvLCBvZmZzZXQqOiAvb2Zmc2V0LyB9XG4gKlxuICogSWYgb2Zmc2V0IGlzIGRlZmluZWQsIHdlIGxzZWVrKG9mZnNldCwgU0VFS19TRVQpIGJlZm9yZSByZWFkaW5nIHRoZSBuZXh0XG4gKiB2YWx1ZS4gVmFsdWUgaXMgZGVmaW5lZCB3aGVuIHdlJ3JlIHdyaXRpbmcgb3V0IGRhdGEsIG90aGVyd2lzZSBpdCdzIGlnbm9yZWQuXG4gKlxuICovXG5cbnZhciBtb2RfY3RmID0gcmVxdWlyZSgnLi9jdGYuanMnKTtcbnZhciBtb2RfY3RpbyA9IHJlcXVpcmUoJy4vY3Rpby5qcycpO1xudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLypcbiAqIFRoaXMgaXMgdGhlIHNldCBvZiBiYXNpYyB0eXBlcyB0aGF0IHdlIHN1cHBvcnQuXG4gKlxuICpcdHJlYWRcdFx0VGhlIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcmVhZCBpbiBhIHZhbHVlIGZyb20gYSBidWZmZXJcbiAqXG4gKlx0d3JpdGVcdFx0VGhlIGZ1bmN0aW9uIHRvIGNhbGwgdG8gd3JpdGUgYSB2YWx1ZSB0byBhIGJ1ZmZlclxuICpcbiAqL1xudmFyIGRlZnR5cGVzID0ge1xuICAgICd1aW50OF90JzogIHsgcmVhZDogY3RSZWFkVWludDgsIHdyaXRlOiBjdFdyaXRlVWludDggfSxcbiAgICAndWludDE2X3QnOiB7IHJlYWQ6IGN0UmVhZFVpbnQxNiwgd3JpdGU6IGN0V3JpdGVVaW50MTYgfSxcbiAgICAndWludDMyX3QnOiB7IHJlYWQ6IGN0UmVhZFVpbnQzMiwgd3JpdGU6IGN0V3JpdGVVaW50MzIgfSxcbiAgICAndWludDY0X3QnOiB7IHJlYWQ6IGN0UmVhZFVpbnQ2NCwgd3JpdGU6IGN0V3JpdGVVaW50NjQgfSxcbiAgICAnaW50OF90JzogeyByZWFkOiBjdFJlYWRTaW50OCwgd3JpdGU6IGN0V3JpdGVTaW50OCB9LFxuICAgICdpbnQxNl90JzogeyByZWFkOiBjdFJlYWRTaW50MTYsIHdyaXRlOiBjdFdyaXRlU2ludDE2IH0sXG4gICAgJ2ludDMyX3QnOiB7IHJlYWQ6IGN0UmVhZFNpbnQzMiwgd3JpdGU6IGN0V3JpdGVTaW50MzIgfSxcbiAgICAnaW50NjRfdCc6IHsgcmVhZDogY3RSZWFkU2ludDY0LCB3cml0ZTogY3RXcml0ZVNpbnQ2NCB9LFxuICAgICdmbG9hdCc6IHsgcmVhZDogY3RSZWFkRmxvYXQsIHdyaXRlOiBjdFdyaXRlRmxvYXQgfSxcbiAgICAnZG91YmxlJzogeyByZWFkOiBjdFJlYWREb3VibGUsIHdyaXRlOiBjdFdyaXRlRG91YmxlIH0sXG4gICAgJ2NoYXInOiB7IHJlYWQ6IGN0UmVhZENoYXIsIHdyaXRlOiBjdFdyaXRlQ2hhciB9LFxuICAgICdjaGFyW10nOiB7IHJlYWQ6IGN0UmVhZENoYXJBcnJheSwgd3JpdGU6IGN0V3JpdGVDaGFyQXJyYXkgfVxufTtcblxuLypcbiAqIFRoZSBmb2xsb3dpbmcgYXJlIHdyYXBwZXJzIGFyb3VuZCB0aGUgQ1R5cGUgSU8gbG93IGxldmVsIEFQSS4gVGhleSBlbmNvZGVcbiAqIGtub3dsZWRnZSBhYm91dCB0aGUgc2l6ZSBhbmQgcmV0dXJuIHNvbWV0aGluZyBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBjdFJlYWRVaW50OChlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnVpbnQ4KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogMSB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkVWludDE2KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogMiB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkVWludDMyKGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogNCB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkVWludDY0KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogOCB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkU2ludDgoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJzaW50OChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDEgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZFNpbnQxNihlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDIgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZFNpbnQzMihlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDQgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZFNpbnQ2NChlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDggfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZEZsb2F0KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5yZmxvYXQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiA0IH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWREb3VibGUoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJkb3VibGUoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiA4IH0pO1xufVxuXG4vKlxuICogUmVhZHMgYSBzaW5nbGUgY2hhcmFjdGVyIGludG8gYSBub2RlIGJ1ZmZlclxuICovXG5mdW5jdGlvbiBjdFJlYWRDaGFyKGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciByZXMgPSBuZXcgQnVmZmVyKDEpO1xuXHRyZXNbMF0gPSBtb2RfY3Rpby5ydWludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogcmVzLCBzaXplOiAxIH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWRDaGFyQXJyYXkobGVuZ3RoLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgaWk7XG5cdHZhciByZXMgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG5cblx0Zm9yIChpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKVxuXHRcdHJlc1tpaV0gPSBtb2RfY3Rpby5ydWludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCArIGlpKTtcblxuXHRyZXR1cm4gKHsgdmFsdWU6IHJlcywgc2l6ZTogbGVuZ3RoIH0pO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlVWludDgodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLnd1aW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoMSk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVVaW50MTYodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLnd1aW50MTYodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDIpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlVWludDMyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53dWludDMyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg0KTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVVpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3VpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoOCk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVTaW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3NpbnQ4KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICgxKTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVNpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3NpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoMik7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVTaW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLndzaW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDQpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlU2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53c2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg4KTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZUZsb2F0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53ZmxvYXQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDQpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlRG91YmxlKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53ZG91YmxlKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg4KTtcbn1cblxuLypcbiAqIFdyaXRlcyBhIHNpbmdsZSBjaGFyYWN0ZXIgaW50byBhIG5vZGUgYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIGN0V3JpdGVDaGFyKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIGJ1ZmZlcicpKTtcblxuXHRtb2RfY3Rpby5ydWludDgodmFsdWVbMF0sIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDEpO1xufVxuXG4vKlxuICogV2UncmUgZ29pbmcgdG8gd3JpdGUgMHMgaW50byB0aGUgYnVmZmVyIGlmIHRoZSBzdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY3RXcml0ZUNoYXJBcnJheSh2YWx1ZSwgbGVuZ3RoLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgaWk7XG5cblx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBCdWZmZXIpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBidWZmZXInKSk7XG5cblx0aWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBsZW5ndGggZ3JlYXRlciB0aGFuIGFycmF5IGxlbmd0aCcpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCB2YWx1ZS5sZW5ndGggJiYgaWkgPCBsZW5ndGg7IGlpKyspXG5cdFx0bW9kX2N0aW8ud3VpbnQ4KHZhbHVlW2lpXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCArIGlpKTtcblxuXHRmb3IgKDsgaWkgPCBsZW5ndGg7IGlpKyspXG5cdFx0bW9kX2N0aW8ud3VpbnQ4KDAsIGVuZGlhbiwgb2Zmc2V0ICsgaWkpO1xuXG5cblx0cmV0dXJuIChsZW5ndGgpO1xufVxuXG4vKlxuICogRWFjaCBwYXJzZXIgaGFzIHRoZWlyIG93biBzZXQgb2YgdHlwZXMuIFdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhleSBlYWNoXG4gKiBnZXQgdGhlaXIgb3duIGNvcHkgYXMgdGhleSBtYXkgbmVlZCB0byBtb2RpZnkgaXQuXG4gKi9cbmZ1bmN0aW9uIGN0R2V0QmFzaWNUeXBlcygpXG57XG5cdHZhciByZXQgPSB7fTtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gZGVmdHlwZXMpXG5cdFx0cmV0W2tleV0gPSBkZWZ0eXBlc1trZXldO1xuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIEdpdmVuIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIHR5cGVbbGVuZ3RoXSB3ZSB3YW50IHRvIHNwbGl0IHRoaXMgaW50byBhblxuICogb2JqZWN0IHRoYXQgZXh0cmFjdHMgdGhhdCBpbmZvcm1hdGlvbi4gV2Ugd2FudCB0byBub3RlIHRoYXQgd2UgY291bGQgcG9zc2libHlcbiAqIGhhdmUgbmVzdGVkIGFycmF5cyBzbyB0aGlzIHNob3VsZCBvbmx5IGNoZWNrIHRoZSBmdXJ0aGVzdCBvbmUuIEl0IG1heSBhbHNvIGJlXG4gKiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgbm8gW10gcGllY2VzLCBpbiB3aGljaCBjYXNlIHdlIGp1c3QgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiB0eXBlLlxuICovXG5mdW5jdGlvbiBjdFBhcnNlVHlwZShzdHIpXG57XG5cdHZhciBiZWdJbmQsIGVuZEluZDtcblx0dmFyIHR5cGUsIGxlbjtcblx0aWYgKHR5cGVvZiAoc3RyKSAhPSAnc3RyaW5nJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCd0eXBlIG11c3QgYmUgYSBKYXZhc2NyaXB0IHN0cmluZycpKTtcblxuXHRlbmRJbmQgPSBzdHIubGFzdEluZGV4T2YoJ10nKTtcblx0aWYgKGVuZEluZCA9PSAtMSkge1xuXHRcdGlmIChzdHIubGFzdEluZGV4T2YoJ1snKSAhPSAtMSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2ZvdW5kIGludmFsaWQgdHlwZSB3aXRoIFxcJ1tcXCcgYnV0ICcgK1xuXHRcdFx0ICAgICdubyBjb3JyZXNwb25kaW5nIFxcJ11cXCcnKSk7XG5cblx0XHRyZXR1cm4gKHsgdHlwZTogc3RyIH0pO1xuXHR9XG5cblx0YmVnSW5kID0gc3RyLmxhc3RJbmRleE9mKCdbJyk7XG5cdGlmIChiZWdJbmQgPT0gLTEpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignZm91bmQgaW52YWxpZCB0eXBlIHdpdGggXFwnXVxcJyBidXQgJyArXG5cdFx0ICAgICdubyBjb3JyZXNwb25kaW5nIFxcJ1tcXCcnKSk7XG5cblx0aWYgKGJlZ0luZCA+PSBlbmRJbmQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWFsZm9ybWVkIHR5cGUsIFxcJ11cXCcgYXBwZWFycyBiZWZvcmUgXFwnW1xcJycpKTtcblxuXHR0eXBlID0gc3RyLnN1YnN0cmluZygwLCBiZWdJbmQpO1xuXHRsZW4gPSBzdHIuc3Vic3RyaW5nKGJlZ0luZCArIDEsIGVuZEluZCk7XG5cblx0cmV0dXJuICh7IHR5cGU6IHR5cGUsIGxlbjogbGVuIH0pO1xufVxuXG4vKlxuICogR2l2ZW4gYSByZXF1ZXN0IHZhbGlkYXRlIHRoYXQgYWxsIG9mIHRoZSBmaWVsZHMgZm9yIGl0IGFyZSB2YWxpZCBhbmQgbWFrZVxuICogc2Vuc2UuIFRoaXMgaW5jbHVkZXMgdmVyaWZ5aW5nIHRoZSBmb2xsb3dpbmcgbm90aW9uczpcbiAqICAtIEVhY2ggdHlwZSByZXF1ZXN0ZWQgaXMgcHJlc2VudCBpbiB0eXBlc1xuICogIC0gT25seSBhbGxvdyBhIG5hbWUgZm9yIGEgZmllbGQgdG8gYmUgc3BlY2lmaWVkIG9uY2VcbiAqICAtIElmIGFuIGFycmF5IGlzIHNwZWNpZmllZCwgdmFsaWRhdGUgdGhhdCB0aGUgcmVxdWVzdGVkIGZpZWxkIGV4aXN0cyBhbmRcbiAqICAgIGNvbWVzIGJlZm9yZSBpdC5cbiAqICAtIElmIGZpZWxkcyBpcyBkZWZpbmVkLCBjaGVjayB0aGF0IGVhY2ggZW50cnkgaGFzIHRoZSBvY2N1cnJlbmNlIG9mIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGN0Q2hlY2tSZXEoZGVmLCB0eXBlcywgZmllbGRzKVxue1xuXHR2YXIgaWksIGpqO1xuXHR2YXIgcmVxLCBrZXlzLCBrZXk7XG5cdHZhciBmb3VuZCA9IHt9O1xuXG5cdGlmICghKGRlZiBpbnN0YW5jZW9mIEFycmF5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdkZWZpbml0aW9uIGlzIG5vdCBhbiBhcnJheScpKTtcblxuXHRpZiAoZGVmLmxlbmd0aCA9PT0gMClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdkZWZpbml0aW9uIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCcpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBkZWYubGVuZ3RoOyBpaSsrKSB7XG5cdFx0cmVxID0gZGVmW2lpXTtcblx0XHRpZiAoIShyZXEgaW5zdGFuY2VvZiBPYmplY3QpKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignZGVmaW5pdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mJyArXG5cdFx0XHQgICAgJ29iamVjdHMnKSk7XG5cblx0XHRrZXlzID0gT2JqZWN0LmtleXMocmVxKTtcblx0XHRpZiAoa2V5cy5sZW5ndGggIT0gMSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2RlZmluaXRpb24gZW50cnkgbXVzdCBvbmx5IGhhdmUgJyArXG5cdFx0XHQgICAgJ29uZSBrZXknKSk7XG5cblx0XHRpZiAoa2V5c1swXSBpbiBmb3VuZClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1NwZWNpZmllZCBuYW1lIGFscmVhZHkgJyArXG5cdFx0XHQgICAgJ3NwZWNpZmllZDogJyArIGtleXNbMF0pKTtcblxuXHRcdGlmICghKCd0eXBlJyBpbiByZXFba2V5c1swXV0pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eXBlIGRlZmluaXRpb24nKSk7XG5cblx0XHRrZXkgPSBjdFBhcnNlVHlwZShyZXFba2V5c1swXV1bJ3R5cGUnXSk7XG5cblx0XHQvKlxuXHRcdCAqIFdlIG1heSBoYXZlIG5lc3RlZCBhcnJheXMsIHdlIG5lZWQgdG8gY2hlY2sgdGhlIHZhbGlkaXR5IG9mXG5cdFx0ICogdGhlIHR5cGVzIHVudGlsIHRoZSBsZW4gZmllbGQgaXMgdW5kZWZpbmVkIGluIGtleS4gSG93ZXZlcixcblx0XHQgKiBlYWNoIHRpbWUgbGVuIGlzIGRlZmluZWQgd2UgbmVlZCB0byB2ZXJpZnkgaXQgaXMgZWl0aGVyIGFuXG5cdFx0ICogaW50ZWdlciBvciBjb3JyZXNwb25kcyB0byBhbiBhbHJlYWR5IHNlZW4ga2V5LlxuXHRcdCAqL1xuXHRcdHdoaWxlIChrZXlbJ2xlbiddICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChpc05hTihwYXJzZUludChrZXlbJ2xlbiddLCAxMCkpKSB7XG5cdFx0XHRcdGlmICghKGtleVsnbGVuJ10gaW4gZm91bmQpKVxuXHRcdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0dpdmVuIGFuIGFycmF5ICcgK1xuXHRcdFx0XHRcdCAgICAnbGVuZ3RoIHdpdGhvdXQgYSBtYXRjaGluZyB0eXBlJykpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGtleSA9IGN0UGFyc2VUeXBlKGtleVsndHlwZSddKTtcblx0XHR9XG5cblx0XHQvKiBOb3cgd2UgY2FuIHZhbGlkYXRlIGlmIHRoZSB0eXBlIGlzIHZhbGlkICovXG5cdFx0aWYgKCEoa2V5Wyd0eXBlJ10gaW4gdHlwZXMpKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndHlwZSBub3QgZm91bmQgb3IgdHlwZGVmZWQ6ICcgK1xuXHRcdFx0ICAgIGtleVsndHlwZSddKSk7XG5cblx0XHQvKiBDaGVjayBmb3IgYW55IHJlcXVpcmVkIGZpZWxkcyAqL1xuXHRcdGlmIChmaWVsZHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yIChqaiA9IDA7IGpqIDwgZmllbGRzLmxlbmd0aDsgamorKykge1xuXHRcdFx0XHRpZiAoIShmaWVsZHNbampdIGluIHJlcVtrZXlzWzBdXSkpXG5cdFx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCAnICtcblx0XHRcdFx0XHQgICAgJ2ZpZWxkOiAnICsgZmllbGRzW2pqXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvdW5kW2tleXNbMF1dID0gdHJ1ZTtcblx0fVxufVxuXG5cbi8qXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHBhcnNlci4gRWFjaCBwYXJzZXIgaGFzIGl0cyBvd24gc3RvcmUgb2ZcbiAqIHR5cGVkZWZzIGFuZCBlbmRpYW5uZXNzLiBDb25mIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcmVxdWlyZWRcbiAqIHZhbHVlczpcbiAqXG4gKlx0ZW5kaWFuXHRcdEVpdGhlciAnYmlnJyBvciAnbGl0dGxlJyBkbyBkZXRlcm1pbmUgdGhlIGVuZGlhbm5lc3Mgd2VcbiAqXHRcdFx0d2FudCB0byByZWFkIGZyb20gb3Igd3JpdGUgdG8uXG4gKlxuICogQW5kIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgdmFsdWVzOlxuICpcbiAqIFx0Y2hhci10eXBlXHRWYWxpZCBvcHRpb25zIGhlcmUgYXJlIHVpbnQ4IGFuZCBpbnQ4LiBJZiB1aW50OCBpc1xuICogXHRcdFx0c3BlY2lmaWVkIHRoaXMgY2hhbmdlcyB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBhIHNpbmdsZVxuICogXHRcdFx0Y2hhciBmcm9tIGJlaW5nIGEgYnVmZmVyIG9mIGEgc2luZ2xlIGNoYXJhY3RlciB0byBiZWluZ1xuICogXHRcdFx0YSB1aW50OF90LiBJZiBpbnQ4LCBpdCBiZWNvbWVzIGFuIGludDhfdCBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBDVHlwZVBhcnNlcihjb25mKVxue1xuXHRpZiAoIWNvbmYpIHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQnKSk7XG5cblx0aWYgKCEoJ2VuZGlhbicgaW4gY29uZikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBlbmRpYW4gdmFsdWUnKSk7XG5cblx0aWYgKGNvbmZbJ2VuZGlhbiddICE9ICdiaWcnICYmIGNvbmZbJ2VuZGlhbiddICE9ICdsaXR0bGUnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgZW5kaWFuIHR5cGUnKSk7XG5cblx0aWYgKCdjaGFyLXR5cGUnIGluIGNvbmYgJiYgKGNvbmZbJ2NoYXItdHlwZSddICE9ICd1aW50OCcgJiZcblx0ICAgIGNvbmZbJ2NoYXItdHlwZSddICE9ICdpbnQ4JykpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignaW52YWxpZCBvcHRpb24gZm9yIGNoYXItdHlwZTogJyArXG5cdFx0ICAgIGNvbmZbJ2NoYXItdHlwZSddKSk7XG5cblx0dGhpcy5lbmRpYW4gPSBjb25mWydlbmRpYW4nXTtcblx0dGhpcy50eXBlcyA9IGN0R2V0QmFzaWNUeXBlcygpO1xuXG5cdC8qXG5cdCAqIFRoZXJlIG1heSBiZSBhIG1vcmUgZ3JhY2VmdWwgd2F5IHRvIGRvIHRoaXMsIGJ1dCB0aGlzIHdpbGwgaGF2ZSB0b1xuXHQgKiBzZXJ2ZS5cblx0ICovXG5cdGlmICgnY2hhci10eXBlJyBpbiBjb25mICYmIGNvbmZbJ2NoYXItdHlwZSddID09ICd1aW50OCcpXG5cdFx0dGhpcy50eXBlc1snY2hhciddID0gdGhpcy50eXBlc1sndWludDhfdCddO1xuXG5cdGlmICgnY2hhci10eXBlJyBpbiBjb25mICYmIGNvbmZbJ2NoYXItdHlwZSddID09ICdpbnQ4Jylcblx0XHR0aGlzLnR5cGVzWydjaGFyJ10gPSB0aGlzLnR5cGVzWydpbnQ4X3QnXTtcbn1cblxuLypcbiAqIFNldHMgdGhlIGN1cnJlbnQgZW5kaWFuIHZhbHVlIGZvciB0aGUgUGFyc2VyLiBJZiB0aGUgdmFsdWUgaXMgbm90IHZhbGlkLFxuICogdGhyb3dzIGFuIEVycm9yLlxuICpcbiAqXHRlbmRpYW5cdFx0RWl0aGVyICdiaWcnIG9yICdsaXR0bGUnIGRvIGRldGVybWluZSB0aGUgZW5kaWFubmVzcyB3ZVxuICpcdFx0XHR3YW50IHRvIHJlYWQgZnJvbSBvciB3cml0ZSB0by5cbiAqXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5zZXRFbmRpYW4gPSBmdW5jdGlvbiAoZW5kaWFuKVxue1xuXHRpZiAoZW5kaWFuICE9ICdiaWcnICYmIGVuZGlhbiAhPSAnbGl0dGxlJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIGVuZGlhbiB0eXBlLCBtdXN0IGJlIGJpZyBvciAnICtcblx0XHQgICAgJ2xpdHRsZScpKTtcblxuXHR0aGlzLmVuZGlhbiA9IGVuZGlhbjtcbn07XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBlbmRpYW4gdmFsdWUgZm9yIHRoZSBwYXJzZXIuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5nZXRFbmRpYW4gPSBmdW5jdGlvbiAoKVxue1xuXHRyZXR1cm4gKHRoaXMuZW5kaWFuKTtcbn07XG5cbi8qXG4gKiBBIHVzZXIgaGFzIHJlcXVlc3RlZCB0byBhZGQgYSB0eXBlLCBsZXQgdXMgaG9ub3IgdGhlaXIgcmVxdWVzdC4gWWV0LCBpZiB0aGVpclxuICogcmVxdWVzdCBkb3RoIHNwdXJuIHVzLCBzZW5kIHRoZW0gdW50byB0aGUgSGVsbHMgd2hpY2ggRGFudGUgZGVzY3JpYmVzLlxuICpcbiAqIFx0bmFtZVx0XHRUaGUgc3RyaW5nIGZvciB0aGUgdHlwZSBkZWZpbml0aW9uIHdlJ3JlIGFkZGluZ1xuICpcbiAqXHR2YWx1ZVx0XHRFaXRoZXIgYSBzdHJpbmcgdGhhdCBpcyBhIHR5cGUvYXJyYXkgbmFtZSBvciBhbiBvYmplY3RcbiAqXHRcdFx0dGhhdCBkZXNjcmliZXMgYSBzdHJ1Y3QuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS50eXBlZGVmID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKVxue1xuXHR2YXIgdHlwZTtcblxuXHRpZiAobmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR5cGVkZWYgYXJndW1lbnQ6IG5hbWUnKSkpO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR5cGVkZWYgYXJndW1lbnQ6IHZhbHVlJykpKTtcblxuXHRpZiAodHlwZW9mIChuYW1lKSAhPSAnc3RyaW5nJylcblx0XHR0aHJvdyAobmV3IChFcnJvcigndGhlIG5hbWUgb2YgYSB0eXBlIG11c3QgYmUgYSBzdHJpbmcnKSkpO1xuXG5cdHR5cGUgPSBjdFBhcnNlVHlwZShuYW1lKTtcblxuXHRpZiAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBhbiBhcnJheSBpbiB0aGUgdHlwZWRlZiBuYW1lJykpO1xuXG5cdGlmIChuYW1lIGluIHRoaXMudHlwZXMpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndHlwZWRlZiBuYW1lIGFscmVhZHkgcHJlc2VudDogJyArIG5hbWUpKTtcblxuXHRpZiAodHlwZW9mICh2YWx1ZSkgIT0gJ3N0cmluZycgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd0eXBlZGVmIHZhbHVlIG11c3QgZWl0aGVyIGJlIGEgc3RyaW5nIG9yICcgK1xuXHRcdCAgICAnc3RydWN0JykpO1xuXG5cdGlmICh0eXBlb2YgKHZhbHVlKSA9PSAnc3RyaW5nJykge1xuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZSh2YWx1ZSk7XG5cdFx0aWYgKHR5cGVbJ2xlbiddICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmIChpc05hTihwYXJzZUludCh0eXBlWydsZW4nXSwgMTApKSlcblx0XHRcdFx0dGhyb3cgKG5ldyAoRXJyb3IoJ3R5cGVkZWYgdmFsdWUgbXVzdCB1c2UgJyArXG5cdFx0XHRcdCAgICAnZml4ZWQgc2l6ZSBhcnJheSB3aGVuIG91dHNpZGUgb2YgYSAnICtcblx0XHRcdFx0ICAgICdzdHJ1Y3QnKSkpO1xuXHRcdH1cblxuXHRcdHRoaXMudHlwZXNbbmFtZV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHQvKiBXZSBoYXZlIGEgc3RydWN0LCB2YWxpZGF0ZSBpdCAqL1xuXHRcdGN0Q2hlY2tSZXEodmFsdWUsIHRoaXMudHlwZXMpO1xuXHRcdHRoaXMudHlwZXNbbmFtZV0gPSB2YWx1ZTtcblx0fVxufTtcblxuLypcbiAqIEluY2x1ZGUgYWxsIG9mIHRoZSB0eXBlZGVmcywgYnV0IG5vbmUgb2YgdGhlIGJ1aWx0IGluIHR5cGVzLiBUaGlzIHNob3VsZCBiZVxuICogdHJlYXRlZCBhcyByZWFkLW9ubHkuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5sc3R5cGVzID0gZnVuY3Rpb24gKClcbntcblx0dmFyIGtleTtcblx0dmFyIHJldCA9IHt9O1xuXG5cdGZvciAoa2V5IGluIHRoaXMudHlwZXMpIHtcblx0XHRpZiAoa2V5IGluIGRlZnR5cGVzKVxuXHRcdFx0Y29udGludWU7XG5cdFx0cmV0W2tleV0gPSB0aGlzLnR5cGVzW2tleV07XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59O1xuXG4vKlxuICogR2l2ZW4gYSB0eXBlIHN0cmluZyB0aGF0IG1heSBoYXZlIGFycmF5IHR5cGVzIHRoYXQgYXJlbid0IG51bWJlcnMsIHRyeSBhbmRcbiAqIGZpbGwgdGhlbSBpbiBmcm9tIHRoZSB2YWx1ZXMgb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IHdoZXJlXG4gKiBpbmRleGluZyBpbnRvIGl0IHNob3VsZCByZXR1cm4gYSBudW1iZXIgZm9yIHRoYXQgdHlwZS5cbiAqXG4gKlx0c3RyXHRcdFRoZSB0eXBlIHN0cmluZ1xuICpcbiAqXHR2YWx1ZXNcdFx0QW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZnVsZmlsbCB0eXBlIGluZm9ybWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGN0UmVzb2x2ZUFycmF5KHN0ciwgdmFsdWVzKVxue1xuXHR2YXIgcmV0ID0gJyc7XG5cdHZhciB0eXBlID0gY3RQYXJzZVR5cGUoc3RyKTtcblxuXHR3aGlsZSAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChpc05hTihwYXJzZUludCh0eXBlWydsZW4nXSwgMTApKSkge1xuXHRcdFx0aWYgKHR5cGVvZiAodmFsdWVzW3R5cGVbJ2xlbiddXSkgIT0gJ251bWJlcicpXG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2Nhbm5vdCBzYXdwIGluIG5vbi1udW1iZXIgJyArXG5cdFx0XHRcdCAgICAnZm9yIGFycmF5IHZhbHVlJykpO1xuXHRcdFx0cmV0ID0gJ1snICsgdmFsdWVzW3R5cGVbJ2xlbiddXSArICddJyArIHJldDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0gJ1snICsgdHlwZVsnbGVuJ10gKyAnXScgKyByZXQ7XG5cdFx0fVxuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZSh0eXBlWyd0eXBlJ10pO1xuXHR9XG5cblx0cmV0ID0gdHlwZVsndHlwZSddICsgcmV0O1xuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIFtwcml2YXRlXSBFaXRoZXIgdGhlIHR5cGVkZWYgcmVzb2x2ZXMgdG8gYW5vdGhlciB0eXBlIHN0cmluZyBvciB0byBhIHN0cnVjdC5cbiAqIElmIGl0IHJlc29sdmVzIHRvIGEgc3RydWN0LCB3ZSBqdXN0IHBhc3MgaXQgb2ZmIHRvIHJlYWQgc3RydWN0LiBJZiBub3QsIHdlXG4gKiBjYW4ganVzdCBwYXNzIGl0IG9mZiB0byByZWFkIGVudHJ5LlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVzb2x2ZVR5cGVkZWYgPSBmdW5jdGlvbiAodHlwZSwgZGlzcGF0Y2gsIGJ1ZmZlcixcbiAgICBvZmZzZXQsIHZhbHVlKVxue1xuXHR2YXIgcHQ7XG5cblx0bW9kX2Fzc2VydC5vayh0eXBlIGluIHRoaXMudHlwZXMpO1xuXHRpZiAodHlwZW9mICh0aGlzLnR5cGVzW3R5cGVdKSA9PSAnc3RyaW5nJykge1xuXHRcdHB0ID0gY3RQYXJzZVR5cGUodGhpcy50eXBlc1t0eXBlXSk7XG5cdFx0aWYgKGRpc3BhdGNoID09ICdyZWFkJylcblx0XHRcdHJldHVybiAodGhpcy5yZWFkRW50cnkocHQsIGJ1ZmZlciwgb2Zmc2V0KSk7XG5cdFx0ZWxzZSBpZiAoZGlzcGF0Y2ggPT0gJ3dyaXRlJylcblx0XHRcdHJldHVybiAodGhpcy53cml0ZUVudHJ5KHZhbHVlLCBwdCwgYnVmZmVyLCBvZmZzZXQpKTtcblx0XHRlbHNlXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIGRpc3BhdGNoIHR5cGUgdG8gJyArXG5cdFx0XHQgICAgJ3Jlc29sdmVUeXBlZGVmJykpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChkaXNwYXRjaCA9PSAncmVhZCcpXG5cdFx0XHRyZXR1cm4gKHRoaXMucmVhZFN0cnVjdCh0aGlzLnR5cGVzW3R5cGVdLCBidWZmZXIsXG5cdFx0XHQgICAgb2Zmc2V0KSk7XG5cdFx0ZWxzZSBpZiAoZGlzcGF0Y2ggPT0gJ3dyaXRlJylcblx0XHRcdHJldHVybiAodGhpcy53cml0ZVN0cnVjdCh2YWx1ZSwgdGhpcy50eXBlc1t0eXBlXSxcblx0XHRcdCAgICBidWZmZXIsIG9mZnNldCkpO1xuXHRcdGVsc2Vcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2ludmFsaWQgZGlzcGF0Y2ggdHlwZSB0byAnICtcblx0XHRcdCAgICAncmVzb2x2ZVR5cGVkZWYnKSk7XG5cdH1cblxufTtcblxuLypcbiAqIFtwcml2YXRlXSBUcnkgYW5kIHJlYWQgaW4gdGhlIHNwZWNpZmljIGVudHJ5LlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZEVudHJ5ID0gZnVuY3Rpb24gKHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgcGFyc2UsIGxlbjtcblxuXHQvKlxuXHQgKiBCZWNhdXNlIHdlIHdhbnQgdG8gc3BlY2lhbCBjYXNlIGNoYXJbXXMgdGhpcyBpcyB1bmZvcnR1bmF0ZWx5XG5cdCAqIGEgYml0IHVnbGllciB0aGFuIGl0IHJlYWxseSBzaG91bGQgYmUuIFdlIHdhbnQgdG8gc3BlY2lhbFxuXHQgKiBjYXNlIGNoYXJbXXMgc28gdGhhdCB3ZSByZXR1cm4gYSBub2RlIGJ1ZmZlciwgdGh1cyB0aGV5IGFyZSBhXG5cdCAqIGZpcnN0IGNsYXNzIHR5cGUgd2hlcmUgYXMgYWxsIG90aGVyIGFycmF5cyBqdXN0IGNhbGwgaW50byBhXG5cdCAqIGdlbmVyaWMgYXJyYXkgcm91dGluZSB3aGljaCBjYWxscyB0aGVpciBkYXRhLXNwZWNpZmljIHJvdXRpbmVcblx0ICogdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG5cdCAqXG5cdCAqIFRoZSB2YWxpZCBkaXNwYXRjaCBvcHRpb25zIHdlIGhhdmUgYXJlOlxuXHQgKiAgLSBBcnJheSBhbmQgY2hhciA9PiBjaGFyW10gaGFuZGxlclxuXHQgKiAgLSBHZW5lcmljIGFycmF5IGhhbmRsZXJcblx0ICogIC0gR2VuZXJpYyB0eXBlZGVmIGhhbmRsZXJcblx0ICogIC0gQmFzaWMgdHlwZSBoYW5kbGVyXG5cdCAqL1xuXHRpZiAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdGxlbiA9IHBhcnNlSW50KHR5cGVbJ2xlbiddLCAxMCk7XG5cdFx0aWYgKGlzTmFOKGxlbikpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdzb21laG93IGdvdCBhIG5vbi1udW1lcmljIGxlbmd0aCcpKTtcblxuXHRcdGlmICh0eXBlWyd0eXBlJ10gPT0gJ2NoYXInKVxuXHRcdFx0cGFyc2UgPSB0aGlzLnR5cGVzWydjaGFyW10nXVsncmVhZCddKGxlbixcblx0XHRcdCAgICB0aGlzLmVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdGVsc2Vcblx0XHRcdHBhcnNlID0gdGhpcy5yZWFkQXJyYXkodHlwZVsndHlwZSddLFxuXHRcdFx0ICAgIGxlbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0eXBlWyd0eXBlJ10gaW4gZGVmdHlwZXMpXG5cdFx0XHRwYXJzZSA9IHRoaXMudHlwZXNbdHlwZVsndHlwZSddXVsncmVhZCddKHRoaXMuZW5kaWFuLFxuXHRcdFx0ICAgIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRlbHNlXG5cdFx0XHRwYXJzZSA9IHRoaXMucmVzb2x2ZVR5cGVkZWYodHlwZVsndHlwZSddLCAncmVhZCcsXG5cdFx0XHQgICAgYnVmZmVyLCBvZmZzZXQpO1xuXHR9XG5cblx0cmV0dXJuIChwYXJzZSk7XG59O1xuXG4vKlxuICogW3ByaXZhdGVdIFJlYWQgYW4gYXJyYXkgb2YgZGF0YVxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZEFycmF5ID0gZnVuY3Rpb24gKHR5cGUsIGxlbmd0aCwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBpaSwgZW50LCBwdDtcblx0dmFyIGJhc2VPZmZzZXQgPSBvZmZzZXQ7XG5cdHZhciByZXQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0cHQgPSBjdFBhcnNlVHlwZSh0eXBlKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcblx0XHRlbnQgPSB0aGlzLnJlYWRFbnRyeShwdCwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBlbnRbJ3NpemUnXTtcblx0XHRyZXRbaWldID0gZW50Wyd2YWx1ZSddO1xuXHR9XG5cblx0cmV0dXJuICh7IHZhbHVlOiByZXQsIHNpemU6IG9mZnNldCAtIGJhc2VPZmZzZXQgfSk7XG59O1xuXG4vKlxuICogW3ByaXZhdGVdIFJlYWQgYSBzaW5nbGUgc3RydWN0IGluLlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZFN0cnVjdCA9IGZ1bmN0aW9uIChkZWYsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgcGFyc2UsIGlpLCB0eXBlLCBlbnRyeSwga2V5O1xuXHR2YXIgYmFzZU9mZnNldCA9IG9mZnNldDtcblx0dmFyIHJldCA9IHt9O1xuXG5cdC8qIFdhbGsgaXQgYW5kIGhhbmRsZSBkb2luZyB3aGF0J3MgbmVjZXNzYXJ5ICovXG5cdGZvciAoaWkgPSAwOyBpaSA8IGRlZi5sZW5ndGg7IGlpKyspIHtcblx0XHRrZXkgPSBPYmplY3Qua2V5cyhkZWZbaWldKVswXTtcblx0XHRlbnRyeSA9IGRlZltpaV1ba2V5XTtcblxuXHRcdC8qIFJlc29sdmUgYWxsIGFycmF5IHZhbHVlcyAqL1xuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZShjdFJlc29sdmVBcnJheShlbnRyeVsndHlwZSddLCByZXQpKTtcblxuXHRcdGlmICgnb2Zmc2V0JyBpbiBlbnRyeSlcblx0XHRcdG9mZnNldCA9IGJhc2VPZmZzZXQgKyBlbnRyeVsnb2Zmc2V0J107XG5cblx0XHRwYXJzZSA9IHRoaXMucmVhZEVudHJ5KHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KTtcblxuXHRcdG9mZnNldCArPSBwYXJzZVsnc2l6ZSddO1xuXHRcdHJldFtrZXldID0gcGFyc2VbJ3ZhbHVlJ107XG5cdH1cblxuXHRyZXR1cm4gKHsgdmFsdWU6IHJldCwgc2l6ZTogKG9mZnNldC1iYXNlT2Zmc2V0KX0pO1xufTtcblxuLypcbiAqIFRoaXMgaXMgd2hhdCB3ZSB3ZXJlIGJvcm4gdG8gZG8uIFdlIHJlYWQgdGhlIGRhdGEgZnJvbSBhIGJ1ZmZlciBhbmQgcmV0dXJuIGl0XG4gKiBpbiBhbiBvYmplY3Qgd2hvc2Uga2V5cyBtYXRjaCB0aGUgdmFsdWVzIGZyb20gdGhlIG9iamVjdC5cbiAqXG4gKlx0ZGVmXHRcdFRoZSBhcnJheSBkZWZpbml0aW9uIG9mIHRoZSBkYXRhIHRvIHJlYWQgaW5cbiAqXG4gKlx0YnVmZmVyXHRcdFRoZSBidWZmZXIgdG8gcmVhZCBkYXRhIGZyb21cbiAqXG4gKlx0b2Zmc2V0XHRcdFRoZSBvZmZzZXQgdG8gc3RhcnQgd3JpdGluZyB0b1xuICpcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdoZXJlIGVhY2gga2V5IGNvcnJlc3BvbmRzIHRvIGFuIGVudHJ5IGluIGRlZiBhbmQgdGhlIHZhbHVlXG4gKiBpcyB0aGUgcmVhZCB2YWx1ZS5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24gKGRlZiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdC8qIFNhbml0eSBjaGVjayBmb3IgYXJndW1lbnRzICovXG5cdGlmIChkZWYgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGRlZmluaXRpb24gZm9yIHdoYXQgd2Ugc2hvdWxkIGJlJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlciBmb3Igd2hhdCB3ZSBzaG91bGQgYmUgJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCBmb3Igd2hhdCB3ZSBzaG91bGQgYmUgJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdC8qIFNhbml0eSBjaGVjayB0aGUgb2JqZWN0IGRlZmluaXRpb24gKi9cblx0Y3RDaGVja1JlcShkZWYsIHRoaXMudHlwZXMpO1xuXG5cdHJldHVybiAodGhpcy5yZWFkU3RydWN0KGRlZiwgYnVmZmVyLCBvZmZzZXQpWyd2YWx1ZSddKTtcbn07XG5cbi8qXG4gKiBbcHJpdmF0ZV0gV3JpdGUgb3V0IGFuIGFycmF5IG9mIGRhdGFcbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlQXJyYXkgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUsIGxlbmd0aCwgYnVmZmVyLFxuICAgIG9mZnNldClcbntcblx0dmFyIGlpLCBwdDtcblx0dmFyIGJhc2VPZmZzZXQgPSBvZmZzZXQ7XG5cdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ2Fza2VkIHRvIHdyaXRlIGFuIGFycmF5LCBidXQgdmFsdWUgaXMgbm90ICcgK1xuXHRcdCAgICAnYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbHVlLmxlbmd0aCAhPSBsZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignYXNrZWQgdG8gd3JpdGUgYXJyYXkgb2YgbGVuZ3RoICcgKyBsZW5ndGggK1xuXHRcdCAgICAnIGJ1dCB0aGF0IGRvZXMgbm90IG1hdGNoIHZhbHVlIGxlbmd0aDogJyArIHZhbHVlLmxlbmd0aCkpO1xuXG5cdHB0ID0gY3RQYXJzZVR5cGUodHlwZSk7XG5cdGZvciAoaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKylcblx0XHRvZmZzZXQgKz0gdGhpcy53cml0ZUVudHJ5KHZhbHVlW2lpXSwgcHQsIGJ1ZmZlciwgb2Zmc2V0KTtcblxuXHRyZXR1cm4gKG9mZnNldCAtIGJhc2VPZmZzZXQpO1xufTtcblxuLypcbiAqIFtwcml2YXRlXSBXcml0ZSB0aGUgc3BlY2lmaWMgZW50cnlcbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlRW50cnkgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgbGVuLCByZXQ7XG5cblx0aWYgKHR5cGVbJ2xlbiddICE9PSB1bmRlZmluZWQpIHtcblx0XHRsZW4gPSBwYXJzZUludCh0eXBlWydsZW4nXSwgMTApO1xuXHRcdGlmIChpc05hTihsZW4pKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignc29tZWhvdyBnb3QgYSBub24tbnVtZXJpYyBsZW5ndGgnKSk7XG5cblx0XHRpZiAodHlwZVsndHlwZSddID09ICdjaGFyJylcblx0XHRcdHJldCA9IHRoaXMudHlwZXNbJ2NoYXJbXSddWyd3cml0ZSddKHZhbHVlLCBsZW4sXG5cdFx0XHQgICAgdGhpcy5lbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSB0aGlzLndyaXRlQXJyYXkodmFsdWUsIHR5cGVbJ3R5cGUnXSxcblx0XHRcdCAgICBsZW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0fSBlbHNlIHtcblx0XHRpZiAodHlwZVsndHlwZSddIGluIGRlZnR5cGVzKVxuXHRcdFx0cmV0ID0gdGhpcy50eXBlc1t0eXBlWyd0eXBlJ11dWyd3cml0ZSddKHZhbHVlLFxuXHRcdFx0ICAgIHRoaXMuZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0ID0gdGhpcy5yZXNvbHZlVHlwZWRlZih0eXBlWyd0eXBlJ10sICd3cml0ZScsXG5cdFx0XHQgICAgYnVmZmVyLCBvZmZzZXQsIHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn07XG5cbi8qXG4gKiBbcHJpdmF0ZV0gV3JpdGUgYSBzaW5nbGUgc3RydWN0IG91dC5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlU3RydWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWYsIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgaWksIGVudHJ5LCB0eXBlLCBrZXk7XG5cdHZhciBiYXNlT2Zmc2V0ID0gb2Zmc2V0O1xuXHR2YXIgdmFscyA9IHt9O1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGRlZi5sZW5ndGg7IGlpKyspIHtcblx0XHRrZXkgPSBPYmplY3Qua2V5cyhkZWZbaWldKVswXTtcblx0XHRlbnRyeSA9IGRlZltpaV1ba2V5XTtcblxuXHRcdHR5cGUgPSBjdFBhcnNlVHlwZShjdFJlc29sdmVBcnJheShlbnRyeVsndHlwZSddLCB2YWxzKSk7XG5cblx0XHRpZiAoJ29mZnNldCcgaW4gZW50cnkpXG5cdFx0XHRvZmZzZXQgPSBiYXNlT2Zmc2V0ICsgZW50cnlbJ29mZnNldCddO1xuXG5cdFx0b2Zmc2V0ICs9IHRoaXMud3JpdGVFbnRyeSh2YWx1ZVtpaV0sIHR5cGUsIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHQvKiBOb3cgdGhhdCB3ZSd2ZSB3cml0dGVuIGl0IG91dCwgd2UgY2FuIHVzZSBpdCBmb3IgYXJyYXlzICovXG5cdFx0dmFsc1trZXldID0gdmFsdWVbaWldO1xuXHR9XG5cblx0cmV0dXJuIChvZmZzZXQpO1xufTtcblxuLypcbiAqIFVuZm9ydHVuYXRlbHksIHdlJ3JlIHN0dWNrIHdpdGggdGhlIHNpbnMgb2YgYW4gaW5pdGlhbCBwb29yIGRlc2lnbi4gQmVjYXVzZVxuICogb2YgdGhhdCwgd2UgYXJlIGdvaW5nIHRvIGhhdmUgdG8gc3VwcG9ydCB0aGUgb2xkIHdheSBvZiB3cml0aW5nIGRhdGEgdmlhXG4gKiB3cml0ZURhdGEuIFRoZXJlIHdlIGluc2VydCB0aGUgdmFsdWVzIHRoYXQgeW91IHdhbnQgdG8gd3JpdGUgaW50byB0aGVcbiAqIGRlZmluaXRpb24uIEEgbGl0dGxlIGJhcm9xdWUuIEludGVybmFsbHksIHdlIHVzZSB0aGUgbmV3IG1vZGVsLiBTbyB3ZSBuZWVkIHRvXG4gKiBqdXN0IGdldCB0aG9zZSB2YWx1ZXMgb3V0IG9mIHRoZXJlLiBCdXQgdG8gbWFpbnRhaW4gdGhlIHByaW5jaXBsZSBvZiBsZWFzdFxuICogc3VycHJpc2UsIHdlJ3JlIG5vdCBnb2luZyB0byBtb2RpZnkgdGhlIGlucHV0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlcyhkZWYpXG57XG5cdHZhciBpaSwgb3V0LCBrZXk7XG5cdG91dCA9IFtdO1xuXHRmb3IgKGlpID0gMDsgaWkgPCBkZWYubGVuZ3RoOyBpaSsrKSB7XG5cdFx0a2V5ID0gT2JqZWN0LmtleXMoZGVmW2lpXSlbMF07XG5cdFx0bW9kX2Fzc2VydC5vaygndmFsdWUnIGluIGRlZltpaV1ba2V5XSk7XG5cdFx0b3V0LnB1c2goZGVmW2lpXVtrZXldWyd2YWx1ZSddKTtcblx0fVxuXG5cdHJldHVybiAob3V0KTtcbn1cblxuLypcbiAqIFRoaXMgaXMgdGhlIHNlY29uZCBoYWxmIG9mIHdoYXQgd2Ugd2VyZSBib3JuIHRvIGRvLCB3cml0ZSBvdXQgdGhlIGRhdGFcbiAqIGl0c2VsZi4gSGlzdG9yaWNhbGx5IHRoaXMgZnVuY3Rpb24gcmVxdWlyZWQgeW91IHRvIHB1dCB5b3VyIHZhbHVlcyBpbiB0aGVcbiAqIGRlZmluaXRpb24gc2VjdGlvbi4gVGhpcyB3YXMgbm90IHRoZSBzbWFydGVzdCB0aGluZyB0byBkbyBhbmQgYSBiaXQgb2YgYW5cbiAqIG92ZXJzaWdodCB0byBiZSBob25lc3QuIEFzIHN1Y2gsIHRoaXMgZnVuY3Rpb24gbm93IHRha2VzIGEgdmFsdWVzIGFyZ3VtZW50LlxuICogSWYgdmFsdWVzIGlzIG5vbi1udWxsIGFuZCBub24tdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICogdmFsdWVzLiBUaGlzIG1lYW5zIHRoYXQgdGhlIG9sZCBtZXRob2QgaXMgc3RpbGwgc3VwcG9ydGVkLCBidXQgaXMgbm8gbG9uZ2VyXG4gKiBhY2NlcHRhYmxlLlxuICpcbiAqXHRkZWZcdFx0VGhlIGFycmF5IGRlZmluaXRpb24gb2YgdGhlIGRhdGEgdG8gd3JpdGUgb3V0IHdpdGhcbiAqXHRcdFx0dmFsdWVzXG4gKlxuICpcdGJ1ZmZlclx0XHRUaGUgYnVmZmVyIHRvIHdyaXRlIHRvXG4gKlxuICpcdG9mZnNldFx0XHRUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgdG8gd3JpdGUgdG9cbiAqXG4gKlx0dmFsdWVzXHRcdEFuIGFycmF5IG9mIHZhbHVlcyB0byB3cml0ZS5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLndyaXRlRGF0YSA9IGZ1bmN0aW9uIChkZWYsIGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZXMpXG57XG5cdHZhciBodjtcblxuXHRpZiAoZGVmID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBkZWZpbml0aW9uIGZvciB3aGF0IHdlIHNob3VsZCBiZScgK1xuXHRcdCAgICAncGFyc2luZycpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXIgZm9yIHdoYXQgd2Ugc2hvdWxkIGJlICcgK1xuXHRcdCAgICAncGFyc2luZycpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQgZm9yIHdoYXQgd2Ugc2hvdWxkIGJlICcgK1xuXHRcdCAgICAncGFyc2luZycpKTtcblxuXHRodiA9ICh2YWx1ZXMgIT0gbnVsbCAmJiB2YWx1ZXMgIT0gdW5kZWZpbmVkKTtcblx0aWYgKGh2KSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlcyBmb3Igd3JpdGluZycpKTtcblx0XHRjdENoZWNrUmVxKGRlZiwgdGhpcy50eXBlcyk7XG5cdH0gZWxzZSB7XG5cdFx0Y3RDaGVja1JlcShkZWYsIHRoaXMudHlwZXMsIFsgJ3ZhbHVlJyBdKTtcblx0fVxuXG5cdHRoaXMud3JpdGVTdHJ1Y3QoaHYgPyB2YWx1ZXMgOiBnZXRWYWx1ZXMoZGVmKSwgZGVmLCBidWZmZXIsIG9mZnNldCk7XG59O1xuXG4vKlxuICogRnVuY3Rpb25zIHRvIGdvIHRvIGFuZCBmcm9tIDY0IGJpdCBudW1iZXJzIGluIGEgd2F5IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoXG4gKiBKYXZhc2NyaXB0IGxpbWl0YXRpb25zLiBUaGVyZSBhcmUgdHdvIHNldHMuIE9uZSB3aGVyZSB0aGUgdXNlciBpcyBva2F5IHdpdGhcbiAqIGFuIGFwcHJveGltYXRpb24gYW5kIG9uZSB3aGVyZSB0aGV5IGFyZSBkZWZpbml0ZWx5IG5vdCBva2F5IHdpdGggYW5cbiAqIGFwcHJveGltYXRpb24uXG4gKi9cblxuLypcbiAqIEF0dGVtcHRzIHRvIGNvbnZlcnQgYW4gYXJyYXkgb2YgdHdvIGludGVnZXJzIHJldHVybmVkIGZyb20gcnNpbnQ2NCAvIHJ1aW50NjRcbiAqIGludG8gYW4gYWJzb2x1dGUgNjQgYml0IG51bWJlci4gSWYgaG93ZXZlciB0aGUgdmFsdWUgd291bGQgZXhjZWVkIDJeNTIgdGhpc1xuICogd2lsbCBpbnN0ZWFkIHRocm93IGFuIGVycm9yLiBUaGUgbWFudGlzc2EgaW4gYSBkb3VibGUgaXMgYSA1MiBiaXQgbnVtYmVyIGFuZFxuICogcmF0aGVyIHRoYW4gcG90ZW50aWFsbHkgZ2l2ZSB5b3UgYSB2YWx1ZSB0aGF0IGlzIGFuIGFwcHJveGltYXRpb24gdGhpcyB3aWxsXG4gKiBlcnJvci4gSWYgeW91IHdvdWxkIHJhdGhlciBhbiBhcHByb3hpbWF0aW9uLCBwbGVhc2Ugc2VlIHRvQXBwcm94NjQuXG4gKlxuICpcdHZhbFx0XHRBbiBhcnJheSBvZiB0d28gMzItYml0IGludGVnZXJzXG4gKi9cbmZ1bmN0aW9uIHRvQWJzNjQodmFsKVxue1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBhcmc6IHZhbHVlJykpO1xuXG5cdGlmICghQXJyYXkuaXNBcnJheSh2YWwpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbC5sZW5ndGggIT0gMilcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJykpO1xuXG5cdC8qIFdlIGhhdmUgMjAgYml0cyB3b3J0aCBvZiBwcmVjaXNpb24gaW4gdGhpcyByYW5nZSAqL1xuXHRpZiAodmFsWzBdID49IDB4MTAwMDAwKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIHdvdWxkIGJlY29tZSBhcHByb3hpbWF0ZWQnKSk7XG5cblx0cmV0dXJuICh2YWxbMF0gKiBNYXRoLnBvdygyLCAzMikgKyB2YWxbMV0pO1xufVxuXG4vKlxuICogV2lsbCByZXR1cm4gdGhlIDY0IGJpdCB2YWx1ZSBhcyByZXR1cm5lZCBpbiBhbiBhcnJheSBmcm9tIHJzaW50NjQgLyBydWludDY0XG4gKiB0byBhIHZhbHVlIGFzIGNsb3NlIGFzIGl0IGNhbi4gTm90ZSB0aGF0IEphdmFzY3JpcHQgc3RvcmVzIGFsbCBudW1iZXJzIGFzIGFcbiAqIGRvdWJsZSBhbmQgdGhlIG1hbnRpc3NhIG9ubHkgaGFzIDUyIGJpdHMuIFRodXMgdGhpcyB2ZXJzaW9uIG1heSBhcHByb3hpbWF0ZVxuICogdGhlIHZhbHVlLlxuICpcbiAqXHR2YWxcdFx0QW4gYXJyYXkgb2YgdHdvIDMyLWJpdCBpbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiB0b0FwcHJveDY0KHZhbClcbntcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgYXJnOiB2YWx1ZScpKTtcblxuXHRpZiAoIUFycmF5LmlzQXJyYXkodmFsKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5JykpO1xuXG5cdGlmICh2YWwubGVuZ3RoICE9IDIpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggMicpKTtcblxuXHRyZXR1cm4gKE1hdGgucG93KDIsIDMyKSAqIHZhbFswXSArIHZhbFsxXSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ1RGKGpzb24sIGNvbmYpXG57XG5cdHZhciBjdHlwZSA9IG5ldyBDVHlwZVBhcnNlcihjb25mKTtcblx0bW9kX2N0Zi5jdGZQYXJzZUpzb24oanNvbiwgY3R5cGUpO1xuXG5cdHJldHVybiAoY3R5cGUpO1xufVxuXG4vKlxuICogRXhwb3J0IHRoZSBmZXcgdGhpbmdzIHdlIGFjdHVhbGx5IHdhbnQgdG8uIEN1cnJlbnRseSB0aGlzIGlzIGp1c3QgdGhlIENUeXBlXG4gKiBQYXJzZXIgYW5kIGN0aW8uXG4gKi9cbmV4cG9ydHMuUGFyc2VyID0gQ1R5cGVQYXJzZXI7XG5leHBvcnRzLnRvQWJzNjQgPSB0b0FiczY0O1xuZXhwb3J0cy50b0FwcHJveDY0ID0gdG9BcHByb3g2NDtcblxuZXhwb3J0cy5wYXJzZUNURiA9IHBhcnNlQ1RGO1xuXG5leHBvcnRzLnJ1aW50OCA9IG1vZF9jdGlvLnJ1aW50ODtcbmV4cG9ydHMucnVpbnQxNiA9IG1vZF9jdGlvLnJ1aW50MTY7XG5leHBvcnRzLnJ1aW50MzIgPSBtb2RfY3Rpby5ydWludDMyO1xuZXhwb3J0cy5ydWludDY0ID0gbW9kX2N0aW8ucnVpbnQ2NDtcbmV4cG9ydHMud3VpbnQ4ID0gbW9kX2N0aW8ud3VpbnQ4O1xuZXhwb3J0cy53dWludDE2ID0gbW9kX2N0aW8ud3VpbnQxNjtcbmV4cG9ydHMud3VpbnQzMiA9IG1vZF9jdGlvLnd1aW50MzI7XG5leHBvcnRzLnd1aW50NjQgPSBtb2RfY3Rpby53dWludDY0O1xuXG5leHBvcnRzLnJzaW50OCA9IG1vZF9jdGlvLnJzaW50ODtcbmV4cG9ydHMucnNpbnQxNiA9IG1vZF9jdGlvLnJzaW50MTY7XG5leHBvcnRzLnJzaW50MzIgPSBtb2RfY3Rpby5yc2ludDMyO1xuZXhwb3J0cy5yc2ludDY0ID0gbW9kX2N0aW8ucnNpbnQ2NDtcbmV4cG9ydHMud3NpbnQ4ID0gbW9kX2N0aW8ud3NpbnQ4O1xuZXhwb3J0cy53c2ludDE2ID0gbW9kX2N0aW8ud3NpbnQxNjtcbmV4cG9ydHMud3NpbnQzMiA9IG1vZF9jdGlvLndzaW50MzI7XG5leHBvcnRzLndzaW50NjQgPSBtb2RfY3Rpby53c2ludDY0O1xuXG5leHBvcnRzLnJmbG9hdCA9IG1vZF9jdGlvLnJmbG9hdDtcbmV4cG9ydHMucmRvdWJsZSA9IG1vZF9jdGlvLnJkb3VibGU7XG5leHBvcnRzLndmbG9hdCA9IG1vZF9jdGlvLndmbG9hdDtcbmV4cG9ydHMud2RvdWJsZSA9IG1vZF9jdGlvLndkb3VibGU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3R5cGUvY3R5cGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBjdGYuanNcbiAqXG4gKiBVbmRlcnN0YW5kIGFuZCBwYXJzZSBhbGwgb2YgdGhlIGRpZmZlcmVudCBKU09OIGZvcm1hdHMgb2YgQ1RGIGRhdGEgYW5kXG4gKiB0cmFuc2xhdGUgdGhhdCBpbnRvIGEgc2VyaWVzIG9mIG5vZGUtY3R5cGUgZnJpZW5kbHkgcGllY2VzLiBUaGUgcmVhc29uIGZvclxuICogdGhlIGFic3RyYWN0aW9uIGlzIHRvIGhhbmRsZSBkaWZmZXJlbnQgY2hhbmdlcyBpbiB0aGUgZmlsZSBmb3JtYXQuXG4gKlxuICogV2UgaGF2ZSB0byBiZSBjYXJlZnVsIGhlcmUgdGhhdCB3ZSBkb24ndCBlbmQgdXAgdXNpbmcgYSBuYW1lIHRoYXQgaXMgYWxyZWFkeVxuICogYSBidWlsdCBpbiB0eXBlLlxuICovXG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIEFTU0VSVCA9IG1vZF9hc3NlcnQub2s7XG5cbnZhciBjdGZfdmVyc2lvbnMgPSBbICcxLjAnIF07XG52YXIgY3RmX2VudHJpZXMgPSBbICdpbnRlZ2VyJywgJ2Zsb2F0JywgJ3R5cGVkZWYnLCAnc3RydWN0JyBdO1xudmFyIGN0Zl9kZWZ0eXBlcyA9IFsgJ2ludDhfdCcsICd1aW50OF90JywgJ2ludDE2X3QnLCAndWludDE2X3QnLCAnaW50MzJfdCcsXG4gICAgJ3VpbnQzMl90JywgJ2Zsb2F0JywgJ2RvdWJsZScgXTtcblxuZnVuY3Rpb24gY3RmUGFyc2VJbnRlZ2VyKGVudHJ5LCBjdHlwZSlcbntcblx0dmFyIG5hbWUsIHNpZ24sIGxlbiwgdHlwZTtcblxuXHRuYW1lID0gZW50cnlbJ25hbWUnXTtcblx0aWYgKCEoJ3NpZ25lZCcgaW4gZW50cnlbJ2ludGVnZXInXSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBpbnRlZ2VyIG1pc3NpbmcgJyArXG5cdFx0ICAgICdzaWduZWQgdmFsdWUnKSk7XG5cblxuXHRpZiAoISgnbGVuZ3RoJyBpbiBlbnRyeVsnaW50ZWdlciddKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGludGVnZXIgbWlzc2luZyAnICtcblx0XHQgICAgJ2xlbmd0aCB2YWx1ZScpKTtcblxuXHRzaWduID0gZW50cnlbJ2ludGVnZXInXVsnc2lnbmVkJ107XG5cdGxlbiA9IGVudHJ5WydpbnRlZ2VyJ11bJ2xlbmd0aCddO1xuXHR0eXBlID0gbnVsbDtcblxuXHRpZiAoc2lnbiAmJiBsZW4gPT0gMSlcblx0XHR0eXBlID0gJ2ludDhfdCc7XG5cdGVsc2UgaWYgKGxlbiA9PSAxKVxuXHRcdHR5cGUgPSAndWludDhfdCc7XG5cdGVsc2UgaWYgKHNpZ24gJiYgbGVuID09IDIpXG5cdFx0dHlwZSA9ICdpbnQxNl90Jztcblx0ZWxzZSBpZiAobGVuID09IDIpXG5cdFx0dHlwZSA9ICd1aW50MTZfdCc7XG5cdGVsc2UgaWYgKHNpZ24gJiYgbGVuID09IDQpXG5cdFx0dHlwZSA9ICdpbnQzMl90Jztcblx0ZWxzZSBpZiAobGVuID09IDQpXG5cdFx0dHlwZSA9ICd1aW50MzJfdCc7XG5cdGVsc2UgaWYgKHNpZ24gJiYgbGVuID09IDgpXG5cdFx0dHlwZSA9ICdpbnQ2NF90Jztcblx0ZWxzZSBpZiAobGVuID09IDgpXG5cdFx0dHlwZSA9ICd1aW50NjRfdCc7XG5cblx0aWYgKHR5cGUgPT09IG51bGwpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBpbnRlZ2VyIGhhcyAnICtcblx0XHQgICAgJ3Vuc3VwcG9ydGVkIGxlbmd0aCBhbmQgc2lnbiAtICcgKyBsZW4gKyAnLycgKyBzaWduKSk7XG5cblx0Lypcblx0ICogVGhpcyBtZWFucyB0aGF0IHRoaXMgaXMgdGhlIHNhbWUgYXMgb25lIG9mIG91ciBidWlsdCBpbiB0eXBlcy4gSWZcblx0ICogdGhhdCdzIHRoZSBjYXNlIGRlZmluaW5nIGl0IHdvdWxkIGJlIGFuIGVycm9yLiBTbyBpbnN0ZWFkIG9mIHRyeWluZ1xuXHQgKiB0byB0eXBlZGVmIGl0LCB3ZSdsbCByZXR1cm4gaGVyZS5cblx0ICovXG5cdGlmIChuYW1lID09IHR5cGUpXG5cdFx0cmV0dXJuO1xuXG5cdGlmIChuYW1lID09ICdjaGFyJykge1xuXHRcdEFTU0VSVCh0eXBlID09ICdpbnQ4X3QnKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHlwZS50eXBlZGVmKG5hbWUsIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBjdGZQYXJzZUZsb2F0KGVudHJ5LCBjdHlwZSlcbntcblx0dmFyIG5hbWUsIGxlbjtcblxuXHRuYW1lID0gZW50cnlbJ25hbWUnXTtcblx0aWYgKCEoJ2xlbmd0aCcgaW4gZW50cnlbJ2Zsb2F0J10pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogZmxvYXQgbWlzc2luZyAnICtcblx0XHQgICAgJ2xlbmd0aCB2YWx1ZScpKTtcblxuXHRsZW4gPSBlbnRyeVsnZmxvYXQnXVsnbGVuZ3RoJ107XG5cdGlmIChsZW4gIT0gNCAmJiBsZW4gIT0gOClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGZsb2F0IGhhcyBpbnZhbGlkICcgK1xuXHRcdCAgICAnbGVuZ3RoIHZhbHVlJykpO1xuXG5cdGlmIChsZW4gPT0gNCkge1xuXHRcdGlmIChuYW1lID09ICdmbG9hdCcpXG5cdFx0XHRyZXR1cm47XG5cdFx0Y3R5cGUudHlwZWRlZihuYW1lLCAnZmxvYXQnKTtcblx0fSBlbHNlIGlmIChsZW4gPT0gOCkge1xuXHRcdGlmIChuYW1lID09ICdkb3VibGUnKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGN0eXBlLnR5cGVkZWYobmFtZSwgJ2RvdWJsZScpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGN0ZlBhcnNlVHlwZWRlZihlbnRyeSwgY3R5cGUpXG57XG5cdHZhciBuYW1lLCB0eXBlLCBpaTtcblxuXHRuYW1lID0gZW50cnlbJ25hbWUnXTtcblx0aWYgKHR5cGVvZiAoZW50cnlbJ3R5cGVkZWYnXSkgIT0gJ3N0cmluZycpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiB0eXBlZGVmIHZhbHVlIGluIG5vdCAnICtcblx0XHQgICAgJ2Egc3RyaW5nJykpO1xuXG5cdHR5cGUgPSBlbnRyeVsndHlwZWRlZiddO1xuXG5cdC8qXG5cdCAqIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2UncmUgbm90IGxvb2tpbmcgYXQgdHlwZSB0aGF0J3Mgb25lIG9mIG91clxuXHQgKiBidWlsdCBpbiB0eXBlcy4gVHJhZGl0aW9uYWxseSBpbiBDIGEgdWludDMyX3Qgd291bGQgYmUgYSB0eXBlZGVmIHRvXG5cdCAqIHNvbWUga2luZCBvZiBpbnRlZ2VyLiBIb3dldmVyLCB0aG9zZSBzaXplIHR5cGVzIGFyZSBidWlsdCBpbnMuXG5cdCAqL1xuXHRmb3IgKGlpID0gMDsgaWkgPCBjdGZfZGVmdHlwZXMubGVuZ3RoOyBpaSsrKSB7XG5cdFx0aWYgKG5hbWUgPT0gY3RmX2RlZnR5cGVzW2lpXSlcblx0XHRcdHJldHVybjtcblx0fVxuXG5cdGN0eXBlLnR5cGVkZWYobmFtZSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGN0ZlBhcnNlU3RydWN0KGVudHJ5LCBjdHlwZSlcbntcblx0dmFyIG5hbWUsIHR5cGUsIGlpLCB2YWwsIGluZGV4LCBtZW1iZXIsIHB1c2g7XG5cblx0bWVtYmVyID0gW107XG5cdGlmICghQXJyYXkuaXNBcnJheShlbnRyeVsnc3RydWN0J10pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogc3RydWN0IHZhbHVlIGlzIG5vdCAnICtcblx0XHQgICAgJ2FuIGFycmF5JykpO1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGVudHJ5WydzdHJ1Y3QnXS5sZW5ndGg7IGlpKyspIHtcblx0XHR2YWwgPSBlbnRyeVsnc3RydWN0J11baWldO1xuXHRcdGlmICghKCduYW1lJyBpbiB2YWwpKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBzdHJ1Y3QgbWVtYmVyICcgK1xuXHRcdFx0ICAgICdtaXNzaW5nIG5hbWUnKSk7XG5cblx0XHRpZiAoISgndHlwZScgaW4gdmFsKSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogc3RydWN0IG1lbWJlciAnICtcblx0XHRcdCAgICAnbWlzc2luZyB0eXBlJykpO1xuXG5cdFx0aWYgKHR5cGVvZiAodmFsWyduYW1lJ10pICE9ICdzdHJpbmcnKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBzdHJ1Y3QgbWVtYmVyICcgK1xuXHRcdFx0ICAgICduYW1lIGlzblxcJ3QgYSBzdHJpbmcnKSk7XG5cblx0XHRpZiAodHlwZW9mICh2YWxbJ3R5cGUnXSkgIT0gJ3N0cmluZycpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IHN0cnVjdCBtZW1iZXIgJyArXG5cdFx0XHQgICAgJ3R5cGUgaXNuXFwndCBhIHN0cmluZycpKTtcblxuXHRcdC8qXG5cdFx0ICogQ1RGIHZlcnNpb24gMiBzcGVjaWZpZXMgYXJyYXkgbmFtZXMgYXMgPHR5cGU+IFs8bnVtPl0gd2hlcmVcblx0XHQgKiBhcyBub2RlLWN0eXBlIGRvZXMgdGhpcyBhcyA8dHlwZT5bPG51bT5dLlxuXHRcdCAqL1xuXHRcdG5hbWUgPSB2YWxbJ25hbWUnXTtcblx0XHR0eXBlID0gdmFsWyd0eXBlJ107XG5cdFx0aW5kZXggPSB0eXBlLmluZGV4T2YoJyBbJyk7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR0eXBlID0gdHlwZS5zdWJzdHJpbmcoMCwgaW5kZXgpICtcblx0XHRcdCAgICB0eXBlLnN1YnN0cmluZyhpbmRleCArIDEsIHR5cGUubGVuZ3RoKTtcblx0XHR9XG5cdFx0cHVzaCA9IHt9O1xuXHRcdHB1c2hbbmFtZV0gPSB7ICd0eXBlJzogdHlwZSB9O1xuXHRcdG1lbWJlci5wdXNoKHB1c2gpO1xuXHR9XG5cblx0bmFtZSA9IGVudHJ5WyduYW1lJ107XG5cdGN0eXBlLnR5cGVkZWYobmFtZSwgbWVtYmVyKTtcbn1cblxuZnVuY3Rpb24gY3RmUGFyc2VFbnRyeShlbnRyeSwgY3R5cGUpXG57XG5cdHZhciBpaSwgZm91bmQ7XG5cblx0aWYgKCEoJ25hbWUnIGluIGVudHJ5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGVudHJ5IG1pc3NpbmcgXCJuYW1lXCIgJyArXG5cdFx0ICAgICdzZWN0aW9uJykpO1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGN0Zl9lbnRyaWVzLmxlbmd0aDsgaWkrKykge1xuXHRcdGlmIChjdGZfZW50cmllc1tpaV0gaW4gZW50cnkpXG5cdFx0XHRmb3VuZCsrO1xuXHR9XG5cblx0aWYgKGZvdW5kID09PSAwKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogZm91bmQgbm8gZW50cmllcycpKTtcblxuXHRpZiAoZm91bmQgPj0gMilcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGZvdW5kIG1vcmUgdGhhbiBvbmUgJyArXG5cdFx0ICAgICdlbnRyeScpKTtcblxuXHRpZiAoJ2ludGVnZXInIGluIGVudHJ5KSB7XG5cdFx0Y3RmUGFyc2VJbnRlZ2VyKGVudHJ5LCBjdHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCdmbG9hdCcgaW4gZW50cnkpIHtcblx0XHRjdGZQYXJzZUZsb2F0KGVudHJ5LCBjdHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCd0eXBlZGVmJyBpbiBlbnRyeSkge1xuXHRcdGN0ZlBhcnNlVHlwZWRlZihlbnRyeSwgY3R5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICgnc3RydWN0JyBpbiBlbnRyeSkge1xuXHRcdGN0ZlBhcnNlU3RydWN0KGVudHJ5LCBjdHlwZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0QVNTRVJUKGZhbHNlLCAnc2hvdWxkblxcJ3QgcmVhY2ggaGVyZScpO1xufVxuXG5mdW5jdGlvbiBjdGZQYXJzZUpzb24oanNvbiwgY3R5cGUpXG57XG5cdHZhciB2ZXJzaW9uLCBpaTtcblxuXHRBU1NFUlQoanNvbik7XG5cdEFTU0VSVChjdHlwZSk7XG5cdGlmICghKCdtZXRhZGF0YScgaW4ganNvbikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBDVEYgSlNPTjogbWlzc2luZyBtZXRhZGF0YSBzZWN0aW9uJykpO1xuXG5cdGlmICghKCdjdGYyanNvbl92ZXJzaW9uJyBpbiBqc29uWydtZXRhZGF0YSddKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIENURiBKU09OOiBtaXNzaW5nIGN0ZjJqc29uX3ZlcnNpb24nKSk7XG5cblx0dmVyc2lvbiA9IGpzb25bJ21ldGFkYXRhJ11bJ2N0ZjJqc29uX3ZlcnNpb24nXTtcblx0Zm9yIChpaSA9IDA7IGlpIDwgY3RmX3ZlcnNpb25zLmxlbmd0aDsgaWkrKykge1xuXHRcdGlmIChjdGZfdmVyc2lvbnNbaWldID09IHZlcnNpb24pXG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmIChpaSA9PSBjdGZfdmVyc2lvbnMubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3Vwb3J0ZWQgY3RmMmpzb25fdmVyc2lvbjogJyArIHZlcnNpb24pKTtcblxuXHRpZiAoISgnZGF0YScgaW4ganNvbikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBDVEYgSlNPTjogbWlzc2luZyBkYXRhIHNlY3Rpb24nKSk7XG5cblx0aWYgKCFBcnJheS5pc0FycmF5KGpzb25bJ2RhdGEnXSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBkYXRhIHNlY3Rpb24gaXMgbm90ICcgK1xuXHRcdCAgICAnYW4gYXJyYXknKSk7XG5cblx0Zm9yIChpaSA9IDA7IGlpIDwganNvblsnZGF0YSddLmxlbmd0aDsgaWkrKylcblx0XHRjdGZQYXJzZUVudHJ5KGpzb25bJ2RhdGEnXVtpaV0sIGN0eXBlKTtcbn1cblxuZXhwb3J0cy5jdGZQYXJzZUpzb24gPSBjdGZQYXJzZUpzb247XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vY3R5cGUvY3RmLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogcm0gLSBGZWIgMjAxMVxuICogY3Rpby5qczpcbiAqXG4gKiBBIHNpbXBsZSB3YXkgdG8gcmVhZCBhbmQgd3JpdGUgc2ltcGxlIGN0eXBlcy4gT2YgY291cnNlLCBhcyB5b3UnbGwgZmluZCB0aGVcbiAqIGNvZGUgaXNuJ3QgYXMgc2ltcGxlIGFzIGl0IG1pZ2h0IGFwcGVhci4gVGhlIGZvbGxvd2luZyB0eXBlcyBhcmUgY3VycmVudGx5XG4gKiBzdXBwb3J0ZWQgaW4gYmlnIGFuZCBsaXR0bGUgZW5kaWFuIGZvcm1hdHM6XG4gKlxuICogXHR1aW50OF90XHRcdFx0aW50OF90XG4gKiBcdHVpbnQxNl90XHRcdGludDE2X3RcbiAqIFx0dWludDMyX3RcdFx0aW50MzJfdFxuICpcdGZsb2F0IChzaW5nbGUgcHJlY2lzaW9uIElFRUUgNzU0KVxuICpcdGRvdWJsZSAoZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NClcbiAqXG4gKiBUaGlzIGlzIGRlc2lnbmVkIHRvIHdvcmsgaW4gTm9kZSBhbmQgdjguIEl0IG1heSBpbiBmYWN0IHdvcmsgaW4gb3RoZXJcbiAqIEphdmFzY3JpcHQgaW50ZXJwcmV0ZXJzICh0aGF0J2QgYmUgcHJldHR5IG5lYXQpLCBidXQgaXQgaGFzbid0IGJlZW4gdGVzdGVkLlxuICogSWYgeW91IGZpbmQgdGhhdCBpdCBkb2VzIGluIGZhY3Qgd29yaywgdGhhdCdzIHByZXR0eSBjb29sLiBUcnkgYW5kIHBhc3Mgd29yZFxuICogYmFjayB0byB0aGUgb3JpZ2luYWwgYXV0aG9yLlxuICpcbiAqIE5vdGUgdG8gdGhlIHJlYWRlcjogSWYgeW91J3JlIHRhYnN0b3AgaXNuJ3Qgc2V0IHRvIDgsIHBhcnRzIG9mIHRoaXMgbWF5IGxvb2tcbiAqIHdlaXJkLlxuICovXG5cbi8qXG4gKiBOdW1iZXJzIGluIEphdmFzY3JpcHQgaGF2ZSBhIHNlY3JldDogYWxsIG51bWJlcnMgbXVzdCBiZSByZXByZXNlbnRlZCB3aXRoIGFuXG4gKiBJRUVFLTc1NCBkb3VibGUuIFRoZSBkb3VibGUgaGFzIGEgbWFudGlzc2Egd2l0aCBhIGxlbmd0aCBvZiA1MiBiaXRzIHdpdGggYW5cbiAqIGltcGxpY2l0IG9uZS4gVGh1cyB0aGUgcmFuZ2Ugb2YgaW50ZWdlcnMgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaXMgbGltaXRlZFxuICogdG8gdGhlIHNpemUgb2YgdGhlIG1hbnRpc3NhLCB0aGlzIG1ha2VzIHJlYWRpbmcgYW5kIHdyaXRpbmcgNjQtYml0IGludGVnZXJzXG4gKiBkaWZmaWN1bHQsIGJ1dCBmYXIgZnJvbSBpbXBvc3NpYmxlLlxuICpcbiAqIEFub3RoZXIgc2lkZSBlZmZlY3Qgb2YgdGhpcyByZXByZXNlbnRhdGlvbiBpcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgdXNlIHRoZVxuICogYml0d2lzZSBvcGVyYXRvcnMsIGkuZS4gc2hpZnQgbGVmdCwgc2hpZnQgcmlnaHQsIGFuZCwgb3IsIGV0Yy4gSW4gSmF2YXNjcmlwdCxcbiAqIGVhY2ggb3BlcmFuZCBhbmQgdGhlIHJlc3VsdCBpcyBjYXN0IHRvIGEgc2lnbmVkIDMyLWJpdCBudW1iZXIuIEhvd2V2ZXIsIGluXG4gKiB0aGUgY2FzZSBvZiA+Pj4gdGhlIHZhbHVlcyBhcmUgY2FzdCB0byBhbiB1bnNpZ25lZCBudW1iZXIuXG4gKi9cblxuLypcbiAqIEEgcmVtaW5kZXIgb24gZW5kaWFuIHJlbGF0ZWQgaXNzdWVzOlxuICpcbiAqIEJpZyBFbmRpYW46IE1TQiAtPiBGaXJzdCBieXRlXG4gKiBMaXR0bGUgRW5kaWFuOiBNU0ItPkxhc3QgYnl0ZVxuICovXG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4vKlxuICogQW4gOCBiaXQgdW5zaWduZWQgaW50ZWdlciBpbnZvbHZlcyBkb2luZyBubyBzaWduaWZpY2FudCB3b3JrLlxuICovXG5mdW5jdGlvbiBydWludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHJldHVybiAoYnVmZmVyW29mZnNldF0pO1xufVxuXG4vKlxuICogRm9yIDE2IGJpdCB1bnNpZ25lZCBudW1iZXJzIHdlIGNhbiBkbyBhbGwgdGhlIGNhc3RpbmcgdGhhdCB3ZSB3YW50IHRvIGRvLlxuICovXG5mdW5jdGlvbiByZ2ludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSAwO1xuXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHR2YWwgPSBidWZmZXJbb2Zmc2V0XSA8PCA4O1xuXHRcdHZhbCB8PSAgYnVmZmVyW29mZnNldCsxXTtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBidWZmZXJbb2Zmc2V0XTtcblx0XHR2YWwgfD0gYnVmZmVyW29mZnNldCsxXSA8PCA4O1xuXHR9XG5cblx0cmV0dXJuICh2YWwpO1xuXG59XG5cbmZ1bmN0aW9uIHJ1aW50MTYoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDEgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRyZXR1cm4gKHJnaW50MTYoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCkpO1xufVxuXG4vKlxuICogQmVjYXVzZSBtb3N0IGJpdHNoaWZ0aW5nIGlzIGRvbmUgdXNpbmcgc2lnbmVkIG51bWJlcnMsIGlmIHdlIHdvdWxkIGdvIGludG9cbiAqIHRoZSByZWFsbSB3aGVyZSB3ZSB1c2UgdGhhdCAzMm5kIGJpdCwgd2UnbGwgZW5kIHVwIGdvaW5nIGludG8gdGhlIG5lZ2F0aXZlXG4gKiByYW5nZS4gaS5lLjpcbiAqID4gMjAwIDw8IDI0XG4gKiAtOTM5NTI0MDk2XG4gKlxuICogTm90IHRoZSB2YWx1ZSB5b3UnZCBleHBlY3QuIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGVuZCB1cCBoYXZpbmcgdG8gZG8gc29tZVxuICogYWJ1c2Ugb2YgdGhlIEphdmFTY3JpcHQgc3RhbmRhcmQuIGluIHRoaXMgY2FzZSwgd2Uga25vdyB0aGF0IGEgPj4+IHNoaWZ0IGlzXG4gKiBkZWZpbmVkIHRvIGNhc3Qgb3VyIHZhbHVlIHRvIGFuICp1bnNpZ25lZCogMzItYml0IG51bWJlci4gQmVjYXVzZSBvZiB0aGF0LCB3ZVxuICogdXNlIHRoYXQgaW5zdGVhZCB0byBzYXZlIHVzIHNvbWUgYWRkaXRpb25hbCBtYXRoLCB0aG91Z2ggaXQgZG9lcyBmZWVsIGFcbiAqIGxpdHRsZSB3ZWlyZCBhbmQgaXQgaXNuJ3Qgb2J2aW91cyBhcyB0byB3aHkgeW91IHdvdWwgZHdhbnQgdG8gZG8gdGhpcyBhdFxuICogZmlyc3QuXG4gKi9cbmZ1bmN0aW9uIHJnaW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIHZhbCA9IDA7XG5cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdHZhbCA9IGJ1ZmZlcltvZmZzZXQrMV0gPDwgMTY7XG5cdFx0dmFsIHw9IGJ1ZmZlcltvZmZzZXQrMl0gPDwgODtcblx0XHR2YWwgfD0gYnVmZmVyW29mZnNldCszXTtcblx0XHR2YWwgPSB2YWwgKyAoYnVmZmVyW29mZnNldF0gPDwgMjQgPj4+IDApO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IGJ1ZmZlcltvZmZzZXQrMl0gPDwgMTY7XG5cdFx0dmFsIHw9IGJ1ZmZlcltvZmZzZXQrMV0gPDwgODtcblx0XHR2YWwgfD0gYnVmZmVyW29mZnNldF07XG5cdFx0dmFsID0gdmFsICsgKGJ1ZmZlcltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMCk7XG5cdH1cblxuXHRyZXR1cm4gKHZhbCk7XG59XG5cbmZ1bmN0aW9uIHJ1aW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRyZXR1cm4gKHJnaW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCkpO1xufVxuXG4vKlxuICogUmVhZHMgYSA2NC1iaXQgdW5zaWduZWQgbnVtYmVyLiBUaGUgYXN0dWUgb2JzZXJ2ZXIgd2lsbCBub3RlIHRoYXQgdGhpc1xuICogZG9lc24ndCBxdWl0ZSB3b3JrLiBKYXZhc2NyaXB0IGhhcyBjaG9zZW4gdG8gb25seSBoYXZlIG51bWJlcnMgdGhhdCBjYW4gYmVcbiAqIHJlcHJlc2VudGVkIGJ5IGEgZG91YmxlLiBBIGRvdWJsZSBvbmx5IGhhcyA1MiBiaXRzIG9mIG1hbnRpc3NhIHdpdGggYW5cbiAqIGltcGxpY2l0IDEsIHRodXMgd2UgaGF2ZSB1cCB0byA1MyBiaXRzIHRvIHJlcHJlc2VudCBhbiBpbnRlZ2VyLiBIb3dldmVyLCAyXjUzXG4gKiBkb2Vzbid0IHF1aXRlIGdpdmUgdXMgd2hhdCB3ZSB3YW50LiBJc24ndCA1MyBiaXRzIGVub3VnaCBmb3IgYW55b25lPyBXaGF0XG4gKiBjb3VsZCB5b3UgaGF2ZSBwb3NzaWJseSB3YW50ZWQgdG8gcmVwcmVzZW50IHRoYXQgd2FzIGxhcmdlciB0aGFuIHRoYXQ/IE9oLFxuICogbWF5YmUgYSBzaXplPyBZb3UgbWVhbiB3ZSBieXBhc3NlZCB0aGUgNCBHQiBsaW1pdCBvbiBmaWxlIHNpemVzLCB3aGVuIGRpZFxuICogdGhhdCBoYXBwZW4/XG4gKlxuICogVG8gZ2V0IGFyb3VuZCB0aGlzIGVncmVnaW91cyBsYW5ndWFnZSBpc3N1ZSwgd2UncmUgZ29pbmcgdG8gaW5zdGVhZCBjb25zdHJ1Y3RcbiAqIGFuIGFycmF5IG9mIHR3byAzMiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuIFdoZXJlIGFyclswXSA8PCAzMiArIGFyclsxXSB3b3VsZFxuICogZ2l2ZSB0aGUgYWN0dWFsIG51bWJlci4gSG93ZXZlciwgbm90ZSB0aGF0IHRoZSBhYm92ZSBjb2RlIHByb2JhYmx5IHdvbid0XG4gKiBwcm9kdWNlIHRoZSBkZXNpcmVkIHJlc3VsdHMgYmVjYXVzZSBvZiB0aGUgd2F5IEphdmFzY3JpcHQgbnVtYmVycyBhcmVcbiAqIGRvdWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHJnaW50NjQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG5ldyBBcnJheSgyKTtcblxuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0dmFsWzBdID0gcnVpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0XHR2YWxbMV0gPSBydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQrNCk7XG5cdH0gZWxzZSB7XG5cdFx0dmFsWzBdID0gcnVpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KzQpO1xuXHRcdHZhbFsxXSA9IHJ1aW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdH1cblxuXHRyZXR1cm4gKHZhbCk7XG59XG5cbmZ1bmN0aW9uIHJ1aW50NjQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDcgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRyZXR1cm4gKHJnaW50NjQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCkpO1xufVxuXG5cbi8qXG4gKiBTaWduZWQgaW50ZWdlciB0eXBlcywgeWF5IHRlYW0hIEEgcmVtaW5kZXIgb24gaG93IHR3bydzIGNvbXBsZW1lbnQgYWN0dWFsbHlcbiAqIHdvcmtzLiBUaGUgZmlyc3QgYml0IGlzIHRoZSBzaWduZWQgYml0LCBpLmUuIHRlbGxzIHVzIHdoZXRoZXIgb3Igbm90IHRoZVxuICogbnVtYmVyIHNob3VsZCBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZS4gSWYgdGhlIHR3bydzIGNvbXBsZW1lbnQgdmFsdWUgaXNcbiAqIHBvc2l0aXZlLCB0aGVuIHdlJ3JlIGRvbmUsIGFzIGl0J3MgZXF1aXZhbGVudCB0byB0aGUgdW5zaWduZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogTm93IGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHlvdSdyZSBwcmV0dHkgbXVjaCBkb25lLCB5b3UgY2FuIGp1c3QgbGV2ZXJhZ2VcbiAqIHRoZSB1bnNpZ25lZCB0cmFuc2xhdGlvbnMgYW5kIHJldHVybiB0aG9zZS4gVW5mb3J0dW5hdGVseSwgbmVnYXRpdmUgbnVtYmVyc1xuICogYXJlbid0IHF1aXRlIHRoYXQgc3RyYWlnaHRmb3J3YXJkLlxuICpcbiAqIEF0IGZpcnN0IGdsYW5jZSwgb25lIG1pZ2h0IGJlIGluY2xpbmVkIHRvIHVzZSB0aGUgdHJhZGl0aW9uYWwgZm9ybXVsYSB0b1xuICogdHJhbnNsYXRlIGJpbmFyeSBudW1iZXJzIGJldHdlZW4gdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgaW4gdHdvJ3NcbiAqIGNvbXBsZW1lbnQuIChUaG91Z2ggaXQgZG9lc24ndCBxdWl0ZSB3b3JrIGZvciB0aGUgbW9zdCBuZWdhdGl2ZSB2YWx1ZSlcbiAqIE1haW5seTpcbiAqICAtIGludmVydCBhbGwgdGhlIGJpdHNcbiAqICAtIGFkZCBvbmUgdG8gdGhlIHJlc3VsdFxuICpcbiAqIE9mIGNvdXJzZSwgdGhpcyBkb2Vzbid0IHF1aXRlIHdvcmsgaW4gSmF2YXNjcmlwdC4gVGFrZSBmb3IgZXhhbXBsZSB0aGUgdmFsdWVcbiAqIG9mIC0xMjguIFRoaXMgY291bGQgYmUgcmVwcmVzZW50ZWQgaW4gMTYgYml0cyAoYmlnLWVuZGlhbikgYXMgMHhmZjgwLiBCdXQgb2ZcbiAqIGNvdXJzZSwgSmF2YXNjcmlwdCB3aWxsIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogPiB+MHhmZjgwXG4gKiAtNjU0MDlcbiAqXG4gKiBXaG9oIHRoZXJlLCBKYXZhc2NyaXB0LCB0aGF0J3Mgbm90IHF1aXRlIHJpZ2h0LiBCdXQgd2FpdCwgYWNjb3JkaW5nIHRvXG4gKiBKYXZhc2NyaXB0IHRoYXQncyBwZXJmZWN0bHkgY29ycmVjdC4gV2hlbiBKYXZhc2NyaXB0IGVuZHMgdXAgc2VlaW5nIHRoZVxuICogY29uc3RhbnQgMHhmZjgwLCBpdCBoYXMgbm8gbm90aW9uIHRoYXQgaXQgaXMgYWN0dWFsbHkgYSBzaWduZWQgbnVtYmVyLiBJdFxuICogYXNzdW1lcyB0aGF0IHdlJ3ZlIGlucHV0IHRoZSB1bnNpZ25lZCB2YWx1ZSAweGZmODAuIFRodXMsIHdoZW4gaXQgZG9lcyB0aGVcbiAqIGJpbmFyeSBuZWdhdGlvbiwgaXQgY2FzdHMgaXQgaW50byBhIHNpZ25lZCB2YWx1ZSwgKHBvc2l0aXZlIDB4ZmY4MCkuIFRoZW5cbiAqIHdoZW4geW91IHBlcmZvcm0gYmluYXJ5IG5lZ2F0aW9uIG9uIHRoYXQsIGl0IHR1cm5zIGl0IGludG8gYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogSW5zdGVhZCwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB1c2UgdGhlIGZvbGxvd2luZyBnZW5lcmFsIGZvcm11bGEsIHRoYXQgd29ya3NcbiAqIGluIGEgcmF0aGVyIEphdmFzY3JpcHQgZnJpZW5kbHkgd2F5LiBJJ20gZ2xhZCB3ZSBkb24ndCBzdXBwb3J0IHRoaXMga2luZCBvZlxuICogd2VpcmQgbnVtYmVyaW5nIHNjaGVtZSBpbiB0aGUga2VybmVsLlxuICpcbiAqIChCSVQtTUFYIC0gKHVuc2lnbmVkKXZhbCArIDEpICogLTFcbiAqXG4gKiBUaGUgYXN0dXRlIG9ic2VydmVyLCBtYXkgdGhpbmsgdGhhdCB0aGlzIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IgOC1iaXQgbnVtYmVyc1xuICogKHJlYWxseSBpdCBpc24ndCBuZWNlc3NhcnkgZm9yIHRoZW0pLiBIb3dldmVyLCB3aGVuIHlvdSBnZXQgMTYtYml0IG51bWJlcnMsXG4gKiB5b3UgZG8uIExldCdzIGdvIGJhY2sgdG8gb3VyIHByaW9yIGV4YW1wbGUgYW5kIHNlZSBob3cgdGhpcyB3aWxsIGxvb2s6XG4gKlxuICogKDB4ZmZmZiAtIDB4ZmY4MCArIDEpICogLTFcbiAqICgweDAwN2YgKyAxKSAqIC0xXG4gKiAoMHgwMDgwKSAqIC0xXG4gKlxuICogRG9pbmcgaXQgdGhpcyB3YXkgZW5kcyB1cCBhbGxvd2luZyB1cyB0byB0cmVhdCBpdCBhcHByb3ByaWF0ZWx5IGluXG4gKiBKYXZhc2NyaXB0LiBTaWdoLCB0aGF0J3MgcmVhbGx5IHF1aXRlIHVnbHkgZm9yIHdoYXQgc2hvdWxkIGp1c3QgYmUgYSBmZXcgYml0XG4gKiBzaGlmdHMsIH4gYW5kICYuXG4gKi9cblxuLypcbiAqIEVuZGlhbm5lc3MgZG9lc24ndCBtYXR0ZXIgZm9yIDgtYml0IHNpZ25lZCB2YWx1ZXMuIFdlIGNvdWxkIGluIGZhY3Qgb3B0aW1pemVcbiAqIHRoaXMgY2FzZSBiZWNhdXNlIHRoZSBtb3JlIHRyYWRpdGlvbmFsIG1ldGhvZHMgd29yaywgYnV0IGZvciBjb25zaXN0ZW5jeSxcbiAqIHdlJ2xsIGtlZXAgZG9pbmcgdGhpcyB0aGUgc2FtZSB3YXkuXG4gKi9cbmZ1bmN0aW9uIHJzaW50OChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgbmVnO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRuZWcgPSBidWZmZXJbb2Zmc2V0XSAmIDB4ODA7XG5cdGlmICghbmVnKVxuXHRcdHJldHVybiAoYnVmZmVyW29mZnNldF0pO1xuXG5cdHJldHVybiAoKDB4ZmYgLSBidWZmZXJbb2Zmc2V0XSArIDEpICogLTEpO1xufVxuXG4vKlxuICogVGhlIDE2LWJpdCB2ZXJzaW9uIHJlcXVpcmVzIGEgYml0IG1vcmUgZWZmb3J0LiBJbiB0aGlzIGNhc2UsIHdlIGNhbiBsZXZlcmFnZVxuICogb3VyIHVuc2lnbmVkIGNvZGUgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHdlIHdhbnQgdG8gcmV0dXJuLlxuICovXG5mdW5jdGlvbiByc2ludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciBuZWcsIHZhbDtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMSA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHJnaW50MTYoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdG5lZyA9IHZhbCAmIDB4ODAwMDtcblx0aWYgKCFuZWcpXG5cdFx0cmV0dXJuICh2YWwpO1xuXG5cdHJldHVybiAoKDB4ZmZmZiAtIHZhbCArIDEpICogLTEpO1xufVxuXG4vKlxuICogV2UgcmVhbGx5IHNob3VsZG4ndCBsZXZlcmFnZSBvdXIgMzItYml0IGNvZGUgaGVyZSBhbmQgaW5zdGVhZCB1dGlsaXplIHRoZVxuICogZmFjdCB0aGF0IHdlIGtub3cgdGhhdCBzaW5jZSB0aGVzZSBhcmUgc2lnbmVkIG51bWJlcnMsIHdlIGNhbiBkbyBhbGwgdGhlXG4gKiBzaGlmdGluZyBhbmQgYmluYXJ5IGFuZGluZyB0byBnZW5lcmF0ZSB0aGUgMzItYml0IG51bWJlci4gQnV0LCBmb3JcbiAqIGNvbnNpc3RlbmN5IHdlJ2xsIGRvIHRoZSBzYW1lLiBJZiB3ZSB3YW50IHRvIGRvIG90aGVyd2lzZSwgd2Ugc2hvdWxkIGluc3RlYWRcbiAqIG1ha2UgdGhlIDMyIGJpdCB1bnNpZ25lZCBjb2RlIGRvIHRoZSBvcHRpbWl6YXRpb24uIEJ1dCBhcyBsb25nIGFzIHRoZXJlXG4gKiBhcmVuJ3QgZmxvYXRzIHNlY3JldGx5IHVuZGVyIHRoZSBob29kIGZvciB0aGF0LCB3ZSAvc2hvdWxkLyBiZSBva2F5LlxuICovXG5mdW5jdGlvbiByc2ludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciBuZWcsIHZhbDtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHJnaW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdG5lZyA9IHZhbCAmIDB4ODAwMDAwMDA7XG5cdGlmICghbmVnKVxuXHRcdHJldHVybiAodmFsKTtcblxuXHRyZXR1cm4gKCgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMSk7XG59XG5cbi8qXG4gKiBUaGUgc2lnbmVkIHZlcnNpb24gb2YgdGhpcyBjb2RlIHN1ZmZlcnMgZnJvbSBhbGwgb2YgdGhlIHNhbWUgcHJvYmxlbXMgb2YgdGhlXG4gKiBvdGhlciA2NCBiaXQgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gcnNpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgbmVnLCB2YWw7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSByZ2ludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRuZWcgPSB2YWxbMF0gJiAweDgwMDAwMDAwO1xuXG5cdGlmICghbmVnKVxuXHRcdHJldHVybiAodmFsKTtcblxuXHR2YWxbMF0gPSAoMHhmZmZmZmZmZiAtIHZhbFswXSkgKiAtMTtcblx0dmFsWzFdID0gKDB4ZmZmZmZmZmYgLSB2YWxbMV0gKyAxKSAqIC0xO1xuXG5cdC8qXG5cdCAqIElmIHdlIGhhZCB0aGUga2V5IDB4ODAwMDAwMDAwMDAwMDAwMCwgdGhhdCB3b3VsZCBsZWF2ZSB0aGUgbG93ZXIgMzJcblx0ICogYml0cyBhcyAweGZmZmZmZmZmLCBob3dldmVyLCBzaW5jZSB3ZSdyZSBnb2ludCB0byBhZGQgb25lLCB0aGF0IHdvdWxkXG5cdCAqIGFjdHVhbGx5IGxlYXZlIHRoZSBsb3dlciAzMi1iaXRzIGFzIDB4MTAwMDAwMDAwLCB3aGljaCB3b3VsZCBicmVha1xuXHQgKiBvdXIgYWJpbGl0eSB0byB3cml0ZSBiYWNrIGEgdmFsdWUgdGhhdCB3ZSByZWNlaXZlZC4gVG8gd29yayBhcm91bmRcblx0ICogdGhpcywgaWYgd2UgYWN0dWFsbHkgZ2V0IHRoYXQgdmFsdWUsIHdlJ3JlIGdvaW5nIHRvIGJ1bXAgdGhlIHVwcGVyXG5cdCAqIHBvcnRpb24gYnkgMSBhbmQgc2V0IHRoaXMgdG8gemVyby5cblx0ICovXG5cdG1vZF9hc3NlcnQub2sodmFsWzFdIDw9IDB4MTAwMDAwMDAwKTtcblx0aWYgKHZhbFsxXSA9PSAtMHgxMDAwMDAwMDApIHtcblx0XHR2YWxbMV0gPSAwO1xuXHRcdHZhbFswXS0tO1xuXHR9XG5cblx0cmV0dXJuICh2YWwpO1xufVxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBJRUVFIDc1NDogVGhlIHRyYWRpdGlvbmFsIGZvcm0gZm9yIGZsb2F0aW5nIHBvaW50IG51bWJlcnNcbiAqIGFuZCB3aGF0IGlzIHNlY3JldGx5IGhpZGluZyBhdCB0aGUgaGVhcnQgb2YgZXZlcnl0aGluZyBpbiB0aGlzLiBJIHJlYWxseSBob3BlXG4gKiB0aGF0IHNvbWVvbmUgaXMgYWN0dWFsbHkgdXNpbmcgdGhpcywgYXMgb3RoZXJ3aXNlLCB0aGlzIGVmZm9ydCBpcyBwcm9iYWJseVxuICogZ29pbmcgdG8gYmUgbW9yZSB3YXN0ZWQuXG4gKlxuICogT25lIG1pZ2h0IGJlIHRlbXB0ZWQgdG8gdXNlIHBhcnNlRmxvYXQgaGVyZSwgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBhdCBhbGxcbiAqIGZvciBzZXZlcmFsIHJlYXNvbnMuIE1vc3RseSBkdWUgdG8gdGhlIHdheSBmbG9hdHMgYWN0dWFsbHkgd29yaywgYW5kXG4gKiBwYXJzZUZsb2F0IG9ubHkgYWN0dWFsbHkgd29ya3MgaW4gYmFzZSAxMC4gSSBkb24ndCBzZWUgYmFzZSAxMCBhbnl3aGVyZSBuZWFyXG4gKiB0aGlzIGZpbGUuXG4gKlxuICogSW4gdGhpcyBjYXNlIHdlJ2xsIGltcGxlbWVudCB0aGUgc2luZ2xlIGFuZCBkb3VibGUgcHJlY2lzaW9uIHZlcnNpb25zLiBUaGVcbiAqIHF1YWRydXBsZSBwcmVjaXNpb24sIHdoaWxlIHByb2JhYmx5IHVzZWZ1bCwgd291bGRuJ3QgcmVhbGx5IGJlIGFjY2VwdGVkIGJ5XG4gKiBKYXZhc2NyaXB0LCBzbyBsZXQncyBub3QgZXZlbiB3YXN0ZSBvdXIgdGltZS5cbiAqXG4gKiBTbyBsZXQncyByZXZpZXcgaG93IHRoaXMgZm9ybWF0IGxvb2tzIGxpa2UuIEEgc2luZ2xlIHByZWNpc2lvbiB2YWx1ZSBpcyAzMlxuICogYml0cyBhbmQgaGFzIHRocmVlIHBhcnRzOlxuICogICAtICBTaWduIGJpdFxuICogICAtICBFeHBvbmVudCAoVXNpbmcgYmlhcyBub3RhdGlvbilcbiAqICAgLSAgTWFudGlzc2FcbiAqXG4gKiB8c3xlZWVlZWVlZXxtbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tfFxuICogMzF8IDMwLTIzICB8ICAyMiAgICBcdC0gICAgICAgMCAgICAgICB8XG4gKlxuICogVGhlIGV4cG9uZW50IGlzIHN0b3JlZCBpbiBhIGJpYXNlZCBpbnB1dC4gVGhlIGJpYXMgaW4gdGhpcyBjYXNlIDEyNy5cbiAqIFRoZXJlZm9yZSwgb3VyIGV4cG9uZW50IGlzIGVxdWFsIHRvIHRoZSA4LWJpdCB2YWx1ZSAtIDEyNy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBhIG51bWJlciBpcyBub3JtYWxpemVkIGluIElFRUUsIHRoYXQgbWVhbnMgdGhhdCB0aGUgbWFudGlzc2EgaGFzXG4gKiBhbiBpbXBsaWNpdCBvbmUgdGhhdCB3ZSBkb24ndCBzZWUuIFNvIHJlYWxseSB0aGUgdmFsdWUgc3RvcmVkIGlzIDEubS5cbiAqIEhvd2V2ZXIsIGlmIHRoZSBleHBvbmVudCBpcyBhbGwgemVyb3MsIHRoZW4gaW5zdGVhZCB3ZSBoYXZlIHRvIHNoaWZ0XG4gKiBldmVyeXRoaW5nIHRvIHRoZSByaWdodCBvbmUgYW5kIHRoZXJlIGlzIG5vIG1vcmUgaW1wbGljaXQgb25lLlxuICpcbiAqIFNwZWNpYWwgdmFsdWVzOlxuICogIC0gUG9zaXRpdmUgSW5maW5pdHk6XG4gKlx0U2lnbjpcdFx0MFxuICpcdEV4cG9uZW50OiBcdEFsbCAxc1xuICpcdE1hbnRpc3NhOlx0MFxuICogIC0gTmVnYXRpdmUgSW5maW5pdHk6XG4gKlx0U2lnbjpcdFx0MVxuICpcdEV4cG9uZW50OiBcdEFsbCAxc1xuICpcdE1hbnRpc3NhOlx0MFxuICogIC0gTmFOOlxuICpcdFNpZ246XHRcdCpcbiAqXHRFeHBvbmVudDogXHRBbGwgMXNcbiAqXHRNYW50aXNzYTpcdG5vbi16ZXJvXG4gKiAgLSBaZXJvOlxuICpcdFNpZ246XHRcdCpcbiAqXHRFeHBvbmVudDpcdEFsbCAwc1xuICpcdE1hbnRpc3NhOlx0MFxuICpcbiAqIEluIHRoZSBjYXNlIG9mIHplcm8sIHRoZSBzaWduIGJpdCBkZXRlcm1pbmVzIHdoZXRoZXIgd2UgZ2V0IGEgcG9zaXRpdmUgb3JcbiAqIG5lZ2F0aXZlIHplcm8uIEhvd2V2ZXIsIHNpbmNlIEphdmFzY3JpcHQgY2Fubm90IGRldGVybWluZSB0aGUgZGlmZmVyZW5jZVxuICogYmV0d2VlbiB0aGUgdHdvOiBpLmUuIC0wID09IDAsIHdlIGp1c3QgYWx3YXlzIHJldHVybiAwLlxuICpcbiAqL1xuZnVuY3Rpb24gcmZsb2F0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciBieXRlcyA9IFtdO1xuXHR2YXIgc2lnbiwgZXhwb25lbnQsIG1hbnRpc3NhLCB2YWw7XG5cdHZhciBiaWFzID0gMTI3O1xuXHR2YXIgbWF4ZXhwID0gMHhmZjtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdC8qIE5vcm1hbGl6ZSB0aGUgYnl0ZXMgdG8gYmUgaW4gZW5kaWFuIG9yZGVyICovXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHRieXRlc1swXSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdGJ5dGVzWzFdID0gYnVmZmVyW29mZnNldCsxXTtcblx0XHRieXRlc1syXSA9IGJ1ZmZlcltvZmZzZXQrMl07XG5cdFx0Ynl0ZXNbM10gPSBidWZmZXJbb2Zmc2V0KzNdO1xuXHR9IGVsc2Uge1xuXHRcdGJ5dGVzWzNdID0gYnVmZmVyW29mZnNldF07XG5cdFx0Ynl0ZXNbMl0gPSBidWZmZXJbb2Zmc2V0KzFdO1xuXHRcdGJ5dGVzWzFdID0gYnVmZmVyW29mZnNldCsyXTtcblx0XHRieXRlc1swXSA9IGJ1ZmZlcltvZmZzZXQrM107XG5cdH1cblxuXHRzaWduID0gYnl0ZXNbMF0gJiAweDgwO1xuXHRleHBvbmVudCA9IChieXRlc1swXSAmIDB4N2YpIDw8IDE7XG5cdGV4cG9uZW50IHw9IChieXRlc1sxXSAmIDB4ODApID4+PiA3O1xuXHRtYW50aXNzYSA9IChieXRlc1sxXSAmIDB4N2YpIDw8IDE2O1xuXHRtYW50aXNzYSB8PSBieXRlc1syXSA8PCA4O1xuXHRtYW50aXNzYSB8PSBieXRlc1szXTtcblxuXHQvKiBDaGVjayBmb3Igc3BlY2lhbCBjYXNlcyBiZWZvcmUgd2UgZG8gZ2VuZXJhbCBwYXJzaW5nICovXG5cdGlmICghc2lnbiAmJiBleHBvbmVudCA9PSBtYXhleHAgJiYgbWFudGlzc2EgPT09IDApXG5cdFx0cmV0dXJuIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG5cdGlmIChzaWduICYmIGV4cG9uZW50ID09IG1heGV4cCAmJiBtYW50aXNzYSA9PT0gMClcblx0XHRyZXR1cm4gKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG5cblx0aWYgKGV4cG9uZW50ID09IG1heGV4cCAmJiBtYW50aXNzYSAhPT0gMClcblx0XHRyZXR1cm4gKE51bWJlci5OYU4pO1xuXG5cdC8qXG5cdCAqIEphdmFzY3JpcHQgcmVhbGx5IGRvZXNuJ3QgaGF2ZSBzdXBwb3J0IGZvciBwb3NpdGl2ZSBvciBuZWdhdGl2ZSB6ZXJvLlxuXHQgKiBTbyB3ZSdyZSBub3QgZ29pbmcgdG8gdHJ5IGFuZCBnaXZlIGl0IHRvIHlvdS4gVGhhdCB3b3VsZCBiZSBqdXN0XG5cdCAqIHBsYWluIHdlaXJkLiBCZXNpZGVzIC0wID09IDAuXG5cdCAqL1xuXHRpZiAoZXhwb25lbnQgPT09IDAgJiYgbWFudGlzc2EgPT09IDApXG5cdFx0cmV0dXJuICgwKTtcblxuXHQvKlxuXHQgKiBOb3cgd2UgY2FuIGRlYWwgd2l0aCB0aGUgYmlhcyBhbmQgdGhlIGRldGVybWluZSB3aGV0aGVyIHRoZSBtYW50aXNzYVxuXHQgKiBoYXMgdGhlIGltcGxpY2l0IG9uZSBvciBub3QuXG5cdCAqL1xuXHRleHBvbmVudCAtPSBiaWFzO1xuXHRpZiAoZXhwb25lbnQgPT0gLWJpYXMpIHtcblx0XHRleHBvbmVudCsrO1xuXHRcdHZhbCA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gMTtcblx0fVxuXG5cdHZhbCA9ICh2YWwgKyBtYW50aXNzYSAqIE1hdGgucG93KDIsIC0yMykpICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuXG5cdGlmIChzaWduKVxuXHRcdHZhbCAqPSAtMTtcblxuXHRyZXR1cm4gKHZhbCk7XG59XG5cbi8qXG4gKiBEb3VibGVzIGluIElFRUUgNzU0IGFyZSBsaWtlIHRoZWlyIGJyb3RoZXJzIGV4Y2VwdCBmb3IgYSBmZXcgY2hhbmdlcyBhbmRcbiAqIGluY3JlYXNlcyBpbiBzaXplOlxuICogICAtIFRoZSBleHBvbmVudCBpcyBub3cgMTEgYml0c1xuICogICAtIFRoZSBtYW50aXNzYSBpcyBub3cgNTIgYml0c1xuICogICAtIFRoZSBiaWFzIGlzIG5vdyAxMDIzXG4gKlxuICogfHN8ZWVlZWVlZWVlZWV8bW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbXxcbiAqIDYzfCA2MiAtIDUyICAgfCBcdDUxXHRcdC1cdFx0XHQwICAgICB8XG4gKiA2M3wgNjIgLSA1MiAgIHwgICAgICA1MSAgICAgICAgICAgICAgLSAgICAgICAgICAgICAgICAgICAgICAgMCAgICAgfFxuICpcbiAqIFdoaWxlIHRoZSBzaXplIGhhcyBpbmNyZWFzZWQgYSBmYWlyIGFtb3VudCwgd2UncmUgZ29pbmcgdG8gZW5kIHVwIGtlZXBpbmcgdGhlXG4gKiBzYW1lIGdlbmVyYWwgZm9ybXVsYSBmb3IgY2FsY3VsYXRpbmcgdGhlIGZpbmFsIHZhbHVlLiBBcyBhIHJlbWluZGVyLCB0aGlzXG4gKiBmb3JtdWxhIGlzOlxuICpcbiAqICgtMSlecyAqIChuICsgbSkgKiAyXihlLWIpXG4gKlxuICogV2hlcmU6XG4gKlx0c1x0aXMgdGhlIHNpZ24gYml0XG4gKlx0blx0aXMgKGV4cG9uZW50ID4gMCkgPyAxIDogMCAtLSBEZXRlcm1pbmVzIHdoZXRoZXIgd2UncmUgbm9ybWFsaXplZFxuICpcdFx0XHRcdFx0ICAgICBvciBub3RcbiAqXHRtXHRpcyB0aGUgbWFudGlzc2FcbiAqXHRlXHRpcyB0aGUgZXhwb25lbnQgc3BlY2lmaWVkXG4gKlx0Ylx0aXMgdGhlIGJpYXMgZm9yIHRoZSBleHBvbmVudFxuICpcbiAqL1xuZnVuY3Rpb24gcmRvdWJsZShidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgYnl0ZXMgPSBbXTtcblx0dmFyIHNpZ24sIGV4cG9uZW50LCBtYW50aXNzYSwgdmFsLCBsb3dtYW50O1xuXHR2YXIgYmlhcyA9IDEwMjM7XG5cdHZhciBtYXhleHAgPSAweDdmZjtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgNyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdC8qIE5vcm1hbGl6ZSB0aGUgYnl0ZXMgdG8gYmUgaW4gZW5kaWFuIG9yZGVyICovXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHRieXRlc1swXSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdGJ5dGVzWzFdID0gYnVmZmVyW29mZnNldCsxXTtcblx0XHRieXRlc1syXSA9IGJ1ZmZlcltvZmZzZXQrMl07XG5cdFx0Ynl0ZXNbM10gPSBidWZmZXJbb2Zmc2V0KzNdO1xuXHRcdGJ5dGVzWzRdID0gYnVmZmVyW29mZnNldCs0XTtcblx0XHRieXRlc1s1XSA9IGJ1ZmZlcltvZmZzZXQrNV07XG5cdFx0Ynl0ZXNbNl0gPSBidWZmZXJbb2Zmc2V0KzZdO1xuXHRcdGJ5dGVzWzddID0gYnVmZmVyW29mZnNldCs3XTtcblx0fSBlbHNlIHtcblx0XHRieXRlc1s3XSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdGJ5dGVzWzZdID0gYnVmZmVyW29mZnNldCsxXTtcblx0XHRieXRlc1s1XSA9IGJ1ZmZlcltvZmZzZXQrMl07XG5cdFx0Ynl0ZXNbNF0gPSBidWZmZXJbb2Zmc2V0KzNdO1xuXHRcdGJ5dGVzWzNdID0gYnVmZmVyW29mZnNldCs0XTtcblx0XHRieXRlc1syXSA9IGJ1ZmZlcltvZmZzZXQrNV07XG5cdFx0Ynl0ZXNbMV0gPSBidWZmZXJbb2Zmc2V0KzZdO1xuXHRcdGJ5dGVzWzBdID0gYnVmZmVyW29mZnNldCs3XTtcblx0fVxuXG5cdC8qXG5cdCAqIFdlIGNhbiBjb25zdHJ1Y3QgdGhlIGV4cG9uZW50IGFuZCBtYW50aXNzYSB0aGUgc2FtZSB3YXkgYXMgd2UgZGlkIGluXG5cdCAqIHRoZSBjYXNlIG9mIGEgZmxvYXQsIGp1c3QgaW5jcmVhc2UgdGhlIHJhbmdlIG9mIHRoZSBleHBvbmVudC5cblx0ICovXG5cdHNpZ24gPSBieXRlc1swXSAmIDB4ODA7XG5cdGV4cG9uZW50ID0gKGJ5dGVzWzBdICYgMHg3ZikgPDwgNDtcblx0ZXhwb25lbnQgfD0gKGJ5dGVzWzFdICYgMHhmMCkgPj4+IDQ7XG5cblx0Lypcblx0ICogVGhpcyBpcyBnb2luZyB0byBiZSB1Z2x5IGJ1dCB0aGVuIGFnYWluLCB3ZSdyZSBkZWFsaW5nIHdpdGggSUVFRSA3NTQuXG5cdCAqIFRoaXMgY291bGQgcHJvYmFibHkgYmUgZG9uZSBhcyBhIG5vZGUgYWRkIG9uIGluIGEgZmV3IGxpbmVzIG9mIEMrKyxcblx0ICogYnV0IG9oIHdlJ2xsLCB3ZSd2ZSBtYWRlIGl0IHRoaXMgZmFyIHNvIGxldCdzIGJlIG5hdGl2ZSB0aGUgcmVzdCBvZlxuXHQgKiB0aGUgd2F5Li4uXG5cdCAqXG5cdCAqIFdoYXQgd2UncmUgZ29pbmcgdG8gZG8gaXMgYnJlYWsgdGhlIG1hbnRpc3NhIGludG8gdHdvIHBhcnRzLCB0aGVcblx0ICogbG93ZXIgMjQgYml0cyBhbmQgdGhlIHVwcGVyIDI4IGJpdHMuIFdlJ2xsIG11bHRpcGx5IHRoZSB1cHBlciAyOCBiaXRzXG5cdCAqIGJ5IHRoZSBhcHByb3ByaWF0ZSBwb3dlciBhbmQgdGhlbiBhZGQgaW4gdGhlIGxvd2VyIDI0LWJpdHMuIE5vdFxuXHQgKiByZWFsbHkgdGhhdCBncmVhdC4gSXQncyBwcmV0dHkgbXVjaCBhIGdpYW50IGtsdWRnZSB0byBkZWFsIHdpdGhcblx0ICogSmF2YXNjcmlwdCBlY2NlbnRyaWNpdGllcyBhcm91bmQgbnVtYmVycy5cblx0ICovXG5cdGxvd21hbnQgPSBieXRlc1s3XTtcblx0bG93bWFudCB8PSBieXRlc1s2XSA8PCA4O1xuXHRsb3dtYW50IHw9IGJ5dGVzWzVdIDw8IDE2O1xuXHRtYW50aXNzYSA9IGJ5dGVzWzRdO1xuXHRtYW50aXNzYSB8PSBieXRlc1szXSA8PCA4O1xuXHRtYW50aXNzYSB8PSBieXRlc1syXSA8PCAxNjtcblx0bWFudGlzc2EgfD0gKGJ5dGVzWzFdICYgMHgwZikgPDwgMjQ7XG5cdG1hbnRpc3NhICo9IE1hdGgucG93KDIsIDI0KTsgLyogRXF1aXZhbGVudCB0byA8PCAyNCwgYnV0IEpTIGNvbXBhdCAqL1xuXHRtYW50aXNzYSArPSBsb3dtYW50O1xuXG5cdC8qIENoZWNrIGZvciBzcGVjaWFsIGNhc2VzIGJlZm9yZSB3ZSBkbyBnZW5lcmFsIHBhcnNpbmcgKi9cblx0aWYgKCFzaWduICYmIGV4cG9uZW50ID09IG1heGV4cCAmJiBtYW50aXNzYSA9PT0gMClcblx0XHRyZXR1cm4gKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cblx0aWYgKHNpZ24gJiYgZXhwb25lbnQgPT0gbWF4ZXhwICYmIG1hbnRpc3NhID09PSAwKVxuXHRcdHJldHVybiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblxuXHRpZiAoZXhwb25lbnQgPT0gbWF4ZXhwICYmIG1hbnRpc3NhICE9PSAwKVxuXHRcdHJldHVybiAoTnVtYmVyLk5hTik7XG5cblx0Lypcblx0ICogSmF2YXNjcmlwdCByZWFsbHkgZG9lc24ndCBoYXZlIHN1cHBvcnQgZm9yIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIHplcm8uXG5cdCAqIFNvIHdlJ3JlIG5vdCBnb2luZyB0byB0cnkgYW5kIGdpdmUgaXQgdG8geW91LiBUaGF0IHdvdWxkIGJlIGp1c3Rcblx0ICogcGxhaW4gd2VpcmQuIEJlc2lkZXMgLTAgPT0gMC5cblx0ICovXG5cdGlmIChleHBvbmVudCA9PT0gMCAmJiBtYW50aXNzYSA9PT0gMClcblx0XHRyZXR1cm4gKDApO1xuXG5cdC8qXG5cdCAqIE5vdyB3ZSBjYW4gZGVhbCB3aXRoIHRoZSBiaWFzIGFuZCB0aGUgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG1hbnRpc3NhXG5cdCAqIGhhcyB0aGUgaW1wbGljaXQgb25lIG9yIG5vdC5cblx0ICovXG5cdGV4cG9uZW50IC09IGJpYXM7XG5cdGlmIChleHBvbmVudCA9PSAtYmlhcykge1xuXHRcdGV4cG9uZW50Kys7XG5cdFx0dmFsID0gMDtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSAxO1xuXHR9XG5cblx0dmFsID0gKHZhbCArIG1hbnRpc3NhICogTWF0aC5wb3coMiwgLTUyKSkgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG5cblx0aWYgKHNpZ24pXG5cdFx0dmFsICo9IC0xO1xuXG5cdHJldHVybiAodmFsKTtcbn1cblxuLypcbiAqIE5vdyB0aGF0IHdlIGhhdmUgZ29uZSB0aHJvdWdoIHRoZSBwYWluIG9mIHJlYWRpbmcgdGhlIGluZGl2aWR1YWwgdHlwZXMsIHdlJ3JlXG4gKiBwcm9iYWJseSBnb2luZyB0byB3YW50IHNvbWUgd2F5IHRvIHdyaXRlIHRoZXNlIGJhY2suIE5vbmUgb2YgdGhpcyBpcyBnb2luZyB0b1xuICogYmUgZ29vZC4gQnV0IHNpbmNlIHdlIGhhdmUgSmF2YXNjcmlwdCBudW1iZXJzIHRoaXMgc2hvdWxkIGNlcnRhaW5seSBiZSBtb3JlXG4gKiBpbnRlcmVzdGluZy4gVGhvdWdoIHdlIGNhbiBjb25zdHJhaW4gdGhpcyBlbmQgYSBsaXR0bGUgYml0IG1vcmUgaW4gd2hhdCBpc1xuICogdmFsaWQuIEZvciBub3csIGxldCdzIGdvIGJhY2sgdG8gb3VyIGZyaWVuZHMgdGhlIHVuc2lnbmVkIHZhbHVlLlxuICovXG5cbi8qXG4gKiBVbnNpZ25lZCBudW1iZXJzIHNlZW0gZGVjZXB0aXZlbHkgZWFzeS4gSGVyZSBhcmUgdGhlIGdlbmVyYWwgc3RlcHMgYW5kIHJ1bGVzXG4gKiB0aGF0IHdlIGFyZSBnb2luZyB0byB0YWtlOlxuICogICAtICBJZiB0aGUgbnVtYmVyIGlzIG5lZ2F0aXZlLCB0aHJvdyBhbiBFcnJvclxuICogICAtICBUcnVuY2F0ZSBhbnkgZmxvYXRpbmcgcG9pbnQgcG9ydGlvblxuICogICAtICBUYWtlIHRoZSBtb2R1bHVzIG9mIHRoZSBudW1iZXIgaW4gb3VyIGJhc2VcbiAqICAgLSAgV3JpdGUgaXQgb3V0IHRvIHRoZSBidWZmZXIgaW4gdGhlIGVuZGlhbiBmb3JtYXQgcmVxdWVzdGVkIGF0IHRoZSBvZmZzZXRcbiAqL1xuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXQgaXNcbiAqIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90IGV4Y2VlZCB0aGVcbiAqIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqXG4gKlx0dmFsdWVcdFx0VGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKlx0bWF4XHRcdFRoZSBtYXhpbXVtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHByZXB1aW50KHZhbHVlLCBtYXgpXG57XG5cdGlmICh0eXBlb2YgKHZhbHVlKSAhPSAnbnVtYmVyJylcblx0XHR0aHJvdyAobmV3IChFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpKSk7XG5cblx0aWYgKHZhbHVlIDwgMClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiAnICtcblx0XHQgICAgJ3Vuc2lnbmVkIHZhbHVlJykpO1xuXG5cdGlmICh2YWx1ZSA+IG1heClcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciAnICtcblx0XHQgICAgJ3R5cGUnKSk7XG5cblx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpKTtcblxuXHRyZXR1cm4gKHZhbHVlKTtcbn1cblxuLypcbiAqIDgtYml0IHZlcnNpb24sIGNsYXNzeS4gV2UgY2FuIGlnbm9yZSBlbmRpYW5uZXNzIHdoaWNoIGlzIGdvb2QuXG4gKi9cbmZ1bmN0aW9uIHd1aW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbDtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSBwcmVwdWludCh2YWx1ZSwgMHhmZik7XG5cdGJ1ZmZlcltvZmZzZXRdID0gdmFsO1xufVxuXG4vKlxuICogUHJldHR5IG11Y2ggdGhlIHNhbWUgYXMgdGhlIDgtYml0IHZlcnNpb24sIGp1c3QgdGhpcyB0aW1lIHdlIG5lZWQgdG8gd29ycnlcbiAqIGFib3V0IGVuZGlhbiByZWxhdGVkIGlzc3Vlcy5cbiAqL1xuZnVuY3Rpb24gd2dpbnQxNih2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9ICh2YWwgJiAweGZmMDApID4+PiA4O1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSB2YWwgJiAweDAwZmY7XG5cdH0gZWxzZSB7XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9ICh2YWwgJiAweGZmMDApID4+PiA4O1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gdmFsICYgMHgwMGZmO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHd1aW50MTYodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWw7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMSA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHByZXB1aW50KHZhbHVlLCAweGZmZmYpO1xuXHR3Z2ludDE2KHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG59XG5cbi8qXG4gKiBUaGUgMzItYml0IHZlcnNpb24gaXMgZ29pbmcgdG8gaGF2ZSB0byBiZSBhIGxpdHRsZSBkaWZmZXJlbnQgdW5mb3J0dW5hdGVseS5cbiAqIFdlIGNhbid0IHF1aXRlIGJpdHNoaWZ0IHRvIGdldCB0aGUgbGFyZ2VzdCBieXRlLCBiZWNhdXNlIHRoYXQgd291bGQgZW5kIHVwXG4gKiBnZXR0aW5nIHVzIGNhdWdodCBieSB0aGUgc2lnbmVkIHZhbHVlcy5cbiAqXG4gKiBBbmQgeWVzLCB3ZSBkbyB3YW50IHRvIHN1YnRyYWN0IG91dCB0aGUgbG93ZXIgcGFydCBieSBkZWZhdWx0LiBUaGlzIG1lYW5zXG4gKiB0aGF0IHdoZW4gd2UgZG8gdGhlIGRpdmlzaW9uLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBiaXQgc2hpZnQgYW5kIHdlIHdvbid0XG4gKiBlbmQgdXAgZ2VuZXJhdGluZyBhIGZsb2F0aW5nIHBvaW50IHZhbHVlLiBJZiB3ZSBkaWQgZ2VuZXJhdGUgYSBmbG9hdGluZyBwb2ludFxuICogdmFsdWUgd2UnZCBoYXZlIHRvIHRydW5jYXRlIGl0IGludGVsbGlnZW50bHksIHRoaXMgc2F2ZXMgdXMgdGhhdCBwcm9ibGVtIGFuZFxuICogbWF5IGV2ZW4gYmUgc29tZXdoYXQgZmFzdGVyIHVuZGVyIHRoZSBob29kLlxuICovXG5mdW5jdGlvbiB3Z2ludDMyKHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gKHZhbCAtICh2YWwgJiAweDAwZmZmZmZmKSkgLyBNYXRoLnBvdygyLCAyNCk7XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9ICh2YWwgPj4+IDE2KSAmIDB4ZmY7XG5cdFx0YnVmZmVyW29mZnNldCsyXSA9ICh2YWwgPj4+IDgpICYgMHhmZjtcblx0XHRidWZmZXJbb2Zmc2V0KzNdID0gdmFsICYgMHhmZjtcblx0fSBlbHNlIHtcblx0XHRidWZmZXJbb2Zmc2V0KzNdID0gKHZhbCAtICh2YWwgJiAweDAwZmZmZmZmKSkgL1xuXHRcdCAgICBNYXRoLnBvdygyLCAyNCk7XG5cdFx0YnVmZmVyW29mZnNldCsyXSA9ICh2YWwgPj4+IDE2KSAmIDB4ZmY7XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9ICh2YWwgPj4+IDgpICYgMHhmZjtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IHZhbCAmIDB4ZmY7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3VpbnQzMih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbDtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcHJlcHVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpO1xuXHR3Z2ludDMyKHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG59XG5cbi8qXG4gKiBVbmxpa2UgdGhlIG90aGVyIHZlcnNpb25zLCB3ZSBleHBlY3QgdGhlIHZhbHVlIHRvIGJlIGluIHRoZSBmb3JtIG9mIHR3b1xuICogYXJyYXlzIHdoZXJlIHZhbHVlWzBdIDw8IDMyICsgdmFsdWVbMV0gd291bGQgcmVzdWx0IGluIHRoZSB2YWx1ZSB0aGF0IHdlXG4gKiB3YW50LlxuICovXG5mdW5jdGlvbiB3Z2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0d2dpbnQzMih2YWx1ZVswXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdFx0d2dpbnQzMih2YWx1ZVsxXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCs0KTtcblx0fSBlbHNlIHtcblx0XHR3Z2ludDMyKHZhbHVlWzBdLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KzQpO1xuXHRcdHdnaW50MzIodmFsdWVbMV0sIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHd1aW50NjQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheScpKTtcblxuXHRpZiAodmFsdWUubGVuZ3RoICE9IDIpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggMicpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgNyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHByZXB1aW50KHZhbHVlWzBdLCAweGZmZmZmZmZmKTtcblx0cHJlcHVpbnQodmFsdWVbMV0sIDB4ZmZmZmZmZmYpO1xuXHR3Z2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICpcdHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKlx0d2UgZG8gdGhlIGZvbGxvd2luZyBjb21wdXRhdGlvbjpcbiAqXHRtYiArIHZhbCArIDEsIHdoZXJlXG4gKlx0bWJcdGlzIHRoZSBtYXhpbXVtIHVuc2lnbmVkIHZhbHVlIGluIHRoYXQgYnl0ZSBzaXplXG4gKlx0dmFsXHRpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqXG4gKiBUaHVzIHRoZSBvdmVyYWxsIGZsb3cgaXM6XG4gKiAgIC0gIFRydW5jYXRlIHRoZSBmbG9hdGluZyBwb2ludCBwYXJ0IG9mIHRoZSBudW1iZXJcbiAqICAgLSAgV2UgZG9uJ3QgaGF2ZSB0byB0YWtlIHRoZSBtb2R1bHVzLCBiZWNhdXNlIHRoZSB1bnNpZ25lZCB2ZXJzaW9ucyB3aWxsXG4gKiAgIFx0dGFrZSBjYXJlIG9mIHRoYXQgZm9yIHVzLiBBbmQgd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGF0XG4gKiAgIFx0cG90ZW50aWFsbHkgY2F1c2luZyBiYWQgdGhpbmdzIHRvIGhhcHBlbiBiZWNhdXNlIG9mIHNpZ24gZXh0ZW5zaW9uXG4gKiAgIC0gIFBhc3MgaXQgb2ZmIHRvIHRoZSBhcHByb3ByaWF0ZSB1bnNpZ25lZCB2ZXJzaW9uLCBwb3RlbnRpYWxseSBtb2RpZnlpbmdcbiAqXHR0aGUgbmVnYXRpdmUgcG9ydGlvbnMgYXMgbmVjZXNzYXJ5LlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiBwcmVwc2ludCh2YWx1ZSwgbWF4LCBtaW4pXG57XG5cdGlmICh0eXBlb2YgKHZhbHVlKSAhPSAnbnVtYmVyJylcblx0XHR0aHJvdyAobmV3IChFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpKSk7XG5cblx0aWYgKHZhbHVlID4gbWF4KVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpKTtcblxuXHRpZiAodmFsdWUgPCBtaW4pXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpKTtcblxuXHRpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50JykpO1xuXG5cdHJldHVybiAodmFsdWUpO1xufVxuXG4vKlxuICogVGhlIDgtYml0IHZlcnNpb24gb2YgdGhlIHNpZ25lZCB2YWx1ZS4gT3ZlcmFsbCwgZmFpcmx5IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqL1xuZnVuY3Rpb24gd3NpbnQ4KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHByZXBzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG5cdGlmICh2YWwgPj0gMClcblx0XHR3dWludDgodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0ZWxzZVxuXHRcdHd1aW50OCgweGZmICsgdmFsICsgMSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG59XG5cbi8qXG4gKiBUaGUgMTYtYml0IHZlcnNpb24gb2YgdGhlIHNpZ25lZCB2YWx1ZS4gQWxzbywgZmFpcmx5IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqL1xuZnVuY3Rpb24gd3NpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbDtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAxID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcHJlcHNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG5cdGlmICh2YWwgPj0gMClcblx0XHR3Z2ludDE2KHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdGVsc2Vcblx0XHR3Z2ludDE2KDB4ZmZmZiArIHZhbCArIDEsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXG59XG5cbi8qXG4gKiBXZSBjYW4gZG8gdGhpcyByZWxhdGl2ZWx5IGVhc2lseSBieSBsZXZlcmFnaW5nIHRoZSBjb2RlIHVzZWQgZm9yIDMyLWJpdFxuICogdW5zaWduZWQgY29kZS5cbiAqL1xuZnVuY3Rpb24gd3NpbnQzMih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbDtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcHJlcHNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcblx0aWYgKHZhbCA+PSAwKVxuXHRcdHdnaW50MzIodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0ZWxzZVxuXHRcdHdnaW50MzIoMHhmZmZmZmZmZiArIHZhbCArIDEsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xufVxuXG4vKlxuICogVGhlIHNpZ25lZCA2NCBiaXQgaW50ZWdlciBzaG91bGQgYnkgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHdoZW4gcmVjZWl2ZWQuXG4gKiBNYWlubHkgaXQgc2hvdWxkIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheSBvZiB0d28gaW50ZWdlcnMgd2hlcmVcbiAqIHZhbHVlWzBdIDw8IDMyICsgdmFsdWVbMV0gaXMgdGhlIGRlc2lyZWQgbnVtYmVyLiBGdXJ0aGVybW9yZSwgdGhlIHR3byB2YWx1ZXNcbiAqIG5lZWQgdG8gYmUgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHdzaW50NjQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2enBvcywgdm9wb3M7XG5cdHZhciB2YWxzID0gbmV3IEFycmF5KDIpO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheScpKTtcblxuXHRpZiAodmFsdWUubGVuZ3RoICE9IDIpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggMicpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgNyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdC8qXG5cdCAqIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSB0aGUgc2FtZSBzaWduIG9uIGJvdGggdmFsdWVzLiBUaGVcblx0ICogaG9raWVzdCB3YXkgdG8gdG8gZG8gdGhpcyBpcyB0byBtdWx0aXBseSB0aGUgbnVtYmVyIGJ5ICtpbmYuIElmIHdlIGRvXG5cdCAqIHRoaXMsIHdlJ2xsIGdldCBlaXRoZXIgKy8taW5mIGRlcGVuZGluZyBvbiB0aGUgc2lnbiBvZiB0aGUgdmFsdWUuXG5cdCAqIE9uY2Ugd2UgaGF2ZSB0aGlzLCB3ZSBjYW4gY29tcGFyZSBpdCB0byAraW5mIHRvIHNlZSBpZiB0aGUgbnVtYmVyIGlzXG5cdCAqIHBvc2l0aXZlIG9yIG5vdC5cblx0ICovXG5cdHZ6cG9zID0gKHZhbHVlWzBdICogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSA9PVxuXHQgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR2b3BvcyA9ICh2YWx1ZVsxXSAqIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgPT1cblx0ICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuXHQvKlxuXHQgKiBJZiBlaXRoZXIgb2YgdGhlc2UgaXMgemVybywgdGhlbiB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoaXMgY2hlY2suXG5cdCAqL1xuXHRpZiAodmFsdWVbMF0gIT0gMCAmJiB2YWx1ZVsxXSAhPSAwICYmIHZ6cG9zICE9IHZvcG9zKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0JvdGggZW50cmllcyBpbiB0aGUgYXJyYXkgbXVzdCBoYXZlICcgK1xuXHRcdCAgICAndGhlIHNhbWUgc2lnbicpKTtcblxuXHQvKlxuXHQgKiBEb2luZyB2ZXJpZmljYXRpb24gZm9yIGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGlzIGFjdHVhbGx5IGEgYmlnXG5cdCAqIHRyaWNraWVyIHRoYW4gaXQgYXBwZWFycy4gV2UgY2FuJ3QgcXVpdGUgdXNlIG91ciBzdGFuZGFyZCB0ZWNobmlxdWVzXG5cdCAqIGJlY2F1c2Ugd2UgbmVlZCB0byBjb21wYXJlIGJvdGggc2V0cyBvZiB2YWx1ZXMuIFRoZSBmaXJzdCB2YWx1ZSBpc1xuXHQgKiBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkLiBJZiB0aGUgZmlyc3QgdmFsdWUgaXMgYmVvbmQgdGhlIGV4dHJlbWVzIHRoYW5cblx0ICogd2UgZXJyb3Igb3V0LiBIb3dldmVyLCB0aGUgdmFsaWQgcmFuZ2Ugb2YgdGhlIHNlY29uZCB2YWx1ZSB2YXJpZXNcblx0ICogYmFzZWQgb24gdGhlIGZpcnN0IG9uZS4gSWYgdGhlIGZpcnN0IHZhbHVlIGlzIG5lZ2F0aXZlLCBhbmQgKm5vdCogdGhlXG5cdCAqIGxhcmdlc3QgbmVnYXRpdmUgdmFsdWUsIHRoYW4gaXQgY2FuIGJlIGFueSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgW1xuXHQgKiAwLCAweGZmZmZmZmZmIF0uIElmIGl0IGlzIHRoZSBsYXJnZXN0IG5lZ2F0aXZlIG51bWJlciwgaXQgbXVzdCBiZVxuXHQgKiB6ZXJvLlxuXHQgKlxuXHQgKiBJZiB0aGUgZmlyc3QgbnVtYmVyIGlzIHBvc2l0aXZlLCB0aGFuIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlXG5cdCAqIHZhbHVlIGlzLiBXZSBqdXN0IHNpbXBseSBoYXZlIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgdmFsaWQgcG9zaXRpdmVcblx0ICogaW50ZWdlci5cblx0ICovXG5cdGlmICh2enBvcykge1xuXHRcdHByZXB1aW50KHZhbHVlWzBdLCAweDdmZmZmZmZmKTtcblx0XHRwcmVwdWludCh2YWx1ZVsxXSwgMHhmZmZmZmZmZik7XG5cdH0gZWxzZSB7XG5cdFx0cHJlcHNpbnQodmFsdWVbMF0sIDAsIC0weDgwMDAwMDAwKTtcblx0XHRwcmVwc2ludCh2YWx1ZVsxXSwgMCwgLTB4ZmZmZmZmZmYpO1xuXHRcdGlmICh2YWx1ZVswXSA9PSAtMHg4MDAwMDAwMCAmJiB2YWx1ZVsxXSAhPSAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gJyArXG5cdFx0XHQgICAgJ2FsbG93ZWQgdmFsdWUnKSk7XG5cdH1cblxuXHQvKiBGaXggbmVnYXRpdmUgbnVtYmVycyAqL1xuXHRpZiAodmFsdWVbMF0gPCAwIHx8IHZhbHVlWzFdIDwgMCkge1xuXHRcdHZhbHNbMF0gPSAweGZmZmZmZmZmIC0gTWF0aC5hYnModmFsdWVbMF0pO1xuXHRcdHZhbHNbMV0gPSAweDEwMDAwMDAwMCAtIE1hdGguYWJzKHZhbHVlWzFdKTtcblx0XHRpZiAodmFsc1sxXSA9PSAweDEwMDAwMDAwMCkge1xuXHRcdFx0dmFsc1sxXSA9IDA7XG5cdFx0XHR2YWxzWzBdKys7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHZhbHNbMF0gPSB2YWx1ZVswXTtcblx0XHR2YWxzWzFdID0gdmFsdWVbMV07XG5cdH1cblx0d2dpbnQ2NCh2YWxzLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuLypcbiAqIE5vdyB3ZSBhcmUgbW92aW5nIG9udG8gdGhlIHdlaXJkZXIgb2YgdGhlc2UsIHRoZSBmbG9hdCBhbmQgZG91YmxlLiBGb3IgdGhpc1xuICogd2UncmUgZ29pbmcgdG8ganVzdCBoYXZlIHRvIGRvIHNvbWV0aGluZyB0aGF0J3MgcHJldHR5IHdlaXJkLiBGaXJzdCBvZmYsIHdlXG4gKiBoYXZlIG5vIHdheSB0byBnZXQgYXQgdGhlIHVuZGVybHlpbmcgZmxvYXQgcmVwcmVzZW50YXRpb24sIGF0IGxlYXN0IG5vdFxuICogZWFzaWx5LiBCdXQgdGhhdCBkb2Vzbid0IG1lYW4gd2UgY2FuJ3QgZmlndXJlIGl0IG91dCwgd2UganVzdCBoYXZlIHRvIHVzZSBvdXJcbiAqIGhlYWRzLlxuICpcbiAqIE9uZSBtaWdodCBwcm9wb3NlIHRvIHVzZSBOdW1iZXIudG9TdHJpbmcoMikuIE9mIGNvdXJzZSwgdGhpcyBpcyBub3QgcmVhbGx5XG4gKiB0aGF0IGdvb2QsIGJlY2F1c2UgdGhlIEVDTUFTY3JpcHQgMjYyIHYzIFN0YW5kYXJkIHNheXMgdGhlIGZvbGxvd2luZyBTZWN0aW9uXG4gKiAxNS43LjQuMi1OdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nIChyYWRpeCk6XG4gKlxuICogSWYgcmFkaXggaXMgYW4gaW50ZWdlciBmcm9tIDIgdG8gMzYsIGJ1dCBub3QgMTAsIHRoZSByZXN1bHQgaXMgYSBzdHJpbmcsIHRoZVxuICogY2hvaWNlIG9mIHdoaWNoIGlzIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudC5cbiAqXG4gKiBXZWxsIHRoYXQgZG9lc24ndCByZWFsbHkgaGVscCB1cyBvbmUgYml0IG5vdyBkb2VzIGl0PyBXZSBjb3VsZCB1c2UgdGhlXG4gKiBzdGFuZGFyZCBiYXNlIDEwIHZlcnNpb24gb2YgdGhlIHN0cmluZywgYnV0IHRoYXQncyBqdXN0IGdvaW5nIHRvIGNyZWF0ZSBtb3JlXG4gKiBlcnJvcnMgYXMgd2UgZW5kIHVwIHRyeWluZyB0byBjb252ZXJ0IGl0IGJhY2sgdG8gYSBiaW5hcnkgdmFsdWUuIFNvLCByZWFsbHlcbiAqIHRoaXMganVzdCBtZWFucyB3ZSBoYXZlIHRvIGJlIG5vbi1sYXp5IGFuZCBwYXJzZSB0aGUgc3RydWN0dXJlIGludGVsbGlnZW50bHkuXG4gKlxuICogRmlyc3Qgb2ZmLCB3ZSBjYW4gZG8gdGhlIGJhc2ljIGNoZWNrczogTmFOLCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgaW5maW5pdHkuXG4gKlxuICogTm93IHRoYXQgdGhvc2UgYXJlIGRvbmUgd2UgY2FuIHdvcmsgYmFja3dhcmRzIHRvIGdlbmVyYXRlIHRoZSBtYW50aXNzYSBhbmRcbiAqIGV4cG9uZW50LlxuICpcbiAqIFRoZSBmaXJzdCB0aGluZyB3ZSBuZWVkIHRvIGRvIGlzIGRldGVybWluZSB0aGUgc2lnbiBiaXQsIGVhc3kgdG8gZG8sIGNoZWNrXG4gKiB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBsZXNzIHRoYW4gMC4gQW5kIGNvbnZlcnQgdGhlIG51bWJlciB0byBpdHMgYWJzb2x1dGVcbiAqIHZhbHVlIHJlcHJlc2VudGF0aW9uLiBOZXh0LCB3ZSBuZWVkIHRvIGRldGVybWluZSBpZiB0aGUgdmFsdWUgaXMgbGVzcyB0aGFuXG4gKiBvbmUgb3IgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG9uZSBhbmQgZnJvbSB0aGVyZSBkZXRlcm1pbmUgd2hhdCBwb3dlciB3YXNcbiAqIHVzZWQgdG8gZ2V0IHRoZXJlLiBXaGF0IGZvbGxvd3MgaXMgbm93IHNwZWNpZmljIHRvIGZsb2F0cywgdGhvdWdoIHRoZSBnZW5lcmFsXG4gKiBpZGVhcyBiZWhpbmQgdGhpcyB3aWxsIGhvbGQgZm9yIGRvdWJsZXMgYXMgd2VsbCwgYnV0IHRoZSBleGFjdCBudW1iZXJzXG4gKiBpbnZvbHZlZCB3aWxsIGNoYW5nZS5cbiAqXG4gKiBPbmNlIHdlIGhhdmUgdGhhdCBwb3dlciB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSBleHBvbmVudCBhbmQgdGhlIG1hbnRpc3NhLiBDYWxsXG4gKiB0aGUgdmFsdWUgdGhhdCBoYXMgdGhlIG51bWJlciBvZiBiaXRzIHRvIHJlYWNoIHRoZSBwb3dlciBlYml0cy4gSW4gdGhlXG4gKiBnZW5lcmFsIGNhc2UgdGhleSBoYXZlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqXHRleHBvbmVudFx0MTI3ICsgZWJpdHNcbiAqXHRtYW50aXNzYVx0dmFsdWUgKiAyXigyMyAtIGViaXRzKSAmIDB4N2ZmZmZmXG4gKlxuICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHZhbHVlIG9mIGViaXRzIGlzIDw9IC0xMjcgd2UgYXJlIG5vdyBpbiB0aGUgY2FzZSB3aGVyZVxuICogd2Ugbm8gbG9uZ2VyIGhhdmUgbm9ybWFsaXplZCBudW1iZXJzLiBJbiB0aGlzIGNhc2UgdGhlIHZhbHVlcyB0YWtlIG9uIHRoZVxuICogZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKiBcdGV4cG9uZW50XHQwXG4gKlx0bWFudGlzc2FcdHZhbHVlICogMl4xNDkgJiAweDdmZmZmZlxuICpcbiAqIE9uY2Ugd2UgaGF2ZSB0aGUgdmFsdWVzIGZvciB0aGUgc2lnbiwgbWFudGlzc2EsIGFuZCBleHBvbmVudC4gV2UgcmVjb25zdHJ1Y3RcbiAqIHRoZSBmb3VyIGJ5dGVzIGFzIGZvbGxvd3M6XG4gKlxuICpcdGJ5dGUwXHRcdHNpZ24gYml0IGFuZCBzZXZlbiBtb3N0IHNpZ25pZmljYW50IGJpdHMgZnJvbSB0aGUgZXhwXG4gKlx0XHRcdHNpZ24gPDwgNyB8IChleHBvbmVudCAmIDB4ZmUpID4+PiAxXG4gKlxuICpcdGJ5dGUxXHRcdGxzYiBmcm9tIHRoZSBleHBvbmVudCBhbmQgNyB0b3AgYml0cyBmcm9tIHRoZSBtYW50aXNzYVxuICpcdFx0XHQoZXhwb25lbnQgJiAweDAxKSA8PCA3IHwgKG1hbnRpc3NhICYgMHg3ZjAwMDApID4+PiAxNlxuICpcbiAqXHRieXRlMlx0XHRiaXRzIDgtMTUgKHplcm8gaW5kZXhpbmcpIGZyb20gbWFudGlzc2FcbiAqXHRcdFx0bWFudGlzc2EgJiAweGZmMDAgPj4gOFxuICpcbiAqXHRieXRlM1x0XHRiaXRzIDAtNyBmcm9tIG1hbnRpc3NhXG4gKlx0XHRcdG1hbnRpc3NhICYgMHhmZlxuICpcbiAqIE9uY2Ugd2UgaGF2ZSB0aGlzIHdlIGhhdmUgdG8gYXNzaWduIHRoZW0gaW50byB0aGUgYnVmZmVyIGluIHByb3BlciBlbmRpYW5cbiAqIG9yZGVyLlxuICovXG5cbi8qXG4gKiBDb21wdXRlIHRoZSBsb2cgYmFzZSAyIG9mIHRoZSB2YWx1ZS4gTm93LCBzb21lb25lIHdobyByZW1lbWJlcnMgYmFzaWNcbiAqIHByb3BlcnRpZXMgb2YgbG9nYXJpdGhtcyB3aWxsIHBvaW50IG91dCB0aGF0IHdlIGNvdWxkIHVzZSB0aGUgY2hhbmdlIG9mIGJhc2VcbiAqIGZvcm11bGEgZm9yIGxvZ3MsIGFuZCBpbiBmYWN0IHRoYXQgd291bGQgYmUgYXN0dXRlLCBiZWNhdXNlIHRoYXQncyB3aGF0IHdlJ2xsXG4gKiBkbyBmb3Igbm93LiBJdCBmZWVscyBjbGVhbmVyLCBhbGJlaXQgaXQgbWF5IGJlIGxlc3MgZWZmaWNpZW50IHRoYW4ganVzdFxuICogaXRlcmF0aW5nIGFuZCBkaXZpZGluZyBieSAyLiBXZSBtYXkgd2FudCB0byBjb21lIGJhY2sgYW5kIHJldmlzaXQgdGhhdCBzb21lXG4gKiBkYXkuXG4gKi9cbmZ1bmN0aW9uIGxvZzIodmFsdWUpXG57XG5cdHJldHVybiAoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5sb2coMikpO1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVybWluZSB0aGUgZXhwb25lbnQgb2YgdGhlIG51bWJlciB3ZSdyZSBsb29raW5nIGF0LlxuICovXG5mdW5jdGlvbiBpbnRleHAodmFsdWUpXG57XG5cdHJldHVybiAoTWF0aC5mbG9vcihsb2cyKHZhbHVlKSkpO1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVybWluZSB0aGUgZXhwb25lbnQgb2YgdGhlIGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGZyYWNleHAodmFsdWUpXG57XG5cdHJldHVybiAoTWF0aC5mbG9vcihsb2cyKHZhbHVlKSkpO1xufVxuXG5mdW5jdGlvbiB3ZmxvYXQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBzaWduLCBleHBvbmVudCwgbWFudGlzc2EsIGViaXRzO1xuXHR2YXIgYnl0ZXMgPSBbXTtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRpZiAoaXNOYU4odmFsdWUpKSB7XG5cdFx0c2lnbiA9IDA7XG5cdFx0ZXhwb25lbnQgPSAweGZmO1xuXHRcdG1hbnRpc3NhID0gMjM7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG5cdFx0c2lnbiA9IDA7XG5cdFx0ZXhwb25lbnQgPSAweGZmO1xuXHRcdG1hbnRpc3NhID0gMDtcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcblx0XHRzaWduID0gMTtcblx0XHRleHBvbmVudCA9IDB4ZmY7XG5cdFx0bWFudGlzc2EgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdC8qIFdlbGwgd2UgaGF2ZSBzb21lIHdvcmsgdG8gZG8gKi9cblxuXHRcdC8qIFRoYW5rZnVsbHkgdGhlIHNpZ24gYml0IGlzIHRyaXZpYWwgKi9cblx0XHRpZiAodmFsdWUgPCAwKSB7XG5cdFx0XHRzaWduID0gMTtcblx0XHRcdHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaWduID0gMDtcblx0XHR9XG5cblx0XHQvKiBVc2UgdGhlIGNvcnJlY3QgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIG51bWJlciBvZiBiaXRzICovXG5cdFx0aWYgKHZhbHVlIDwgMSlcblx0XHRcdGViaXRzID0gZnJhY2V4cCh2YWx1ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0ZWJpdHMgPSBpbnRleHAodmFsdWUpO1xuXG5cdFx0LyogVGltZSB0byBkZWFsIHdpdGggdGhlIGlzc3VlcyBzdXJyb3VuZGluZyBub3JtYWxpemF0aW9uICovXG5cdFx0aWYgKGViaXRzIDw9IC0xMjcpIHtcblx0XHRcdGV4cG9uZW50ID0gMDtcblx0XHRcdG1hbnRpc3NhID0gKHZhbHVlICogTWF0aC5wb3coMiwgMTQ5KSkgJiAweDdmZmZmZjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb25lbnQgPSAxMjcgKyBlYml0cztcblx0XHRcdG1hbnRpc3NhID0gdmFsdWUgKiBNYXRoLnBvdygyLCAyMyAtIGViaXRzKTtcblx0XHRcdG1hbnRpc3NhICY9IDB4N2ZmZmZmO1xuXHRcdH1cblx0fVxuXG5cdGJ5dGVzWzBdID0gc2lnbiA8PCA3IHwgKGV4cG9uZW50ICYgMHhmZSkgPj4+IDE7XG5cdGJ5dGVzWzFdID0gKGV4cG9uZW50ICYgMHgwMSkgPDwgNyB8IChtYW50aXNzYSAmIDB4N2YwMDAwKSA+Pj4gMTY7XG5cdGJ5dGVzWzJdID0gKG1hbnRpc3NhICYgMHgwMGZmMDApID4+PiA4O1xuXHRieXRlc1szXSA9IG1hbnRpc3NhICYgMHgwMDAwZmY7XG5cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gYnl0ZXNbMF07XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9IGJ5dGVzWzFdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMl0gPSBieXRlc1syXTtcblx0XHRidWZmZXJbb2Zmc2V0KzNdID0gYnl0ZXNbM107XG5cdH0gZWxzZSB7XG5cdFx0YnVmZmVyW29mZnNldF0gPSBieXRlc1szXTtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gYnl0ZXNbMl07XG5cdFx0YnVmZmVyW29mZnNldCsyXSA9IGJ5dGVzWzFdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrM10gPSBieXRlc1swXTtcblx0fVxufVxuXG4vKlxuICogTm93IHdlIG1vdmUgb250byBkb3VibGVzLiBEb3VibGVzIGFyZSBzaW1pbGFyIHRvIGZsb2F0cyBpbiBwcmV0dHkgbXVjaCBhbGxcbiAqIHdheXMgZXhjZXB0IHRoYXQgdGhlIHByb2Nlc3NpbmcgaXNuJ3QgcXVpdGUgYXMgc3RyYWlnaHRmb3J3YXJkIGJlY2F1c2Ugd2VcbiAqIGNhbid0IGFsd2F5cyB1c2Ugc2hpZnRpbmcsIGkuZS4gd2UgaGF2ZSA+IDMyIGJpdCB2YWx1ZXMuXG4gKlxuICogV2UncmUgZ29pbmcgdG8gcHJvY2VlZCBpbiBhbiBpZGVudGljYWwgZmFzaGlvbiB0byBmbG9hdHMgYW5kIHV0aWxpemUgdGhlIHNhbWVcbiAqIGhlbHBlciBmdW5jdGlvbnMuIEFsbCB0aGF0IHJlYWxseSBpcyBjaGFuZ2luZyBhcmUgdGhlIHNwZWNpZmljIHZhbHVlcyB0aGF0IHdlXG4gKiB1c2UgdG8gZG8gdGhlIGNhbGN1bGF0aW9ucy4gVGh1cywgdG8gcmV2aWV3IHdlIGhhdmUgdG8gZG8gdGhlIGZvbGxvd2luZy5cbiAqXG4gKiBGaXJzdCBnZXQgdGhlIHNpZ24gYml0IGFuZCBjb252ZXJ0IHRoZSB2YWx1ZSB0byBpdHMgYWJzb2x1dGUgdmFsdWVcbiAqIHJlcHJlc2VudGF0aW9uLiBOZXh0LCB3ZSBkZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXRzIHRoYXQgd2UgdXNlZCB0byBnZXQgdG9cbiAqIHRoZSB2YWx1ZSwgYnJhbmNoaW5nIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBsZXNzIHRoYW4gMS4gT25jZVxuICogd2UgaGF2ZSB0aGF0IHZhbHVlIHdoaWNoIHdlIHdpbGwgYWdhaW4gY2FsbCBlYml0cywgd2UgaGF2ZSB0byBkbyB0aGVcbiAqIGZvbGxvd2luZyBpbiB0aGUgZ2VuZXJhbCBjYXNlOlxuICpcbiAqXHRleHBvbmVudFx0MTAyMyArIGViaXRzXG4gKlx0bWFudGlzc2FcdFt2YWx1ZSAqIDJeKDUyIC0gZWJpdHMpXSAlIDJeNTJcbiAqXG4gKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgdmFsdWUgb2YgZWJpdHMgPD0gLTEwMjMgd2Ugbm8gbG9uZ2VyIHVzZSBub3JtYWxpemVkXG4gKiBudW1iZXJzLCB0aHVzIGxpa2Ugd2l0aCBmbG9hdHMgd2UgaGF2ZSB0byBkbyBzbGlnaHRseSBkaWZmZXJlbnQgcHJvY2Vzc2luZzpcbiAqXG4gKlx0ZXhwb25lbnRcdDBcbiAqXHRtYW50aXNzYVx0W3ZhbHVlICogMl4xMDc0XSAlIDJeNTJcbiAqXG4gKiBPbmNlIHdlIGhhdmUgZGV0ZXJtaW5lZCB0aGUgc2lnbiwgZXhwb25lbnQgYW5kIG1hbnRpc3NhIHdlIGNhbiBjb25zdHJ1Y3QgdGhlXG4gKiBieXRlcyBhcyBmb2xsb3dzOlxuICpcbiAqXHRieXRlMFx0XHRzaWduIGJpdCBhbmQgc2V2ZW4gbW9zdCBzaWduaWZpY2FudCBiaXRzIGZvcm0gdGhlIGV4cFxuICpcdFx0XHRzaWduIDw8IDcgfCAoZXhwb25lbnQgJiAweDdmMCkgPj4+IDRcbiAqXG4gKlx0Ynl0ZTFcdFx0UmVtYWluaW5nIDQgYml0cyBmcm9tIHRoZSBleHBvbmVudCBhbmQgdGhlIGZvdXIgbW9zdFxuICpcdFx0XHRzaWduaWZpY2FudCBiaXRzIGZyb20gdGhlIG1hbnRpc3NhIDQ4LTUxXG4gKlx0XHRcdChleHBvbmVudCAmIDB4MDBmKSA8PCA0IHwgbWFudGlzc2EgPj4+IDQ4XG4gKlxuICpcdGJ5dGUyXHRcdEJpdHMgNDAtNDcgZnJvbSB0aGUgbWFudGlzc2FcbiAqXHRcdFx0KG1hbnRpc3NhID4+PiA0MCkgJiAweGZmXG4gKlxuICpcdGJ5dGUzXHRcdEJpdHMgMzItMzkgZnJvbSB0aGUgbWFudGlzc2FcbiAqXHRcdFx0KG1hbnRpc3NhID4+PiAzMikgJiAweGZmXG4gKlxuICpcdGJ5dGU0XHRcdEJpdHMgMjQtMzEgZnJvbSB0aGUgbWFudGlzc2FcbiAqXHRcdFx0KG1hbnRpc3NhID4+PiAyNCkgJiAweGZmXG4gKlxuICpcdGJ5dGU1XHRcdEJpdHMgMTYtMjMgZnJvbSB0aGUgTWFudGlzc2FcbiAqXHRcdFx0KG1hbnRpc3NhID4+PiAxNikgJiAweGZmXG4gKlxuICpcdGJ5dGU2XHRcdEJpdHMgOC0xNSBmcm9tIHRoZSBtYW50aXNzYVxuICpcdFx0XHQobWFudGlzc2EgPj4+IDgpICYgMHhmZlxuICpcbiAqXHRieXRlN1x0XHRCaXRzIDAtNyBmcm9tIHRoZSBtYW50aXNzYVxuICpcdFx0XHRtYW50aXNzYSAmIDB4ZmZcbiAqXG4gKiBOb3cgd2UgY2FuJ3QgcXVpdGUgZG8gdGhlIHJpZ2h0IHNoaWZ0aW5nIHRoYXQgd2Ugd2FudCBpbiBieXRlcyAxIC0gMywgYmVjYXVzZVxuICogd2UnbGwgaGF2ZSBleHRlbmRlZCB0b28gZmFyIGFuZCB3ZSdsbCBsb3NlIHRob3NlIHZhbHVlcyB3aGVuIHdlIHRyeSBhbmQgZG9cbiAqIHRoZSBzaGlmdC4gSW5zdGVhZCB3ZSBoYXZlIHRvIHVzZSBhbiBhbHRlcm5hdGUgYXBwcm9hY2guIFRvIHRyeSBhbmQgc3RheSBvdXRcbiAqIG9mIGZsb2F0aW5nIHBvaW50LCB3aGF0IHdlJ2xsIGRvIGlzIHNheSB0aGF0IG1hbnRpc3NhIC09IGJ5dGVzWzQtN10gYW5kIHRoZW5cbiAqIGRpdmlkZSBieSAyXjMyLiBPbmNlIHdlJ3ZlIGRvbmUgdGhhdCB3ZSBjYW4gdXNlIGJpbmFyeSBhcml0aG1ldGljLiBPb2YsXG4gKiB0aGF0J3MgdWdseSwgYnV0IGl0IHNlZW1zIHRvIGF2b2lkIHVzaW5nIGZsb2F0aW5nIHBvaW50IChqdXN0IGJhc2VkIG9uIGhvdyB2OFxuICogc2VlbXMgdG8gYmUgb3B0aW1pemluZyBmb3IgYmFzZSAyIGFyaXRobWV0aWMpLlxuICovXG5mdW5jdGlvbiB3ZG91YmxlKHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgc2lnbiwgZXhwb25lbnQsIG1hbnRpc3NhLCBlYml0cztcblx0dmFyIGJ5dGVzID0gW107XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXG5cdGlmIChvZmZzZXQgKyA3ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0aWYgKGlzTmFOKHZhbHVlKSkge1xuXHRcdHNpZ24gPSAwO1xuXHRcdGV4cG9uZW50ID0gMHg3ZmY7XG5cdFx0bWFudGlzc2EgPSAyMztcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcblx0XHRzaWduID0gMDtcblx0XHRleHBvbmVudCA9IDB4N2ZmO1xuXHRcdG1hbnRpc3NhID0gMDtcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcblx0XHRzaWduID0gMTtcblx0XHRleHBvbmVudCA9IDB4N2ZmO1xuXHRcdG1hbnRpc3NhID0gMDtcblx0fSBlbHNlIHtcblx0XHQvKiBXZWxsIHdlIGhhdmUgc29tZSB3b3JrIHRvIGRvICovXG5cblx0XHQvKiBUaGFua2Z1bGx5IHRoZSBzaWduIGJpdCBpcyB0cml2aWFsICovXG5cdFx0aWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0c2lnbiA9IDE7XG5cdFx0XHR2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2lnbiA9IDA7XG5cdFx0fVxuXG5cdFx0LyogVXNlIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBudW1iZXIgb2YgYml0cyAqL1xuXHRcdGlmICh2YWx1ZSA8IDEpXG5cdFx0XHRlYml0cyA9IGZyYWNleHAodmFsdWUpO1xuXHRcdGVsc2Vcblx0XHRcdGViaXRzID0gaW50ZXhwKHZhbHVlKTtcblxuXHRcdC8qXG5cdFx0ICogVGhpcyBpcyBhIHRvdGFsIGhhY2sgdG8gZGV0ZXJtaW5lIGEgZGVub3JtYWxpemVkIHZhbHVlLlxuXHRcdCAqIFVuZm9ydHVuYXRlbHksIHdlIHNvbWV0aW1lcyBkbyBub3QgZ2V0IGEgcHJvcGVyIHZhbHVlIGZvclxuXHRcdCAqIGViaXRzLCBpLmUuIHdlIGxvc2UgdGhlIHZhbHVlcyB0aGF0IHdvdWxkIGdldCByb3VuZGVkIG9mZi5cblx0XHQgKlxuXHRcdCAqXG5cdFx0ICogVGhlIGFzdHV0ZSBvYnNlcnZlciBtYXkgd29uZGVyIHdoeSB3ZSB3b3VsZCBiZVxuXHRcdCAqIG11bHRpcGx5aW5nIGJ5IHR3byBNYXRoLnBvd3MgcmF0aGVyIHRoYW4ganVzdCBzdW1taW5nXG5cdFx0ICogdGhlbS4gV2VsbCwgdGhhdCdzIHRvIGdldCBhcm91bmQgYSBzbWFsbCBidWcgaW4gdGhlXG5cdFx0ICogd2F5IHY4IHNlZW1zIHRvIGltcGxlbWVudCB0aGUgZnVuY3Rpb24uIE9uIG9jY2FzaW9uXG5cdFx0ICogZG9pbmc6XG5cdFx0ICpcblx0XHQgKiBmb28gKiBNYXRoLnBvdygyLCAxMDIzICsgNTEpXG5cdFx0ICpcblx0XHQgKiBDYXVzZXMgdXMgdG8gb3ZlcmZsb3cgdG8gaW5maW5pdHksIHdoZXJlIGFzIGRvaW5nOlxuXHRcdCAqXG5cdFx0ICogZm9vICogTWF0aC5wb3coMiwgMTAyMykgKiBNYXRoLnBvdygyLCA1MSlcblx0XHQgKlxuXHRcdCAqIERvZXMgbm90IGNhdXNlIHVzIHRvIG92ZXJmbG93LiBHbyBmaWd1cmUuXG5cdFx0ICpcblx0XHQgKi9cblx0XHRpZiAodmFsdWUgPD0gMi4yMjUwNzM4NTg1MDcyMDFlLTMwOCB8fCBlYml0cyA8PSAtMTAyMykge1xuXHRcdFx0ZXhwb25lbnQgPSAwO1xuXHRcdFx0bWFudGlzc2EgPSB2YWx1ZSAqIE1hdGgucG93KDIsIDEwMjMpICogTWF0aC5wb3coMiwgNTEpO1xuXHRcdFx0bWFudGlzc2EgJT0gTWF0aC5wb3coMiwgNTIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKlxuXHRcdFx0ICogV2UgbWlnaHQgaGF2ZSBnb3R0ZW4gZnVja2VkIGJ5IG91ciBmbG9hdGluZyBwb2ludFxuXHRcdFx0ICogbG9nYXJpdGhtIG1hZ2ljLiBUaGlzIGlzIHJhdGhlciBjcmFwcHksIGJ1dCB0aGF0J3Ncblx0XHRcdCAqIG91ciBsdWNrLiBJZiB3ZSBqdXN0IGhhZCBhIGxvZyBiYXNlIDIgb3IgYWNjZXNzIHRvXG5cdFx0XHQgKiB0aGUgc3R1cGlkIHVuZGVybHlpbmcgcmVwcmVzZW50YXRpb24gdGhpcyB3b3VsZCBoYXZlXG5cdFx0XHQgKiBiZWVuIG11Y2ggZWFzaWVyIGFuZCB3ZSB3b3VsZG4ndCBoYXZlIHN1Y2ggc3R1cGlkXG5cdFx0XHQgKiBrbHVkZ2VzIG9yIGhhY2tzLlxuXHRcdFx0ICovXG5cdFx0XHRpZiAoZWJpdHMgPiAxMDIzKVxuXHRcdFx0XHRlYml0cyA9IDEwMjM7XG5cdFx0XHRleHBvbmVudCA9IDEwMjMgKyBlYml0cztcblx0XHRcdG1hbnRpc3NhID0gdmFsdWUgKiBNYXRoLnBvdygyLCAtZWJpdHMpO1xuXHRcdFx0bWFudGlzc2EgKj0gTWF0aC5wb3coMiwgNTIpO1xuXHRcdFx0bWFudGlzc2EgJT0gTWF0aC5wb3coMiwgNTIpO1xuXHRcdH1cblx0fVxuXG5cdC8qIEZpbGwgdGhlIGJ5dGVzIGluIGJhY2t3YXJkcyB0byBkZWFsIHdpdGggdGhlIHNpemUgaXNzdWVzICovXG5cdGJ5dGVzWzddID0gbWFudGlzc2EgJiAweGZmO1xuXHRieXRlc1s2XSA9IChtYW50aXNzYSA+Pj4gOCkgJiAweGZmO1xuXHRieXRlc1s1XSA9IChtYW50aXNzYSA+Pj4gMTYpICYgMHhmZjtcblx0bWFudGlzc2EgPSAobWFudGlzc2EgLSAobWFudGlzc2EgJiAweGZmZmZmZikpIC8gTWF0aC5wb3coMiwgMjQpO1xuXHRieXRlc1s0XSA9IG1hbnRpc3NhICYgMHhmZjtcblx0Ynl0ZXNbM10gPSAobWFudGlzc2EgPj4+IDgpICYgMHhmZjtcblx0Ynl0ZXNbMl0gPSAobWFudGlzc2EgPj4+IDE2KSAmIDB4ZmY7XG5cdGJ5dGVzWzFdID0gKGV4cG9uZW50ICYgMHgwMGYpIDw8IDQgfCBtYW50aXNzYSA+Pj4gMjQ7XG5cdGJ5dGVzWzBdID0gKHNpZ24gPDwgNykgfCAoZXhwb25lbnQgJiAweDdmMCkgPj4+IDQ7XG5cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gYnl0ZXNbMF07XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9IGJ5dGVzWzFdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMl0gPSBieXRlc1syXTtcblx0XHRidWZmZXJbb2Zmc2V0KzNdID0gYnl0ZXNbM107XG5cdFx0YnVmZmVyW29mZnNldCs0XSA9IGJ5dGVzWzRdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrNV0gPSBieXRlc1s1XTtcblx0XHRidWZmZXJbb2Zmc2V0KzZdID0gYnl0ZXNbNl07XG5cdFx0YnVmZmVyW29mZnNldCs3XSA9IGJ5dGVzWzddO1xuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlcltvZmZzZXQrN10gPSBieXRlc1swXTtcblx0XHRidWZmZXJbb2Zmc2V0KzZdID0gYnl0ZXNbMV07XG5cdFx0YnVmZmVyW29mZnNldCs1XSA9IGJ5dGVzWzJdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrNF0gPSBieXRlc1szXTtcblx0XHRidWZmZXJbb2Zmc2V0KzNdID0gYnl0ZXNbNF07XG5cdFx0YnVmZmVyW29mZnNldCsyXSA9IGJ5dGVzWzVdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSBieXRlc1s2XTtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IGJ5dGVzWzddO1xuXHR9XG59XG5cbi8qXG4gKiBBY3R1YWxseSBleHBvcnQgb3VyIHdvcmsgYWJvdmUuIE9uZSBtaWdodCBhcmd1ZSB0aGF0IHdlIHNob3VsZG4ndCBleHBvc2VcbiAqIHRoZXNlIGludGVyZmFjZXMgYW5kIGp1c3QgZm9yY2UgcGVvcGxlIHRvIHVzZSB0aGUgaGlnaGVyIGxldmVsIGFic3RyYWN0aW9uc1xuICogYXJvdW5kIHRoaXMgd29yay4gSG93ZXZlciwgdW5saWtlIHNheSBvdGhlciBsaWJyYXJpZXMgd2UndmUgY29tZSBhY3Jvc3MsIHRoaXNcbiAqIGludGVyZmFjZSBoYXMgc2V2ZXJhbCBwcm9wZXJ0aWVzOiBpdCBtYWtlcyBzZW5zZSwgaXQncyBzaW1wbGUsIGFuZCBpdCdzXG4gKiB1c2VmdWwuXG4gKi9cbmV4cG9ydHMucnVpbnQ4ID0gcnVpbnQ4O1xuZXhwb3J0cy5ydWludDE2ID0gcnVpbnQxNjtcbmV4cG9ydHMucnVpbnQzMiA9IHJ1aW50MzI7XG5leHBvcnRzLnJ1aW50NjQgPSBydWludDY0O1xuZXhwb3J0cy53dWludDggPSB3dWludDg7XG5leHBvcnRzLnd1aW50MTYgPSB3dWludDE2O1xuZXhwb3J0cy53dWludDMyID0gd3VpbnQzMjtcbmV4cG9ydHMud3VpbnQ2NCA9IHd1aW50NjQ7XG5cbmV4cG9ydHMucnNpbnQ4ID0gcnNpbnQ4O1xuZXhwb3J0cy5yc2ludDE2ID0gcnNpbnQxNjtcbmV4cG9ydHMucnNpbnQzMiA9IHJzaW50MzI7XG5leHBvcnRzLnJzaW50NjQgPSByc2ludDY0O1xuZXhwb3J0cy53c2ludDggPSB3c2ludDg7XG5leHBvcnRzLndzaW50MTYgPSB3c2ludDE2O1xuZXhwb3J0cy53c2ludDMyID0gd3NpbnQzMjtcbmV4cG9ydHMud3NpbnQ2NCA9IHdzaW50NjQ7XG5cbmV4cG9ydHMucmZsb2F0ID0gcmZsb2F0O1xuZXhwb3J0cy5yZG91YmxlID0gcmRvdWJsZTtcbmV4cG9ydHMud2Zsb2F0ID0gd2Zsb2F0O1xuZXhwb3J0cy53ZG91YmxlID0gd2RvdWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jdHlwZS9jdGlvLmpzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbnZhciBkYiA9IHJlcXVpcmUoJ21pbWUtZGInKVxuXG4vLyB0eXBlc1tleHRlbnNpb25dID0gdHlwZVxuZXhwb3J0cy50eXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcbi8vIGV4dGVuc2lvbnNbdHlwZV0gPSBbZXh0ZW5zaW9uc11cbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuT2JqZWN0LmtleXMoZGIpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIG1pbWUgPSBkYltuYW1lXVxuICB2YXIgZXh0cyA9IG1pbWUuZXh0ZW5zaW9uc1xuICBpZiAoIWV4dHMgfHwgIWV4dHMubGVuZ3RoKSByZXR1cm5cbiAgZXhwb3J0cy5leHRlbnNpb25zW25hbWVdID0gZXh0c1xuICBleHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgIGV4cG9ydHMudHlwZXNbZXh0XSA9IG5hbWVcbiAgfSlcbn0pXG5cbmV4cG9ydHMubG9va3VwID0gZnVuY3Rpb24gKHN0cmluZykge1xuICBpZiAoIXN0cmluZyB8fCB0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2VcbiAgLy8gcmVtb3ZlIGFueSBsZWFkaW5nIHBhdGhzLCB0aG91Z2ggd2Ugc2hvdWxkIGp1c3QgdXNlIHBhdGguYmFzZW5hbWVcbiAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLy4qW1xcLlxcL1xcXFxdLywgJycpLnRvTG93ZXJDYXNlKClcbiAgaWYgKCFzdHJpbmcpIHJldHVybiBmYWxzZVxuICByZXR1cm4gZXhwb3J0cy50eXBlc1tzdHJpbmddIHx8IGZhbHNlXG59XG5cbmV4cG9ydHMuZXh0ZW5zaW9uID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2VcbiAgLy8gdG8gZG86IHVzZSBtZWRpYS10eXBlclxuICB0eXBlID0gdHlwZS5tYXRjaCgvXlxccyooW147XFxzXSopKD86O3xcXHN8JCkvKVxuICBpZiAoIXR5cGUpIHJldHVybiBmYWxzZVxuICB2YXIgZXh0cyA9IGV4cG9ydHMuZXh0ZW5zaW9uc1t0eXBlWzFdLnRvTG93ZXJDYXNlKCldXG4gIGlmICghZXh0cyB8fCAhZXh0cy5sZW5ndGgpIHJldHVybiBmYWxzZVxuICByZXR1cm4gZXh0c1swXVxufVxuXG4vLyB0eXBlIGhhcyB0byBiZSBhbiBleGFjdCBtaW1lIHR5cGVcbmV4cG9ydHMuY2hhcnNldCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBtaW1lID0gZGJbdHlwZV1cbiAgaWYgKG1pbWUgJiYgbWltZS5jaGFyc2V0KSByZXR1cm4gbWltZS5jaGFyc2V0XG5cbiAgLy8gZGVmYXVsdCB0ZXh0LyogdG8gdXRmLThcbiAgaWYgKC9edGV4dFxcLy8udGVzdCh0eXBlKSkgcmV0dXJuICdVVEYtOCdcblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmV4cG9ydHMuY2hhcnNldHMgPSB7XG4gIGxvb2t1cDogZXhwb3J0cy5jaGFyc2V0XG59XG5cbi8vIHRvIGRvOiBtYXliZSB1c2Ugc2V0LXR5cGUgbW9kdWxlIG9yIHNvbWV0aGluZ1xuZXhwb3J0cy5jb250ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlXG4gIGlmICghfnR5cGUuaW5kZXhPZignLycpKSB0eXBlID0gZXhwb3J0cy5sb29rdXAodHlwZSlcbiAgaWYgKCF0eXBlKSByZXR1cm4gZmFsc2VcbiAgaWYgKCF+dHlwZS5pbmRleE9mKCdjaGFyc2V0JykpIHtcbiAgICB2YXIgY2hhcnNldCA9IGV4cG9ydHMuY2hhcnNldCh0eXBlKVxuICAgIGlmIChjaGFyc2V0KSB0eXBlICs9ICc7IGNoYXJzZXQ9JyArIGNoYXJzZXQudG9Mb3dlckNhc2UoKVxuICB9XG4gIHJldHVybiB0eXBlXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vbWltZS10eXBlcy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBtaW1lLWRiXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RiLmpzb24nKVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L21pbWUtdHlwZXMvfi9taW1lLWRiL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJhcHBsaWNhdGlvbi8xZC1pbnRlcmxlYXZlZC1wYXJpdHlmZWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vM2dwZGFzaC1xb2UtcmVwb3J0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi8zZ3BwLWltcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYTJsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2FjdGl2ZW1lc3NhZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYWx0by1jb3N0bWFwK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hbHRvLWNvc3RtYXBmaWx0ZXIranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2FsdG8tZGlyZWN0b3J5K2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hbHRvLWVuZHBvaW50Y29zdCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYWx0by1lbmRwb2ludGNvc3RwYXJhbXMranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2FsdG8tZW5kcG9pbnRwcm9wK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hbHRvLWVuZHBvaW50cHJvcHBhcmFtcytqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYWx0by1lcnJvcitqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYWx0by1uZXR3b3JrbWFwK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hbHRvLW5ldHdvcmttYXBmaWx0ZXIranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2FtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hbmRyZXctaW5zZXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImV6XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYXBwbGVmaWxlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2FwcGxpeHdhcmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXdcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hdGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYXRmeFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hdG9tK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhdG9tXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYXRvbWNhdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImF0b21jYXRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hdG9tZGVsZXRlZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vYXRvbWljbWFpbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXRvbXN2Y1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2F0eG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2F1dGgtcG9saWN5K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9iYWNuZXQteGRkK3ppcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9iYXRjaC1zbXRwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2Jkb2NcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImJkb2NcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9iZWVwK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jYWxlbmRhcitqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY2FsZW5kYXIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NhbGwtY29tcGxldGlvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jYWxzLTE4NDBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY2JvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jY21wK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jY3htbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNjeG1sXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY2RmeCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY2RtaS1jYXBhYmlsaXR5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZG1pYVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NkbWktY29udGFpbmVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZG1pY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NkbWktZG9tYWluXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZG1pZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NkbWktb2JqZWN0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZG1pb1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NkbWktcXVldWVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNkbWlxXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY2VhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NlYS0yMDE4K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jZWxsbWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2Nmd1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jbXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY25ycCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY29hcC1ncm91cCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY29tbW9uZ3JvdW5kXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2NvbmZlcmVuY2UtaW5mbyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY3BsK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jc3JhdHRyc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jc3RhK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jc3RhZGF0YSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vY3Utc2VlbWVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY3VcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9jeWJlcmNhc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZGFydFwiOiB7XG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2Rhc2greG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtZHBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9kYXNoZGVsdGFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZGF2bW91bnQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkYXZtb3VudFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2RjYS1yZnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZGNkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2RlYy1keFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9kaWFsb2ctaW5mbyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZGljb21cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZGlpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2RpdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9kbnNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZG9jYm9vayt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZGJrXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZHNrcHAreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2Rzc2MrZGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkc3NjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZHNzYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhkc3NjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZHZjc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVjbWFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9lZGktY29uc2VudFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9lZGkteDEyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2VkaWZhY3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZW1tYSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVtbWFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9lbW90aW9ubWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2VuY2FwcnRwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2VwcCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZXB1Yit6aXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVwdWJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9lc2hvcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9leGlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImV4aVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2Zhc3RpbmZvc2V0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2Zhc3Rzb2FwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2ZkdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZml0c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9mb250LXNmbnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZm9udC10ZHBmclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGZyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZm9udC13b2ZmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3b2ZmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZm9udC13b2ZmMlwiOiB7XG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid29mZjJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9mcmFtZXdvcmstYXR0cmlidXRlcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vZ21sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJnbWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9ncHgreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdweFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2d4ZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJneGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9nemlwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2gyMjRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaGVsZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaHR0cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9oeXBlcnN0dWRpb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3RrXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaWJlLWtleS1yZXF1ZXN0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9pYmUtcGtnLXJlcGx5K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9pYmUtcHAtZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9pZ2VzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2ltLWlzY29tcG9zaW5nK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9pbmRleFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9pbmRleC5jbWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaW5kZXgub2JqXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2luZGV4LnJlc3BvbnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2luZGV4LnZuZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9pbmttbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImlua1wiLFxuXHRcdFx0XCJpbmttbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2lvdHBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaXBmaXhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImlwZml4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaXBwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2lzdXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vaXRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiamFyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vamF2YS1zZXJpYWxpemVkLW9iamVjdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZXJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9qYXZhLXZtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNsYXNzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjaGFyc2V0XCI6IFwiVVRGLThcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImpzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vam9zZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9qb3NlK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9qcmQranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY2hhcnNldFwiOiBcIlVURi04XCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqc29uXCIsXG5cdFx0XHRcIm1hcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2pzb24tc2VxXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2pzb241XCI6IHtcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqc29uNVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2pzb25tbCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwianNvbm1sXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vandrK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9qd2stc2V0K2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9qd3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24va3BtbC1yZXF1ZXN0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9rcG1sLXJlc3BvbnNlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9sZCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImpzb25sZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2xpbmstZm9ybWF0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL2xvYWQtY29udHJvbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbG9zdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImxvc3R4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9sb3N0c3luYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbHhmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21hYy1iaW5oZXg0MFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaHF4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWFjLWNvbXBhY3Rwcm9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY3B0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWFjd3JpdGVpaVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tYWRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWFkc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21hbmlmZXN0K2pzb25cIjoge1xuXHRcdFwiY2hhcnNldFwiOiBcIlVURi04XCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3ZWJtYW5pZmVzdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21hcmNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1yY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21hcmN4bWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtcmN4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWF0aGVtYXRpY2FcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1hXCIsXG5cdFx0XHRcIm5iXCIsXG5cdFx0XHRcIm1iXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWF0aG1sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWF0aG1sXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWF0aG1sLWNvbnRlbnQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21hdGhtbC1wcmVzZW50YXRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21ibXMtYXNzb2NpYXRlZC1wcm9jZWR1cmUtZGVzY3JpcHRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21ibXMtZGVyZWdpc3Rlcit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWJtcy1lbnZlbG9wZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWJtcy1tc2sreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21ibXMtbXNrLXJlc3BvbnNlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tYm1zLXByb3RlY3Rpb24tZGVzY3JpcHRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21ibXMtcmVjZXB0aW9uLXJlcG9ydCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWJtcy1yZWdpc3Rlcit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWJtcy1yZWdpc3Rlci1yZXNwb25zZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWJtcy1zY2hlZHVsZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWJtcy11c2VyLXNlcnZpY2UtZGVzY3JpcHRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21ib3hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1ib3hcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tZWRpYS1wb2xpY3ktZGF0YXNldCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWVkaWFfY29udHJvbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWVkaWFzZXJ2ZXJjb250cm9sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXNjbWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tZXJnZS1wYXRjaCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWV0YWxpbmsreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1ldGFsaW5rXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbWV0YWxpbms0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWV0YTRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tZXRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWV0c1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21mNFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9taWtleVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tb2RzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibW9kc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21vc3Mta2V5c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tb3NzLXNpZ25hdHVyZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tb3Nza2V5LWRhdGFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbW9zc2tleS1yZXF1ZXN0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21wMjFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm0yMVwiLFxuXHRcdFx0XCJtcDIxXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbXA0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtcDRzXCIsXG5cdFx0XHRcIm00cFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21wZWc0LWdlbmVyaWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbXBlZzQtaW9kXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL21wZWc0LWlvZC14bXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbXJiLWNvbnN1bWVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tcmItcHVibGlzaCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbXNjLWl2cit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbXNjLW1peGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9tc3dvcmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImRvY1wiLFxuXHRcdFx0XCJkb3RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9teGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm14ZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL25hc2RhdGFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbmV3cy1jaGVja2dyb3Vwc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9uZXdzLWdyb3VwaW5mb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9uZXdzLXRyYW5zbWlzc2lvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9ubHNtbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vbnNzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL29jc3AtcmVxdWVzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9vY3NwLXJlc3BvbnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYmluXCIsXG5cdFx0XHRcImRtc1wiLFxuXHRcdFx0XCJscmZcIixcblx0XHRcdFwibWFyXCIsXG5cdFx0XHRcInNvXCIsXG5cdFx0XHRcImRpc3RcIixcblx0XHRcdFwiZGlzdHpcIixcblx0XHRcdFwicGtnXCIsXG5cdFx0XHRcImJwa1wiLFxuXHRcdFx0XCJkdW1wXCIsXG5cdFx0XHRcImVsY1wiLFxuXHRcdFx0XCJkZXBsb3lcIixcblx0XHRcdFwiYnVmZmVyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vb2RhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZGFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9vZHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vb2VicHMtcGFja2FnZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9wZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL29nZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib2d4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vb21kb2MreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9tZG9jXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vb25lbm90ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvbmV0b2NcIixcblx0XHRcdFwib25ldG9jMlwiLFxuXHRcdFx0XCJvbmV0bXBcIixcblx0XHRcdFwib25lcGtnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vb3hwc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3hwc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3AycC1vdmVybGF5K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9wYXJpdHlmZWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGF0Y2gtb3BzLWVycm9yK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGVyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwZGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9wZHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGdwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGdwLWtleXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGdwLXNpZ25hdHVyZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXNjXCIsXG5cdFx0XHRcInNpZ1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BpY3MtcnVsZXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicHJmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGlkZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGlkZi1kaWZmK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9wa2NzMTBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInAxMFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BrY3M3LW1pbWVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInA3bVwiLFxuXHRcdFx0XCJwN2NcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9wa2NzNy1zaWduYXR1cmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInA3c1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BrY3M4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwOFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BraXgtYXR0ci1jZXJ0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BraXgtY2VydFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2VyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcGtpeC1jcmxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNybFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BraXgtcGtpcGF0aFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGtpcGF0aFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BraXhjbXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBraVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Bscyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBsc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3BvYy1zZXR0aW5ncyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcG9zdHNjcmlwdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhaVwiLFxuXHRcdFx0XCJlcHNcIixcblx0XHRcdFwicHNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9wcm92ZW5hbmNlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9wcnMuYWx2ZXN0cmFuZC50aXRyYXgtc2hlZXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcHJzLmN3d1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY3d3XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcHJzLmhwdWIremlwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Bycy5ucHJlbmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcHJzLnBsdWNrZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcHJzLnJkZi14bWwtY3J5cHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcHJzLnhzZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcHNrYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBza2N4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9xc2lnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3JhcHRvcmZlY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9yZGFwK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9yZGYreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJkZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3JlZ2luZm8reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJyaWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9yZWxheC1uZy1jb21wYWN0LXN5bnRheFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicm5jXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcmVtb3RlLXByaW50aW5nXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3JlcHV0b24ranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cy1kaWZmK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmxkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcmlzY29zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3JsbWkreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcnBraS1naG9zdGJ1c3RlcnNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdiclwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Jwa2ktbWFuaWZlc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1mdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Jwa2ktcm9hXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJyb2FcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9ycGtpLXVwZG93blwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9yc2QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJzZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Jzcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJyc3NcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9ydGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicnRmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcnRwbG9vcGJhY2tcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vcnR4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NhbWxhc3NlcnRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NhbWxtZXRhZGF0YSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc2JtbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNibWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zY2FpcCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc2N2cC1jdi1yZXF1ZXN0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzY3FcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlc3BvbnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzY3NcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNwcVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NjdnAtdnAtcmVzcG9uc2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNwcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NkcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2RwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc2VwK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zZXAtZXhpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3Nlc3Npb24taW5mb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zZXQtcGF5bWVudFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zZXQtcGF5bWVudC1pbml0aWF0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZXRwYXlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zZXQtcmVnaXN0cmF0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2V0cmVnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc2dtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zZ21sLW9wZW4tY2F0YWxvZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zaGYreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzaGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zaWV2ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zaW1wbGUtZmlsdGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zaW1wbGUtbWVzc2FnZS1zdW1tYXJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NpbXBsZXN5bWJvbGNvbnRhaW5lclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zbWlsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NtaWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzbWlcIixcblx0XHRcdFwic21pbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NtcHRlMzM2bVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zb2FwK2Zhc3RpbmZvc2V0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NvYXAreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJycVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3J4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc3Bpcml0cy1ldmVudCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc3FsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3NyZ3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdyYW1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zcmdzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ3J4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zcnUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzcnVcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi9zc2RsK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzc2RsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vc3NtbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNzbWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi90YW1wLWFwZXgtdXBkYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RhbXAtYXBleC11cGRhdGUtY29uZmlybVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi90YW1wLWNvbW11bml0eS11cGRhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdGFtcC1jb21tdW5pdHktdXBkYXRlLWNvbmZpcm1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdGFtcC1lcnJvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi90YW1wLXNlcXVlbmNlLWFkanVzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi90YW1wLXNlcXVlbmNlLWFkanVzdC1jb25maXJtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RhbXAtc3RhdHVzLXF1ZXJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RhbXAtc3RhdHVzLXJlc3BvbnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RhbXAtdXBkYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RhbXAtdXBkYXRlLWNvbmZpcm1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdGFyXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdGVpK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidGVpXCIsXG5cdFx0XHRcInRlaWNvcnB1c1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RocmF1ZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRmaVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3RpbWVzdGFtcC1xdWVyeVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi90aW1lc3RhbXAtcmVwbHlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdGltZXN0YW1wZWQtZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidHNkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdHRtbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdHZlLXRyaWdnZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdWxwZmVjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3VyYy1ncnBzaGVldCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdXJjLXJlc3NoZWV0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi91cmMtdGFyZ2V0ZGVzYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdXJjLXVpc29ja2V0ZGVzYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdmNhcmQranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZjYXJkK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92ZW1taVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92aXZpZGVuY2Uuc2NyaXB0ZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLmJzZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LWxhcmdlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwbGJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctc21hbGxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBzYlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy12YXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInB2YlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwLnNtc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuM2dwcDIuYmNtY3NpbmZvK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuM2dwcDIuc21zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0Y2FwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLjNtLnBvc3QtaXQtbm90ZXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInB3blwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hY2NwYWMuc2ltcGx5LmFzb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXNvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuaW1wXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpbXBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYWN1Y29ib2xcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImFjdVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhdGNcIixcblx0XHRcdFwiYWN1dGNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYWRvYmUuYWlyLWFwcGxpY2F0aW9uLWluc3RhbGxlci1wYWNrYWdlK3ppcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhaXJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYWRvYmUuZmxhc2gubW92aWVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmZvcm1zY2VudHJhbC5mY2R0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmY2R0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLmZ4cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZnhwXCIsXG5cdFx0XHRcImZ4cGxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYWRvYmUucGFydGlhbC11cGxvYWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFkb2JlLnhkcCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhkcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZmRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4ZmRmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFldGhlci5pbXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFoLWJhcmNvZGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFoZWFkLnNwYWNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhaGVhZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5hemZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImF6ZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImF6c1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2tcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXp3XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFtZXJpY2FuZHluYW1pY3MuYWNjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhY2NcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYW1pZ2EuYW1pXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhbWlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYW11bmRzZW4ubWF6ZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFuZHJvaWQucGFja2FnZS1hcmNoaXZlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImFwa1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItY2VydGlmaWNhdGUtaXNzdWUtaW5pdGlhdGlvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2lpXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1mdW5kcy10cmFuc2Zlci1pbml0aWF0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZ0aVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hbnRpeC5nYW1lLWNvbXBvbmVudFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXR4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFwYWNoZS50aHJpZnQuYmluYXJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hcGFjaGUudGhyaWZ0LmNvbXBhY3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFwYWNoZS50aHJpZnQuanNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYXBpK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXBrZ1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtM3U4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFyYXN0cmEuc3dpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hcmlzdGFuZXR3b3Jrcy5zd2lcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN3aVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hcnRzcXVhcmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmFzdHJhZWEtc29mdHdhcmUuaW90YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaW90YVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5hdWRpb2dyYXBoXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhZXBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYXV0b3BhY2thZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmF2aXN0YXIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5iYWxzYW1pcS5ibW1sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYmFsc2FtaXEuYm1wclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuYmVraXR6dXItc3RlY2granNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ibHVlaWNlLm11bHRpcGFzc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXBtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmJsdWV0b290aC5lcC5vb2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmJsdWV0b290aC5sZS5vb2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmJtaVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYm1pXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmJ1c2luZXNzb2JqZWN0c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmVwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNhYi1qc2NyaXB0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jYW5vbi1jcGRsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jYW5vbi1saXBzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jZW5kaW8udGhpbmxpbmMuY2xpZW50Y29uZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY2VudHVyeS1zeXN0ZW1zLnRjcF9zdHJlYW1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNoZW1kcmF3K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2R4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1tZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jaW5kZXJlbGxhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZHlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY2lycGFjay5pc2RuLWV4dFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY2l0YXRpb25zdHlsZXMuc3R5bGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jbGF5bW9yZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2xhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNsb2FudG8ucnA5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJycDlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY2xvbmsuYzRncm91cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYzRnXCIsXG5cdFx0XHRcImM0ZFwiLFxuXHRcdFx0XCJjNGZcIixcblx0XHRcdFwiYzRwXCIsXG5cdFx0XHRcImM0dVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jbHVldHJ1c3QuY2FydG9tb2JpbGUtY29uZmlnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjMTFhbWNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZy1wa2dcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImMxMWFtelwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jb2ZmZWVzY3JpcHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNvbGxlY3Rpb24ranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jb2xsZWN0aW9uLmRvYytqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNvbGxlY3Rpb24ubmV4dCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNvbW1lcmNlLWJhdHRlbGxlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY3NwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNvbnRhY3QuY21zZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2RiY21zZ1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jb3Ntb2NhbGxlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY21jXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNsa3hcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci5rZXlib2FyZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2xra1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnBhbGV0dGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNsa3BcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci50ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2xrdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLndvcmRiYW5rXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjbGt3XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmNyaXRpY2FsdG9vbHMud2JzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2JzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmN0Yy1wb3NtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicG1sXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmN0Y3Qud3MreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jdXBzLXBkZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY3Vwcy1wb3N0c2NyaXB0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jdXBzLXBwZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicHBkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmN1cHMtcmFzdGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jdXBzLXJhd1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY3VybFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY3VybC5jYXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2FyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmN1cmwucGN1cmxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGN1cmxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuY3lhbi5kZWFuLnJvb3QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5jeWJhbmtcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRhcnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZGFydFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kYXRhLXZpc2lvbi5yZHpcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJkelwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kZWJpYW4uYmluYXJ5LXBhY2thZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRlY2UuZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZmXCIsXG5cdFx0XHRcInV2dmZcIixcblx0XHRcdFwidXZkXCIsXG5cdFx0XHRcInV2dmRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZGVjZS50dG1sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZ0XCIsXG5cdFx0XHRcInV2dnRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZGVjZS51bnNwZWNpZmllZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZ4XCIsXG5cdFx0XHRcInV2dnhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZGVjZS56aXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInV2elwiLFxuXHRcdFx0XCJ1dnZ6XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRlbm92by5mY3NlbGF5b3V0LWxpbmtcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZlX2xhdW5jaFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kZXNtdW1lLW1vdmllXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kaXItYmkucGxhdGUtZGwtbm9zdWZmaXhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRtLmRlbGVnYXRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kbmFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImRuYVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kb2N1bWVudCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRvbGJ5Lm1scFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtbHBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZG9sYnkubW9iaWxlLjFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRvbGJ5Lm1vYmlsZS4yXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kb3JlbWlyLnNjb3JlY2xvdWQtYmluYXJ5LWRvY3VtZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kcGdyYXBoXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkcGdcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZHJlYW1mYWN0b3J5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkZmFjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmRzLWtleXBvaW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImtweHhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZHRnLmxvY2FsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdGcubG9jYWwuZmxhc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR0Zy5sb2NhbC5odG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIuYWl0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhaXRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZHZiLmR2YmpcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5lc2djb250YWluZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcGRjZGZ0bm90aWZhY2Nlc3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcGRjZXNnYWNjZXNzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIuaXBkY2VzZ2FjY2VzczJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcGRjZXNncGRkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIuaXBkY3JvYW1pbmdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcHR2LmFsZmVjLWJhc2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5pcHR2LmFsZmVjLWVuaGFuY2VtZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIubm90aWYtYWdncmVnYXRlLXJvb3QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIubm90aWYtY29udGFpbmVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZHZiLm5vdGlmLWdlbmVyaWMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIubm90aWYtaWEtbXNnbGlzdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5ub3RpZi1pYS1yZWdpc3RyYXRpb24tcmVxdWVzdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5ub3RpZi1pYS1yZWdpc3RyYXRpb24tcmVzcG9uc2UreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5kdmIubm90aWYtaW5pdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5wZnJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmR2Yi5zZXJ2aWNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzdmNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZHhyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5keW5hZ2VvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJnZW9cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZHpyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lYXN5a2FyYW9rZS5jZGdkb3dubG9hZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZWNkaXMtdXBkYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uY2hhcnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1hZ1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uZmlsZXJlcXVlc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmVjb3dpbi5maWxldXBkYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uc2VyaWVzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lY293aW4uc2VyaWVzcmVxdWVzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZWNvd2luLnNlcmllc3VwZGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZW1jbGllbnQuYWNjZXNzcmVxdWVzdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmVubGl2ZW5cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm5tbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lbnBoYXNlLmVudm95XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lcHJpbnRzLmRhdGEreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5lc2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVzZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5tc2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1zZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5lcHNvbi5xdWlja2FuaW1lXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJxYW1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXBzb24uc2FsdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2x0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmVwc29uLnNzZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3NmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmVyaWNzc29uLnF1aWNrY2FsbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXN6aWdubzMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJlczNcIixcblx0XHRcdFwiZXQzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kuYW9jK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXRzaS5hc2ljLWUremlwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmFzaWMtcyt6aXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kuY3VnK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXRzaS5pcHR2Y29tbWFuZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kuaXB0dmRpc2NvdmVyeSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kuaXB0dnByb2ZpbGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmlwdHZzYWQtYmMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmlwdHZzYWQtY29kK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXRzaS5pcHR2c2FkLW5wdnIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLmlwdHZzZXJ2aWNlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXRzaS5pcHR2c3luYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kuaXB0dnVlcHJvZmlsZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kubWNpZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kubWhlZzVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kub3ZlcmxvYWQtY29udHJvbC1wb2xpY3ktZGF0YXNldCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kucHN0bit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kuc2NpK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXRzaS5zaW1zZXJ2cyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kudGltZXN0YW1wLXRva2VuXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ldHNpLnRzbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV0c2kudHNsLmRlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXVkb3JhLmRhdGFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmV6cGl4LWFsYnVtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJlejJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZXpwaXgtcGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZXozXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmYtc2VjdXJlLm1vYmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZmFzdGNvcHktZGlzay1pbWFnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZmRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmZGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZmRzbi5tc2VlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXNlZWRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZWVkXCIsXG5cdFx0XHRcImRhdGFsZXNzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZmc25zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5maW50c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZmxvZ3JhcGhpdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ3BoXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZsdXh0aW1lLmNsaXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZ0Y1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mb250LWZvbnRmb3JnZS1zZmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZyYW1lbWFrZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZtXCIsXG5cdFx0XHRcImZyYW1lXCIsXG5cdFx0XHRcIm1ha2VyXCIsXG5cdFx0XHRcImJvb2tcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5mbmNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZuY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmx0ZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibHRmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZzYy53ZWJsYXVuY2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZzY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvYXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9hMlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzM1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib2EzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNncFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmc1XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNwcnNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImJoMlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guYXJ0LWV4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guYXJ0NFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRkZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZGRkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kb2N1d29ya3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhkd1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzLmJpbmRlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGJkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kb2N1d29ya3MuY29udGFpbmVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guaGJwbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZnV0LW1pc25ldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZnV6enlzaGVldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZnpzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmdlbm9tYXRpeC50dXhlZG9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInR4ZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nZW8ranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nZW9jdWJlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEuZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ2diXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmdlb2dlYnJhLnRvb2xcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdndFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nZW9tZXRyeS1leHBsb3JlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ2V4XCIsXG5cdFx0XHRcImdyZVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nZW9uZXh0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJneHRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ2VvcGxhblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZzJ3XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmdlb3NwYWNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJnM3dcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ2VyYmVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nbG9iYWxwbGF0Zm9ybS5jYXJkLWNvbnRlbnQtbWd0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nbG9iYWxwbGF0Zm9ybS5jYXJkLWNvbnRlbnQtbWd0LXJlc3BvbnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nbXhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdteFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJrbWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttelwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwia216XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmdvdi5zay5lLWZvcm0reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5nb3Yuc2suZS1mb3JtK3ppcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ292LnNrLnhtbGRhdGFjb250YWluZXIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ncmFmZXFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdxZlwiLFxuXHRcdFx0XCJncXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ3JpZG1wXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtYWNjb3VudFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ2FjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmdyb292ZS1oZWxwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJnaGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWlkZW50aXR5LW1lc3NhZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdpbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaW5qZWN0b3JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdydlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC1tZXNzYWdlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJndG1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtdGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRwbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdmNhcmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInZjZ1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5oYWwranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5oYWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJoYWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaGFuZGhlbGQtZW50ZXJ0YWlubWVudCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInptbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5oYmNpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJoYmNpXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmhjbC1iaXJlcG9ydHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmhlcm9rdStqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmhoZS5sZXNzb24tcGxheWVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJsZXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaHAtaHBnbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaHBnbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ocC1ocGlkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJocGlkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmhwLWhwc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaHBzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmhwLWpseXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImpsdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ocC1wY2xcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBjbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ocC1wY2x4bFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGNseGxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaHR0cGhvbmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmh5ZHJvc3RhdGl4LnNvZi1kYXRhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZmQtaGRzdHhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaHlwZXJkcml2ZStqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmh6bi0zZC1jcm9zc3dvcmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlibS5hZnBsaW5lZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaWJtLmVsZWN0cm9uaWMtbWVkaWFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlibS5taW5pcGF5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtcHlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaWJtLm1vZGNhcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYWZwXCIsXG5cdFx0XHRcImxpc3RhZnBcIixcblx0XHRcdFwibGlzdDM4MjBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaWJtLnJpZ2h0cy1tYW5hZ2VtZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpcm1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaWJtLnNlY3VyZS1jb250YWluZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmljY3Byb2ZpbGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImljY1wiLFxuXHRcdFx0XCJpY21cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaWVlZS4xOTA1XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pZ2xvYWRlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaWdsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaXZwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2dVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaXZ1XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltcy5pbXNjY3YxcDFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltcy5pbXNjY3YxcDJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltcy5pbXNjY3YxcDNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltcy5saXMudjIucmVzdWx0K2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29sY29uc3VtZXJwcm9maWxlK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29scHJveHkranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pbXMubHRpLnYyLnRvb2xwcm94eS5pZCtqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmltcy5sdGkudjIudG9vbHNldHRpbmdzK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW1zLmx0aS52Mi50b29sc2V0dGluZ3Muc2ltcGxlK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW5mb3JtZWRjb250cm9sLnJtcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmluZm9ybWl4LXZpc2lvbmFyeVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW5mb3RlY2gucHJvamVjdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW5mb3RlY2gucHJvamVjdCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlubm9wYXRoLndhbXAubm90aWZpY2F0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pbnNvcnMuaWdtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpZ21cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW50ZXJjb24uZm9ybW5ldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieHB3XCIsXG5cdFx0XHRcInhweFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pbnRlcmdlb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaTJnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmludGVydHJ1c3QuZGlnaWJveFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaW50ZXJ0cnVzdC5ubmNwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pbnR1LnFib1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicWJvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmludHUucWZ4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJxZnhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaXB0Yy5nMi5jYXRhbG9naXRlbSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlwdGMuZzIuY29uY2VwdGl0ZW0reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pcHRjLmcyLmtub3dsZWRnZWl0ZW0reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pcHRjLmcyLm5ld3NpdGVtK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaXB0Yy5nMi5uZXdzbWVzc2FnZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlwdGMuZzIucGFja2FnZWl0ZW0reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5pcHRjLmcyLnBsYW5uaW5naXRlbSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlwdW5wbHVnZ2VkLnJjcHJvZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmNwcm9maWxlXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmlyZXBvc2l0b3J5LnBhY2thZ2UreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpcnBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaXMteHByXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4cHJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuaXNhYy5mY3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZjc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5qYW1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImphbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC1kaXJlY3Rvcnktc2VydmljZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuamFwYW5uZXQtanBuc3RvcmUtd2FrZXVwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC1wYXltZW50LXdha2V1cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuamFwYW5uZXQtcmVnaXN0cmF0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC1yZWdpc3RyYXRpb24td2FrZXVwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5qYXBhbm5ldC1zZXRzdG9yZS13YWtldXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmphcGFubmV0LXZlcmlmaWNhdGlvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuamFwYW5uZXQtdmVyaWZpY2F0aW9uLXdha2V1cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuamNwLmphdmFtZS5taWRsZXQtcm1zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJybXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuamlzcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiamlzcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5qb29zdC5qb2RhLWFyY2hpdmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImpvZGFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuanNrLmlzZG4tbmduXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5rYWhvb3R6XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJrdHpcIixcblx0XHRcdFwia3RyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmtkZS5rYXJib25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImthcmJvblwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5rZGUua2NoYXJ0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjaHJ0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmtkZS5rZm9ybXVsYVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwia2ZvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmtkZS5raXZpb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmx3XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmtkZS5rb250b3VyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJrb25cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQua2RlLmtwcmVzZW50ZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImtwclwiLFxuXHRcdFx0XCJrcHRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQua2RlLmtzcHJlYWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImtzcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5rZGUua3dvcmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImt3ZFwiLFxuXHRcdFx0XCJrd3RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQua2VuYW1lYWFwcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaHRrZVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5raWRzcGlyYXRpb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImtpYVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5raW5hclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwia25lXCIsXG5cdFx0XHRcImtucFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5rb2FuXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJza3BcIixcblx0XHRcdFwic2tkXCIsXG5cdFx0XHRcInNrdFwiLFxuXHRcdFx0XCJza21cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQua29kYWstZGVzY3JpcHRvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3NlXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmxhcy5sYXMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJsYXN4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubGliZXJ0eS1yZXF1ZXN0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZGVza3RvcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibGJkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmxsYW1hZ3JhcGhpY3MubGlmZS1iYWxhbmNlLmV4Y2hhbmdlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibGJlXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLTEtMi0zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCIxMjNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubG90dXMtYXBwcm9hY2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImFwclwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1mcmVlbGFuY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInByZVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5sb3R1cy1ub3Rlc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibnNmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLW9yZ2FuaXplclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3JnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLXNjcmVlbmNhbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2NtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLmxvdHVzLXdvcmRwcm9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImx3cFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tYWNwb3J0cy5wb3J0cGtnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwb3J0cGtnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1hcmxpbi5kcm0uYWN0aW9udG9rZW4reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tYXJsaW4uZHJtLmNvbmZ0b2tlbit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1hcmxpbi5kcm0ubGljZW5zZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1hcmxpbi5kcm0ubWRjZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubWFzb24ranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tYXhtaW5kLm1heG1pbmQtZGJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1jZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWNkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1lZGNhbGNkYXRhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtYzFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubWVkaWFzdGF0aW9uLmNka2V5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZGtleVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tZXJpZGlhbi1zbGluZ3Nob3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1mZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm13ZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tZm1wXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtZm1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubWljcm8ranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmZsb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmxvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguaWd4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpZ3hcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubWljcm9zb2Z0LnBvcnRhYmxlLWV4ZWN1dGFibGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1pZWxlK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubWlmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtaWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubWluaXNvZnQtaHAzMDAwLXNhdmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1pdHN1YmlzaGkubWlzdHktZ3VhcmQudHJ1c3R3ZWJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5kYWZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImRhZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGlzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkaXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1ia1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWJrXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy5tcXlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1xeVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXNsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtc2xcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubW9iaXVzLnBsY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGxjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vYml1cy50eGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInR4ZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb3BodW4uYXBwbGljYXRpb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1wblwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb3BodW4uY2VydGlmaWNhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1wY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb3Rvcm9sYS5mbGV4c3VpdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vdG9yb2xhLmZsZXhzdWl0ZS5hZHNpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb3Rvcm9sYS5mbGV4c3VpdGUuZmlzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tb3Rvcm9sYS5mbGV4c3VpdGUuZ290YXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vdG9yb2xhLmZsZXhzdWl0ZS5rbXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vdG9yb2xhLmZsZXhzdWl0ZS50dGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vdG9yb2xhLmZsZXhzdWl0ZS53ZW1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vdG9yb2xhLmlwcm1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4dWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtM21mZG9jdW1lbnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLWFydGdhbHJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjaWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtYXNmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1jYWItY29tcHJlc3NlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2FiXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLWNvbG9yLmljY3Byb2ZpbGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhsc1wiLFxuXHRcdFx0XCJ4bG1cIixcblx0XHRcdFwieGxhXCIsXG5cdFx0XHRcInhsY1wiLFxuXHRcdFx0XCJ4bHRcIixcblx0XHRcdFwieGx3XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGxhbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9lbmFibGVkLjEyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4bHNiXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvZW5hYmxlZC4xMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGxzbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhsdG1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJlb3RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtaHRtbGhlbHBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNobVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1pbXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImltc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1scm1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImxybVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1vZmZpY2UuYWN0aXZleCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZXRoZW1lXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0aG14XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLW9wZW50eXBlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtcGFja2FnZS5vYmZ1c2NhdGVkLW9wZW50eXBlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXBraS5zZWNjYXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2F0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXBraS5zdGxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3RsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXBsYXlyZWFkeS5pbml0aWF0b3IreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwcHRcIixcblx0XHRcdFwicHBzXCIsXG5cdFx0XHRcInBvdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LmFkZGluLm1hY3JvZW5hYmxlZC4xMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicHBhbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb2VuYWJsZWQuMTJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBwdG1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5zbGlkZS5tYWNyb2VuYWJsZWQuMTJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNsZG1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5zbGlkZXNob3cubWFjcm9lbmFibGVkLjEyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwcHNtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwb3RtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXByaW50aW5nLnByaW50dGlja2V0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy1wcm9qZWN0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtcHBcIixcblx0XHRcdFwibXB0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXRuZWZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXdpbmRvd3MucHJpbnRlcnBhaXJpbmdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXdtZHJtLmxpYy1jaGxnLXJlcVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXMtd21kcm0ubGljLXJlc3BcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXdtZHJtLm1ldGVyLWNobGctcmVxXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy13bWRybS5tZXRlci1yZXNwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLmRvY3VtZW50Lm1hY3JvZW5hYmxlZC4xMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZG9jbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZG90bVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3Jrc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid3BzXCIsXG5cdFx0XHRcIndrc1wiLFxuXHRcdFx0XCJ3Y21cIixcblx0XHRcdFwid2RiXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXdwbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid3BsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zLXhwc2RvY3VtZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4cHNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXNhLWRpc2staW1hZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm1zZXFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1zZXFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXNpZ25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm11bHRpYWQuY3JlYXRvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXVsdGlhZC5jcmVhdG9yLmNpZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXVzaWMtbmlmZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubXVzaWNpYW5cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm11c1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5tdXZlZS5zdHlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXN0eVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5teW5mY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidGFnbGV0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm5jZC5jb250cm9sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5uY2QucmVmZXJlbmNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5uZXJ2YW5hXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5uZXRmcHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm5ldXJvbGFuZ3VhZ2Uubmx1XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJubHVcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubmludGVuZG8ubml0cm8ucm9tXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5uaW50ZW5kby5zbmVzLnJvbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubml0ZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibnRmXCIsXG5cdFx0XHRcIm5pdGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtZGlyZWN0b3J5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJubmRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtc2VhbGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJubnNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtd2ViXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJubndcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9raWEuY2F0YWxvZ3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm5va2lhLmNvbm1sK3dieG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5jb25tbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm5va2lhLmlwdHYuY29uZmlnK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9raWEuaXNkcy1yYWRpby1wcmVzZXRzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5sYW5kbWFyayt3YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9raWEubGFuZG1hcmsreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5sYW5kbWFya2NvbGxlY3Rpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2UuYWMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2UuZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibmdkYXRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9raWEubi1nYWdlLnN5bWJpYW4uaW5zdGFsbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibi1nYWdlXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm5va2lhLm5jZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9raWEucGNkK3dieG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5wY2QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJwc3RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicnBzc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZG1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVkbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVkeFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5leHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImV4dFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5udHQtbG9jYWwuY29udGVudC1zaGFyZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubnR0LWxvY2FsLmZpbGUtdHJhbnNmZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm50dC1sb2NhbC5vZ3dfcmVtb3RlLWFjY2Vzc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQubnR0LWxvY2FsLnNpcC10YV9yZW1vdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm50dC1sb2NhbC5zaXAtdGFfdGNwX3N0cmVhbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZGNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmNoYXJ0LXRlbXBsYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvdGNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmRhdGFiYXNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZGJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmZvcm11bGFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9kZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZm9ybXVsYS10ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib2RmdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9kZ1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3MtdGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm90Z1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuaW1hZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9kaVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuaW1hZ2UtdGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm90aVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZHBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbi10ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3RwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib2RzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldC10ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3RzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZHRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtbWFzdGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZG1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtdGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm90dFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC13ZWJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm90aFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vYm5cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9mdG4ubDEwbitqc29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9pcGYuY29udGVudGFjY2Vzc2Rvd25sb2FkK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2lwZi5jb250ZW50YWNjZXNzc3RyZWFtaW5nK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2lwZi5jc3BnLWhleGJpbmFyeVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2lwZi5kYWUuc3ZnK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub2lwZi5kYWUueGh0bWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLm1pcHB2Y29udHJvbG1lc3NhZ2UreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLnBhZS5nZW1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9pcGYuc3BkaXNjb3ZlcnkreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLnNwZGxpc3QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vaXBmLnVlcHJvZmlsZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9pcGYudXNlcnByb2ZpbGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbHBjLXN1Z2FyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4b1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEtc2N3cy1jb25maWdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS1zY3dzLWh0dHAtcmVxdWVzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLXNjd3MtaHR0cC1yZXNwb25zZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmJjYXN0LmFzc29jaWF0ZWQtcHJvY2VkdXJlLXBhcmFtZXRlcit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5kcm0tdHJpZ2dlcit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5pbWQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3QubHRrbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmJjYXN0Lm5vdGlmaWNhdGlvbit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5wcm92aXNpb25pbmd0cmlnZ2VyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc2dib290XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc2dkZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5zZ2R1XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEuYmNhc3Quc2ltcGxlLXN5bWJvbC1jb250YWluZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5zbWFydGNhcmQtdHJpZ2dlcit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5zcHJvdit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5iY2FzdC5zdGttXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEuY2FiLWFkZHJlc3MtYm9vayt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5jYWItZmVhdHVyZS1oYW5kbGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmNhYi1wY2MreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEuY2FiLXN1YnMtaW52aXRlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmNhYi11c2VyLXByZWZzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmRjZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmRjZGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5kZDIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkZDJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmRybS5yaXNkK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLmdyb3VwLXVzYWdlLWxpc3QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEucGFsK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLnBvYy5kZXRhaWxlZC1wcm9ncmVzcy1yZXBvcnQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEucG9jLmZpbmFsLXJlcG9ydCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9tYS5wb2MuZ3JvdXBzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLnBvYy5pbnZvY2F0aW9uLWRlc2NyaXB0b3IreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEucG9jLm9wdGltaXplZC1wcm9ncmVzcy1yZXBvcnQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWEucHVzaFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLnNjaWRtLm1lc3NhZ2VzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hLnhjYXAtZGlyZWN0b3J5K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hZHMtZW1haWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vbWFkcy1maWxlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hZHMtZm9sZGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub21hbG9jLXN1cGwtaW5pdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbmV5ZS5vZWJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW5vZmZpY2VvcmcuZXh0ZW5zaW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm94dFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5jdXN0b20tcHJvcGVydGllcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmN1c3RvbXhtbHByb3BlcnRpZXMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmNoYXJ0K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmNoYXJ0c2hhcGVzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmRpYWdyYW1jb2xvcnMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuZGlhZ3JhbWRhdGEreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuZGlhZ3JhbWxheW91dCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmRyYXdpbmdtbC5kaWFncmFtc3R5bGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5leHRlbmRlZC1wcm9wZXJ0aWVzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwtdGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLmNvbW1lbnRhdXRob3JzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuY29tbWVudHMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5oYW5kb3V0bWFzdGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwubm90ZXNtYXN0ZXIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5ub3Rlc3NsaWRlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwcHR4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbi5tYWluK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc3Byb3BzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNsZHhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZWxheW91dCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlbWFzdGVyK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVzaG93XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwcHN4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvdy5tYWluK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGV1cGRhdGVpbmZvK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGFibGVzdHlsZXMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50YWdzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicG90eFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC50ZW1wbGF0ZS5tYWluK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudmlld3Byb3BzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC10ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5jYWxjY2hhaW4reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLmNoYXJ0c2hlZXQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLmNvbW1lbnRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5jb25uZWN0aW9ucyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuZGlhbG9nc2hlZXQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLmV4dGVybmFsbGluayt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwucGl2b3RjYWNoZWRlZmluaXRpb24reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnBpdm90Y2FjaGVyZWNvcmRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5waXZvdHRhYmxlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5xdWVyeXRhYmxlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5yZXZpc2lvbmhlYWRlcnMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnJldmlzaW9ubG9nK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGFyZWRzdHJpbmdzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGxzeFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0Lm1haW4reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0bWV0YWRhdGEreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnN0eWxlcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGFibGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRhYmxlc2luZ2xlY2VsbHMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRlbXBsYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhsdHhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZS5tYWluK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC51c2VybmFtZXMreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnZvbGF0aWxlZGVwZW5kZW5jaWVzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC50aGVtZSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnRoZW1lb3ZlcnJpZGUreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC52bWxkcmF3aW5nXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLXRlbXBsYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmNvbW1lbnRzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZG9jeFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Lmdsb3NzYXJ5K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudC5tYWluK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5lbmRub3Rlcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9udHRhYmxlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290ZXIreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rub3Rlcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwubnVtYmVyaW5nK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5zZXR0aW5ncyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuc3R5bGVzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkb3R4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUubWFpbit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwud2Vic2V0dGluZ3MreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLmNvcmUtcHJvcGVydGllcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UuZGlnaXRhbC1zaWduYXR1cmUteG1sc2lnbmF0dXJlK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5yZWxhdGlvbnNoaXBzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3JhY2xlLnJlc291cmNlK2pzb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3JhbmdlLmluZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3NhLm5ldGRlcGxveVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWdwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm9zZ2kuYnVuZGxlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vc2dpLmRwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5vc2dpLnN1YnN5c3RlbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZXNhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLm90cHMuY3Qta2lwK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucGFsbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGRiXCIsXG5cdFx0XHRcInBxYVwiLFxuXHRcdFx0XCJvcHJjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnBhbm9wbHlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnBhb3MreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wYW9zLnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wYXdhYWZpbGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBhd1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wY29zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wZy5mb3JtYXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN0clwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wZy5vc2FzbGlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVpNlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5waWFjY2Vzcy5hcHBsaWNhdGlvbi1saWNlbmNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5waWNzZWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVmaWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucG1pLndpZGdldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2dcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucG9jLmdyb3VwLWFkdmVydGlzZW1lbnQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wb2NrZXRsZWFyblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGxmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBiZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wb3dlcmJ1aWxkZXI2LXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjctc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucG93ZXJidWlsZGVyNzVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjc1LXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnByZW1pbmV0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wcmV2aWV3c3lzdGVtcy5ib3hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImJveFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5wcm90ZXVzLm1hZ2F6aW5lXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtZ3pcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucHVibGlzaGFyZS1kZWx0YS10cmVlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJxcHNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucHZpLnB0aWQxXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwdGlkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnB3Zy1tdWx0aXBsZXhlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucHdnLXhodG1sLXByaW50K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucXVhbGNvbW0uYnJldy1hcHAtcmVzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5xdWFyay5xdWFya3hwcmVzc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicXhkXCIsXG5cdFx0XHRcInF4dFwiLFxuXHRcdFx0XCJxd2RcIixcblx0XHRcdFwicXd0XCIsXG5cdFx0XHRcInF4bFwiLFxuXHRcdFx0XCJxeGJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucXVvYmplY3QtcXVveGRvY3VtZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1vbWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtYXVkaXQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtYXVkaXQtY29uZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1hdWRpdC1jb25uK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmFkaXN5cy5tc21sLWF1ZGl0LWRpYWxvZyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1hdWRpdC1zdHJlYW0reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtY29uZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1kaWFsb2creG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLWJhc2UreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLWZheC1kZXRlY3QreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLWZheC1zZW5kcmVjdit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1kaWFsb2ctZ3JvdXAreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yYWRpc3lzLm1zbWwtZGlhbG9nLXNwZWVjaCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJhZGlzeXMubXNtbC1kaWFsb2ctdHJhbnNmb3JtK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmFpbnN0b3IuZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmFwaWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJlYWx2bmMuYmVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJiZWRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJteGxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXVzaWN4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmVubGVhcm4ucmxwcmludFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNyeXB0b25vdGVcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucmltLmNvZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjb2RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQucm4tcmVhbG1lZGlhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnJuLXJlYWxtZWRpYS12YnJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicm12YlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5yb3V0ZTY2Lmxpbms2Nit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImxpbms2NlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ycy0yNzR4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5ydWNrdXMuZG93bmxvYWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnMzc21zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zYWlsaW5ndHJhY2tlci50cmFja1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc2JtLmNpZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc2JtLm1pZDJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNjcmlidXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC4zZGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5jc2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5kb2NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5lbWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5taHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5uZXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC5wcHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlYWxlZC50aWZmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWQueGxzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWRtZWRpYS5zb2Z0c2VhbC5odG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zZWFsZWRtZWRpYS5zb2Z0c2VhbC5wZGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlZW1haWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNlZVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zZW1hXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZW1hXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNlbWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNlbWRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc2VtZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2VtZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5mb3JtZGF0YVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaWZtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm10ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaXRwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmludGVyY2hhbmdlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpaWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQucGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaXBrXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNpbXRlY2gtbWluZG1hcHBlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidHdkXCIsXG5cdFx0XHRcInR3ZHNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc2lyZW4ranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zbWFmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtbWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc21hcnQubm90ZWJvb2tcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnNtYXJ0LnRlYWNoZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRlYWNoZXJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc29mdHdhcmU2MDIuZmlsbGVyLmZvcm0reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zb2Z0d2FyZTYwMi5maWxsZXIuZm9ybS14bWwtemlwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zb2xlbnQuc2RrbSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNka21cIixcblx0XHRcdFwic2RrZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5keHBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImR4cFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5zZnNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNmc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zc3MtY29kXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zc3MtZHRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zc3MtbnRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uY2FsY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZGNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmRyYXdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2RhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5pbXByZXNzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNkZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ubWF0aFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzbWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZHdcIixcblx0XHRcdFwidm9yXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXItZ2xvYmFsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNnbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdGVwbWFuaWEucGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic216aXBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnN0ZXBjaGFydFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic21cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3RyZWV0LXN0cmVhbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3VuLndhZGwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3hjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYy50ZW1wbGF0ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzdGNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN4ZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXcudGVtcGxhdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3RkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzeGlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5pbXByZXNzLnRlbXBsYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN0aVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLm1hdGhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3htXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN4d1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci5nbG9iYWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3hnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLnRlbXBsYXRlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN0d1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zdXMtY2FsZW5kYXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInN1c1wiLFxuXHRcdFx0XCJzdXNwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN2ZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3ZkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN3aWZ0dmlldy1pY3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN5bWJpYW4uaW5zdGFsbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzaXNcIixcblx0XHRcdFwic2lzeFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC5zeW5jbWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4c21cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3dieG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJiZG1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGRtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbS5ub3RpZmljYXRpb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbWRkZit3YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtZGRmK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtdG5kcyt3YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtdG5kcyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kcy5ub3RpZmljYXRpb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnRhby5pbnRlbnQtbW9kdWxlLWFyY2hpdmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRhb1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC50Y3BkdW1wLnBjYXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBjYXBcIixcblx0XHRcdFwiY2FwXCIsXG5cdFx0XHRcImRtcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC50bWQubWVkaWFmbGV4LmFwaSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnRtb2JpbGUtbGl2ZXR2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0bW9cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudHJpZC50cHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRwdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC50cmlzY2FwZS5teHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm14c1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC50cnVlYXBwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0cmFcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudHJ1ZWRvY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudWJpc29mdC53ZWJwbGF5ZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVmZGxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInVmZFwiLFxuXHRcdFx0XCJ1ZmRsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVpcS50aGVtZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXR6XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVtYWppblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidW1qXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVuaXR5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ1bml0eXdlYlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51b21sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidW9tbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmFsZXJ0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmFsZXJ0LXdieG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmJlYXJlci1jaG9pY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQuYmVhcmVyLWNob2ljZS13YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5jYWNoZW9wXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0LmNhY2hlb3Atd2J4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQuY2hhbm5lbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5jaGFubmVsLXdieG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0Lmxpc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQubGlzdC13YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudXBsYW5ldC5saXN0Y21kXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC51cGxhbmV0Lmxpc3RjbWQtd2J4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnVwbGFuZXQuc2lnbmFsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC52YWx2ZS5zb3VyY2UubWF0ZXJpYWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnZjeFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidmN4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnZkLXN0dWR5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC52ZWN0b3J3b3Jrc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudmVyaW1hdHJpeC52Y2FzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC52aWRzb2Z0LnZpZGNvbmZlcmVuY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnZpc2lvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ2c2RcIixcblx0XHRcdFwidnN0XCIsXG5cdFx0XHRcInZzc1wiLFxuXHRcdFx0XCJ2c3dcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudmlzaW9uYXJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ2aXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQudml2aWRlbmNlLnNjcmlwdGZpbGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnZzZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidnNmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndhcC5zaWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndhcC5zbGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndhcC53YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2J4bWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud2FwLndtbGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndtbGNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud2FwLndtbHNjcmlwdGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndtbHNjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndlYnR1cmJvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3dGJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud2ZhLnAycFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud2ZhLndzY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud2luZG93cy5kZXZpY2VwYWlyaW5nXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC53bWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndtZi5ib290c3RyYXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndvbGZyYW0ubWF0aGVtYXRpY2FcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndvbGZyYW0ubWF0aGVtYXRpY2EucGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud29sZnJhbS5wbGF5ZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm5icFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC53b3JkcGVyZmVjdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid3BkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndxZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid3FkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLndycS1ocDMwMDAtbGFiZWxsZWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnd0LnN0ZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3RmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnd2LmNzcCt3YnhtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud3YuY3NwK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQud3Yuc3NwK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQueGFjbWwranNvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC54YXJhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4YXJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQueGZkbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGZkbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC54ZmRsLndlYmZvcm1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnhtaSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnhtcGllLmNwa2dcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnhtcGllLmRwa2dcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnhtcGllLnBsYW5cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnhtcGllLnBwa2dcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnhtcGllLnhsaW1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1kaWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImh2ZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtc2NyaXB0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJodnNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LXZvaWNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJodnBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3NmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXQub3NmcHZnK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3NmcHZnXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5yZW1vdGUtc2V0dXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLWF1ZGlvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzYWZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtcGhyYXNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzcGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQueWFtYWhhLnRocm91Z2gtbmduXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC55YW1haGEudHVubmVsLXVkcGVuY2FwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC55YW93ZW1lXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY21wXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vdm5kLnp1bFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiemlyXCIsXG5cdFx0XHRcInppcnpcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi92bmQuenphenouZGVjayt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInphelwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZvaWNleG1sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidnhtbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3ZxLXJ0Y3B4clwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi93YXRjaGVyaW5mbyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vd2hvaXNwcC1xdWVyeVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi93aG9pc3BwLXJlc3BvbnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3dpZGdldFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2d0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vd2luaGxwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImhscFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3dpdGFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vd29yZHBlcmZlY3Q1LjFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24vd3NkbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndzZGxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi93c3BvbGljeSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndzcG9saWN5XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIjd6XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1hYml3b3JkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImFid1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtYWNlLWNvbXByZXNzZWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYWNlXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1hbWZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWFwcGxlLWRpc2tpbWFnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkbWdcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtYmluXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImFhYlwiLFxuXHRcdFx0XCJ4MzJcIixcblx0XHRcdFwidTMyXCIsXG5cdFx0XHRcInZveFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1tYXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYWFtXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1hdXRob3J3YXJlLXNlZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhYXNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWJjcGlvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImJjcGlvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1iZG9jXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJiZG9jXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1iaXR0b3JyZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRvcnJlbnRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWJsb3JiXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImJsYlwiLFxuXHRcdFx0XCJibG9yYlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtYnppcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJielwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtYnppcDJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYnoyXCIsXG5cdFx0XHRcImJvelwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtY2JyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNiclwiLFxuXHRcdFx0XCJjYmFcIixcblx0XHRcdFwiY2J0XCIsXG5cdFx0XHRcImNielwiLFxuXHRcdFx0XCJjYjdcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWNkbGlua1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ2Y2RcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWNmcy1jb21wcmVzc2VkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNmc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtY2hhdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjaGF0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1jaGVzcy1wZ25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGduXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1jaHJvbWUtZXh0ZW5zaW9uXCI6IHtcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjcnhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWNvbXByZXNzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1jb25mZXJlbmNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm5zY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtY3Bpb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjcGlvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1jc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY3NoXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1kZWJcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1kZWJpYW4tcGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkZWJcIixcblx0XHRcdFwidWRlYlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZGdjLWNvbXByZXNzZWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZGdjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1kaXJlY3RvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkaXJcIixcblx0XHRcdFwiZGNyXCIsXG5cdFx0XHRcImR4clwiLFxuXHRcdFx0XCJjc3RcIixcblx0XHRcdFwiY2N0XCIsXG5cdFx0XHRcImN4dFwiLFxuXHRcdFx0XCJ3M2RcIixcblx0XHRcdFwiZmdkXCIsXG5cdFx0XHRcInN3YVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZG9vbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3YWRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWR0Ym5jeCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibmN4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1kdGJvb2sreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImR0YlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZHRicmVzb3VyY2UreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJlc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZHZpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImR2aVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZW52b3lcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZXZ5XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1ldmFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZXZhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mb250LWJkZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJiZGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWZvbnQtZG9zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mb250LWZyYW1lbWFrZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWZvbnQtZ2hvc3RzY3JpcHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ3NmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mb250LWxpYmdyeFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZm9udC1saW51eC1wc2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicHNmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mb250LW90ZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm90ZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZm9udC1wY2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGNmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mb250LXNuZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzbmZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWZvbnQtc3BlZWRvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mb250LXN1bm9zLW5ld3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWZvbnQtdHRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidHRmXCIsXG5cdFx0XHRcInR0Y1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZm9udC10eXBlMVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwZmFcIixcblx0XHRcdFwicGZiXCIsXG5cdFx0XHRcInBmbVwiLFxuXHRcdFx0XCJhZm1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWZvbnQtdmZvbnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWZyZWVhcmNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXJjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1mdXR1cmVzcGxhc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3BsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1nY2EtY29tcHJlc3NlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJnY2FcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWdsdWx4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInVseFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtZ251bWVyaWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ251bWVyaWNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWdyYW1wcy14bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZ3JhbXBzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1ndGFyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImd0YXJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWd6aXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWhkZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJoZGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWluc3RhbGwtaW5zdHJ1Y3Rpb25zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImluc3RhbGxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LWlzbzk2NjAtaW1hZ2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaXNvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1qYXZhLWpubHAtZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqbmxwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1qYXZhc2NyaXB0XCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1sYXRleFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJsYXRleFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbHVhLWJ5dGVjb2RlXCI6IHtcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJsdWFjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1semgtY29tcHJlc3NlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJsemhcIixcblx0XHRcdFwibGhhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1taWVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWllXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInByY1wiLFxuXHRcdFx0XCJtb2JpXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1tcGVndXJsXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXMtYXBwbGljYXRpb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXBwbGljYXRpb25cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LW1zLXNob3J0Y3V0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImxua1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXMtd21kXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndtZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXMtd216XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndtelwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXMteGJhcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4YmFwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1tc2FjY2Vzc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtZGJcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LW1zYmluZGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9iZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXNjYXJkZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjcmRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LW1zY2xpcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjbHBcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LW1zZG93bmxvYWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZXhlXCIsXG5cdFx0XHRcImRsbFwiLFxuXHRcdFx0XCJjb21cIixcblx0XHRcdFwiYmF0XCIsXG5cdFx0XHRcIm1zaVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXZiXCIsXG5cdFx0XHRcIm0xM1wiLFxuXHRcdFx0XCJtMTRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LW1zbWV0YWZpbGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid21mXCIsXG5cdFx0XHRcIndtelwiLFxuXHRcdFx0XCJlbWZcIixcblx0XHRcdFwiZW16XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1tc21vbmV5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1ueVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXNwdWJsaXNoZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicHViXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1tc3NjaGVkdWxlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNjZFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbXN0ZXJtaW5hbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0cm1cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LW1zd3JpdGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid3JpXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1uZXRjZGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibmNcIixcblx0XHRcdFwiY2RmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1ucy1wcm94eS1hdXRvY29uZmlnXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBhY1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtbnpiXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm56YlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtcGtjczEyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInAxMlwiLFxuXHRcdFx0XCJwZnhcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRpZmljYXRlc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwN2JcIixcblx0XHRcdFwic3BjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0cmVxcmVzcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwN3JcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJhclwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtcmVzZWFyY2gtaW5mby1zeXN0ZW1zXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJpc1wiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzaFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtc2hhclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzaGFyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3dmXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1zaWx2ZXJsaWdodC1hcHBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGFwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1zcWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3FsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1zdHVmZml0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNpdFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2l0eFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtc3VicmlwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNydFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtc3Y0Y3Bpb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzdjRjcGlvXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC1zdjRjcmNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3Y0Y3JjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC10M3ZtLWltYWdlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInQzXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC10YWRzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdhbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtdGFyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidGFyXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC10Y2xcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidGNsXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC10ZXhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidGV4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC10ZXgtdGZtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRmbVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtdGV4aW5mb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0ZXhpbmZvXCIsXG5cdFx0XHRcInRleGlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LXRnaWZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib2JqXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC11c3RhclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ1c3RhclwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gtd2Fpcy1zb3VyY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3JjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC13ZWItYXBwLW1hbmlmZXN0K2pzb25cIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2ViYXBwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZGVyXCIsXG5cdFx0XHRcImNydFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3gteGZpZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmaWdcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LXhsaWZmK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4bGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LXhwaW5zdGFsbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4cGlcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94LXh6XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInh6XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veC16bWFjaGluZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ6MVwiLFxuXHRcdFx0XCJ6MlwiLFxuXHRcdFx0XCJ6M1wiLFxuXHRcdFx0XCJ6NFwiLFxuXHRcdFx0XCJ6NVwiLFxuXHRcdFx0XCJ6NlwiLFxuXHRcdFx0XCJ6N1wiLFxuXHRcdFx0XCJ6OFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3g0MDAtYnBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veGFjbWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3hhbWwreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhhbWxcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94Y2FwLWF0dCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veGNhcC1jYXBzK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94Y2FwLWRpZmYreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4ZGZcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94Y2FwLWVsK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94Y2FwLWVycm9yK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94Y2FwLW5zK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94Y29uLWNvbmZlcmVuY2UtaW5mbyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veGNvbi1jb25mZXJlbmNlLWluZm8tZGlmZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veGVuYyt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhlbmNcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGh0bWxcIixcblx0XHRcdFwieGh0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veGh0bWwtdm9pY2UreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhtbFwiLFxuXHRcdFx0XCJ4c2xcIixcblx0XHRcdFwieHNkXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veG1sLWR0ZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkdGRcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi94bWwtZXh0ZXJuYWwtcGFyc2VkLWVudGl0eVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhcHBsaWNhdGlvbi94bWwtcGF0Y2greG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3htcHAreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3hvcCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieG9wXCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veHByb2MreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhwbFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3hzbHQreG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4c2x0XCJcblx0XHRdXG5cdH0sXG5cdFwiYXBwbGljYXRpb24veHNwZit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieHNwZlwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3h2K3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXhtbFwiLFxuXHRcdFx0XCJ4aHZtbFwiLFxuXHRcdFx0XCJ4dm1sXCIsXG5cdFx0XHRcInh2bVwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3lhbmdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInlhbmdcIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi95aW4reG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ5aW5cIlxuXHRcdF1cblx0fSxcblx0XCJhcHBsaWNhdGlvbi96aXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInppcFwiXG5cdFx0XVxuXHR9LFxuXHRcImFwcGxpY2F0aW9uL3psaWJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vMWQtaW50ZXJsZWF2ZWQtcGFyaXR5ZmVjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvLzMya2FkcGNtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvLzNncHBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vM2dwcDJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vYWMzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2FkcGNtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImFkcFwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL2FtclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9hbXItd2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vYW1yLXdiK1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9hcHR4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2FzY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9hdHJhYy1hZHZhbmNlZC1sb3NzbGVzc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9hdHJhYy14XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2F0cmFjM1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9iYXNpY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYXVcIixcblx0XHRcdFwic25kXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8vYnYxNlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9idjMyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2NsZWFybW9kZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9jblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9kYXQxMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9kbHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZHNyLWVzMjAxMTA4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2Rzci1lczIwMjA1MFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9kc3ItZXMyMDIyMTFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZHNyLWVzMjAyMjEyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2R2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2R2aTRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZWFjM1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9lbmNhcHJ0cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9ldnJjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2V2cmMtcWNwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2V2cmMwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2V2cmMxXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2V2cmNiXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2V2cmNiMFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9ldnJjYjFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZXZyY253XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2V2cmNudzBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZXZyY253MVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9ldnJjd2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZXZyY3diMFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9ldnJjd2IxXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2Z3ZHJlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nNzE5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2c3MjJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZzcyMjFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZzcyM1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nNzI2LTE2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2c3MjYtMjRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZzcyNi0zMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nNzI2LTQwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2c3MjhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZzcyOVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nNzI5MVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nNzI5ZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nNzI5ZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nc21cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vZ3NtLWVmclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9nc20taHItMDhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vaWxiY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9pcC1tcl92Mi41XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2lzYWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJhdWRpby9sMTZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vbDIwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL2wyNFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2Vcblx0fSxcblx0XCJhdWRpby9sOFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9scGNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vbWlkaVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtaWRcIixcblx0XHRcdFwibWlkaVwiLFxuXHRcdFx0XCJrYXJcIixcblx0XHRcdFwicm1pXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8vbW9iaWxlLXhtZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9tcDRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1wNGFcIixcblx0XHRcdFwibTRhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8vbXA0YS1sYXRtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL21wYVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9tcGEtcm9idXN0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL21wZWdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1wZ2FcIixcblx0XHRcdFwibXAyXCIsXG5cdFx0XHRcIm1wMmFcIixcblx0XHRcdFwibXAzXCIsXG5cdFx0XHRcIm0yYVwiLFxuXHRcdFx0XCJtM2FcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby9tcGVnNC1nZW5lcmljXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL211c2VwYWNrXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXVkaW8vb2dnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJvZ2FcIixcblx0XHRcdFwib2dnXCIsXG5cdFx0XHRcInNweFwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL29wdXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcGFyaXR5ZmVjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3BjbWFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcGNtYS13YlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9wY211XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3BjbXUtd2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcHJzLnNpZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9xY2VscFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9yYXB0b3JmZWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcmVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3J0cC1lbmMtYWVzY20xMjhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcnRwLW1pZGlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcnRwbG9vcGJhY2tcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vcnR4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3MzbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzM21cIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby9zaWxrXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNpbFwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL3NtdlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9zbXYtcWNwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3NtdjBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vc3AtbWlkaVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby9zcGVleFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby90MTQwY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby90MzhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdGVsZXBob25lLWV2ZW50XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3RvbmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdWVtY2xpcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby91bHBmZWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdmR2aVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bXItd2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdm5kLjNncHAuaXVmcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuNHNiXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5hdWRpb2tvelwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuY2VscFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuY2lzY28ubnNlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5jbWxlcy5yYWRpby1ldmVudHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdm5kLmNucy5hbnAxXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5jbnMuaW5mMVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZGVjZS5hdWRpb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZhXCIsXG5cdFx0XHRcInV2dmFcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQuZGlnaXRhbC13aW5kc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZW9sXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8vdm5kLmRsbmEuYWR0c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZG9sYnkuaGVhYWMuMVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZG9sYnkuaGVhYWMuMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZG9sYnkubWxwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5kb2xieS5tcHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdm5kLmRvbGJ5LnBsMlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZG9sYnkucGwyeFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZG9sYnkucGwyelwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZG9sYnkucHVsc2UuMVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZHJhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkcmFcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQuZHRzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkdHNcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQuZHRzLmhkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkdHNoZFwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5kdmIuZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuZXZlcmFkLnBsalwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQuaG5zLmF1ZGlvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5sdWNlbnQudm9pY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImx2cFwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHlhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJweWFcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQubm9raWEubW9iaWxlLXhtZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQubm9ydGVsLnZia1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQubnVlcmEuZWNlbHA0ODAwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJlY2VscDQ4MDBcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQubnVlcmEuZWNlbHA3NDcwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJlY2VscDc0NzBcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQubnVlcmEuZWNlbHA5NjAwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJlY2VscDk2MDBcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby92bmQub2N0ZWwuc2JjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImF1ZGlvL3ZuZC5xY2VscFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQucmhldG9yZXguMzJrYWRwY21cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdm5kLnJpcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmlwXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8vdm5kLnJuLXJlYWxhdWRpb1wiOiB7XG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2Vcblx0fSxcblx0XCJhdWRpby92bmQuc2VhbGVkbWVkaWEuc29mdHNlYWwubXBlZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJhdWRpby92bmQudm14LmN2c2RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vdm5kLndhdmVcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwiYXVkaW8vdm9yYmlzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcImF1ZGlvL3ZvcmJpcy1jb25maWdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiYXVkaW8vd2F2XCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3YXZcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby93YXZlXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3YXZcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby93ZWJtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndlYmFcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby94LWFhY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhYWNcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby94LWFpZmZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYWlmXCIsXG5cdFx0XHRcImFpZmZcIixcblx0XHRcdFwiYWlmY1wiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL3gtY2FmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNhZlwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL3gtZmxhY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmbGFjXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8veC1tYXRyb3NrYVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJta2FcIlxuXHRcdF1cblx0fSxcblx0XCJhdWRpby94LW1wZWd1cmxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibTN1XCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8veC1tcy13YXhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2F4XCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8veC1tcy13bWFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid21hXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8veC1wbi1yZWFsYXVkaW9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmFtXCIsXG5cdFx0XHRcInJhXCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8veC1wbi1yZWFsYXVkaW8tcGx1Z2luXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJtcFwiXG5cdFx0XVxuXHR9LFxuXHRcImF1ZGlvL3gtdHRhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwiYXVkaW8veC13YXZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid2F2XCJcblx0XHRdXG5cdH0sXG5cdFwiYXVkaW8veG1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieG1cIlxuXHRcdF1cblx0fSxcblx0XCJjaGVtaWNhbC94LWNkeFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjZHhcIlxuXHRcdF1cblx0fSxcblx0XCJjaGVtaWNhbC94LWNpZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjaWZcIlxuXHRcdF1cblx0fSxcblx0XCJjaGVtaWNhbC94LWNtZGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY21kZlwiXG5cdFx0XVxuXHR9LFxuXHRcImNoZW1pY2FsL3gtY21sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNtbFwiXG5cdFx0XVxuXHR9LFxuXHRcImNoZW1pY2FsL3gtY3NtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJjc21sXCJcblx0XHRdXG5cdH0sXG5cdFwiY2hlbWljYWwveC1wZGJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJjaGVtaWNhbC94LXh5elwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ4eXpcIlxuXHRcdF1cblx0fSxcblx0XCJmb250L29wZW50eXBlXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm90ZlwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL2JtcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImJtcFwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL2NnbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY2dtXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UvZml0c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS9nM2ZheFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZzNcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS9naWZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdpZlwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL2llZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaWVmXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UvanAyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImltYWdlL2pwZWdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImpwZWdcIixcblx0XHRcdFwianBnXCIsXG5cdFx0XHRcImpwZVwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL2pwbVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS9qcHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uva3R4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJrdHhcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS9uYXBscHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2UvcGpwZWdcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwiaW1hZ2UvcG5nXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwbmdcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS9wcnMuYnRpZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiYnRpZlwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3Bycy5wdGlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2UvcHdnLXJhc3RlclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS9zZ2lcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2dpXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2Uvc3ZnK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzdmdcIixcblx0XHRcdFwic3ZnelwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3QzOFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS90aWZmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0aWZmXCIsXG5cdFx0XHRcInRpZlwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3RpZmYtZnhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLmFkb2JlLnBob3Rvc2hvcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwc2RcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuYWlyemlwLmFjY2VsZXJhdG9yLmF6dlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS92bmQuY25zLmluZjJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZpXCIsXG5cdFx0XHRcInV2dmlcIixcblx0XHRcdFwidXZnXCIsXG5cdFx0XHRcInV2dmdcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZGp2dVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZGp2dVwiLFxuXHRcdFx0XCJkanZcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZHZiLnN1YnRpdGxlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzdWJcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZHdnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkd2dcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZHhmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkeGZcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZmFzdGJpZHNoZWV0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmYnNcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZnB4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmcHhcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZnN0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJmc3RcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQuZnVqaXhlcm94LmVkbWljcy1tbXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1tclwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicmxjXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLmdsb2JhbGdyYXBoaWNzLnBnYlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS92bmQubWljcm9zb2Z0Lmljb25cIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLm1peFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS92bmQubXMtbW9kaVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWRpXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLm1zLXBob3RvXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndkcFwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3ZuZC5uZXQtZnB4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJucHhcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQucmFkaWFuY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLnNlYWxlZC5wbmdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLnNlYWxlZG1lZGlhLnNvZnRzZWFsLmdpZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS92bmQuc2VhbGVkbWVkaWEuc29mdHNlYWwuanBnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImltYWdlL3ZuZC5zdmZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLnRlbmNlbnQudGFwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcImltYWdlL3ZuZC52YWx2ZS5zb3VyY2UudGV4dHVyZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJpbWFnZS92bmQud2FwLndibXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndibXBcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS92bmQueGlmZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGlmXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2Uvdm5kLnpicnVzaC5wY3hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwiaW1hZ2Uvd2VicFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3ZWJwXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UveC0zZHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiM2RzXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UveC1jbXUtcmFzdGVyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInJhc1wiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3gtY214XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNteFwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3gtZnJlZWhhbmRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmhcIixcblx0XHRcdFwiZmhjXCIsXG5cdFx0XHRcImZoNFwiLFxuXHRcdFx0XCJmaDVcIixcblx0XHRcdFwiZmg3XCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UveC1pY29uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaWNvXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UveC1tcnNpZC1pbWFnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzaWRcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LW1zLWJtcFwiOiB7XG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJibXBcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LXBjeFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwY3hcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LXBpY3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicGljXCIsXG5cdFx0XHRcInBjdFwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3gtcG9ydGFibGUtYW55bWFwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBubVwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3gtcG9ydGFibGUtYml0bWFwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInBibVwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3gtcG9ydGFibGUtZ3JheW1hcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwZ21cIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LXBvcnRhYmxlLXBpeG1hcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJwcG1cIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LXJnYlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJyZ2JcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LXRnYVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ0Z2FcIlxuXHRcdF1cblx0fSxcblx0XCJpbWFnZS94LXhiaXRtYXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieGJtXCJcblx0XHRdXG5cdH0sXG5cdFwiaW1hZ2UveC14Y2ZcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwiaW1hZ2UveC14cGl4bWFwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInhwbVwiXG5cdFx0XVxuXHR9LFxuXHRcImltYWdlL3gteHdpbmRvd2R1bXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieHdkXCJcblx0XHRdXG5cdH0sXG5cdFwibWVzc2FnZS9jcGltXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1lc3NhZ2UvZGVsaXZlcnktc3RhdHVzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1lc3NhZ2UvZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1lc3NhZ2UvZXh0ZXJuYWwtYm9keVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtZXNzYWdlL2ZlZWRiYWNrLXJlcG9ydFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtZXNzYWdlL2dsb2JhbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtZXNzYWdlL2dsb2JhbC1kZWxpdmVyeS1zdGF0dXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibWVzc2FnZS9nbG9iYWwtZGlzcG9zaXRpb24tbm90aWZpY2F0aW9uXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1lc3NhZ2UvZ2xvYmFsLWhlYWRlcnNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibWVzc2FnZS9odHRwXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcIm1lc3NhZ2UvaW1kbit4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJtZXNzYWdlL25ld3NcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibWVzc2FnZS9wYXJ0aWFsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcIm1lc3NhZ2UvcmZjODIyXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImVtbFwiLFxuXHRcdFx0XCJtaW1lXCJcblx0XHRdXG5cdH0sXG5cdFwibWVzc2FnZS9zLWh0dHBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibWVzc2FnZS9zaXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibWVzc2FnZS9zaXBmcmFnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1lc3NhZ2UvdHJhY2tpbmctc3RhdHVzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1lc3NhZ2Uvdm5kLnNpLnNpbXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibWVzc2FnZS92bmQud2ZhLndzY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtb2RlbC9pZ2VzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJpZ3NcIixcblx0XHRcdFwiaWdlc1wiXG5cdFx0XVxuXHR9LFxuXHRcIm1vZGVsL21lc2hcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1zaFwiLFxuXHRcdFx0XCJtZXNoXCIsXG5cdFx0XHRcInNpbG9cIlxuXHRcdF1cblx0fSxcblx0XCJtb2RlbC92bmQuY29sbGFkYSt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImRhZVwiXG5cdFx0XVxuXHR9LFxuXHRcIm1vZGVsL3ZuZC5kd2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImR3ZlwiXG5cdFx0XVxuXHR9LFxuXHRcIm1vZGVsL3ZuZC5mbGF0bGFuZC4zZG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1vZGVsL3ZuZC5nZGxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImdkbFwiXG5cdFx0XVxuXHR9LFxuXHRcIm1vZGVsL3ZuZC5ncy1nZGxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJtb2RlbC92bmQuZ3MuZ2RsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm1vZGVsL3ZuZC5ndHdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImd0d1wiXG5cdFx0XVxuXHR9LFxuXHRcIm1vZGVsL3ZuZC5tb21sK3htbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtb2RlbC92bmQubXRzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtdHNcIlxuXHRcdF1cblx0fSxcblx0XCJtb2RlbC92bmQub3BlbmdleFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtb2RlbC92bmQucGFyYXNvbGlkLnRyYW5zbWl0LmJpbmFyeVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtb2RlbC92bmQucGFyYXNvbGlkLnRyYW5zbWl0LnRleHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibW9kZWwvdm5kLnZhbHZlLnNvdXJjZS5jb21waWxlZC1tYXBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibW9kZWwvdm5kLnZ0dVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidnR1XCJcblx0XHRdXG5cdH0sXG5cdFwibW9kZWwvdnJtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwid3JsXCIsXG5cdFx0XHRcInZybWxcIlxuXHRcdF1cblx0fSxcblx0XCJtb2RlbC94M2QrYmluYXJ5XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIngzZGJcIixcblx0XHRcdFwieDNkYnpcIlxuXHRcdF1cblx0fSxcblx0XCJtb2RlbC94M2QrZmFzdGluZm9zZXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibW9kZWwveDNkK3ZybWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieDNkdlwiLFxuXHRcdFx0XCJ4M2R2elwiXG5cdFx0XVxuXHR9LFxuXHRcIm1vZGVsL3gzZCt4bWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwieDNkXCIsXG5cdFx0XHRcIngzZHpcIlxuXHRcdF1cblx0fSxcblx0XCJtb2RlbC94M2QtdnJtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtdWx0aXBhcnQvYWx0ZXJuYXRpdmVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwibXVsdGlwYXJ0L2FwcGxlZG91YmxlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm11bHRpcGFydC9ieXRlcmFuZ2VzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm11bHRpcGFydC9kaWdlc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibXVsdGlwYXJ0L2VuY3J5cHRlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2Vcblx0fSxcblx0XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcIm11bHRpcGFydC9oZWFkZXItc2V0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm11bHRpcGFydC9taXhlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2Vcblx0fSxcblx0XCJtdWx0aXBhcnQvcGFyYWxsZWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwibXVsdGlwYXJ0L3JlbGF0ZWRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlXG5cdH0sXG5cdFwibXVsdGlwYXJ0L3JlcG9ydFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJtdWx0aXBhcnQvc2lnbmVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZVxuXHR9LFxuXHRcIm11bHRpcGFydC92b2ljZS1tZXNzYWdlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcIm11bHRpcGFydC94LW1peGVkLXJlcGxhY2VcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC8xZC1pbnRlcmxlYXZlZC1wYXJpdHlmZWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC9jYWNoZS1tYW5pZmVzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhcHBjYWNoZVwiLFxuXHRcdFx0XCJtYW5pZmVzdFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvY2FsZW5kYXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImljc1wiLFxuXHRcdFx0XCJpZmJcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L2NhbGVuZGVyXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwidGV4dC9jbWRcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJ0ZXh0L2NvZmZlZXNjcmlwdFwiOiB7XG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY29mZmVlXCIsXG5cdFx0XHRcImxpdGNvZmZlZVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvY3NzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNzc1wiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvY3N2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImNzdlwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvY3N2LXNjaGVtYVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L2RpcmVjdG9yeVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L2Ruc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L2VjbWFzY3JpcHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC9lbmNhcHJ0cFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L2VucmljaGVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvZndkcmVkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvZ3JhbW1hci1yZWYtbGlzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L2hqc29uXCI6IHtcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJoanNvblwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvaHRtbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJodG1sXCIsXG5cdFx0XHRcImh0bVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvamFkZVwiOiB7XG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiamFkZVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvamF2YXNjcmlwdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9LFxuXHRcInRleHQvamNyLWNuZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L2pzeFwiOiB7XG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqc3hcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L2xlc3NcIjoge1xuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImxlc3NcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L21hcmtkb3duXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvbWl6YXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC9uM1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJuM1wiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvcGFyYW1ldGVyc1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3Bhcml0eWZlY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3BsYWluXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInR4dFwiLFxuXHRcdFx0XCJ0ZXh0XCIsXG5cdFx0XHRcImNvbmZcIixcblx0XHRcdFwiZGVmXCIsXG5cdFx0XHRcImxpc3RcIixcblx0XHRcdFwibG9nXCIsXG5cdFx0XHRcImluXCIsXG5cdFx0XHRcImluaVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvcHJvdmVuYW5jZS1ub3RhdGlvblwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3Bycy5mYWxsZW5zdGVpbi5yc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC9wcnMubGluZXMudGFnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkc2NcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3JhcHRvcmZlY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3JlZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3JmYzgyMi1oZWFkZXJzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvcmljaHRleHRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicnR4XCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC9ydGZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWUsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicnRmXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC9ydHAtZW5jLWFlc2NtMTI4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvcnRwbG9vcGJhY2tcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC9ydHhcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC9zZ21sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzZ21sXCIsXG5cdFx0XHRcInNnbVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvc3R5bHVzXCI6IHtcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzdHlsdXNcIixcblx0XHRcdFwic3R5bFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvdDE0MFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3RhYi1zZXBhcmF0ZWQtdmFsdWVzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRzdlwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvdHJvZmZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInRcIixcblx0XHRcdFwidHJcIixcblx0XHRcdFwicm9mZlwiLFxuXHRcdFx0XCJtYW5cIixcblx0XHRcdFwibWVcIixcblx0XHRcdFwibXNcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3R1cnRsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidHRsXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC91bHBmZWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC91cmktbGlzdFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ1cmlcIixcblx0XHRcdFwidXJpc1wiLFxuXHRcdFx0XCJ1cmxzXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92Y2FyZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ2Y2FyZFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvdm5kLmFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC92bmQuYWJjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLmN1cmxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImN1cmxcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3ZuZC5jdXJsLmRjdXJsXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImRjdXJsXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92bmQuY3VybC5tY3VybFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtY3VybFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvdm5kLmN1cmwuc2N1cmxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2N1cmxcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3ZuZC5kZWJpYW4uY29weXJpZ2h0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLmRtY2xpZW50c2NyaXB0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLmR2Yi5zdWJ0aXRsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic3ViXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92bmQuZXNtZXJ0ZWMudGhlbWUtZGVzY3JpcHRvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3ZuZC5mbHlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZseVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQvdm5kLmZtaS5mbGV4c3RvclwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmx4XCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92bmQuZ3JhcGh2aXpcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImd2XCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92bmQuaW4zZC4zZG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCIzZG1sXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92bmQuaW4zZC5zcG90XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzcG90XCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92bmQuaXB0Yy5uZXdzbWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC92bmQuaXB0Yy5uaXRmXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLmxhdGV4LXpcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC92bmQubW90b3JvbGEucmVmbGV4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLm1zLW1lZGlhcGFja2FnZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3ZuZC5uZXQycGhvbmUuY29tbWNlbnRlci5jb21tYW5kXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLnJhZGlzeXMubXNtbC1iYXNpYy1sYXlvdXRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC92bmQuc2kudXJpY2F0YWxvZ3VlXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqYWRcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3ZuZC50cm9sbHRlY2gubGluZ3Vpc3RcIjoge1xuXHRcdFwic291cmNlXCI6IFwiaWFuYVwiXG5cdH0sXG5cdFwidGV4dC92bmQud2FwLnNpXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIlxuXHR9LFxuXHRcInRleHQvdm5kLndhcC5zbFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3ZuZC53YXAud21sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3bWxcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3ZuZC53YXAud21sc2NyaXB0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3bWxzXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC92dHRcIjoge1xuXHRcdFwiY2hhcnNldFwiOiBcIlVURi04XCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ2dHRcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3gtYXNtXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNcIixcblx0XHRcdFwiYXNtXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LWNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiY1wiLFxuXHRcdFx0XCJjY1wiLFxuXHRcdFx0XCJjeHhcIixcblx0XHRcdFwiY3BwXCIsXG5cdFx0XHRcImhcIixcblx0XHRcdFwiaGhcIixcblx0XHRcdFwiZGljXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LWNvbXBvbmVudFwiOiB7XG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaHRjXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LWZvcnRyYW5cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZlwiLFxuXHRcdFx0XCJmb3JcIixcblx0XHRcdFwiZjc3XCIsXG5cdFx0XHRcImY5MFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC1nd3QtcnBjXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwidGV4dC94LWhhbmRsZWJhcnMtdGVtcGxhdGVcIjoge1xuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImhic1wiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC1qYXZhLXNvdXJjZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqYXZhXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LWpxdWVyeS10bXBsXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwidGV4dC94LWx1YVwiOiB7XG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibHVhXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LW1hcmtkb3duXCI6IHtcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1hcmtkb3duXCIsXG5cdFx0XHRcIm1kXCIsXG5cdFx0XHRcIm1rZFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC1uZm9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibmZvXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LW9wbWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwib3BtbFwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC1wYXNjYWxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicFwiLFxuXHRcdFx0XCJwYXNcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3gtc2Fzc1wiOiB7XG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwic2Fzc1wiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC1zY3NzXCI6IHtcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJzY3NzXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LXNldGV4dFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJldHhcIlxuXHRcdF1cblx0fSxcblx0XCJ0ZXh0L3gtc2Z2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNmdlwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC11dWVuY29kZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ1dVwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveC12Y2FsZW5kYXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidmNzXCJcblx0XHRdXG5cdH0sXG5cdFwidGV4dC94LXZjYXJkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInZjZlwiXG5cdFx0XVxuXHR9LFxuXHRcInRleHQveG1sXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImlhbmFcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiB0cnVlXG5cdH0sXG5cdFwidGV4dC94bWwtZXh0ZXJuYWwtcGFyc2VkLWVudGl0eVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJpYW5hXCJcblx0fSxcblx0XCJ0ZXh0L3lhbWxcIjoge1xuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInlhbWxcIixcblx0XHRcdFwieW1sXCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vMWQtaW50ZXJsZWF2ZWQtcGFyaXR5ZmVjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vM2dwcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCIzZ3BcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby8zZ3BwLXR0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vM2dwcDJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiM2cyXCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vYm1wZWdcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby9idDY1NlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL2NlbGJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby9kdlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL2gyNjFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaDI2MVwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL2gyNjNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaDI2M1wiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL2gyNjMtMTk5OFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL2gyNjMtMjAwMFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL2gyNjRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiaDI2NFwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL2gyNjQtcmNkb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL2gyNjQtc3ZjXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vanBlZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJqcGd2XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vanBlZzIwMDBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby9qcG1cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwianBtXCIsXG5cdFx0XHRcImpwZ21cIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby9tajJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibWoyXCIsXG5cdFx0XHRcIm1qcDJcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby9tcDFzXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vbXAycFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL21wMnRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidHNcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby9tcDRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXA0XCIsXG5cdFx0XHRcIm1wNHZcIixcblx0XHRcdFwibXBnNFwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL21wNHYtZXNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby9tcGVnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm1wZWdcIixcblx0XHRcdFwibXBnXCIsXG5cdFx0XHRcIm1wZVwiLFxuXHRcdFx0XCJtMXZcIixcblx0XHRcdFwibTJ2XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vbXBlZzQtZ2VuZXJpY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL21wdlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL252XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vb2dnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIm9ndlwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3Bhcml0eWZlY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3BvaW50ZXJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby9xdWlja3RpbWVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwicXRcIixcblx0XHRcdFwibW92XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vcmF3XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vcnRwLWVuYy1hZXNjbTEyOFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3J0eFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3NtcHRlMjkybVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3VscGZlY1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3ZjMVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3ZuZC5jY3R2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vdm5kLmRlY2UuaGRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZoXCIsXG5cdFx0XHRcInV2dmhcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby92bmQuZGVjZS5tb2JpbGVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZtXCIsXG5cdFx0XHRcInV2dm1cIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby92bmQuZGVjZS5tcDRcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuZGVjZS5wZFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ1dnBcIixcblx0XHRcdFwidXZ2cFwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3ZuZC5kZWNlLnNkXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInV2c1wiLFxuXHRcdFx0XCJ1dnZzXCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vdm5kLmRlY2UudmlkZW9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidXZ2XCIsXG5cdFx0XHRcInV2dnZcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby92bmQuZGlyZWN0di5tcGVnXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vdm5kLmRpcmVjdHYubXBlZy10dHNcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuZGxuYS5tcGVnLXR0c1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3ZuZC5kdmIuZmlsZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJkdmJcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby92bmQuZnZ0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImZ2dFwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3ZuZC5obnMudmlkZW9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuaXB0dmZvcnVtLjFkcGFyaXR5ZmVjLTEwMTBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuaXB0dmZvcnVtLjFkcGFyaXR5ZmVjLTIwMDVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuaXB0dmZvcnVtLjJkcGFyaXR5ZmVjLTEwMTBcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuaXB0dmZvcnVtLjJkcGFyaXR5ZmVjLTIwMDVcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuaXB0dmZvcnVtLnR0c2F2Y1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3ZuZC5pcHR2Zm9ydW0udHRzbXBlZzJcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQubW90b3JvbGEudmlkZW9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQubW90b3JvbGEudmlkZW9wXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vdm5kLm1wZWd1cmxcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibXh1XCIsXG5cdFx0XHRcIm00dVwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHl2XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInB5dlwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3ZuZC5ub2tpYS5pbnRlcmxlYXZlZC1tdWx0aW1lZGlhXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vdm5kLm5va2lhLnZpZGVvdm9pcFwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3ZuZC5vYmplY3R2aWRlb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIlxuXHR9LFxuXHRcInZpZGVvL3ZuZC5zZWFsZWQubXBlZzFcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuc2VhbGVkLm1wZWc0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vdm5kLnNlYWxlZC5zd2ZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCJcblx0fSxcblx0XCJ2aWRlby92bmQuc2VhbGVkbWVkaWEuc29mdHNlYWwubW92XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiXG5cdH0sXG5cdFwidmlkZW8vdm5kLnV2dnUubXA0XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInV2dVwiLFxuXHRcdFx0XCJ1dnZ1XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vdm5kLnZpdm9cIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidml2XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8vd2VibVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3ZWJtXCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1mNHZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZjR2XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1mbGlcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmxpXCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1mbHZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJjb21wcmVzc2libGVcIjogZmFsc2UsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwiZmx2XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1tNHZcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwibTR2XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1tYXRyb3NrYVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImNvbXByZXNzaWJsZVwiOiBmYWxzZSxcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJta3ZcIixcblx0XHRcdFwibWszZFwiLFxuXHRcdFx0XCJta3NcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby94LW1uZ1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtbmdcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby94LW1zLWFzZlwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhc2ZcIixcblx0XHRcdFwiYXN4XCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1tcy12b2JcIjoge1xuXHRcdFwic291cmNlXCI6IFwiYXBhY2hlXCIsXG5cdFx0XCJleHRlbnNpb25zXCI6IFtcblx0XHRcdFwidm9iXCJcblx0XHRdXG5cdH0sXG5cdFwidmlkZW8veC1tcy13bVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJ3bVwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3gtbXMtd212XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiY29tcHJlc3NpYmxlXCI6IGZhbHNlLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndtdlwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3gtbXMtd214XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcIndteFwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3gtbXMtd3Z4XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInd2eFwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3gtbXN2aWRlb1wiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJhdmlcIlxuXHRcdF1cblx0fSxcblx0XCJ2aWRlby94LXNnaS1tb3ZpZVwiOiB7XG5cdFx0XCJzb3VyY2VcIjogXCJhcGFjaGVcIixcblx0XHRcImV4dGVuc2lvbnNcIjogW1xuXHRcdFx0XCJtb3ZpZVwiXG5cdFx0XVxuXHR9LFxuXHRcInZpZGVvL3gtc212XCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcInNtdlwiXG5cdFx0XVxuXHR9LFxuXHRcIngtY29uZmVyZW5jZS94LWNvb2x0YWxrXCI6IHtcblx0XHRcInNvdXJjZVwiOiBcImFwYWNoZVwiLFxuXHRcdFwiZXh0ZW5zaW9uc1wiOiBbXG5cdFx0XHRcImljZVwiXG5cdFx0XVxuXHR9LFxuXHRcIngtc2hhZGVyL3gtZnJhZ21lbnRcIjoge1xuXHRcdFwiY29tcHJlc3NpYmxlXCI6IHRydWVcblx0fSxcblx0XCJ4LXNoYWRlci94LXZlcnRleFwiOiB7XG5cdFx0XCJjb21wcmVzc2libGVcIjogdHJ1ZVxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9taW1lLXR5cGVzL34vbWltZS1kYi9kYi5qc29uXG4gKiogbW9kdWxlIGlkID0gMTEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG52YXIgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1N0cmVhbVxubW9kdWxlLmV4cG9ydHMuQWxpZ25lZFN0cmluZ0RlY29kZXIgPSBBbGlnbmVkU3RyaW5nRGVjb2RlclxuXG5mdW5jdGlvbiBTdHJpbmdTdHJlYW0oZnJvbSwgdG8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmluZ1N0cmVhbSkpIHJldHVybiBuZXcgU3RyaW5nU3RyZWFtKGZyb20sIHRvKVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpXG5cbiAgaWYgKGZyb20gPT0gbnVsbCkgZnJvbSA9ICd1dGY4J1xuXG4gIHRoaXMucmVhZGFibGUgPSB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXG4gIHRoaXMudG9FbmNvZGluZyA9ICh0byA9PSBudWxsID8gZnJvbSA6IHRvKVxuICB0aGlzLmZyb21FbmNvZGluZyA9ICh0byA9PSBudWxsID8gJycgOiBmcm9tKVxuICB0aGlzLmRlY29kZXIgPSBuZXcgQWxpZ25lZFN0cmluZ0RlY29kZXIodGhpcy50b0VuY29kaW5nKVxufVxudXRpbC5pbmhlcml0cyhTdHJpbmdTdHJlYW0sIFN0cmVhbSlcblxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignc3RyZWFtIG5vdCB3cml0YWJsZScpXG4gICAgZXJyLmNvZGUgPSAnRVBJUEUnXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAodGhpcy5mcm9tRW5jb2RpbmcpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gZGF0YS50b1N0cmluZygpXG4gICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgdGhpcy5mcm9tRW5jb2RpbmcpXG4gIH1cbiAgdmFyIHN0cmluZyA9IHRoaXMuZGVjb2Rlci53cml0ZShkYXRhKVxuICBpZiAoc3RyaW5nLmxlbmd0aCkgdGhpcy5lbWl0KCdkYXRhJywgc3RyaW5nKVxuICByZXR1cm4gIXRoaXMucGF1c2VkXG59XG5cblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGVjb2Rlci5mbHVzaCkge1xuICAgIHZhciBzdHJpbmcgPSB0aGlzLmRlY29kZXIuZmx1c2goKVxuICAgIGlmIChzdHJpbmcubGVuZ3RoKSB0aGlzLmVtaXQoJ2RhdGEnLCBzdHJpbmcpXG4gIH1cbn1cblxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLndyaXRhYmxlICYmICF0aGlzLnJlYWRhYmxlKSByZXR1cm5cbiAgdGhpcy5mbHVzaCgpXG4gIHRoaXMuZW1pdCgnZW5kJylcbiAgdGhpcy53cml0YWJsZSA9IHRoaXMucmVhZGFibGUgPSBmYWxzZVxuICB0aGlzLmRlc3Ryb3koKVxufVxuXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbFxuICB0aGlzLndyaXRhYmxlID0gdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gIHRoaXMuZW1pdCgnY2xvc2UnKVxufVxuXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZVxufVxuXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGF1c2VkKSB0aGlzLmVtaXQoJ2RyYWluJylcbiAgdGhpcy5wYXVzZWQgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBBbGlnbmVkU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICBTdHJpbmdEZWNvZGVyLmNhbGwodGhpcywgZW5jb2RpbmcpXG5cbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMud3JpdGUgPSBhbGlnbmVkV3JpdGVcbiAgICAgIHRoaXMuYWxpZ25lZEJ1ZmZlciA9IG5ldyBCdWZmZXIoMylcbiAgICAgIHRoaXMuYWxpZ25lZEJ5dGVzID0gMFxuICAgICAgYnJlYWtcbiAgfVxufVxudXRpbC5pbmhlcml0cyhBbGlnbmVkU3RyaW5nRGVjb2RlciwgU3RyaW5nRGVjb2RlcilcblxuQWxpZ25lZFN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5hbGlnbmVkQnVmZmVyIHx8ICF0aGlzLmFsaWduZWRCeXRlcykgcmV0dXJuICcnXG4gIHZhciBsZWZ0b3ZlciA9IHRoaXMuYWxpZ25lZEJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmFsaWduZWRCeXRlcylcbiAgdGhpcy5hbGlnbmVkQnl0ZXMgPSAwXG4gIHJldHVybiBsZWZ0b3ZlclxufVxuXG5mdW5jdGlvbiBhbGlnbmVkV3JpdGUoYnVmZmVyKSB7XG4gIHZhciByZW0gPSAodGhpcy5hbGlnbmVkQnl0ZXMgKyBidWZmZXIubGVuZ3RoKSAlIHRoaXMuYWxpZ25lZEJ1ZmZlci5sZW5ndGhcbiAgaWYgKCFyZW0gJiYgIXRoaXMuYWxpZ25lZEJ5dGVzKSByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpXG5cbiAgdmFyIHJldHVybkJ1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5hbGlnbmVkQnl0ZXMgKyBidWZmZXIubGVuZ3RoIC0gcmVtKVxuXG4gIHRoaXMuYWxpZ25lZEJ1ZmZlci5jb3B5KHJldHVybkJ1ZmZlciwgMCwgMCwgdGhpcy5hbGlnbmVkQnl0ZXMpXG4gIGJ1ZmZlci5jb3B5KHJldHVybkJ1ZmZlciwgdGhpcy5hbGlnbmVkQnl0ZXMsIDAsIGJ1ZmZlci5sZW5ndGggLSByZW0pXG5cbiAgYnVmZmVyLmNvcHkodGhpcy5hbGlnbmVkQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gcmVtLCBidWZmZXIubGVuZ3RoKVxuICB0aGlzLmFsaWduZWRCeXRlcyA9IHJlbVxuXG4gIHJldHVybiByZXR1cm5CdWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZylcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9zdHJpbmdzdHJlYW0vc3RyaW5nc3RyZWFtLmpzXG4gKiogbW9kdWxlIGlkID0gMTE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJmdW5jdGlvbiBDYXNlbGVzcyAoZGljdCkge1xuICB0aGlzLmRpY3QgPSBkaWN0IHx8IHt9XG59XG5DYXNlbGVzcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjbG9iYmVyKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIHRoaXMuc2V0KGksIG5hbWVbaV0sIHZhbHVlKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGNsb2JiZXIgPT09ICd1bmRlZmluZWQnKSBjbG9iYmVyID0gdHJ1ZVxuICAgIHZhciBoYXMgPSB0aGlzLmhhcyhuYW1lKVxuXG4gICAgaWYgKCFjbG9iYmVyICYmIGhhcykgdGhpcy5kaWN0W2hhc10gPSB0aGlzLmRpY3RbaGFzXSArICcsJyArIHZhbHVlXG4gICAgZWxzZSB0aGlzLmRpY3RbaGFzIHx8IG5hbWVdID0gdmFsdWVcbiAgICByZXR1cm4gaGFzXG4gIH1cbn1cbkNhc2VsZXNzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZGljdClcbiAgICAsIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICA7XG4gIGZvciAodmFyIGk9MDtpPGtleXMubGVuZ3RoO2krKykge1xuICAgIGlmIChrZXlzW2ldLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUpIHJldHVybiBrZXlzW2ldXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5DYXNlbGVzcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuICB2YXIgcmVzdWx0LCBfa2V5XG4gIHZhciBoZWFkZXJzID0gdGhpcy5kaWN0XG4gIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIF9rZXkgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgIGlmIChuYW1lID09PSBfa2V5KSByZXN1bHQgPSBoZWFkZXJzW2tleV1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuQ2FzZWxlc3MucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaGFzID0gdGhpcy5oYXMobmFtZSlcbiAgaWYgKCFoYXMpIHRocm93IG5ldyBFcnJvcignVGhlcmUgaXMgbm8gaGVhZGVyIHRoYW4gbWF0Y2hlcyBcIicrbmFtZSsnXCInKVxuICB0aGlzLmRpY3RbbmFtZV0gPSB0aGlzLmRpY3RbaGFzXVxuICBkZWxldGUgdGhpcy5kaWN0W2hhc11cbn1cbkNhc2VsZXNzLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaGFzID0gdGhpcy5oYXMobmFtZSlcbiAgcmV0dXJuIGRlbGV0ZSB0aGlzLmRpY3RbaGFzIHx8IG5hbWVdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRpY3QpIHtyZXR1cm4gbmV3IENhc2VsZXNzKGRpY3QpfVxubW9kdWxlLmV4cG9ydHMuaHR0cGlmeSA9IGZ1bmN0aW9uIChyZXNwLCBoZWFkZXJzKSB7XG4gIHZhciBjID0gbmV3IENhc2VsZXNzKGhlYWRlcnMpXG4gIHJlc3Auc2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNsb2JiZXIpIHtcbiAgICByZXR1cm4gYy5zZXQoa2V5LCB2YWx1ZSwgY2xvYmJlcilcbiAgfVxuICByZXNwLmhhc0hlYWRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gYy5oYXMoa2V5KVxuICB9XG4gIHJlc3AuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBjLmdldChrZXkpXG4gIH1cbiAgcmVzcC5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGMuZGVsKGtleSlcbiAgfVxuICByZXNwLmhlYWRlcnMgPSBjLmRpY3RcbiAgcmV0dXJuIGNcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jYXNlbGVzcy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBGb3JldmVyQWdlbnRcbkZvcmV2ZXJBZ2VudC5TU0wgPSBGb3JldmVyQWdlbnRTU0xcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBBZ2VudCA9IHJlcXVpcmUoJ2h0dHAnKS5BZ2VudFxuICAsIG5ldCA9IHJlcXVpcmUoJ25ldCcpXG4gICwgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgLCBBZ2VudFNTTCA9IHJlcXVpcmUoJ2h0dHBzJykuQWdlbnRcbiAgXG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uTmFtZShob3N0LCBwb3J0KSB7ICBcbiAgdmFyIG5hbWUgPSAnJ1xuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IGhvc3QgKyAnOicgKyBwb3J0XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIG5vZGUuanMgdjAxMi4wIGFuZCBpb2pzLXYxLjUuMSwgaG9zdCBpcyBhbiBvYmplY3QuIEFuZCBhbnkgZXhpc3RpbmcgbG9jYWxBZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGNvbm5lY3Rpb24gbmFtZS5cbiAgICBuYW1lID0gaG9zdC5ob3N0ICsgJzonICsgaG9zdC5wb3J0ICsgJzonICsgKGhvc3QubG9jYWxBZGRyZXNzID8gKGhvc3QubG9jYWxBZGRyZXNzICsgJzonKSA6ICc6JylcbiAgfVxuICByZXR1cm4gbmFtZVxufSAgICBcblxuZnVuY3Rpb24gRm9yZXZlckFnZW50KG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgc2VsZi5yZXF1ZXN0cyA9IHt9XG4gIHNlbGYuc29ja2V0cyA9IHt9XG4gIHNlbGYuZnJlZVNvY2tldHMgPSB7fVxuICBzZWxmLm1heFNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWF4U29ja2V0cyB8fCBBZ2VudC5kZWZhdWx0TWF4U29ja2V0c1xuICBzZWxmLm1pblNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWluU29ja2V0cyB8fCBGb3JldmVyQWdlbnQuZGVmYXVsdE1pblNvY2tldHNcbiAgc2VsZi5vbignZnJlZScsIGZ1bmN0aW9uKHNvY2tldCwgaG9zdCwgcG9ydCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29ubmVjdGlvbk5hbWUoaG9zdCwgcG9ydClcblxuICAgIGlmIChzZWxmLnJlcXVlc3RzW25hbWVdICYmIHNlbGYucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICBzZWxmLnJlcXVlc3RzW25hbWVdLnNoaWZ0KCkub25Tb2NrZXQoc29ja2V0KVxuICAgIH0gZWxzZSBpZiAoc2VsZi5zb2NrZXRzW25hbWVdLmxlbmd0aCA8IHNlbGYubWluU29ja2V0cykge1xuICAgICAgaWYgKCFzZWxmLmZyZWVTb2NrZXRzW25hbWVdKSBzZWxmLmZyZWVTb2NrZXRzW25hbWVdID0gW11cbiAgICAgIHNlbGYuZnJlZVNvY2tldHNbbmFtZV0ucHVzaChzb2NrZXQpXG4gICAgICBcbiAgICAgIC8vIGlmIGFuIGVycm9yIGhhcHBlbnMgd2hpbGUgd2UgZG9uJ3QgdXNlIHRoZSBzb2NrZXQgYW55d2F5LCBtZWgsIHRocm93IHRoZSBzb2NrZXQgYXdheVxuICAgICAgdmFyIG9uSWRsZUVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNvY2tldC5kZXN0cm95KClcbiAgICAgIH1cbiAgICAgIHNvY2tldC5fb25JZGxlRXJyb3IgPSBvbklkbGVFcnJvclxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uSWRsZUVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGVuZGluZyByZXF1ZXN0cyBqdXN0IGRlc3Ryb3kgdGhlXG4gICAgICAvLyBzb2NrZXQgYW5kIGl0IHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcG9vbC4gVGhpc1xuICAgICAgLy8gZ2V0cyB1cyBvdXQgb2YgdGltZW91dCBpc3N1ZXMgYW5kIGFsbG93cyB1cyB0b1xuICAgICAgLy8gZGVmYXVsdCB0byBDb25uZWN0aW9uOmtlZXAtYWxpdmUuXG4gICAgICBzb2NrZXQuZGVzdHJveSgpXG4gICAgfVxuICB9KVxuXG59XG51dGlsLmluaGVyaXRzKEZvcmV2ZXJBZ2VudCwgQWdlbnQpXG5cbkZvcmV2ZXJBZ2VudC5kZWZhdWx0TWluU29ja2V0cyA9IDVcblxuXG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBuZXQuY3JlYXRlQ29ubmVjdGlvblxuRm9yZXZlckFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0Tm9yZXVzZSA9IEFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0XG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmFkZFJlcXVlc3QgPSBmdW5jdGlvbihyZXEsIGhvc3QsIHBvcnQpIHtcbiAgdmFyIG5hbWUgPSBnZXRDb25uZWN0aW9uTmFtZShob3N0LCBwb3J0KVxuICBcbiAgaWYgKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuICAgIHZhciBvcHRpb25zID0gaG9zdFxuICAgIHBvcnQgPSBvcHRpb25zLnBvcnRcbiAgICBob3N0ID0gb3B0aW9ucy5ob3N0XG4gIH1cblxuICBpZiAodGhpcy5mcmVlU29ja2V0c1tuYW1lXSAmJiB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmxlbmd0aCA+IDAgJiYgIXJlcS51c2VDaHVua2VkRW5jb2RpbmdCeURlZmF1bHQpIHtcbiAgICB2YXIgaWRsZVNvY2tldCA9IHRoaXMuZnJlZVNvY2tldHNbbmFtZV0ucG9wKClcbiAgICBpZGxlU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVTb2NrZXQuX29uSWRsZUVycm9yKVxuICAgIGRlbGV0ZSBpZGxlU29ja2V0Ll9vbklkbGVFcnJvclxuICAgIHJlcS5fcmV1c2VkU29ja2V0ID0gdHJ1ZVxuICAgIHJlcS5vblNvY2tldChpZGxlU29ja2V0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkUmVxdWVzdE5vcmV1c2UocmVxLCBob3N0LCBwb3J0KVxuICB9XG59XG5cbkZvcmV2ZXJBZ2VudC5wcm90b3R5cGUucmVtb3ZlU29ja2V0ID0gZnVuY3Rpb24ocywgbmFtZSwgaG9zdCwgcG9ydCkge1xuICBpZiAodGhpcy5zb2NrZXRzW25hbWVdKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zb2NrZXRzW25hbWVdLmluZGV4T2YocylcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnNvY2tldHNbbmFtZV0uc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnNvY2tldHNbbmFtZV0gJiYgdGhpcy5zb2NrZXRzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGRvbid0IGxlYWtcbiAgICBkZWxldGUgdGhpcy5zb2NrZXRzW25hbWVdXG4gICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbmFtZV1cbiAgfVxuICBcbiAgaWYgKHRoaXMuZnJlZVNvY2tldHNbbmFtZV0pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmluZGV4T2YocylcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLnNwbGljZShpbmRleCwgMSlcbiAgICAgIGlmICh0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5mcmVlU29ja2V0c1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnJlcXVlc3RzW25hbWVdICYmIHRoaXMucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHJlcXVlc3RzIGFuZCBhIHNvY2tldCBnZXRzIGNsb3NlZCBhIG5ldyBvbmVcbiAgICAvLyBuZWVkcyB0byBiZSBjcmVhdGVkIHRvIHRha2Ugb3ZlciBpbiB0aGUgcG9vbCBmb3IgdGhlIG9uZSB0aGF0IGNsb3NlZC5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldChuYW1lLCBob3N0LCBwb3J0KS5lbWl0KCdmcmVlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBGb3JldmVyQWdlbnRTU0wgKG9wdGlvbnMpIHtcbiAgRm9yZXZlckFnZW50LmNhbGwodGhpcywgb3B0aW9ucylcbn1cbnV0aWwuaW5oZXJpdHMoRm9yZXZlckFnZW50U1NMLCBGb3JldmVyQWdlbnQpXG5cbkZvcmV2ZXJBZ2VudFNTTC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGNyZWF0ZUNvbm5lY3Rpb25TU0xcbkZvcmV2ZXJBZ2VudFNTTC5wcm90b3R5cGUuYWRkUmVxdWVzdE5vcmV1c2UgPSBBZ2VudFNTTC5wcm90b3R5cGUuYWRkUmVxdWVzdFxuXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU1NMIChwb3J0LCBob3N0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcG9ydCA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gcG9ydDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gaG9zdDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIHBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucy5wb3J0ID0gcG9ydDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLmhvc3QgPSBob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2ZvcmV2ZXItYWdlbnQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xubW9kdWxlLmV4cG9ydHMgPSBGb3JtRGF0YTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBmb3JtYXRIb3N0bmFtZShob3N0bmFtZSkge1xuICAvLyBjYW5vbmljYWxpemUgdGhlIGhvc3RuYW1lLCBzbyB0aGF0ICdvb2dsZS5jb20nIHdvbid0IG1hdGNoICdnb29nbGUuY29tJ1xuICByZXR1cm4gaG9zdG5hbWUucmVwbGFjZSgvXlxcLiovLCAnLicpLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSh6b25lKSB7XG4gIHpvbmUgPSB6b25lLnRyaW0oKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHpvbmVQYXJ0cyA9IHpvbmUuc3BsaXQoJzonLCAyKVxuICAgICwgem9uZUhvc3QgPSBmb3JtYXRIb3N0bmFtZSh6b25lUGFydHNbMF0pXG4gICAgLCB6b25lUG9ydCA9IHpvbmVQYXJ0c1sxXVxuICAgICwgaGFzUG9ydCA9IHpvbmUuaW5kZXhPZignOicpID4gLTFcblxuICByZXR1cm4ge2hvc3RuYW1lOiB6b25lSG9zdCwgcG9ydDogem9uZVBvcnQsIGhhc1BvcnQ6IGhhc1BvcnR9XG59XG5cbmZ1bmN0aW9uIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpIHtcbiAgdmFyIHBvcnQgPSB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICc0NDMnIDogJzgwJylcbiAgICAsIGhvc3RuYW1lID0gZm9ybWF0SG9zdG5hbWUodXJpLmhvc3RuYW1lKVxuICAgICwgbm9Qcm94eUxpc3QgPSBub1Byb3h5LnNwbGl0KCcsJylcblxuICAvLyBpdGVyYXRlIHRocm91Z2ggdGhlIG5vUHJveHlMaXN0IHVudGlsIGl0IGZpbmRzIGEgbWF0Y2guXG4gIHJldHVybiBub1Byb3h5TGlzdC5tYXAocGFyc2VOb1Byb3h5Wm9uZSkuc29tZShmdW5jdGlvbihub1Byb3h5Wm9uZSkge1xuICAgIHZhciBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpXG4gICAgICAsIGhvc3RuYW1lTWF0Y2hlZCA9IChcbiAgICAgICAgICBpc01hdGNoZWRBdCA+IC0xICYmXG4gICAgICAgICAgKGlzTWF0Y2hlZEF0ID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5Wm9uZS5ob3N0bmFtZS5sZW5ndGgpXG4gICAgICAgIClcblxuICAgIGlmIChub1Byb3h5Wm9uZS5oYXNQb3J0KSB7XG4gICAgICByZXR1cm4gKHBvcnQgPT09IG5vUHJveHlab25lLnBvcnQpICYmIGhvc3RuYW1lTWF0Y2hlZFxuICAgIH1cblxuICAgIHJldHVybiBob3N0bmFtZU1hdGNoZWRcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0UHJveHlGcm9tVVJJKHVyaSkge1xuICAvLyBEZWNpZGUgdGhlIHByb3BlciByZXF1ZXN0IHByb3h5IHRvIHVzZSBiYXNlZCBvbiB0aGUgcmVxdWVzdCBVUkkgb2JqZWN0IGFuZCB0aGVcbiAgLy8gZW52aXJvbm1lbnRhbCB2YXJpYWJsZXMgKE5PX1BST1hZLCBIVFRQX1BST1hZLCBldGMuKVxuICAvLyByZXNwZWN0IE5PX1BST1hZIGVudmlyb25tZW50IHZhcmlhYmxlcyAoc2VlOiBodHRwOi8vbHlueC5pc2Mub3JnL2N1cnJlbnQvYnJlYWtvdXQvbHlueF9oZWxwL2tleXN0cm9rZXMvZW52aXJvbm1lbnRzLmh0bWwpXG5cbiAgdmFyIG5vUHJveHkgPSBwcm9jZXNzLmVudi5OT19QUk9YWSB8fCBwcm9jZXNzLmVudi5ub19wcm94eSB8fCAnJ1xuXG4gIC8vIGlmIHRoZSBub1Byb3h5IGlzIGEgd2lsZGNhcmQgdGhlbiByZXR1cm4gbnVsbFxuXG4gIGlmIChub1Byb3h5ID09PSAnKicpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gaWYgdGhlIG5vUHJveHkgaXMgbm90IGVtcHR5IGFuZCB0aGUgdXJpIGlzIGZvdW5kIHJldHVybiBudWxsXG5cbiAgaWYgKG5vUHJveHkgIT09ICcnICYmIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBIVFRQIG9yIEhUVFBTIFByb3h5IGluIGVudmlyb25tZW50IEVsc2UgZGVmYXVsdCB0byBudWxsXG5cbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQX1BST1hZIHx8XG4gICAgICAgICAgIHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgbnVsbFxuICB9XG5cbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkgfHxcbiAgICAgICAgICAgcHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkgfHxcbiAgICAgICAgICAgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSAgfHxcbiAgICAgICAgICAgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSAgfHwgbnVsbFxuICB9XG5cbiAgLy8gaWYgbm9uZSBvZiB0aGF0IHdvcmtzLCByZXR1cm4gbnVsbFxuICAvLyAoV2hhdCB1cmkgcHJvdG9jb2wgYXJlIHlvdSB1c2luZyB0aGVuPylcblxuICByZXR1cm4gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3h5RnJvbVVSSVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlcXVlc3QvbGliL2dldFByb3h5RnJvbVVSSS5qc1xuICoqIG1vZHVsZSBpZCA9IDExOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbiAgLCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcblxuXG5mdW5jdGlvbiBRdWVyeXN0cmluZyAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMubGliID0gbnVsbFxuICB0aGlzLnVzZVF1ZXJ5c3RyaW5nID0gbnVsbFxuICB0aGlzLnBhcnNlT3B0aW9ucyA9IG51bGxcbiAgdGhpcy5zdHJpbmdpZnlPcHRpb25zID0gbnVsbFxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICh0aGlzLmxpYikge3JldHVybn1cblxuICB0aGlzLnVzZVF1ZXJ5c3RyaW5nID0gb3B0aW9ucy51c2VRdWVyeXN0cmluZ1xuICB0aGlzLmxpYiA9ICh0aGlzLnVzZVF1ZXJ5c3RyaW5nID8gcXVlcnlzdHJpbmcgOiBxcylcblxuICB0aGlzLnBhcnNlT3B0aW9ucyA9IG9wdGlvbnMucXNQYXJzZU9wdGlvbnMgfHwge31cbiAgdGhpcy5zdHJpbmdpZnlPcHRpb25zID0gb3B0aW9ucy5xc1N0cmluZ2lmeU9wdGlvbnMgfHwge31cbn1cblxuUXVlcnlzdHJpbmcucHJvdG90eXBlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuICh0aGlzLnVzZVF1ZXJ5c3RyaW5nKVxuICAgID8gdGhpcy5yZmMzOTg2KHRoaXMubGliLnN0cmluZ2lmeShvYmosXG4gICAgICB0aGlzLnN0cmluZ2lmeU9wdGlvbnMuc2VwIHx8IG51bGwsXG4gICAgICB0aGlzLnN0cmluZ2lmeU9wdGlvbnMuZXEgfHwgbnVsbCxcbiAgICAgIHRoaXMuc3RyaW5naWZ5T3B0aW9ucykpXG4gICAgOiB0aGlzLmxpYi5zdHJpbmdpZnkob2JqLCB0aGlzLnN0cmluZ2lmeU9wdGlvbnMpXG59XG5cblF1ZXJ5c3RyaW5nLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuICh0aGlzLnVzZVF1ZXJ5c3RyaW5nKVxuICAgID8gdGhpcy5saWIucGFyc2Uoc3RyLFxuICAgICAgdGhpcy5wYXJzZU9wdGlvbnMuc2VwIHx8IG51bGwsXG4gICAgICB0aGlzLnBhcnNlT3B0aW9ucy5lcSB8fCBudWxsLFxuICAgICAgdGhpcy5wYXJzZU9wdGlvbnMpXG4gICAgOiB0aGlzLmxpYi5wYXJzZShzdHIsIHRoaXMucGFyc2VPcHRpb25zKVxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUucmZjMzk4NiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUudW5lc2NhcGUgPSBxdWVyeXN0cmluZy51bmVzY2FwZVxuXG5leHBvcnRzLlF1ZXJ5c3RyaW5nID0gUXVlcnlzdHJpbmdcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZXF1ZXN0L2xpYi9xdWVyeXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9xcy9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBTdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xudmFyIFBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzdHJpbmdpZnk6IFN0cmluZ2lmeSxcbiAgICBwYXJzZTogUGFyc2Vcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcXMvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgYXJyYXlQcmVmaXhHZW5lcmF0b3JzOiB7XG4gICAgICAgIGJyYWNrZXRzOiBmdW5jdGlvbiAocHJlZml4LCBrZXkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgICAgIH0sXG4gICAgICAgIGluZGljZXM6IGZ1bmN0aW9uIChwcmVmaXgsIGtleSkge1xuXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nO1xuICAgICAgICB9LFxuICAgICAgICByZXBlYXQ6IGZ1bmN0aW9uIChwcmVmaXgsIGtleSkge1xuXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBwcmVmaXgsIGdlbmVyYXRlQXJyYXlQcmVmaXgsIHN0cmljdE51bGxIYW5kbGluZywgZmlsdGVyKSB7XG5cbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmogPSBmaWx0ZXIocHJlZml4LCBvYmopO1xuICAgIH1cbiAgICBlbHNlIGlmIChVdGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIG9iaiA9IG9iai50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0cmljdE51bGxIYW5kbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmVuY29kZShwcmVmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdib29sZWFuJykge1xuXG4gICAgICAgIHJldHVybiBbVXRpbHMuZW5jb2RlKHByZWZpeCkgKyAnPScgKyBVdGlscy5lbmNvZGUob2JqKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIG9iaktleXMgPSBBcnJheS5pc0FycmF5KGZpbHRlcikgPyBmaWx0ZXIgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG9iaktleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIGdlbmVyYXRlQXJyYXlQcmVmaXgocHJlZml4LCBrZXkpLCBnZW5lcmF0ZUFycmF5UHJlZml4LCBzdHJpY3ROdWxsSGFuZGxpbmcsIGZpbHRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChpbnRlcm5hbHMuc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXggKyAnWycgKyBrZXkgKyAnXScsIGdlbmVyYXRlQXJyYXlQcmVmaXgsIHN0cmljdE51bGxIYW5kbGluZywgZmlsdGVyKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gaW50ZXJuYWxzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuICAgIHZhciBzdHJpY3ROdWxsSGFuZGxpbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nIDogaW50ZXJuYWxzLnN0cmljdE51bGxIYW5kbGluZztcbiAgICB2YXIgb2JqS2V5cztcbiAgICB2YXIgZmlsdGVyO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIG9iaiA9IGZpbHRlcignJywgb2JqKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZpbHRlcikpIHtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBhcnJheUZvcm1hdDtcbiAgICBpZiAob3B0aW9ucy5hcnJheUZvcm1hdCBpbiBpbnRlcm5hbHMuYXJyYXlQcmVmaXhHZW5lcmF0b3JzKSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0aW9ucy5hcnJheUZvcm1hdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2luZGljZXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRpb25zLmluZGljZXMgPyAnaW5kaWNlcycgOiAncmVwZWF0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gaW50ZXJuYWxzLmFycmF5UHJlZml4R2VuZXJhdG9yc1thcnJheUZvcm1hdF07XG5cbiAgICBpZiAoIW9iaktleXMpIHtcbiAgICAgICAgb2JqS2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG9iaktleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tpXTtcbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGludGVybmFscy5zdHJpbmdpZnkob2JqW2tleV0sIGtleSwgZ2VuZXJhdGVBcnJheVByZWZpeCwgc3RyaWN0TnVsbEhhbmRsaW5nLCBmaWx0ZXIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cy5qb2luKGRlbGltaXRlcik7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3FzL2xpYi9zdHJpbmdpZnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIExvYWQgbW9kdWxlc1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcbmludGVybmFscy5oZXhUYWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIGludGVybmFscy5oZXhUYWJsZVtpXSA9ICclJyArICgoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCk7XG59XG5cblxuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXG4gICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc291cmNlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRhcmdldFtzb3VyY2VdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IFt0YXJnZXQsIHNvdXJjZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0YXJnZXQgPSBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcblxuICAgICAgICB0YXJnZXQgPSBleHBvcnRzLmFycmF5VG9PYmplY3QodGFyZ2V0KTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgZm9yICh2YXIgayA9IDAsIGtsID0ga2V5cy5sZW5ndGg7IGsgPCBrbDsgKytrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdO1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBleHBvcnRzLm1lcmdlKHRhcmdldFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG5cbiAgICAvLyBUaGlzIGNvZGUgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBieSBCcmlhbiBXaGl0ZSAobXNjZGV4KSBmb3IgdGhlIGlvLmpzIGNvcmUgcXVlcnlzdHJpbmcgbGlicmFyeS5cbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN0ciA9ICcnICsgc3RyO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzdHIubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjID09PSAweDJEIHx8IC8vIC1cbiAgICAgICAgICAgIGMgPT09IDB4MkUgfHwgLy8gLlxuICAgICAgICAgICAgYyA9PT0gMHg1RiB8fCAvLyBfXG4gICAgICAgICAgICBjID09PSAweDdFIHx8IC8vIH5cbiAgICAgICAgICAgIChjID49IDB4MzAgJiYgYyA8PSAweDM5KSB8fCAvLyAwLTlcbiAgICAgICAgICAgIChjID49IDB4NDEgJiYgYyA8PSAweDVBKSB8fCAvLyBhLXpcbiAgICAgICAgICAgIChjID49IDB4NjEgJiYgYyA8PSAweDdBKSkgeyAvLyBBLVpcblxuICAgICAgICAgICAgb3V0ICs9IHN0cltpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBvdXQgKz0gaW50ZXJuYWxzLmhleFRhYmxlW2NdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBvdXQgKz0gaW50ZXJuYWxzLmhleFRhYmxlWzB4QzAgfCAoYyA+PiA2KV0gKyBpbnRlcm5hbHMuaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xuICAgICAgICAgICAgb3V0ICs9IGludGVybmFscy5oZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGludGVybmFscy5oZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaW50ZXJuYWxzLmhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgKytpO1xuICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcbiAgICAgICAgb3V0ICs9IGludGVybmFscy5oZXhUYWJsZVsweEYwIHwgKGMgPj4gMTgpXSArIGludGVybmFscy5oZXhUYWJsZVsweDgwIHwgKChjID4+IDEyKSAmIDB4M0YpXSArIGludGVybmFscy5oZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaW50ZXJuYWxzLmhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuZXhwb3J0cy5jb21wYWN0ID0gZnVuY3Rpb24gKG9iaiwgcmVmcykge1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmVmcyA9IHJlZnMgfHwgW107XG4gICAgdmFyIGxvb2t1cCA9IHJlZnMuaW5kZXhPZihvYmopO1xuICAgIGlmIChsb29rdXAgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiByZWZzW2xvb2t1cF07XG4gICAgfVxuXG4gICAgcmVmcy5wdXNoKG9iaik7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBvYmoubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2gob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAoaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBvYmpba2V5XSA9IGV4cG9ydHMuY29tcGFjdChvYmpba2V5XSwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAob2JqID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmXG4gICAgICAgICAgICAgIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcXMvbGliL3V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7XG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgYXJyYXlMaW1pdDogMjAsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDAsXG4gICAgc3RyaWN0TnVsbEhhbmRsaW5nOiBmYWxzZVxufTtcblxuXG5pbnRlcm5hbHMucGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFydHMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgcG9zID0gcGFydC5pbmRleE9mKCddPScpID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogcGFydC5pbmRleE9mKCddPScpICsgMTtcblxuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAgb2JqW1V0aWxzLmRlY29kZShwYXJ0KV0gPSAnJztcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgb2JqW1V0aWxzLmRlY29kZShwYXJ0KV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleSA9IFV0aWxzLmRlY29kZShwYXJ0LnNsaWNlKDAsIHBvcykpO1xuICAgICAgICAgICAgdmFyIHZhbCA9IFV0aWxzLmRlY29kZShwYXJ0LnNsaWNlKHBvcyArIDEpKTtcblxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IFtdLmNvbmNhdChvYmpba2V5XSkuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGNoYWluLnNoaWZ0KCk7XG5cbiAgICB2YXIgb2JqO1xuICAgIGlmIChyb290ID09PSAnW10nKSB7XG4gICAgICAgIG9iaiA9IFtdO1xuICAgICAgICBvYmogPSBvYmouY29uY2F0KGludGVybmFscy5wYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdFswXSA9PT0gJ1snICYmIHJvb3Rbcm9vdC5sZW5ndGggLSAxXSA9PT0gJ10nID8gcm9vdC5zbGljZSgxLCByb290Lmxlbmd0aCAtIDEpIDogcm9vdDtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoY2xlYW5Sb290LCAxMCk7XG4gICAgICAgIHZhciBpbmRleFN0cmluZyA9ICcnICsgaW5kZXg7XG4gICAgICAgIGlmICghaXNOYU4oaW5kZXgpICYmXG4gICAgICAgICAgICByb290ICE9PSBjbGVhblJvb3QgJiZcbiAgICAgICAgICAgIGluZGV4U3RyaW5nID09PSBjbGVhblJvb3QgJiZcbiAgICAgICAgICAgIGluZGV4ID49IDAgJiZcbiAgICAgICAgICAgIChvcHRpb25zLnBhcnNlQXJyYXlzICYmXG4gICAgICAgICAgICAgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KSkge1xuXG4gICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgIG9ialtpbmRleF0gPSBpbnRlcm5hbHMucGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmpbY2xlYW5Sb290XSA9IGludGVybmFscy5wYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5wYXJzZUtleXMgPSBmdW5jdGlvbiAoa2V5LCB2YWwsIG9wdGlvbnMpIHtcblxuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cblxuICAgIGlmIChvcHRpb25zLmFsbG93RG90cykge1xuICAgICAgICBrZXkgPSBrZXkucmVwbGFjZSgvXFwuKFteXFwuXFxbXSspL2csICdbJDFdJyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIHBhcmVudCA9IC9eKFteXFxbXFxdXSopLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teXFxbXFxdXSpcXF0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBwYXJlbnQuZXhlYyhrZXkpO1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHNlZ21lbnRbMV0pIHtcbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcblxuICAgICAgICArK2k7XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGtleXMsIHZhbCwgb3B0aW9ucyk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgb3B0aW9ucykge1xuXG4gICAgaWYgKHN0ciA9PT0gJycgfHxcbiAgICAgICAgc3RyID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBzdHIgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnIHx8IFV0aWxzLmlzUmVnRXhwKG9wdGlvbnMuZGVsaW1pdGVyKSA/IG9wdGlvbnMuZGVsaW1pdGVyIDogaW50ZXJuYWxzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGludGVybmFscy5kZXB0aDtcbiAgICBvcHRpb25zLmFycmF5TGltaXQgPSB0eXBlb2Ygb3B0aW9ucy5hcnJheUxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuYXJyYXlMaW1pdCA6IGludGVybmFscy5hcnJheUxpbWl0O1xuICAgIG9wdGlvbnMucGFyc2VBcnJheXMgPSBvcHRpb25zLnBhcnNlQXJyYXlzICE9PSBmYWxzZTtcbiAgICBvcHRpb25zLmFsbG93RG90cyA9IG9wdGlvbnMuYWxsb3dEb3RzICE9PSBmYWxzZTtcbiAgICBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID0gdHlwZW9mIG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA6IGludGVybmFscy5wYXJhbWV0ZXJMaW1pdDtcbiAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBpbnRlcm5hbHMuc3RyaWN0TnVsbEhhbmRsaW5nO1xuXG5cbiAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gaW50ZXJuYWxzLnBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGtleXMgYW5kIHNldHVwIHRoZSBuZXcgb2JqZWN0XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRlbXBPYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIG5ld09iaiA9IGludGVybmFscy5wYXJzZUtleXMoa2V5LCB0ZW1wT2JqW2tleV0sIG9wdGlvbnMpO1xuICAgICAgICBvYmogPSBVdGlscy5tZXJnZShvYmosIG5ld09iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWxzLmNvbXBhY3Qob2JqKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcXMvbGliL3BhcnNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnaGFyLXZhbGlkYXRvcicpXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBIYXIgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxufVxuXG5IYXIucHJvdG90eXBlLnJlZHVjZXIgPSBmdW5jdGlvbiAob2JqLCBwYWlyKSB7XG4gIC8vIG5ldyBwcm9wZXJ0eSA/XG4gIGlmIChvYmpbcGFpci5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb2JqW3BhaXIubmFtZV0gPSBwYWlyLnZhbHVlXG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgLy8gZXhpc3Rpbmc/IGNvbnZlcnQgdG8gYXJyYXlcbiAgdmFyIGFyciA9IFtcbiAgICBvYmpbcGFpci5uYW1lXSxcbiAgICBwYWlyLnZhbHVlXG4gIF1cblxuICBvYmpbcGFpci5uYW1lXSA9IGFyclxuXG4gIHJldHVybiBvYmpcbn1cblxuSGFyLnByb3RvdHlwZS5wcmVwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gY29uc3RydWN0IHV0aWxpdHkgcHJvcGVydGllc1xuICBkYXRhLnF1ZXJ5T2JqID0ge31cbiAgZGF0YS5oZWFkZXJzT2JqID0ge31cbiAgZGF0YS5wb3N0RGF0YS5qc29uT2JqID0gZmFsc2VcbiAgZGF0YS5wb3N0RGF0YS5wYXJhbXNPYmogPSBmYWxzZVxuXG4gIC8vIGNvbnN0cnVjdCBxdWVyeSBvYmplY3RzXG4gIGlmIChkYXRhLnF1ZXJ5U3RyaW5nICYmIGRhdGEucXVlcnlTdHJpbmcubGVuZ3RoKSB7XG4gICAgZGF0YS5xdWVyeU9iaiA9IGRhdGEucXVlcnlTdHJpbmcucmVkdWNlKHRoaXMucmVkdWNlciwge30pXG4gIH1cblxuICAvLyBjb25zdHJ1Y3QgaGVhZGVycyBvYmplY3RzXG4gIGlmIChkYXRhLmhlYWRlcnMgJiYgZGF0YS5oZWFkZXJzLmxlbmd0aCkge1xuICAgIC8vIGxvd2VDYXNlIGhlYWRlciBrZXlzXG4gICAgZGF0YS5oZWFkZXJzT2JqID0gZGF0YS5oZWFkZXJzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChoZWFkZXJzLCBoZWFkZXIpIHtcbiAgICAgIGhlYWRlcnNbaGVhZGVyLm5hbWVdID0gaGVhZGVyLnZhbHVlXG4gICAgICByZXR1cm4gaGVhZGVyc1xuICAgIH0sIHt9KVxuICB9XG5cbiAgLy8gY29uc3RydWN0IENvb2tpZSBoZWFkZXJcbiAgaWYgKGRhdGEuY29va2llcyAmJiBkYXRhLmNvb2tpZXMubGVuZ3RoKSB7XG4gICAgdmFyIGNvb2tpZXMgPSBkYXRhLmNvb2tpZXMubWFwKGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICAgIHJldHVybiBjb29raWUubmFtZSArICc9JyArIGNvb2tpZS52YWx1ZVxuICAgIH0pXG5cbiAgICBpZiAoY29va2llcy5sZW5ndGgpIHtcbiAgICAgIGRhdGEuaGVhZGVyc09iai5jb29raWUgPSBjb29raWVzLmpvaW4oJzsgJylcbiAgICB9XG4gIH1cblxuICAvLyBwcmVwIGJvZHlcbiAgc3dpdGNoIChkYXRhLnBvc3REYXRhLm1pbWVUeXBlKSB7XG4gICAgY2FzZSAnbXVsdGlwYXJ0L21peGVkJzpcbiAgICBjYXNlICdtdWx0aXBhcnQvcmVsYXRlZCc6XG4gICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6XG4gICAgY2FzZSAnbXVsdGlwYXJ0L2FsdGVybmF0aXZlJzpcbiAgICAgIC8vIHJlc2V0IHZhbHVlc1xuICAgICAgZGF0YS5wb3N0RGF0YS5taW1lVHlwZSA9ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6XG4gICAgICBpZiAoIWRhdGEucG9zdERhdGEucGFyYW1zKSB7XG4gICAgICAgIGRhdGEucG9zdERhdGEudGV4dCA9ICcnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnBvc3REYXRhLnBhcmFtc09iaiA9IGRhdGEucG9zdERhdGEucGFyYW1zLnJlZHVjZSh0aGlzLnJlZHVjZXIsIHt9KVxuXG4gICAgICAgIC8vIGFsd2F5cyBvdmVyd3JpdGVcbiAgICAgICAgZGF0YS5wb3N0RGF0YS50ZXh0ID0gcXMuc3RyaW5naWZ5KGRhdGEucG9zdERhdGEucGFyYW1zT2JqKVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ3RleHQvanNvbic6XG4gICAgY2FzZSAndGV4dC94LWpzb24nOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtanNvbic6XG4gICAgICBkYXRhLnBvc3REYXRhLm1pbWVUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nXG5cbiAgICAgIGlmIChkYXRhLnBvc3REYXRhLnRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkYXRhLnBvc3REYXRhLmpzb25PYmogPSBKU09OLnBhcnNlKGRhdGEucG9zdERhdGEudGV4dClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMucmVxdWVzdC5kZWJ1ZyhlKVxuXG4gICAgICAgICAgLy8gZm9yY2UgYmFjayB0byB0ZXh0L3BsYWluXG4gICAgICAgICAgZGF0YS5wb3N0RGF0YS5taW1lVHlwZSA9ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuSGFyLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gc2tpcCBpZiBubyBoYXIgcHJvcGVydHkgZGVmaW5lZFxuICBpZiAoIW9wdGlvbnMuaGFyKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIHZhciBoYXIgPSB1dGlsLl9leHRlbmQoe30sIG9wdGlvbnMuaGFyKVxuXG4gIC8vIG9ubHkgcHJvY2VzcyB0aGUgZmlyc3QgZW50cnlcbiAgaWYgKGhhci5sb2cgJiYgaGFyLmxvZy5lbnRyaWVzKSB7XG4gICAgaGFyID0gaGFyLmxvZy5lbnRyaWVzWzBdXG4gIH1cblxuICAvLyBhZGQgb3B0aW9uYWwgcHJvcGVydGllcyB0byBtYWtlIHZhbGlkYXRpb24gc3VjY2Vzc2Z1bFxuICBoYXIudXJsID0gaGFyLnVybCB8fCBvcHRpb25zLnVybCB8fCBvcHRpb25zLnVyaSB8fCBvcHRpb25zLmJhc2VVcmwgfHwgJy8nXG4gIGhhci5odHRwVmVyc2lvbiA9IGhhci5odHRwVmVyc2lvbiB8fCAnSFRUUC8xLjEnXG4gIGhhci5xdWVyeVN0cmluZyA9IGhhci5xdWVyeVN0cmluZyB8fCBbXVxuICBoYXIuaGVhZGVycyA9IGhhci5oZWFkZXJzIHx8IFtdXG4gIGhhci5jb29raWVzID0gaGFyLmNvb2tpZXMgfHwgW11cbiAgaGFyLnBvc3REYXRhID0gaGFyLnBvc3REYXRhIHx8IHt9XG4gIGhhci5wb3N0RGF0YS5taW1lVHlwZSA9IGhhci5wb3N0RGF0YS5taW1lVHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuXG4gIGhhci5ib2R5U2l6ZSA9IDBcbiAgaGFyLmhlYWRlcnNTaXplID0gMFxuICBoYXIucG9zdERhdGEuc2l6ZSA9IDBcblxuICBpZiAoIXZhbGlkYXRlLnJlcXVlc3QoaGFyKSkge1xuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvLyBjbGVhbiB1cCBhbmQgZ2V0IHNvbWUgdXRpbGl0eSBwcm9wZXJ0aWVzXG4gIHZhciByZXEgPSB0aGlzLnByZXAoaGFyKVxuXG4gIC8vIGNvbnN0cnVjdCBuZXcgb3B0aW9uc1xuICBpZiAocmVxLnVybCkge1xuICAgIG9wdGlvbnMudXJsID0gcmVxLnVybFxuICB9XG5cbiAgaWYgKHJlcS5tZXRob2QpIHtcbiAgICBvcHRpb25zLm1ldGhvZCA9IHJlcS5tZXRob2RcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhyZXEucXVlcnlPYmopLmxlbmd0aCkge1xuICAgIG9wdGlvbnMucXMgPSByZXEucXVlcnlPYmpcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhyZXEuaGVhZGVyc09iaikubGVuZ3RoKSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gcmVxLmhlYWRlcnNPYmpcbiAgfVxuXG4gIHN3aXRjaCAocmVxLnBvc3REYXRhLm1pbWVUeXBlKSB7XG4gICAgY2FzZSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzpcbiAgICAgIG9wdGlvbnMuZm9ybSA9IHJlcS5wb3N0RGF0YS5wYXJhbXNPYmpcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICAgIGlmIChyZXEucG9zdERhdGEuanNvbk9iaikge1xuICAgICAgICBvcHRpb25zLmJvZHkgPSByZXEucG9zdERhdGEuanNvbk9ialxuICAgICAgICBvcHRpb25zLmpzb24gPSB0cnVlXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6XG4gICAgICBvcHRpb25zLmZvcm1EYXRhID0ge31cblxuICAgICAgcmVxLnBvc3REYXRhLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHt9XG5cbiAgICAgICAgaWYgKCFwYXJhbS5maWxlTmFtZSAmJiAhcGFyYW0uZmlsZU5hbWUgJiYgIXBhcmFtLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgb3B0aW9ucy5mb3JtRGF0YVtwYXJhbS5uYW1lXSA9IHBhcmFtLnZhbHVlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdHRlbXB0IHRvIHJlYWQgZnJvbSBkaXNrIVxuICAgICAgICBpZiAocGFyYW0uZmlsZU5hbWUgJiYgIXBhcmFtLnZhbHVlKSB7XG4gICAgICAgICAgYXR0YWNobWVudC52YWx1ZSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGFyYW0uZmlsZU5hbWUpXG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW0udmFsdWUpIHtcbiAgICAgICAgICBhdHRhY2htZW50LnZhbHVlID0gcGFyYW0udmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbS5maWxlTmFtZSkge1xuICAgICAgICAgIGF0dGFjaG1lbnQub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJhbS5maWxlTmFtZSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBwYXJhbS5jb250ZW50VHlwZSA/IHBhcmFtLmNvbnRlbnRUeXBlIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuZm9ybURhdGFbcGFyYW0ubmFtZV0gPSBhdHRhY2htZW50XG4gICAgICB9KVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocmVxLnBvc3REYXRhLnRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gcmVxLnBvc3REYXRhLnRleHRcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zXG59XG5cbmV4cG9ydHMuSGFyID0gSGFyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vcmVxdWVzdC9saWIvaGFyLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHNjaGVtYXMgPSByZXF1aXJlKCcuL3NjaGVtYXMnKVxudmFyIFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKVxudmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJ2lzLW15LWpzb24tdmFsaWQnKVxuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKHNjaGVtYSwgZGF0YSwgY2IpIHtcbiAgdmFyIHZhbGlkYXRlID0gdmFsaWRhdG9yKHNjaGVtYSwge1xuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICB2ZXJib3NlOiB0cnVlLFxuICAgIHNjaGVtYXM6IHNjaGVtYXNcbiAgfSlcblxuICB2YXIgdmFsaWQgPSBmYWxzZVxuXG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBleGVjdXRlIGlzLW15LWpzb24tdmFsaWRcbiAgICB2YWxpZCA9IHZhbGlkYXRlKGRhdGEpXG4gIH1cblxuICAvLyBjYWxsYmFjaz9cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB2YWxpZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYih2YWxpZGF0ZS5lcnJvcnMgPyBuZXcgVmFsaWRhdGlvbkVycm9yKHZhbGlkYXRlLmVycm9ycykgOiBudWxsLCB2YWxpZClcbiAgfVxuXG4gIHJldHVybiB2YWxpZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhLCBjYikge1xuICByZXR1cm4gcnVubmVyKHNjaGVtYXMuaGFyLCBkYXRhLCBjYilcbn1cblxuT2JqZWN0LmtleXMoc2NoZW1hcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gIG1vZHVsZS5leHBvcnRzW25hbWVdID0gZnVuY3Rpb24gKGRhdGEsIGNiKSB7XG4gICAgcmV0dXJuIHJ1bm5lcihzY2hlbWFzW25hbWVdLCBkYXRhLCBjYilcbiAgfVxufSlcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBzY2hlbWFzID0ge1xuICBjYWNoZTogcmVxdWlyZSgnLi9jYWNoZS5qc29uJyksXG4gIGNhY2hlRW50cnk6IHJlcXVpcmUoJy4vY2FjaGVFbnRyeS5qc29uJyksXG4gIGNvbnRlbnQ6IHJlcXVpcmUoJy4vY29udGVudC5qc29uJyksXG4gIGNvb2tpZTogcmVxdWlyZSgnLi9jb29raWUuanNvbicpLFxuICBjcmVhdG9yOiByZXF1aXJlKCcuL2NyZWF0b3IuanNvbicpLFxuICBlbnRyeTogcmVxdWlyZSgnLi9lbnRyeS5qc29uJyksXG4gIGhhcjogcmVxdWlyZSgnLi9oYXIuanNvbicpLFxuICBsb2c6IHJlcXVpcmUoJy4vbG9nLmpzb24nKSxcbiAgcGFnZTogcmVxdWlyZSgnLi9wYWdlLmpzb24nKSxcbiAgcGFnZVRpbWluZ3M6IHJlcXVpcmUoJy4vcGFnZVRpbWluZ3MuanNvbicpLFxuICBwb3N0RGF0YTogcmVxdWlyZSgnLi9wb3N0RGF0YS5qc29uJyksXG4gIHJlY29yZDogcmVxdWlyZSgnLi9yZWNvcmQuanNvbicpLFxuICByZXF1ZXN0OiByZXF1aXJlKCcuL3JlcXVlc3QuanNvbicpLFxuICByZXNwb25zZTogcmVxdWlyZSgnLi9yZXNwb25zZS5qc29uJyksXG4gIHRpbWluZ3M6IHJlcXVpcmUoJy4vdGltaW5ncy5qc29uJylcbn1cblxuLy8gaXMtbXktanNvbi12YWxpZCBkb2VzIG5vdCBwcm92aWRlIG1lYW5pbmdmdWwgZXJyb3IgbWVzc2FnZXMgZm9yIGV4dGVybmFsIHNjaGVtYXNcbi8vIHRoaXMgaXMgYSB3b3JrYXJvdW5kXG5zY2hlbWFzLmNhY2hlLnByb3BlcnRpZXMuYmVmb3JlUmVxdWVzdCA9IHNjaGVtYXMuY2FjaGVFbnRyeVxuc2NoZW1hcy5jYWNoZS5wcm9wZXJ0aWVzLmFmdGVyUmVxdWVzdCA9IHNjaGVtYXMuY2FjaGVFbnRyeVxuXG5zY2hlbWFzLnBhZ2UucHJvcGVydGllcy5wYWdlVGltaW5ncyA9IHNjaGVtYXMucGFnZVRpbWluZ3Ncblxuc2NoZW1hcy5yZXF1ZXN0LnByb3BlcnRpZXMuY29va2llcy5pdGVtcyA9IHNjaGVtYXMuY29va2llXG5zY2hlbWFzLnJlcXVlc3QucHJvcGVydGllcy5oZWFkZXJzLml0ZW1zID0gc2NoZW1hcy5yZWNvcmRcbnNjaGVtYXMucmVxdWVzdC5wcm9wZXJ0aWVzLnF1ZXJ5U3RyaW5nLml0ZW1zID0gc2NoZW1hcy5yZWNvcmRcbnNjaGVtYXMucmVxdWVzdC5wcm9wZXJ0aWVzLnBvc3REYXRhID0gc2NoZW1hcy5wb3N0RGF0YVxuXG5zY2hlbWFzLnJlc3BvbnNlLnByb3BlcnRpZXMuY29va2llcy5pdGVtcyA9IHNjaGVtYXMuY29va2llXG5zY2hlbWFzLnJlc3BvbnNlLnByb3BlcnRpZXMuaGVhZGVycy5pdGVtcyA9IHNjaGVtYXMucmVjb3JkXG5zY2hlbWFzLnJlc3BvbnNlLnByb3BlcnRpZXMuY29udGVudCA9IHNjaGVtYXMuY29udGVudFxuXG5zY2hlbWFzLmVudHJ5LnByb3BlcnRpZXMucmVxdWVzdCA9IHNjaGVtYXMucmVxdWVzdFxuc2NoZW1hcy5lbnRyeS5wcm9wZXJ0aWVzLnJlc3BvbnNlID0gc2NoZW1hcy5yZXNwb25zZVxuc2NoZW1hcy5lbnRyeS5wcm9wZXJ0aWVzLmNhY2hlID0gc2NoZW1hcy5jYWNoZVxuc2NoZW1hcy5lbnRyeS5wcm9wZXJ0aWVzLnRpbWluZ3MgPSBzY2hlbWFzLnRpbWluZ3Ncblxuc2NoZW1hcy5sb2cucHJvcGVydGllcy5jcmVhdG9yID0gc2NoZW1hcy5jcmVhdG9yXG5zY2hlbWFzLmxvZy5wcm9wZXJ0aWVzLmJyb3dzZXIgPSBzY2hlbWFzLmNyZWF0b3JcbnNjaGVtYXMubG9nLnByb3BlcnRpZXMucGFnZXMuaXRlbXMgPSBzY2hlbWFzLnBhZ2VcbnNjaGVtYXMubG9nLnByb3BlcnRpZXMuZW50cmllcy5pdGVtcyA9IHNjaGVtYXMuZW50cnlcblxuc2NoZW1hcy5oYXIucHJvcGVydGllcy5sb2cgPSBzY2hlbWFzLmxvZ1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNjaGVtYXNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJwcm9wZXJ0aWVzXCI6IHtcblx0XHRcImJlZm9yZVJlcXVlc3RcIjoge1xuXHRcdFx0XCIkcmVmXCI6IFwiI2NhY2hlRW50cnlcIlxuXHRcdH0sXG5cdFx0XCJhZnRlclJlcXVlc3RcIjoge1xuXHRcdFx0XCIkcmVmXCI6IFwiI2NhY2hlRW50cnlcIlxuXHRcdH0sXG5cdFx0XCJjb21tZW50XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2NhY2hlLmpzb25cbiAqKiBtb2R1bGUgaWQgPSAxMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcIm9uZU9mXCI6IFtcblx0XHR7XG5cdFx0XHRcInR5cGVcIjogXCJvYmplY3RcIixcblx0XHRcdFwib3B0aW9uYWxcIjogdHJ1ZSxcblx0XHRcdFwicmVxdWlyZWRcIjogW1xuXHRcdFx0XHRcImxhc3RBY2Nlc3NcIixcblx0XHRcdFx0XCJlVGFnXCIsXG5cdFx0XHRcdFwiaGl0Q291bnRcIlxuXHRcdFx0XSxcblx0XHRcdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XHRcdFwiZXhwaXJlc1wiOiB7XG5cdFx0XHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJsYXN0QWNjZXNzXCI6IHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImVUYWdcIjoge1xuXHRcdFx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiaGl0Q291bnRcIjoge1xuXHRcdFx0XHRcdFwidHlwZVwiOiBcImludGVnZXJcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRcdFwidHlwZVwiOiBudWxsLFxuXHRcdFx0XCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuXHRcdH1cblx0XVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaGFyLXZhbGlkYXRvci9saWIvc2NoZW1hcy9jYWNoZUVudHJ5Lmpzb25cbiAqKiBtb2R1bGUgaWQgPSAxMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuXHRcInR5cGVcIjogXCJvYmplY3RcIixcblx0XCJyZXF1aXJlZFwiOiBbXG5cdFx0XCJzaXplXCIsXG5cdFx0XCJtaW1lVHlwZVwiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJzaXplXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcImludGVnZXJcIlxuXHRcdH0sXG5cdFx0XCJjb21wcmVzc2lvblwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJpbnRlZ2VyXCJcblx0XHR9LFxuXHRcdFwibWltZVR5cGVcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9LFxuXHRcdFwidGV4dFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJlbmNvZGluZ1wiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJjb21tZW50XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2NvbnRlbnQuanNvblxuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwidHlwZVwiOiBcIm9iamVjdFwiLFxuXHRcInJlcXVpcmVkXCI6IFtcblx0XHRcIm5hbWVcIixcblx0XHRcInZhbHVlXCJcblx0XSxcblx0XCJwcm9wZXJ0aWVzXCI6IHtcblx0XHRcIm5hbWVcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9LFxuXHRcdFwidmFsdWVcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9LFxuXHRcdFwicGF0aFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJkb21haW5cIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9LFxuXHRcdFwiZXhwaXJlc1wiOiB7XG5cdFx0XHRcInR5cGVcIjogW1xuXHRcdFx0XHRcInN0cmluZ1wiLFxuXHRcdFx0XHRcIm51bGxcIlxuXHRcdFx0XSxcblx0XHRcdFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCJcblx0XHR9LFxuXHRcdFwiaHR0cE9ubHlcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiYm9vbGVhblwiXG5cdFx0fSxcblx0XHRcInNlY3VyZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJib29sZWFuXCJcblx0XHR9LFxuXHRcdFwiY29tbWVudFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH1cblx0fVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaGFyLXZhbGlkYXRvci9saWIvc2NoZW1hcy9jb29raWUuanNvblxuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwidHlwZVwiOiBcIm9iamVjdFwiLFxuXHRcInJlcXVpcmVkXCI6IFtcblx0XHRcIm5hbWVcIixcblx0XHRcInZlcnNpb25cIlxuXHRdLFxuXHRcInByb3BlcnRpZXNcIjoge1xuXHRcdFwibmFtZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJ2ZXJzaW9uXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvY3JlYXRvci5qc29uXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwib3B0aW9uYWxcIjogdHJ1ZSxcblx0XCJyZXF1aXJlZFwiOiBbXG5cdFx0XCJzdGFydGVkRGF0ZVRpbWVcIixcblx0XHRcInRpbWVcIixcblx0XHRcInJlcXVlc3RcIixcblx0XHRcInJlc3BvbnNlXCIsXG5cdFx0XCJjYWNoZVwiLFxuXHRcdFwidGltaW5nc1wiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJwYWdlcmVmXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcInN0YXJ0ZWREYXRlVGltZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIixcblx0XHRcdFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCIsXG5cdFx0XHRcInBhdHRlcm5cIjogXCJeKFxcXFxkezR9KSgtKT8oXFxcXGRcXFxcZCkoLSk/KFxcXFxkXFxcXGQpKFQpPyhcXFxcZFxcXFxkKSg6KT8oXFxcXGRcXFxcZCkoOik/KFxcXFxkXFxcXGQpKFxcXFwuXFxcXGQrKT8oWnwoWystXSkoXFxcXGRcXFxcZCkoOik/KFxcXFxkXFxcXGQpKVwiXG5cdFx0fSxcblx0XHRcInRpbWVcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwibnVtYmVyXCIsXG5cdFx0XHRcIm1pblwiOiAwXG5cdFx0fSxcblx0XHRcInJlcXVlc3RcIjoge1xuXHRcdFx0XCIkcmVmXCI6IFwiI3JlcXVlc3RcIlxuXHRcdH0sXG5cdFx0XCJyZXNwb25zZVwiOiB7XG5cdFx0XHRcIiRyZWZcIjogXCIjcmVzcG9uc2VcIlxuXHRcdH0sXG5cdFx0XCJjYWNoZVwiOiB7XG5cdFx0XHRcIiRyZWZcIjogXCIjY2FjaGVcIlxuXHRcdH0sXG5cdFx0XCJ0aW1pbmdzXCI6IHtcblx0XHRcdFwiJHJlZlwiOiBcIiN0aW1pbmdzXCJcblx0XHR9LFxuXHRcdFwic2VydmVySVBBZGRyZXNzXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiLFxuXHRcdFx0XCJvbmVPZlwiOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRcImZvcm1hdFwiOiBcImlwdjRcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0XCJmb3JtYXRcIjogXCJpcHY2XCJcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0sXG5cdFx0XCJjb25uZWN0aW9uXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvZW50cnkuanNvblxuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwidHlwZVwiOiBcIm9iamVjdFwiLFxuXHRcInJlcXVpcmVkXCI6IFtcblx0XHRcImxvZ1wiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJsb2dcIjoge1xuXHRcdFx0XCIkcmVmXCI6IFwiI2xvZ1wiXG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2hhci5qc29uXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwicmVxdWlyZWRcIjogW1xuXHRcdFwidmVyc2lvblwiLFxuXHRcdFwiY3JlYXRvclwiLFxuXHRcdFwiZW50cmllc1wiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJ2ZXJzaW9uXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcImNyZWF0b3JcIjoge1xuXHRcdFx0XCIkcmVmXCI6IFwiI2NyZWF0b3JcIlxuXHRcdH0sXG5cdFx0XCJicm93c2VyXCI6IHtcblx0XHRcdFwiJHJlZlwiOiBcIiNjcmVhdG9yXCJcblx0XHR9LFxuXHRcdFwicGFnZXNcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiYXJyYXlcIixcblx0XHRcdFwiaXRlbXNcIjoge1xuXHRcdFx0XHRcIiRyZWZcIjogXCIjcGFnZVwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImVudHJpZXNcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiYXJyYXlcIixcblx0XHRcdFwiaXRlbXNcIjoge1xuXHRcdFx0XHRcIiRyZWZcIjogXCIjZW50cnlcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJjb21tZW50XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL2xvZy5qc29uXG4gKiogbW9kdWxlIGlkID0gMTM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwib3B0aW9uYWxcIjogdHJ1ZSxcblx0XCJyZXF1aXJlZFwiOiBbXG5cdFx0XCJzdGFydGVkRGF0ZVRpbWVcIixcblx0XHRcImlkXCIsXG5cdFx0XCJ0aXRsZVwiLFxuXHRcdFwicGFnZVRpbWluZ3NcIlxuXHRdLFxuXHRcInByb3BlcnRpZXNcIjoge1xuXHRcdFwic3RhcnRlZERhdGVUaW1lXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiLFxuXHRcdFx0XCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcblx0XHRcdFwicGF0dGVyblwiOiBcIl4oXFxcXGR7NH0pKC0pPyhcXFxcZFxcXFxkKSgtKT8oXFxcXGRcXFxcZCkoVCk/KFxcXFxkXFxcXGQpKDopPyhcXFxcZFxcXFxkKSg6KT8oXFxcXGRcXFxcZCkoXFxcXC5cXFxcZCspPyhafChbKy1dKShcXFxcZFxcXFxkKSg6KT8oXFxcXGRcXFxcZCkpXCJcblx0XHR9LFxuXHRcdFwiaWRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCIsXG5cdFx0XHRcInVuaXF1ZVwiOiB0cnVlXG5cdFx0fSxcblx0XHRcInRpdGxlXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcInBhZ2VUaW1pbmdzXCI6IHtcblx0XHRcdFwiJHJlZlwiOiBcIiNwYWdlVGltaW5nc1wiXG5cdFx0fSxcblx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvcGFnZS5qc29uXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJvbkNvbnRlbnRMb2FkXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcIm51bWJlclwiLFxuXHRcdFx0XCJtaW5cIjogLTFcblx0XHR9LFxuXHRcdFwib25Mb2FkXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcIm51bWJlclwiLFxuXHRcdFx0XCJtaW5cIjogLTFcblx0XHR9LFxuXHRcdFwiY29tbWVudFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH1cblx0fVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaGFyLXZhbGlkYXRvci9saWIvc2NoZW1hcy9wYWdlVGltaW5ncy5qc29uXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwib3B0aW9uYWxcIjogdHJ1ZSxcblx0XCJyZXF1aXJlZFwiOiBbXG5cdFx0XCJtaW1lVHlwZVwiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJtaW1lVHlwZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJ0ZXh0XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcInBhcmFtc1wiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJhcnJheVwiLFxuXHRcdFx0XCJyZXF1aXJlZFwiOiBbXG5cdFx0XHRcdFwibmFtZVwiXG5cdFx0XHRdLFxuXHRcdFx0XCJwcm9wZXJ0aWVzXCI6IHtcblx0XHRcdFx0XCJuYW1lXCI6IHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcInZhbHVlXCI6IHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImZpbGVOYW1lXCI6IHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNvbnRlbnRUeXBlXCI6IHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiY29tbWVudFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH1cblx0fVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaGFyLXZhbGlkYXRvci9saWIvc2NoZW1hcy9wb3N0RGF0YS5qc29uXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwicmVxdWlyZWRcIjogW1xuXHRcdFwibmFtZVwiLFxuXHRcdFwidmFsdWVcIlxuXHRdLFxuXHRcInByb3BlcnRpZXNcIjoge1xuXHRcdFwibmFtZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJ2YWx1ZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJjb21tZW50XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fVxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9oYXItdmFsaWRhdG9yL2xpYi9zY2hlbWFzL3JlY29yZC5qc29uXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwicmVxdWlyZWRcIjogW1xuXHRcdFwibWV0aG9kXCIsXG5cdFx0XCJ1cmxcIixcblx0XHRcImh0dHBWZXJzaW9uXCIsXG5cdFx0XCJjb29raWVzXCIsXG5cdFx0XCJoZWFkZXJzXCIsXG5cdFx0XCJxdWVyeVN0cmluZ1wiLFxuXHRcdFwiaGVhZGVyc1NpemVcIixcblx0XHRcImJvZHlTaXplXCJcblx0XSxcblx0XCJwcm9wZXJ0aWVzXCI6IHtcblx0XHRcIm1ldGhvZFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJ1cmxcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCIsXG5cdFx0XHRcImZvcm1hdFwiOiBcInVyaVwiXG5cdFx0fSxcblx0XHRcImh0dHBWZXJzaW9uXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInN0cmluZ1wiXG5cdFx0fSxcblx0XHRcImNvb2tpZXNcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiYXJyYXlcIixcblx0XHRcdFwiaXRlbXNcIjoge1xuXHRcdFx0XHRcIiRyZWZcIjogXCIjY29va2llXCJcblx0XHRcdH1cblx0XHR9LFxuXHRcdFwiaGVhZGVyc1wiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJhcnJheVwiLFxuXHRcdFx0XCJpdGVtc1wiOiB7XG5cdFx0XHRcdFwiJHJlZlwiOiBcIiNyZWNvcmRcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJxdWVyeVN0cmluZ1wiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJhcnJheVwiLFxuXHRcdFx0XCJpdGVtc1wiOiB7XG5cdFx0XHRcdFwiJHJlZlwiOiBcIiNyZWNvcmRcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJwb3N0RGF0YVwiOiB7XG5cdFx0XHRcIiRyZWZcIjogXCIjcG9zdERhdGFcIlxuXHRcdH0sXG5cdFx0XCJoZWFkZXJzU2l6ZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJpbnRlZ2VyXCJcblx0XHR9LFxuXHRcdFwiYm9keVNpemVcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiaW50ZWdlclwiXG5cdFx0fSxcblx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvcmVxdWVzdC5qc29uXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJ0eXBlXCI6IFwib2JqZWN0XCIsXG5cdFwicmVxdWlyZWRcIjogW1xuXHRcdFwic3RhdHVzXCIsXG5cdFx0XCJzdGF0dXNUZXh0XCIsXG5cdFx0XCJodHRwVmVyc2lvblwiLFxuXHRcdFwiY29va2llc1wiLFxuXHRcdFwiaGVhZGVyc1wiLFxuXHRcdFwiY29udGVudFwiLFxuXHRcdFwicmVkaXJlY3RVUkxcIixcblx0XHRcImhlYWRlcnNTaXplXCIsXG5cdFx0XCJib2R5U2l6ZVwiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJzdGF0dXNcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiaW50ZWdlclwiXG5cdFx0fSxcblx0XHRcInN0YXR1c1RleHRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9LFxuXHRcdFwiaHR0cFZlcnNpb25cIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9LFxuXHRcdFwiY29va2llc1wiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJhcnJheVwiLFxuXHRcdFx0XCJpdGVtc1wiOiB7XG5cdFx0XHRcdFwiJHJlZlwiOiBcIiNjb29raWVcIlxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0XCJoZWFkZXJzXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcImFycmF5XCIsXG5cdFx0XHRcIml0ZW1zXCI6IHtcblx0XHRcdFx0XCIkcmVmXCI6IFwiI3JlY29yZFwiXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRcImNvbnRlbnRcIjoge1xuXHRcdFx0XCIkcmVmXCI6IFwiI2NvbnRlbnRcIlxuXHRcdH0sXG5cdFx0XCJyZWRpcmVjdFVSTFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzdHJpbmdcIlxuXHRcdH0sXG5cdFx0XCJoZWFkZXJzU2l6ZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJpbnRlZ2VyXCJcblx0XHR9LFxuXHRcdFwiYm9keVNpemVcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwiaW50ZWdlclwiXG5cdFx0fSxcblx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvcmVzcG9uc2UuanNvblxuICoqIG1vZHVsZSBpZCA9IDE0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwicmVxdWlyZWRcIjogW1xuXHRcdFwic2VuZFwiLFxuXHRcdFwid2FpdFwiLFxuXHRcdFwicmVjZWl2ZVwiXG5cdF0sXG5cdFwicHJvcGVydGllc1wiOiB7XG5cdFx0XCJkbnNcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwibnVtYmVyXCIsXG5cdFx0XHRcIm1pblwiOiAtMVxuXHRcdH0sXG5cdFx0XCJjb25uZWN0XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcIm51bWJlclwiLFxuXHRcdFx0XCJtaW5cIjogLTFcblx0XHR9LFxuXHRcdFwiYmxvY2tlZFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJudW1iZXJcIixcblx0XHRcdFwibWluXCI6IC0xXG5cdFx0fSxcblx0XHRcInNlbmRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwibnVtYmVyXCIsXG5cdFx0XHRcIm1pblwiOiAtMVxuXHRcdH0sXG5cdFx0XCJ3YWl0XCI6IHtcblx0XHRcdFwidHlwZVwiOiBcIm51bWJlclwiLFxuXHRcdFx0XCJtaW5cIjogLTFcblx0XHR9LFxuXHRcdFwicmVjZWl2ZVwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJudW1iZXJcIixcblx0XHRcdFwibWluXCI6IC0xXG5cdFx0fSxcblx0XHRcInNzbFwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJudW1iZXJcIixcblx0XHRcdFwibWluXCI6IC0xXG5cdFx0fSxcblx0XHRcImNvbW1lbnRcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic3RyaW5nXCJcblx0XHR9XG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL3NjaGVtYXMvdGltaW5ncy5qc29uXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yIChlcnJvcnMpIHtcbiAgdGhpcy5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcidcbiAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcbn1cblxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25FcnJvclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2hhci12YWxpZGF0b3IvbGliL2Vycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2Vub2JqID0gcmVxdWlyZSgnZ2VuZXJhdGUtb2JqZWN0LXByb3BlcnR5JylcbnZhciBnZW5mdW4gPSByZXF1aXJlKCdnZW5lcmF0ZS1mdW5jdGlvbicpXG52YXIganNvbnBvaW50ZXIgPSByZXF1aXJlKCdqc29ucG9pbnRlcicpXG52YXIgeHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpXG5cbnZhciBnZXQgPSBmdW5jdGlvbihvYmosIGFkZGl0aW9uYWxTY2hlbWFzLCBwdHIpIHtcblxuICB2YXIgdmlzaXQgPSBmdW5jdGlvbihzdWIpIHtcbiAgICBpZiAoc3ViICYmIHN1Yi5pZCA9PT0gcHRyKSByZXR1cm4gc3ViXG4gICAgaWYgKHR5cGVvZiBzdWIgIT09ICdvYmplY3QnIHx8ICFzdWIpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN1YikucmVkdWNlKGZ1bmN0aW9uKHJlcywgaykge1xuICAgICAgcmV0dXJuIHJlcyB8fCB2aXNpdChzdWJba10pXG4gICAgfSwgbnVsbClcbiAgfVxuXG4gIHZhciByZXMgPSB2aXNpdChvYmopXG4gIGlmIChyZXMpIHJldHVybiByZXNcblxuICBwdHIgPSBwdHIucmVwbGFjZSgvXiMvLCAnJylcbiAgcHRyID0gcHRyLnJlcGxhY2UoL1xcLyQvLCAnJylcblxuICB0cnkge1xuICAgIHJldHVybiBqc29ucG9pbnRlci5nZXQob2JqLCBkZWNvZGVVUkkocHRyKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdmFyIGVuZCA9IHB0ci5pbmRleE9mKCcjJylcbiAgICB2YXIgb3RoZXJcbiAgICAvLyBleHRlcm5hbCByZWZlcmVuY2VcbiAgICBpZiAoZW5kICE9PSAwKSB7XG4gICAgICAvLyBmcmFnbWVudCBkb2Vzbid0IGV4aXN0LlxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgb3RoZXIgPSBhZGRpdGlvbmFsU2NoZW1hc1twdHJdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXh0ID0gcHRyLnNsaWNlKDAsIGVuZClcbiAgICAgICAgb3RoZXIgPSBhZGRpdGlvbmFsU2NoZW1hc1tleHRdXG4gICAgICAgIHZhciBmcmFnbWVudCA9IHB0ci5zbGljZShlbmQpLnJlcGxhY2UoL14jLywgJycpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGpzb25wb2ludGVyLmdldChvdGhlciwgZnJhZ21lbnQpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhZGRpdGlvbmFsU2NoZW1hc1twdHJdXG4gICAgfVxuICAgIHJldHVybiBvdGhlciB8fCBudWxsXG4gIH1cbn1cblxudmFyIGZvcm1hdE5hbWUgPSBmdW5jdGlvbihmaWVsZCkge1xuICBmaWVsZCA9IEpTT04uc3RyaW5naWZ5KGZpZWxkKVxuICB2YXIgcGF0dGVybiA9IC9cXFsoW15cXFtcXF1cIl0rKVxcXS9cbiAgd2hpbGUgKHBhdHRlcm4udGVzdChmaWVsZCkpIGZpZWxkID0gZmllbGQucmVwbGFjZShwYXR0ZXJuLCAnLlwiKyQxK1wiJylcbiAgcmV0dXJuIGZpZWxkXG59XG5cbnZhciB0eXBlcyA9IHt9XG5cbnR5cGVzLmFueSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ3RydWUnXG59XG5cbnR5cGVzLm51bGwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBuYW1lKycgPT09IG51bGwnXG59XG5cbnR5cGVzLmJvb2xlYW4gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAndHlwZW9mICcrbmFtZSsnID09PSBcImJvb2xlYW5cIidcbn1cblxudHlwZXMuYXJyYXkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAnQXJyYXkuaXNBcnJheSgnK25hbWUrJyknXG59XG5cbnR5cGVzLm9iamVjdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICd0eXBlb2YgJytuYW1lKycgPT09IFwib2JqZWN0XCIgJiYgJytuYW1lKycgJiYgIUFycmF5LmlzQXJyYXkoJytuYW1lKycpJ1xufVxuXG50eXBlcy5udW1iZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAndHlwZW9mICcrbmFtZSsnID09PSBcIm51bWJlclwiJ1xufVxuXG50eXBlcy5pbnRlZ2VyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gJ3R5cGVvZiAnK25hbWUrJyA9PT0gXCJudW1iZXJcIiAmJiAoTWF0aC5mbG9vcignK25hbWUrJykgPT09ICcrbmFtZSsnIHx8ICcrbmFtZSsnID4gOTAwNzE5OTI1NDc0MDk5MiB8fCAnK25hbWUrJyA8IC05MDA3MTk5MjU0NzQwOTkyKSdcbn1cblxudHlwZXMuc3RyaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gJ3R5cGVvZiAnK25hbWUrJyA9PT0gXCJzdHJpbmdcIidcbn1cblxudmFyIHVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciBsaXN0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaCh0eXBlb2YgYXJyYXlbaV0gPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkoYXJyYXlbaV0pIDogYXJyYXlbaV0pXG4gIH1cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpc3QuaW5kZXhPZihsaXN0W2ldKSAhPT0gaSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxudmFyIGlzTXVsdGlwbGVPZiA9IGZ1bmN0aW9uKG5hbWUsIG11bHRpcGxlT2YpIHtcbiAgdmFyIHJlcztcbiAgdmFyIGZhY3RvciA9ICgobXVsdGlwbGVPZiB8IDApICE9PSBtdWx0aXBsZU9mKSA/IE1hdGgucG93KDEwLCBtdWx0aXBsZU9mLnRvU3RyaW5nKCkuc3BsaXQoJy4nKS5wb3AoKS5sZW5ndGgpIDogMVxuICBpZiAoZmFjdG9yID4gMSkge1xuICAgIHZhciBmYWN0b3JOYW1lID0gKChuYW1lIHwgMCkgIT09IG5hbWUpID8gTWF0aC5wb3coMTAsIG5hbWUudG9TdHJpbmcoKS5zcGxpdCgnLicpLnBvcCgpLmxlbmd0aCkgOiAxXG4gICAgaWYgKGZhY3Rvck5hbWUgPiBmYWN0b3IpIHJlcyA9IHRydWVcbiAgICBlbHNlIHJlcyA9IE1hdGgucm91bmQoZmFjdG9yICogbmFtZSkgJSAoZmFjdG9yICogbXVsdGlwbGVPZilcbiAgfVxuICBlbHNlIHJlcyA9IG5hbWUgJSBtdWx0aXBsZU9mO1xuICByZXR1cm4gIXJlcztcbn1cblxudmFyIHRvVHlwZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZVxufVxuXG52YXIgY29tcGlsZSA9IGZ1bmN0aW9uKHNjaGVtYSwgY2FjaGUsIHJvb3QsIHJlcG9ydGVyLCBvcHRzKSB7XG4gIHZhciBmbXRzID0gb3B0cyA/IHh0ZW5kKGZvcm1hdHMsIG9wdHMuZm9ybWF0cykgOiBmb3JtYXRzXG4gIHZhciBzY29wZSA9IHt1bmlxdWU6dW5pcXVlLCBmb3JtYXRzOmZtdHMsIGlzTXVsdGlwbGVPZjppc011bHRpcGxlT2Z9XG4gIHZhciB2ZXJib3NlID0gb3B0cyA/ICEhb3B0cy52ZXJib3NlIDogZmFsc2U7XG4gIHZhciBncmVlZHkgPSBvcHRzICYmIG9wdHMuZ3JlZWR5ICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdHMuZ3JlZWR5IDogZmFsc2U7XG5cbiAgdmFyIHN5bXMgPSB7fVxuICB2YXIgZ2Vuc3ltID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lKyhzeW1zW25hbWVdID0gKHN5bXNbbmFtZV0gfHwgMCkrMSlcbiAgfVxuXG4gIHZhciByZXZlcnNlUGF0dGVybnMgPSB7fVxuICB2YXIgcGF0dGVybnMgPSBmdW5jdGlvbihwKSB7XG4gICAgaWYgKHJldmVyc2VQYXR0ZXJuc1twXSkgcmV0dXJuIHJldmVyc2VQYXR0ZXJuc1twXVxuICAgIHZhciBuID0gZ2Vuc3ltKCdwYXR0ZXJuJylcbiAgICBzY29wZVtuXSA9IG5ldyBSZWdFeHAocClcbiAgICByZXZlcnNlUGF0dGVybnNbcF0gPSBuXG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIHZhciB2YXJzID0gWydpJywnaicsJ2snLCdsJywnbScsJ24nLCdvJywncCcsJ3EnLCdyJywncycsJ3QnLCd1JywndicsJ3gnLCd5JywneiddXG4gIHZhciBnZW5sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YXJzLnNoaWZ0KClcbiAgICB2YXJzLnB1c2godit2WzBdKVxuICAgIHJldHVybiB2XG4gIH1cblxuICB2YXIgdmlzaXQgPSBmdW5jdGlvbihuYW1lLCBub2RlLCByZXBvcnRlciwgZmlsdGVyKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBub2RlLnByb3BlcnRpZXNcbiAgICB2YXIgdHlwZSA9IG5vZGUudHlwZVxuICAgIHZhciB0dXBsZSA9IGZhbHNlXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlLml0ZW1zKSkgeyAvLyB0dXBsZSB0eXBlXG4gICAgICBwcm9wZXJ0aWVzID0ge31cbiAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgICAgIHByb3BlcnRpZXNbaV0gPSBpdGVtXG4gICAgICB9KVxuICAgICAgdHlwZSA9ICdhcnJheSdcbiAgICAgIHR1cGxlID0gdHJ1ZVxuICAgIH1cblxuICAgIHZhciBpbmRlbnQgPSAwXG4gICAgdmFyIGVycm9yID0gZnVuY3Rpb24obXNnLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgdmFsaWRhdGUoJ2Vycm9ycysrJylcbiAgICAgIGlmIChyZXBvcnRlciA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKHZhbGlkYXRlLmVycm9ycyA9PT0gbnVsbCkgdmFsaWRhdGUuZXJyb3JzID0gW10nKVxuICAgICAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICAgIHZhbGlkYXRlKCd2YWxpZGF0ZS5lcnJvcnMucHVzaCh7ZmllbGQ6JXMsbWVzc2FnZTolcyx2YWx1ZTolcyx0eXBlOiVzfSknLCBmb3JtYXROYW1lKHByb3AgfHwgbmFtZSksIEpTT04uc3RyaW5naWZ5KG1zZyksIHZhbHVlIHx8IG5hbWUsIEpTT04uc3RyaW5naWZ5KHR5cGUpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlKCd2YWxpZGF0ZS5lcnJvcnMucHVzaCh7ZmllbGQ6JXMsbWVzc2FnZTolc30pJywgZm9ybWF0TmFtZShwcm9wIHx8IG5hbWUpLCBKU09OLnN0cmluZ2lmeShtc2cpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgIGluZGVudCsrXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSB1bmRlZmluZWQpIHsnLCBuYW1lKVxuICAgICAgZXJyb3IoJ2lzIHJlcXVpcmVkJylcbiAgICAgIHZhbGlkYXRlKCd9IGVsc2UgeycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGVudCsrXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzICE9PSB1bmRlZmluZWQpIHsnLCBuYW1lKVxuICAgIH1cblxuICAgIHZhciB2YWxpZCA9IFtdLmNvbmNhdCh0eXBlKVxuICAgICAgLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0eXBlc1t0IHx8ICdhbnknXShuYW1lKVxuICAgICAgfSlcbiAgICAgIC5qb2luKCcgfHwgJykgfHwgJ3RydWUnXG5cbiAgICBpZiAodmFsaWQgIT09ICd0cnVlJykge1xuICAgICAgaW5kZW50KytcbiAgICAgIHZhbGlkYXRlKCdpZiAoISglcykpIHsnLCB2YWxpZClcbiAgICAgIGVycm9yKCdpcyB0aGUgd3JvbmcgdHlwZScpXG4gICAgICB2YWxpZGF0ZSgnfSBlbHNlIHsnKVxuICAgIH1cblxuICAgIGlmICh0dXBsZSkge1xuICAgICAgaWYgKG5vZGUuYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSkge1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzLmxlbmd0aCA+ICVkKSB7JywgbmFtZSwgbm9kZS5pdGVtcy5sZW5ndGgpXG4gICAgICAgIGVycm9yKCdoYXMgYWRkaXRpb25hbCBpdGVtcycpXG4gICAgICAgIHZhbGlkYXRlKCd9JylcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5hZGRpdGlvbmFsSXRlbXMpIHtcbiAgICAgICAgdmFyIGkgPSBnZW5sb29wKClcbiAgICAgICAgdmFsaWRhdGUoJ2ZvciAodmFyICVzID0gJWQ7ICVzIDwgJXMubGVuZ3RoOyAlcysrKSB7JywgaSwgbm9kZS5pdGVtcy5sZW5ndGgsIGksIG5hbWUsIGkpXG4gICAgICAgIHZpc2l0KG5hbWUrJ1snK2krJ10nLCBub2RlLmFkZGl0aW9uYWxJdGVtcywgcmVwb3J0ZXIsIGZpbHRlcilcbiAgICAgICAgdmFsaWRhdGUoJ30nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLmZvcm1hdCAmJiBmbXRzW25vZGUuZm9ybWF0XSkge1xuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnICYmIGZvcm1hdHNbbm9kZS5mb3JtYXRdKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuc3RyaW5nKG5hbWUpKVxuICAgICAgdmFyIG4gPSBnZW5zeW0oJ2Zvcm1hdCcpXG4gICAgICBzY29wZVtuXSA9IGZtdHNbbm9kZS5mb3JtYXRdXG5cbiAgICAgIGlmICh0eXBlb2Ygc2NvcGVbbl0gPT09ICdmdW5jdGlvbicpIHZhbGlkYXRlKCdpZiAoISVzKCVzKSkgeycsIG4sIG5hbWUpXG4gICAgICBlbHNlIHZhbGlkYXRlKCdpZiAoISVzLnRlc3QoJXMpKSB7JywgbiwgbmFtZSlcbiAgICAgIGVycm9yKCdtdXN0IGJlICcrbm9kZS5mb3JtYXQrJyBmb3JtYXQnKVxuICAgICAgdmFsaWRhdGUoJ30nKVxuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnICYmIGZvcm1hdHNbbm9kZS5mb3JtYXRdKSB2YWxpZGF0ZSgnfScpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZS5yZXF1aXJlZCkpIHtcbiAgICAgIHZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKHJlcSkge1xuICAgICAgICByZXR1cm4gZ2Vub2JqKG5hbWUsIHJlcSkgKyAnID09PSB1bmRlZmluZWQnXG4gICAgICB9XG5cbiAgICAgIHZhciBjaGVja1JlcXVpcmVkID0gZnVuY3Rpb24gKHJlcSkge1xuICAgICAgICB2YXIgcHJvcCA9IGdlbm9iaihuYW1lLCByZXEpO1xuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSB1bmRlZmluZWQpIHsnLCBwcm9wKVxuICAgICAgICBlcnJvcignaXMgcmVxdWlyZWQnLCBwcm9wKVxuICAgICAgICB2YWxpZGF0ZSgnbWlzc2luZysrJylcbiAgICAgICAgdmFsaWRhdGUoJ30nKVxuICAgICAgfVxuICAgICAgdmFsaWRhdGUoJ2lmICgoJXMpKSB7JywgdHlwZSAhPT0gJ29iamVjdCcgPyB0eXBlcy5vYmplY3QobmFtZSkgOiAndHJ1ZScpXG4gICAgICB2YWxpZGF0ZSgndmFyIG1pc3NpbmcgPSAwJylcbiAgICAgIG5vZGUucmVxdWlyZWQubWFwKGNoZWNrUmVxdWlyZWQpXG4gICAgICB2YWxpZGF0ZSgnfScpO1xuICAgICAgaWYgKCFncmVlZHkpIHtcbiAgICAgICAgdmFsaWRhdGUoJ2lmIChtaXNzaW5nID09PSAwKSB7JylcbiAgICAgICAgaW5kZW50KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS51bmlxdWVJdGVtcykge1xuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5hcnJheShuYW1lKSlcbiAgICAgIHZhbGlkYXRlKCdpZiAoISh1bmlxdWUoJXMpKSkgeycsIG5hbWUpXG4gICAgICBlcnJvcignbXVzdCBiZSB1bmlxdWUnKVxuICAgICAgdmFsaWRhdGUoJ30nKVxuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5lbnVtKSB7XG4gICAgICB2YXIgY29tcGxleCA9IG5vZGUuZW51bS5zb21lKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0J1xuICAgICAgfSlcblxuICAgICAgdmFyIGNvbXBhcmUgPSBjb21wbGV4ID9cbiAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiAnSlNPTi5zdHJpbmdpZnkoJytuYW1lKycpJysnICE9PSBKU09OLnN0cmluZ2lmeSgnK0pTT04uc3RyaW5naWZ5KGUpKycpJ1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHJldHVybiBuYW1lKycgIT09ICcrSlNPTi5zdHJpbmdpZnkoZSlcbiAgICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzKSB7Jywgbm9kZS5lbnVtLm1hcChjb21wYXJlKS5qb2luKCcgJiYgJykgfHwgJ2ZhbHNlJylcbiAgICAgIGVycm9yKCdtdXN0IGJlIGFuIGVudW0gdmFsdWUnKVxuICAgICAgdmFsaWRhdGUoJ30nKVxuICAgIH1cblxuICAgIGlmIChub2RlLmRlcGVuZGVuY2llcykge1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KG5hbWUpKVxuXG4gICAgICBPYmplY3Qua2V5cyhub2RlLmRlcGVuZGVuY2llcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGRlcHMgPSBub2RlLmRlcGVuZGVuY2llc1trZXldXG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIGRlcHMgPSBbZGVwc11cblxuICAgICAgICB2YXIgZXhpc3RzID0gZnVuY3Rpb24oaykge1xuICAgICAgICAgIHJldHVybiBnZW5vYmoobmFtZSwgaykgKyAnICE9PSB1bmRlZmluZWQnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgIT09IHVuZGVmaW5lZCAmJiAhKCVzKSkgeycsIGdlbm9iaihuYW1lLCBrZXkpLCBkZXBzLm1hcChleGlzdHMpLmpvaW4oJyAmJiAnKSB8fCAndHJ1ZScpXG4gICAgICAgICAgZXJyb3IoJ2RlcGVuZGVuY2llcyBub3Qgc2V0JylcbiAgICAgICAgICB2YWxpZGF0ZSgnfScpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhbGlkYXRlKCdpZiAoJXMgIT09IHVuZGVmaW5lZCkgeycsIGdlbm9iaihuYW1lLCBrZXkpKVxuICAgICAgICAgIHZpc2l0KG5hbWUsIGRlcHMsIHJlcG9ydGVyLCBmaWx0ZXIpXG4gICAgICAgICAgdmFsaWRhdGUoJ30nKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5hZGRpdGlvbmFsUHJvcGVydGllcyB8fCBub2RlLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KG5hbWUpKVxuXG4gICAgICB2YXIgaSA9IGdlbmxvb3AoKVxuICAgICAgdmFyIGtleXMgPSBnZW5zeW0oJ2tleXMnKVxuXG4gICAgICB2YXIgdG9Db21wYXJlID0gZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4ga2V5cysnWycraSsnXSAhPT0gJytKU09OLnN0cmluZ2lmeShwKVxuICAgICAgfVxuXG4gICAgICB2YXIgdG9UZXN0ID0gZnVuY3Rpb24ocCkge1xuICAgICAgICByZXR1cm4gJyEnK3BhdHRlcm5zKHApKycudGVzdCgnK2tleXMrJ1snK2krJ10pJ1xuICAgICAgfVxuXG4gICAgICB2YXIgYWRkaXRpb25hbFByb3AgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzIHx8IHt9KS5tYXAodG9Db21wYXJlKVxuICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKG5vZGUucGF0dGVyblByb3BlcnRpZXMgfHwge30pLm1hcCh0b1Rlc3QpKVxuICAgICAgICAuam9pbignICYmICcpIHx8ICd0cnVlJ1xuXG4gICAgICB2YWxpZGF0ZSgndmFyICVzID0gT2JqZWN0LmtleXMoJXMpJywga2V5cywgbmFtZSlcbiAgICAgICAgKCdmb3IgKHZhciAlcyA9IDA7ICVzIDwgJXMubGVuZ3RoOyAlcysrKSB7JywgaSwgaSwga2V5cywgaSlcbiAgICAgICAgICAoJ2lmICglcykgeycsIGFkZGl0aW9uYWxQcm9wKVxuXG4gICAgICBpZiAobm9kZS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGZpbHRlcikgdmFsaWRhdGUoJ2RlbGV0ZSAlcycsIG5hbWUrJ1snK2tleXMrJ1snK2krJ11dJylcbiAgICAgICAgZXJyb3IoJ2hhcyBhZGRpdGlvbmFsIHByb3BlcnRpZXMnLCBudWxsLCBKU09OLnN0cmluZ2lmeShuYW1lKycuJykgKyAnICsgJyArIGtleXMgKyAnWycraSsnXScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpdChuYW1lKydbJytrZXlzKydbJytpKyddXScsIG5vZGUuYWRkaXRpb25hbFByb3BlcnRpZXMsIHJlcG9ydGVyLCBmaWx0ZXIpXG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlXG4gICAgICAgICAgKCd9JylcbiAgICAgICAgKCd9JylcblxuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB2YWxpZGF0ZSgnfScpXG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJHJlZikge1xuICAgICAgdmFyIHN1YiA9IGdldChyb290LCBvcHRzICYmIG9wdHMuc2NoZW1hcyB8fCB7fSwgbm9kZS4kcmVmKVxuICAgICAgaWYgKHN1Yikge1xuICAgICAgICB2YXIgZm4gPSBjYWNoZVtub2RlLiRyZWZdXG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICBjYWNoZVtub2RlLiRyZWZdID0gZnVuY3Rpb24gcHJveHkoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGRhdGEpXG4gICAgICAgICAgfVxuICAgICAgICAgIGZuID0gY29tcGlsZShzdWIsIGNhY2hlLCByb290LCBmYWxzZSwgb3B0cylcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IGdlbnN5bSgncmVmJylcbiAgICAgICAgc2NvcGVbbl0gPSBmblxuICAgICAgICB2YWxpZGF0ZSgnaWYgKCEoJXMoJXMpKSkgeycsIG4sIG5hbWUpXG4gICAgICAgIGVycm9yKCdyZWZlcmVuY2VkIHNjaGVtYSBkb2VzIG5vdCBtYXRjaCcpXG4gICAgICAgIHZhbGlkYXRlKCd9JylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub3QpIHtcbiAgICAgIHZhciBwcmV2ID0gZ2Vuc3ltKCdwcmV2JylcbiAgICAgIHZhbGlkYXRlKCd2YXIgJXMgPSBlcnJvcnMnLCBwcmV2KVxuICAgICAgdmlzaXQobmFtZSwgbm9kZS5ub3QsIGZhbHNlLCBmaWx0ZXIpXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSBlcnJvcnMpIHsnLCBwcmV2KVxuICAgICAgZXJyb3IoJ25lZ2F0aXZlIHNjaGVtYSBtYXRjaGVzJylcbiAgICAgIHZhbGlkYXRlKCd9IGVsc2UgeycpXG4gICAgICAgICgnZXJyb3JzID0gJXMnLCBwcmV2KVxuICAgICAgKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5pdGVtcyAmJiAhdHVwbGUpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnYXJyYXknKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuYXJyYXkobmFtZSkpXG5cbiAgICAgIHZhciBpID0gZ2VubG9vcCgpXG4gICAgICB2YWxpZGF0ZSgnZm9yICh2YXIgJXMgPSAwOyAlcyA8ICVzLmxlbmd0aDsgJXMrKykgeycsIGksIGksIG5hbWUsIGkpXG4gICAgICB2aXNpdChuYW1lKydbJytpKyddJywgbm9kZS5pdGVtcywgcmVwb3J0ZXIsIGZpbHRlcilcbiAgICAgIHZhbGlkYXRlKCd9JylcblxuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KG5hbWUpKVxuICAgICAgdmFyIGtleXMgPSBnZW5zeW0oJ2tleXMnKVxuICAgICAgdmFyIGkgPSBnZW5sb29wKClcbiAgICAgIHZhbGlkYXRlXG4gICAgICAgICgndmFyICVzID0gT2JqZWN0LmtleXMoJXMpJywga2V5cywgbmFtZSlcbiAgICAgICAgKCdmb3IgKHZhciAlcyA9IDA7ICVzIDwgJXMubGVuZ3RoOyAlcysrKSB7JywgaSwgaSwga2V5cywgaSlcblxuICAgICAgT2JqZWN0LmtleXMobm9kZS5wYXR0ZXJuUHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHAgPSBwYXR0ZXJucyhrZXkpXG4gICAgICAgIHZhbGlkYXRlKCdpZiAoJXMudGVzdCglcykpIHsnLCBwLCBrZXlzKydbJytpKyddJylcbiAgICAgICAgdmlzaXQobmFtZSsnWycra2V5cysnWycraSsnXV0nLCBub2RlLnBhdHRlcm5Qcm9wZXJ0aWVzW2tleV0sIHJlcG9ydGVyLCBmaWx0ZXIpXG4gICAgICAgIHZhbGlkYXRlKCd9JylcbiAgICAgIH0pXG5cbiAgICAgIHZhbGlkYXRlKCd9JylcbiAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0JykgdmFsaWRhdGUoJ30nKVxuICAgIH1cblxuICAgIGlmIChub2RlLnBhdHRlcm4pIHtcbiAgICAgIHZhciBwID0gcGF0dGVybnMobm9kZS5wYXR0ZXJuKVxuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuc3RyaW5nKG5hbWUpKVxuICAgICAgdmFsaWRhdGUoJ2lmICghKCVzLnRlc3QoJXMpKSkgeycsIHAsIG5hbWUpXG4gICAgICBlcnJvcigncGF0dGVybiBtaXNtYXRjaCcpXG4gICAgICB2YWxpZGF0ZSgnfScpXG4gICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5hbGxPZikge1xuICAgICAgbm9kZS5hbGxPZi5mb3JFYWNoKGZ1bmN0aW9uKHNjaCkge1xuICAgICAgICB2aXNpdChuYW1lLCBzY2gsIHJlcG9ydGVyLCBmaWx0ZXIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChub2RlLmFueU9mICYmIG5vZGUuYW55T2YubGVuZ3RoKSB7XG4gICAgICB2YXIgcHJldiA9IGdlbnN5bSgncHJldicpXG5cbiAgICAgIG5vZGUuYW55T2YuZm9yRWFjaChmdW5jdGlvbihzY2gsIGkpIHtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICB2YWxpZGF0ZSgndmFyICVzID0gZXJyb3JzJywgcHJldilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZSgnaWYgKGVycm9ycyAhPT0gJXMpIHsnLCBwcmV2KVxuICAgICAgICAgICAgKCdlcnJvcnMgPSAlcycsIHByZXYpXG4gICAgICAgIH1cbiAgICAgICAgdmlzaXQobmFtZSwgc2NoLCBmYWxzZSwgZmFsc2UpXG4gICAgICB9KVxuICAgICAgbm9kZS5hbnlPZi5mb3JFYWNoKGZ1bmN0aW9uKHNjaCwgaSkge1xuICAgICAgICBpZiAoaSkgdmFsaWRhdGUoJ30nKVxuICAgICAgfSlcbiAgICAgIHZhbGlkYXRlKCdpZiAoJXMgIT09IGVycm9ycykgeycsIHByZXYpXG4gICAgICBlcnJvcignbm8gc2NoZW1hcyBtYXRjaCcpXG4gICAgICB2YWxpZGF0ZSgnfScpXG4gICAgfVxuXG4gICAgaWYgKG5vZGUub25lT2YgJiYgbm9kZS5vbmVPZi5sZW5ndGgpIHtcbiAgICAgIHZhciBwcmV2ID0gZ2Vuc3ltKCdwcmV2JylcbiAgICAgIHZhciBwYXNzZXMgPSBnZW5zeW0oJ3Bhc3NlcycpXG5cbiAgICAgIHZhbGlkYXRlXG4gICAgICAgICgndmFyICVzID0gZXJyb3JzJywgcHJldilcbiAgICAgICAgKCd2YXIgJXMgPSAwJywgcGFzc2VzKVxuXG4gICAgICBub2RlLm9uZU9mLmZvckVhY2goZnVuY3Rpb24oc2NoLCBpKSB7XG4gICAgICAgIHZpc2l0KG5hbWUsIHNjaCwgZmFsc2UsIGZhbHNlKVxuICAgICAgICB2YWxpZGF0ZSgnaWYgKCVzID09PSBlcnJvcnMpIHsnLCBwcmV2KVxuICAgICAgICAgICgnJXMrKycsIHBhc3NlcylcbiAgICAgICAgKCd9IGVsc2UgeycpXG4gICAgICAgICAgKCdlcnJvcnMgPSAlcycsIHByZXYpXG4gICAgICAgICgnfScpXG4gICAgICB9KVxuXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzICE9PSAxKSB7JywgcGFzc2VzKVxuICAgICAgZXJyb3IoJ25vIChvciBtb3JlIHRoYW4gb25lKSBzY2hlbWFzIG1hdGNoJylcbiAgICAgIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5tdWx0aXBsZU9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnaW50ZWdlcicpIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5udW1iZXIobmFtZSkpXG5cbiAgICAgIHZhbGlkYXRlKCdpZiAoIWlzTXVsdGlwbGVPZiglcywgJWQpKSB7JywgbmFtZSwgbm9kZS5tdWx0aXBsZU9mKVxuXG4gICAgICBlcnJvcignaGFzIGEgcmVtYWluZGVyJylcbiAgICAgIHZhbGlkYXRlKCd9JylcblxuICAgICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdpbnRlZ2VyJykgdmFsaWRhdGUoJ30nKVxuICAgIH1cblxuICAgIGlmIChub2RlLm1heFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KG5hbWUpKVxuXG4gICAgICB2YWxpZGF0ZSgnaWYgKE9iamVjdC5rZXlzKCVzKS5sZW5ndGggPiAlZCkgeycsIG5hbWUsIG5vZGUubWF4UHJvcGVydGllcylcbiAgICAgIGVycm9yKCdoYXMgbW9yZSBwcm9wZXJ0aWVzIHRoYW4gYWxsb3dlZCcpXG4gICAgICB2YWxpZGF0ZSgnfScpXG5cbiAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0JykgdmFsaWRhdGUoJ30nKVxuICAgIH1cblxuICAgIGlmIChub2RlLm1pblByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMub2JqZWN0KG5hbWUpKVxuXG4gICAgICB2YWxpZGF0ZSgnaWYgKE9iamVjdC5rZXlzKCVzKS5sZW5ndGggPCAlZCkgeycsIG5hbWUsIG5vZGUubWluUHJvcGVydGllcylcbiAgICAgIGVycm9yKCdoYXMgbGVzcyBwcm9wZXJ0aWVzIHRoYW4gYWxsb3dlZCcpXG4gICAgICB2YWxpZGF0ZSgnfScpXG5cbiAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0JykgdmFsaWRhdGUoJ30nKVxuICAgIH1cblxuICAgIGlmIChub2RlLm1heEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnYXJyYXknKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuYXJyYXkobmFtZSkpXG5cbiAgICAgIHZhbGlkYXRlKCdpZiAoJXMubGVuZ3RoID4gJWQpIHsnLCBuYW1lLCBub2RlLm1heEl0ZW1zKVxuICAgICAgZXJyb3IoJ2hhcyBtb3JlIGl0ZW1zIHRoYW4gYWxsb3dlZCcpXG4gICAgICB2YWxpZGF0ZSgnfScpXG5cbiAgICAgIGlmICh0eXBlICE9PSAnYXJyYXknKSB2YWxpZGF0ZSgnfScpXG4gICAgfVxuXG4gICAgaWYgKG5vZGUubWluSXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHZhbGlkYXRlKCdpZiAoJXMpIHsnLCB0eXBlcy5hcnJheShuYW1lKSlcblxuICAgICAgdmFsaWRhdGUoJ2lmICglcy5sZW5ndGggPCAlZCkgeycsIG5hbWUsIG5vZGUubWluSXRlbXMpXG4gICAgICBlcnJvcignaGFzIGxlc3MgaXRlbXMgdGhhbiBhbGxvd2VkJylcbiAgICAgIHZhbGlkYXRlKCd9JylcblxuICAgICAgaWYgKHR5cGUgIT09ICdhcnJheScpIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB2YWxpZGF0ZSgnaWYgKCVzKSB7JywgdHlwZXMuc3RyaW5nKG5hbWUpKVxuXG4gICAgICB2YWxpZGF0ZSgnaWYgKCVzLmxlbmd0aCA+ICVkKSB7JywgbmFtZSwgbm9kZS5tYXhMZW5ndGgpXG4gICAgICBlcnJvcignaGFzIGxvbmdlciBsZW5ndGggdGhhbiBhbGxvd2VkJylcbiAgICAgIHZhbGlkYXRlKCd9JylcblxuICAgICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB2YWxpZGF0ZSgnfScpXG4gICAgfVxuXG4gICAgaWYgKG5vZGUubWluTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykgdmFsaWRhdGUoJ2lmICglcykgeycsIHR5cGVzLnN0cmluZyhuYW1lKSlcblxuICAgICAgdmFsaWRhdGUoJ2lmICglcy5sZW5ndGggPCAlZCkgeycsIG5hbWUsIG5vZGUubWluTGVuZ3RoKVxuICAgICAgZXJyb3IoJ2hhcyBsZXNzIGxlbmd0aCB0aGFuIGFsbG93ZWQnKVxuICAgICAgdmFsaWRhdGUoJ30nKVxuXG4gICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHZhbGlkYXRlKCd9JylcbiAgICB9XG5cbiAgICBpZiAobm9kZS5taW5pbXVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbGlkYXRlKCdpZiAoJXMgJXMgJWQpIHsnLCBuYW1lLCBub2RlLmV4Y2x1c2l2ZU1pbmltdW0gPyAnPD0nIDogJzwnLCBub2RlLm1pbmltdW0pXG4gICAgICBlcnJvcignaXMgbGVzcyB0aGFuIG1pbmltdW0nKVxuICAgICAgdmFsaWRhdGUoJ30nKVxuICAgIH1cblxuICAgIGlmIChub2RlLm1heGltdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGUoJ2lmICglcyAlcyAlZCkgeycsIG5hbWUsIG5vZGUuZXhjbHVzaXZlTWF4aW11bSA/ICc+PScgOiAnPicsIG5vZGUubWF4aW11bSlcbiAgICAgIGVycm9yKCdpcyBtb3JlIHRoYW4gbWF4aW11bScpXG4gICAgICB2YWxpZGF0ZSgnfScpXG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSAmJiB0eXBlLmluZGV4T2YoJ251bGwnKSAhPT0gLTEpIHZhbGlkYXRlKCdpZiAoJXMgIT09IG51bGwpIHsnLCBuYW1lKVxuXG4gICAgICAgIHZpc2l0KGdlbm9iaihuYW1lLCBwKSwgcHJvcGVydGllc1twXSwgcmVwb3J0ZXIsIGZpbHRlcilcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSAmJiB0eXBlLmluZGV4T2YoJ251bGwnKSAhPT0gLTEpIHZhbGlkYXRlKCd9JylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgd2hpbGUgKGluZGVudC0tKSB2YWxpZGF0ZSgnfScpXG4gIH1cblxuICB2YXIgdmFsaWRhdGUgPSBnZW5mdW5cbiAgICAoJ2Z1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHsnKVxuICAgICAgKCd2YWxpZGF0ZS5lcnJvcnMgPSBudWxsJylcbiAgICAgICgndmFyIGVycm9ycyA9IDAnKVxuXG4gIHZpc2l0KCdkYXRhJywgc2NoZW1hLCByZXBvcnRlciwgb3B0cyAmJiBvcHRzLmZpbHRlcilcblxuICB2YWxpZGF0ZVxuICAgICAgKCdyZXR1cm4gZXJyb3JzID09PSAwJylcbiAgICAoJ30nKVxuXG4gIHZhbGlkYXRlID0gdmFsaWRhdGUudG9GdW5jdGlvbihzY29wZSlcbiAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbFxuXG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGUsICdlcnJvcicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdmFsaWRhdGUuZXJyb3JzKSByZXR1cm4gJydcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlLmVycm9ycy5tYXAoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGVyci5maWVsZCArICcgJyArIGVyci5tZXNzYWdlO1xuICAgICAgICB9KS5qb2luKCdcXG4nKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB2YWxpZGF0ZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2NoZW1hXG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzY2hlbWEsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnKSBzY2hlbWEgPSBKU09OLnBhcnNlKHNjaGVtYSlcbiAgcmV0dXJuIGNvbXBpbGUoc2NoZW1hLCB7fSwgc2NoZW1hLCB0cnVlLCBvcHRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbihzY2hlbWEsIG9wdHMpIHtcbiAgdmFyIHZhbGlkYXRlID0gbW9kdWxlLmV4cG9ydHMoc2NoZW1hLCB4dGVuZChvcHRzLCB7ZmlsdGVyOiB0cnVlfSkpXG4gIHJldHVybiBmdW5jdGlvbihzY2gpIHtcbiAgICB2YWxpZGF0ZShzY2gpXG4gICAgcmV0dXJuIHNjaFxuICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaXMtbXktanNvbi12YWxpZC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzUHJvcGVydHkgPSByZXF1aXJlKCdpcy1wcm9wZXJ0eScpXG5cbnZhciBnZW4gPSBmdW5jdGlvbihvYmosIHByb3ApIHtcbiAgcmV0dXJuIGlzUHJvcGVydHkocHJvcCkgPyBvYmorJy4nK3Byb3AgOiBvYmorJ1snK0pTT04uc3RyaW5naWZ5KHByb3ApKyddJ1xufVxuXG5nZW4udmFsaWQgPSBpc1Byb3BlcnR5XG5nZW4ucHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcCkge1xuIHJldHVybiBpc1Byb3BlcnR5KHByb3ApID8gcHJvcCA6IEpTT04uc3RyaW5naWZ5KHByb3ApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vZ2VuZXJhdGUtb2JqZWN0LXByb3BlcnR5L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIlxuZnVuY3Rpb24gaXNQcm9wZXJ0eShzdHIpIHtcbiAgcmV0dXJuIC9eWyRBLVpcXF9hLXpcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY11bJEEtWlxcX2EtelxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjMC05XFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjY5XFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGYtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDZmMC1cXHUwNmY5XFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3YzAtXFx1MDdjOVxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWIwLVxcdTE5YzBcXHUxOWM4XFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2YyLVxcdTFjZjRcXHUxZGMwLVxcdTFkZTZcXHUxZGZjLVxcdTFkZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZdKiQvLnRlc3Qoc3RyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3BlcnR5XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2lzLXByb3BlcnR5L2lzLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG52YXIgSU5ERU5UX1NUQVJUID0gL1tcXHtcXFtdL1xudmFyIElOREVOVF9FTkQgPSAvW1xcfVxcXV0vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsaW5lcyA9IFtdXG4gIHZhciBpbmRlbnQgPSAwXG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgc3BhY2VzID0gJydcbiAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aCA8IGluZGVudCoyKSBzcGFjZXMgKz0gJyAgJ1xuICAgIGxpbmVzLnB1c2goc3BhY2VzK3N0cilcbiAgfVxuXG4gIHZhciBsaW5lID0gZnVuY3Rpb24oZm10KSB7XG4gICAgaWYgKCFmbXQpIHJldHVybiBsaW5lXG5cbiAgICBpZiAoSU5ERU5UX0VORC50ZXN0KGZtdC50cmltKClbMF0pICYmIElOREVOVF9TVEFSVC50ZXN0KGZtdFtmbXQubGVuZ3RoLTFdKSkge1xuICAgICAgaW5kZW50LS1cbiAgICAgIHB1c2godXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgICAgIGluZGVudCsrXG4gICAgICByZXR1cm4gbGluZVxuICAgIH1cbiAgICBpZiAoSU5ERU5UX1NUQVJULnRlc3QoZm10W2ZtdC5sZW5ndGgtMV0pKSB7XG4gICAgICBwdXNoKHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cykpXG4gICAgICBpbmRlbnQrK1xuICAgICAgcmV0dXJuIGxpbmVcbiAgICB9XG4gICAgaWYgKElOREVOVF9FTkQudGVzdChmbXQudHJpbSgpWzBdKSkge1xuICAgICAgaW5kZW50LS1cbiAgICAgIHB1c2godXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuXG4gICAgcHVzaCh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpKVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICBsaW5lLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpXG4gIH1cblxuICBsaW5lLnRvRnVuY3Rpb24gPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBzcmMgPSAncmV0dXJuICgnK2xpbmUudG9TdHJpbmcoKSsnKSdcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2NvcGUgfHwge30pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBrZXlcbiAgICB9KVxuXG4gICAgdmFyIHZhbHMgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBzY29wZVtrZXldXG4gICAgfSlcblxuICAgIHJldHVybiBGdW5jdGlvbi5hcHBseShudWxsLCBrZXlzLmNvbmNhdChzcmMpKS5hcHBseShudWxsLCB2YWxzKVxuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIGxpbmUuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuXG4gIHJldHVybiBsaW5lXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vZ2VuZXJhdGUtZnVuY3Rpb24vaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB1bnRpbGRlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi4vZywgZnVuY3Rpb24obSkge1xuICAgIHN3aXRjaCAobSkge1xuICAgICAgY2FzZSBcIn4wXCI6XG4gICAgICAgIHJldHVybiBcIn5cIjtcbiAgICAgIGNhc2UgXCJ+MVwiOlxuICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGlsZGUgZXNjYXBlOiBcIiArIG0pO1xuICB9KTtcbn1cblxudmFyIHRyYXZlcnNlID0gZnVuY3Rpb24ob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICAvLyBhc3NlcnQoaXNBcnJheShwb2ludGVyKSlcbiAgdmFyIHBhcnQgPSB1bnRpbGRlKHBvaW50ZXIuc2hpZnQoKSk7XG4gIGlmKCFvYmouaGFzT3duUHJvcGVydHkocGFydCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZihwb2ludGVyLmxlbmd0aCAhPT0gMCkgeyAvLyBrZWVwIHRyYXZlcnNpbiFcbiAgICByZXR1cm4gdHJhdmVyc2Uob2JqW3BhcnRdLCBwb2ludGVyLCB2YWx1ZSk7XG4gIH1cbiAgLy8gd2UncmUgZG9uZVxuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBqdXN0IHJlYWRpbmdcbiAgICByZXR1cm4gb2JqW3BhcnRdO1xuICB9XG4gIC8vIHNldCBuZXcgdmFsdWUsIHJldHVybiBvbGQgdmFsdWVcbiAgdmFyIG9sZF92YWx1ZSA9IG9ialtwYXJ0XTtcbiAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICBkZWxldGUgb2JqW3BhcnRdO1xuICB9IGVsc2Uge1xuICAgIG9ialtwYXJ0XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvbGRfdmFsdWU7XG59XG5cbnZhciB2YWxpZGF0ZV9pbnB1dCA9IGZ1bmN0aW9uKG9iaiwgcG9pbnRlcikge1xuICBpZih0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBvYmplY3QuXCIpO1xuICB9XG5cbiAgaWYocG9pbnRlciA9PT0gXCJcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmKCFwb2ludGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKU09OIHBvaW50ZXIuXCIpO1xuICB9XG5cbiAgcG9pbnRlciA9IHBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICB2YXIgZmlyc3QgPSBwb2ludGVyLnNoaWZ0KCk7XG4gIGlmIChmaXJzdCAhPT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTiBwb2ludGVyLlwiKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludGVyO1xufVxuXG52YXIgZ2V0ID0gZnVuY3Rpb24ob2JqLCBwb2ludGVyKSB7XG4gIHBvaW50ZXIgPSB2YWxpZGF0ZV9pbnB1dChvYmosIHBvaW50ZXIpO1xuICBpZiAocG9pbnRlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIHJldHVybiB0cmF2ZXJzZShvYmosIHBvaW50ZXIpO1xufVxuXG52YXIgc2V0ID0gZnVuY3Rpb24ob2JqLCBwb2ludGVyLCB2YWx1ZSkge1xuICBwb2ludGVyID0gdmFsaWRhdGVfaW5wdXQob2JqLCBwb2ludGVyKTtcbiAgaWYgKHBvaW50ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKU09OIHBvaW50ZXIgZm9yIHNldC5cIilcbiAgfVxuICByZXR1cm4gdHJhdmVyc2Uob2JqLCBwb2ludGVyLCB2YWx1ZSk7XG59XG5cbmV4cG9ydHMuZ2V0ID0gZ2V0XG5leHBvcnRzLnNldCA9IHNldFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L2pzb25wb2ludGVyL2pzb25wb2ludGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3h0ZW5kL2ltbXV0YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0c1snZGF0ZS10aW1lJ10gPSAvXlxcZHs0fS0oPzowWzAtOV17MX18MVswLTJdezF9KS1bMC05XXsyfVt0VCBdXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFt6Wl18WystXVxcZHsyfTpcXGR7Mn0pJC9cbmV4cG9ydHNbJ2RhdGUnXSA9IC9eXFxkezR9LSg/OjBbMC05XXsxfXwxWzAtMl17MX0pLVswLTldezJ9JC9cbmV4cG9ydHNbJ3RpbWUnXSA9IC9eXFxkezJ9OlxcZHsyfTpcXGR7Mn0kL1xuZXhwb3J0c1snZW1haWwnXSA9IC9eXFxTK0BcXFMrJC9cbmV4cG9ydHNbJ2lwLWFkZHJlc3MnXSA9IGV4cG9ydHNbJ2lwdjQnXSA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJC9cbmV4cG9ydHNbJ2lwdjYnXSA9IC9eXFxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSglLispP1xccyokL1xuZXhwb3J0c1sndXJpJ10gPSAvXlthLXpBLVpdW2EtekEtWjAtOSstLl0qOlteXFxzXSokL1xuZXhwb3J0c1snY29sb3InXSA9IC8oIz8oWzAtOUEtRmEtZl17Myw2fSlcXGIpfChhcXVhKXwoYmxhY2spfChibHVlKXwoZnVjaHNpYSl8KGdyYXkpfChncmVlbil8KGxpbWUpfChtYXJvb24pfChuYXZ5KXwob2xpdmUpfChvcmFuZ2UpfChwdXJwbGUpfChyZWQpfChzaWx2ZXIpfCh0ZWFsKXwod2hpdGUpfCh5ZWxsb3cpfChyZ2JcXChcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqLFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKlxcKSl8KHJnYlxcKFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccyosXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqXFwpKS9cbmV4cG9ydHNbJ2hvc3RuYW1lJ10gPSAvXihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pKFxcLihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pKSokL1xuZXhwb3J0c1snYWxwaGEnXSA9IC9eW2EtekEtWl0rJC9cbmV4cG9ydHNbJ2FscGhhbnVtZXJpYyddID0gL15bYS16QS1aMC05XSskL1xuZXhwb3J0c1snc3R5bGUnXSA9IC9cXHMqKC4rPyk6XFxzKihbXjtdKyk7Py9nXG5leHBvcnRzWydwaG9uZSddID0gL15cXCsoPzpbMC05XSA/KXs2LDE0fVswLTldJC9cbmV4cG9ydHNbJ3V0Yy1taWxsaXNlYyddID0gL15bMC05XXsxLDE1fVxcLj9bMC05XXswLDE1fSQvXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaXMtbXktanNvbi12YWxpZC9mb3JtYXRzLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIGNhc2VsZXNzID0gcmVxdWlyZSgnY2FzZWxlc3MnKVxuICAsIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKVxuICAsIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKVxuXG52YXIgbWQ1ID0gaGVscGVycy5tZDVcbiAgLCB0b0Jhc2U2NCA9IGhlbHBlcnMudG9CYXNlNjRcblxuXG5mdW5jdGlvbiBBdXRoIChyZXF1ZXN0KSB7XG4gIC8vIGRlZmluZSBhbGwgcHVibGljIHByb3BlcnRpZXMgaGVyZVxuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMuaGFzQXV0aCA9IGZhbHNlXG4gIHRoaXMuc2VudEF1dGggPSBmYWxzZVxuICB0aGlzLmJlYXJlclRva2VuID0gbnVsbFxuICB0aGlzLnVzZXIgPSBudWxsXG4gIHRoaXMucGFzcyA9IG51bGxcbn1cblxuQXV0aC5wcm90b3R5cGUuYmFzaWMgPSBmdW5jdGlvbiAodXNlciwgcGFzcywgc2VuZEltbWVkaWF0ZWx5KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAodHlwZW9mIHVzZXIgIT09ICdzdHJpbmcnIHx8IChwYXNzICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhc3MgIT09ICdzdHJpbmcnKSkge1xuICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignYXV0aCgpIHJlY2VpdmVkIGludmFsaWQgdXNlciBvciBwYXNzd29yZCcpKVxuICB9XG4gIHNlbGYudXNlciA9IHVzZXJcbiAgc2VsZi5wYXNzID0gcGFzc1xuICBzZWxmLmhhc0F1dGggPSB0cnVlXG4gIHZhciBoZWFkZXIgPSB1c2VyICsgJzonICsgKHBhc3MgfHwgJycpXG4gIGlmIChzZW5kSW1tZWRpYXRlbHkgfHwgdHlwZW9mIHNlbmRJbW1lZGlhdGVseSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYXV0aEhlYWRlciA9ICdCYXNpYyAnICsgdG9CYXNlNjQoaGVhZGVyKVxuICAgIHNlbGYuc2VudEF1dGggPSB0cnVlXG4gICAgcmV0dXJuIGF1dGhIZWFkZXJcbiAgfVxufVxuXG5BdXRoLnByb3RvdHlwZS5iZWFyZXIgPSBmdW5jdGlvbiAoYmVhcmVyLCBzZW5kSW1tZWRpYXRlbHkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuYmVhcmVyVG9rZW4gPSBiZWFyZXJcbiAgc2VsZi5oYXNBdXRoID0gdHJ1ZVxuICBpZiAoc2VuZEltbWVkaWF0ZWx5IHx8IHR5cGVvZiBzZW5kSW1tZWRpYXRlbHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBiZWFyZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJlYXJlciA9IGJlYXJlcigpXG4gICAgfVxuICAgIHZhciBhdXRoSGVhZGVyID0gJ0JlYXJlciAnICsgKGJlYXJlciB8fCAnJylcbiAgICBzZWxmLnNlbnRBdXRoID0gdHJ1ZVxuICAgIHJldHVybiBhdXRoSGVhZGVyXG4gIH1cbn1cblxuQXV0aC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGF0aCwgYXV0aEhlYWRlcikge1xuICAvLyBUT0RPOiBNb3JlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIFJGQyAyNjE3LlxuICAvLyAgIC0gY2hlY2sgY2hhbGxlbmdlLmFsZ29yaXRobVxuICAvLyAgIC0gc3VwcG9ydCBhbGdvcml0aG09XCJNRDUtc2Vzc1wiXG4gIC8vICAgLSBoYW5kbGUgY2hhbGxlbmdlLmRvbWFpblxuICAvLyAgIC0gc3VwcG9ydCBxb3A9XCJhdXRoLWludFwiIG9ubHlcbiAgLy8gICAtIGhhbmRsZSBBdXRoZW50aWNhdGlvbi1JbmZvIChub3QgbmVjZXNzYXJpbHk/KVxuICAvLyAgIC0gY2hlY2sgY2hhbGxlbmdlLnN0YWxlIChub3QgbmVjZXNzYXJpbHk/KVxuICAvLyAgIC0gaW5jcmVhc2UgbmMgKG5vdCBuZWNlc3NhcmlseT8pXG4gIC8vIEZvciByZWZlcmVuY2U6XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTcjc2VjdGlvbi0zXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWdkZXIvY3VybC9ibG9iL21hc3Rlci9saWIvaHR0cF9kaWdlc3QuY1xuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHZhciBjaGFsbGVuZ2UgPSB7fVxuICB2YXIgcmUgPSAvKFthLXowLTlfLV0rKT0oPzpcIihbXlwiXSspXCJ8KFthLXowLTlfLV0rKSkvZ2lcbiAgZm9yICg7Oykge1xuICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoYXV0aEhlYWRlcilcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjaGFsbGVuZ2VbbWF0Y2hbMV1dID0gbWF0Y2hbMl0gfHwgbWF0Y2hbM11cbiAgfVxuXG4gIHZhciBoYTEgPSBtZDUoc2VsZi51c2VyICsgJzonICsgY2hhbGxlbmdlLnJlYWxtICsgJzonICsgc2VsZi5wYXNzKVxuICB2YXIgaGEyID0gbWQ1KG1ldGhvZCArICc6JyArIHBhdGgpXG4gIHZhciBxb3AgPSAvKF58LClcXHMqYXV0aFxccyooJHwsKS8udGVzdChjaGFsbGVuZ2UucW9wKSAmJiAnYXV0aCdcbiAgdmFyIG5jID0gcW9wICYmICcwMDAwMDAwMSdcbiAgdmFyIGNub25jZSA9IHFvcCAmJiB1dWlkKCkucmVwbGFjZSgvLS9nLCAnJylcbiAgdmFyIGRpZ2VzdFJlc3BvbnNlID0gcW9wXG4gICAgPyBtZDUoaGExICsgJzonICsgY2hhbGxlbmdlLm5vbmNlICsgJzonICsgbmMgKyAnOicgKyBjbm9uY2UgKyAnOicgKyBxb3AgKyAnOicgKyBoYTIpXG4gICAgOiBtZDUoaGExICsgJzonICsgY2hhbGxlbmdlLm5vbmNlICsgJzonICsgaGEyKVxuICB2YXIgYXV0aFZhbHVlcyA9IHtcbiAgICB1c2VybmFtZTogc2VsZi51c2VyLFxuICAgIHJlYWxtOiBjaGFsbGVuZ2UucmVhbG0sXG4gICAgbm9uY2U6IGNoYWxsZW5nZS5ub25jZSxcbiAgICB1cmk6IHBhdGgsXG4gICAgcW9wOiBxb3AsXG4gICAgcmVzcG9uc2U6IGRpZ2VzdFJlc3BvbnNlLFxuICAgIG5jOiBuYyxcbiAgICBjbm9uY2U6IGNub25jZSxcbiAgICBhbGdvcml0aG06IGNoYWxsZW5nZS5hbGdvcml0aG0sXG4gICAgb3BhcXVlOiBjaGFsbGVuZ2Uub3BhcXVlXG4gIH1cblxuICBhdXRoSGVhZGVyID0gW11cbiAgZm9yICh2YXIgayBpbiBhdXRoVmFsdWVzKSB7XG4gICAgaWYgKGF1dGhWYWx1ZXNba10pIHtcbiAgICAgIGlmIChrID09PSAncW9wJyB8fCBrID09PSAnbmMnIHx8IGsgPT09ICdhbGdvcml0aG0nKSB7XG4gICAgICAgIGF1dGhIZWFkZXIucHVzaChrICsgJz0nICsgYXV0aFZhbHVlc1trXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dGhIZWFkZXIucHVzaChrICsgJz1cIicgKyBhdXRoVmFsdWVzW2tdICsgJ1wiJylcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXV0aEhlYWRlciA9ICdEaWdlc3QgJyArIGF1dGhIZWFkZXIuam9pbignLCAnKVxuICBzZWxmLnNlbnRBdXRoID0gdHJ1ZVxuICByZXR1cm4gYXV0aEhlYWRlclxufVxuXG5BdXRoLnByb3RvdHlwZS5vblJlcXVlc3QgPSBmdW5jdGlvbiAodXNlciwgcGFzcywgc2VuZEltbWVkaWF0ZWx5LCBiZWFyZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG5cbiAgdmFyIGF1dGhIZWFkZXJcbiAgaWYgKGJlYXJlciA9PT0gdW5kZWZpbmVkICYmIHVzZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gYXV0aCBtZWNoYW5pc20gZGVmaW5lZCcpKVxuICB9IGVsc2UgaWYgKGJlYXJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXV0aEhlYWRlciA9IHNlbGYuYmVhcmVyKGJlYXJlciwgc2VuZEltbWVkaWF0ZWx5KVxuICB9IGVsc2Uge1xuICAgIGF1dGhIZWFkZXIgPSBzZWxmLmJhc2ljKHVzZXIsIHBhc3MsIHNlbmRJbW1lZGlhdGVseSlcbiAgfVxuICBpZiAoYXV0aEhlYWRlcikge1xuICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXV0aEhlYWRlcilcbiAgfVxufVxuXG5BdXRoLnByb3RvdHlwZS5vblJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgcmVxdWVzdCA9IHNlbGYucmVxdWVzdFxuXG4gIGlmICghc2VsZi5oYXNBdXRoIHx8IHNlbGYuc2VudEF1dGgpIHsgcmV0dXJuIG51bGwgfVxuXG4gIHZhciBjID0gY2FzZWxlc3MocmVzcG9uc2UuaGVhZGVycylcblxuICB2YXIgYXV0aEhlYWRlciA9IGMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJylcbiAgdmFyIGF1dGhWZXJiID0gYXV0aEhlYWRlciAmJiBhdXRoSGVhZGVyLnNwbGl0KCcgJylbMF0udG9Mb3dlckNhc2UoKVxuICByZXF1ZXN0LmRlYnVnKCdyZWF1dGgnLCBhdXRoVmVyYilcblxuICBzd2l0Y2ggKGF1dGhWZXJiKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIHNlbGYuYmFzaWMoc2VsZi51c2VyLCBzZWxmLnBhc3MsIHRydWUpXG5cbiAgICBjYXNlICdiZWFyZXInOlxuICAgICAgcmV0dXJuIHNlbGYuYmVhcmVyKHNlbGYuYmVhcmVyVG9rZW4sIHRydWUpXG5cbiAgICBjYXNlICdkaWdlc3QnOlxuICAgICAgcmV0dXJuIHNlbGYuZGlnZXN0KHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnBhdGgsIGF1dGhIZWFkZXIpXG4gIH1cbn1cblxuZXhwb3J0cy5BdXRoID0gQXV0aFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlcXVlc3QvbGliL2F1dGguanNcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8qZ2xvYmFsIHdpbmRvdywgcmVxdWlyZSwgZGVmaW5lICovXG4oZnVuY3Rpb24oX3dpbmRvdykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcbiAgdmFyIF9ybmcsIF9tYXRoUk5HLCBfbm9kZVJORywgX3doYXR3Z1JORywgX3ByZXZpb3VzUm9vdDtcblxuICBmdW5jdGlvbiBzZXR1cEJyb3dzZXIoKSB7XG4gICAgLy8gQWxsb3cgZm9yIE1TSUUxMSBtc0NyeXB0b1xuICAgIHZhciBfY3J5cHRvID0gX3dpbmRvdy5jcnlwdG8gfHwgX3dpbmRvdy5tc0NyeXB0bztcblxuICAgIGlmICghX3JuZyAmJiBfY3J5cHRvICYmIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgICAgIC8vXG4gICAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgX3doYXR3Z1JORyA9IF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgICAgICAgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICAgICAgICByZXR1cm4gX3JuZHM4O1xuICAgICAgICB9O1xuICAgICAgICBfcm5nKCk7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgfVxuXG4gICAgaWYgKCFfcm5nKSB7XG4gICAgICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gICAgICAvL1xuICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgICAgIC8vIHF1YWxpdHkuXG4gICAgICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgICAgIF9tYXRoUk5HID0gX3JuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgeyByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwOyB9XG4gICAgICAgICAgX3JuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JuZHM7XG4gICAgICB9O1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1NFQ1VSSVRZXSBub2RlLXV1aWQ6IGNyeXB0byBub3QgdXNhYmxlLCBmYWxsaW5nIGJhY2sgdG8gaW5zZWN1cmUgTWF0aC5yYW5kb20oKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cE5vZGUoKSB7XG4gICAgLy8gTm9kZS5qcyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL25vZGVqcy5vcmcvZG9jcy92MC42LjIvYXBpL2NyeXB0by5odG1sXG4gICAgLy9cbiAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgcmVxdWlyZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9yYiA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgICAgICBfbm9kZVJORyA9IF9ybmcgPSBfcmIgJiYgZnVuY3Rpb24oKSB7cmV0dXJuIF9yYigxNik7fTtcbiAgICAgICAgX3JuZygpO1xuICAgICAgfSBjYXRjaChlKSB7fVxuICAgIH1cbiAgfVxuXG4gIGlmIChfd2luZG93KSB7XG4gICAgc2V0dXBCcm93c2VyKCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0dXBOb2RlKCk7XG4gIH1cblxuICAvLyBCdWZmZXIgY2xhc3MgdG8gdXNlXG4gIHZhciBCdWZmZXJDbGFzcyA9ICgnZnVuY3Rpb24nID09PSB0eXBlb2YgQnVmZmVyKSA/IEJ1ZmZlciA6IEFycmF5O1xuXG4gIC8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG4gIHZhciBfYnl0ZVRvSGV4ID0gW107XG4gIHZhciBfaGV4VG9CeXRlID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbiAgfVxuXG4gIC8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuICBmdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICAgIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24ob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbiAgfVxuXG4gIC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbiAgLy9cbiAgLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbiAgLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuICAvLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxuICB2YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgdmFyIF9ub2RlSWQgPSBbXG4gICAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuICBdO1xuXG4gIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gIHZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbiAgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG4gIHZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY2xvY2tzZXEgPSAob3B0aW9ucy5jbG9ja3NlcSAhPSBudWxsKSA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAgIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gICAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gICAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgICB2YXIgbXNlY3MgPSAob3B0aW9ucy5tc2VjcyAhPSBudWxsKSA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICAgIHZhciBuc2VjcyA9IChvcHRpb25zLm5zZWNzICE9IG51bGwpID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gICAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICAgIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gICAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gICAgLy8gdGltZSBpbnRlcnZhbFxuICAgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PSBudWxsKSB7XG4gICAgICBuc2VjcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICAgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gICAgfVxuXG4gICAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICAgIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gICAgLy8gYHRpbWVfbG93YFxuICAgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX21pZGBcbiAgICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IChvcHRpb25zID09PSAnYmluYXJ5JykgPyBuZXcgQnVmZmVyQ2xhc3MoMTYpIDogbnVsbDtcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG4gIHV1aWQuQnVmZmVyQ2xhc3MgPSBCdWZmZXJDbGFzcztcbiAgdXVpZC5fcm5nID0gX3JuZztcbiAgdXVpZC5fbWF0aFJORyA9IF9tYXRoUk5HO1xuICB1dWlkLl9ub2RlUk5HID0gX25vZGVSTkc7XG4gIHV1aWQuX3doYXR3Z1JORyA9IF93aGF0d2dSTkc7XG5cbiAgaWYgKCgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFB1Ymxpc2ggYXMgQU1EIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gdXVpZDt9KTtcblxuXG4gIH0gZWxzZSB7XG4gICAgLy8gUHVibGlzaCBhcyBnbG9iYWwgKGluIGJyb3dzZXJzKVxuICAgIF9wcmV2aW91c1Jvb3QgPSBfd2luZG93LnV1aWQ7XG5cbiAgICAvLyAqKmBub0NvbmZsaWN0KClgIC0gKGJyb3dzZXIgb25seSkgdG8gcmVzZXQgZ2xvYmFsICd1dWlkJyB2YXIqKlxuICAgIHV1aWQubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgX3dpbmRvdy51dWlkID0gX3ByZXZpb3VzUm9vdDtcbiAgICAgIHJldHVybiB1dWlkO1xuICAgIH07XG5cbiAgICBfd2luZG93LnV1aWQgPSB1dWlkO1xuICB9XG59KSgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IG51bGwpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L25vZGUtdXVpZC91dWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG4gICwgcXMgPSByZXF1aXJlKCdxcycpXG4gICwgY2FzZWxlc3MgPSByZXF1aXJlKCdjYXNlbGVzcycpXG4gICwgdXVpZCA9IHJlcXVpcmUoJ25vZGUtdXVpZCcpXG4gICwgb2F1dGggPSByZXF1aXJlKCdvYXV0aC1zaWduJylcbiAgLCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5cbmZ1bmN0aW9uIE9BdXRoIChyZXF1ZXN0KSB7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgdGhpcy5wYXJhbXMgPSBudWxsXG59XG5cbk9BdXRoLnByb3RvdHlwZS5idWlsZFBhcmFtcyA9IGZ1bmN0aW9uIChfb2F1dGgsIHVyaSwgbWV0aG9kLCBxdWVyeSwgZm9ybSwgcXNMaWIpIHtcbiAgdmFyIG9hID0ge31cbiAgZm9yICh2YXIgaSBpbiBfb2F1dGgpIHtcbiAgICBvYVsnb2F1dGhfJyArIGldID0gX29hdXRoW2ldXG4gIH1cbiAgaWYgKCFvYS5vYXV0aF92ZXJzaW9uKSB7XG4gICAgb2Eub2F1dGhfdmVyc2lvbiA9ICcxLjAnXG4gIH1cbiAgaWYgKCFvYS5vYXV0aF90aW1lc3RhbXApIHtcbiAgICBvYS5vYXV0aF90aW1lc3RhbXAgPSBNYXRoLmZsb29yKCBEYXRlLm5vdygpIC8gMTAwMCApLnRvU3RyaW5nKClcbiAgfVxuICBpZiAoIW9hLm9hdXRoX25vbmNlKSB7XG4gICAgb2Eub2F1dGhfbm9uY2UgPSB1dWlkKCkucmVwbGFjZSgvLS9nLCAnJylcbiAgfVxuICBpZiAoIW9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QpIHtcbiAgICBvYS5vYXV0aF9zaWduYXR1cmVfbWV0aG9kID0gJ0hNQUMtU0hBMSdcbiAgfVxuXG4gIHZhciBjb25zdW1lcl9zZWNyZXRfb3JfcHJpdmF0ZV9rZXkgPSBvYS5vYXV0aF9jb25zdW1lcl9zZWNyZXQgfHwgb2Eub2F1dGhfcHJpdmF0ZV9rZXlcbiAgZGVsZXRlIG9hLm9hdXRoX2NvbnN1bWVyX3NlY3JldFxuICBkZWxldGUgb2Eub2F1dGhfcHJpdmF0ZV9rZXlcblxuICB2YXIgdG9rZW5fc2VjcmV0ID0gb2Eub2F1dGhfdG9rZW5fc2VjcmV0XG4gIGRlbGV0ZSBvYS5vYXV0aF90b2tlbl9zZWNyZXRcblxuICB2YXIgcmVhbG0gPSBvYS5vYXV0aF9yZWFsbVxuICBkZWxldGUgb2Eub2F1dGhfcmVhbG1cbiAgZGVsZXRlIG9hLm9hdXRoX3RyYW5zcG9ydF9tZXRob2RcblxuICB2YXIgYmFzZXVybCA9IHVyaS5wcm90b2NvbCArICcvLycgKyB1cmkuaG9zdCArIHVyaS5wYXRobmFtZVxuICB2YXIgcGFyYW1zID0gcXNMaWIucGFyc2UoW10uY29uY2F0KHF1ZXJ5LCBmb3JtLCBxc0xpYi5zdHJpbmdpZnkob2EpKS5qb2luKCcmJykpXG5cbiAgb2Eub2F1dGhfc2lnbmF0dXJlID0gb2F1dGguc2lnbihcbiAgICBvYS5vYXV0aF9zaWduYXR1cmVfbWV0aG9kLFxuICAgIG1ldGhvZCxcbiAgICBiYXNldXJsLFxuICAgIHBhcmFtcyxcbiAgICBjb25zdW1lcl9zZWNyZXRfb3JfcHJpdmF0ZV9rZXksXG4gICAgdG9rZW5fc2VjcmV0KVxuXG4gIGlmIChyZWFsbSkge1xuICAgIG9hLnJlYWxtID0gcmVhbG1cbiAgfVxuXG4gIHJldHVybiBvYVxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRCb2R5SGFzaCA9IGZ1bmN0aW9uKF9vYXV0aCwgYm9keSkge1xuICBpZiAoWydITUFDLVNIQTEnLCAnUlNBLVNIQTEnXS5pbmRleE9mKF9vYXV0aC5zaWduYXR1cmVfbWV0aG9kIHx8ICdITUFDLVNIQTEnKSA8IDApIHtcbiAgICB0aGlzLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ29hdXRoOiAnICsgX29hdXRoLnNpZ25hdHVyZV9tZXRob2QgK1xuICAgICAgJyBzaWduYXR1cmVfbWV0aG9kIG5vdCBzdXBwb3J0ZWQgd2l0aCBib2R5X2hhc2ggc2lnbmluZy4nKSlcbiAgfVxuXG4gIHZhciBzaGFzdW0gPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpXG4gIHNoYXN1bS51cGRhdGUoYm9keSB8fCAnJylcbiAgdmFyIHNoYTEgPSBzaGFzdW0uZGlnZXN0KCdoZXgnKVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHNoYTEpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5PQXV0aC5wcm90b3R5cGUuY29uY2F0UGFyYW1zID0gZnVuY3Rpb24gKG9hLCBzZXAsIHdyYXApIHtcbiAgd3JhcCA9IHdyYXAgfHwgJydcblxuICB2YXIgcGFyYW1zID0gT2JqZWN0LmtleXMob2EpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICE9PSAncmVhbG0nICYmIGkgIT09ICdvYXV0aF9zaWduYXR1cmUnXG4gIH0pLnNvcnQoKVxuXG4gIGlmIChvYS5yZWFsbSkge1xuICAgIHBhcmFtcy5zcGxpY2UoMCwgMSwgJ3JlYWxtJylcbiAgfVxuICBwYXJhbXMucHVzaCgnb2F1dGhfc2lnbmF0dXJlJylcblxuICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICsgJz0nICsgd3JhcCArIG9hdXRoLnJmYzM5ODYob2FbaV0pICsgd3JhcFxuICB9KS5qb2luKHNlcClcbn1cblxuT0F1dGgucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYucGFyYW1zID0gX29hdXRoXG5cbiAgdmFyIHVyaSA9IHNlbGYucmVxdWVzdC51cmkgfHwge31cbiAgICAsIG1ldGhvZCA9IHNlbGYucmVxdWVzdC5tZXRob2QgfHwgJydcbiAgICAsIGhlYWRlcnMgPSBjYXNlbGVzcyhzZWxmLnJlcXVlc3QuaGVhZGVycylcbiAgICAsIGJvZHkgPSBzZWxmLnJlcXVlc3QuYm9keSB8fCAnJ1xuICAgICwgcXNMaWIgPSBzZWxmLnJlcXVlc3QucXNMaWIgfHwgcXNcblxuICB2YXIgZm9ybVxuICAgICwgcXVlcnlcbiAgICAsIGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gICAgLCBmb3JtQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICwgdHJhbnNwb3J0ID0gX29hdXRoLnRyYW5zcG9ydF9tZXRob2QgfHwgJ2hlYWRlcidcblxuICBpZiAoY29udGVudFR5cGUuc2xpY2UoMCwgZm9ybUNvbnRlbnRUeXBlLmxlbmd0aCkgPT09IGZvcm1Db250ZW50VHlwZSkge1xuICAgIGNvbnRlbnRUeXBlID0gZm9ybUNvbnRlbnRUeXBlXG4gICAgZm9ybSA9IGJvZHlcbiAgfVxuICBpZiAodXJpLnF1ZXJ5KSB7XG4gICAgcXVlcnkgPSB1cmkucXVlcnlcbiAgfVxuICBpZiAodHJhbnNwb3J0ID09PSAnYm9keScgJiYgKG1ldGhvZCAhPT0gJ1BPU1QnIHx8IGNvbnRlbnRUeXBlICE9PSBmb3JtQ29udGVudFR5cGUpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogdHJhbnNwb3J0X21ldGhvZCBvZiBib2R5IHJlcXVpcmVzIFBPU1QgJyArXG4gICAgICAnYW5kIGNvbnRlbnQtdHlwZSAnICsgZm9ybUNvbnRlbnRUeXBlKSlcbiAgfVxuXG4gIGlmICghZm9ybSAmJiB0eXBlb2YgX29hdXRoLmJvZHlfaGFzaCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgX29hdXRoLmJvZHlfaGFzaCA9IHNlbGYuYnVpbGRCb2R5SGFzaChfb2F1dGgsIHNlbGYucmVxdWVzdC5ib2R5LnRvU3RyaW5nKCkpXG4gIH1cblxuICB2YXIgb2EgPSBzZWxmLmJ1aWxkUGFyYW1zKF9vYXV0aCwgdXJpLCBtZXRob2QsIHF1ZXJ5LCBmb3JtLCBxc0xpYilcblxuICBzd2l0Y2ggKHRyYW5zcG9ydCkge1xuICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBzZWxmLnJlcXVlc3Quc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ09BdXRoICcgKyBzZWxmLmNvbmNhdFBhcmFtcyhvYSwgJywnLCAnXCInKSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICB2YXIgaHJlZiA9IHNlbGYucmVxdWVzdC51cmkuaHJlZiArPSAocXVlcnkgPyAnJicgOiAnPycpICsgc2VsZi5jb25jYXRQYXJhbXMob2EsICcmJylcbiAgICAgIHNlbGYucmVxdWVzdC51cmkgPSB1cmwucGFyc2UoaHJlZilcbiAgICAgIHNlbGYucmVxdWVzdC5wYXRoID0gc2VsZi5yZXF1ZXN0LnVyaS5wYXRoXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnYm9keSc6XG4gICAgICBzZWxmLnJlcXVlc3QuYm9keSA9IChmb3JtID8gZm9ybSArICcmJyA6ICcnKSArIHNlbGYuY29uY2F0UGFyYW1zKG9hLCAnJicpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb2F1dGg6IHRyYW5zcG9ydF9tZXRob2QgaW52YWxpZCcpKVxuICB9XG59XG5cbmV4cG9ydHMuT0F1dGggPSBPQXV0aFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlcXVlc3QvbGliL29hdXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbiAgO1xuXG5mdW5jdGlvbiBzaGExIChrZXksIGJvZHkpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywga2V5KS51cGRhdGUoYm9keSkuZGlnZXN0KCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiByc2EgKGtleSwgYm9keSkge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZVNpZ24oXCJSU0EtU0hBMVwiKS51cGRhdGUoYm9keSkuc2lnbihrZXksICdiYXNlNjQnKTtcbn1cblxuZnVuY3Rpb24gcmZjMzk4NiAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIC5yZXBsYWNlKC8hL2csJyUyMScpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCclMkEnKVxuICAgIC5yZXBsYWNlKC9cXCgvZywnJTI4JylcbiAgICAucmVwbGFjZSgvXFwpL2csJyUyOScpXG4gICAgLnJlcGxhY2UoLycvZywnJTI3JylcbiAgICA7XG59XG5cbi8vIE1hcHMgb2JqZWN0IHRvIGJpLWRpbWVuc2lvbmFsIGFycmF5XG4vLyBDb252ZXJ0cyB7IGZvbzogJ0EnLCBiYXI6IFsgJ2InLCAnQicgXX0gdG9cbi8vIFsgWydmb28nLCAnQSddLCBbJ2JhcicsICdiJ10sIFsnYmFyJywgJ0InXSBdXG5mdW5jdGlvbiBtYXAgKG9iaikge1xuICB2YXIga2V5LCB2YWwsIGFyciA9IFtdXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIHZhbCA9IG9ialtrZXldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICBhcnIucHVzaChba2V5LCB2YWxbaV1dKVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHZhbClcbiAgICAgICAgYXJyLnB1c2goW2tleSArICdbJyArIHByb3AgKyAnXScsIHZhbFtwcm9wXV0pO1xuICAgIGVsc2VcbiAgICAgIGFyci5wdXNoKFtrZXksIHZhbF0pXG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBDb21wYXJlIGZ1bmN0aW9uIGZvciBzb3J0XG5mdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJhc2UgKGh0dHBNZXRob2QsIGJhc2VfdXJpLCBwYXJhbXMpIHtcbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL2RvY3MvYXV0aC9vYXV0aCBhbmQgXG4gIC8vIGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL2RvY3MvYXV0aC9jcmVhdGluZy1zaWduYXR1cmVcblxuICAvLyBQYXJhbWV0ZXIgbm9ybWFsaXphdGlvblxuICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1ODQ5I3NlY3Rpb24tMy40LjEuMy4yXG4gIHZhciBub3JtYWxpemVkID0gbWFwKHBhcmFtcylcbiAgLy8gMS4gIEZpcnN0LCB0aGUgbmFtZSBhbmQgdmFsdWUgb2YgZWFjaCBwYXJhbWV0ZXIgYXJlIGVuY29kZWRcbiAgLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBbIHJmYzM5ODYocFswXSksIHJmYzM5ODYocFsxXSB8fCAnJykgXVxuICB9KVxuICAvLyAyLiAgVGhlIHBhcmFtZXRlcnMgYXJlIHNvcnRlZCBieSBuYW1lLCB1c2luZyBhc2NlbmRpbmcgYnl0ZSB2YWx1ZVxuICAvLyAgICAgb3JkZXJpbmcuICBJZiB0d28gb3IgbW9yZSBwYXJhbWV0ZXJzIHNoYXJlIHRoZSBzYW1lIG5hbWUsIHRoZXlcbiAgLy8gICAgIGFyZSBzb3J0ZWQgYnkgdGhlaXIgdmFsdWUuXG4gIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYVswXSwgYlswXSkgfHwgY29tcGFyZShhWzFdLCBiWzFdKVxuICB9KVxuICAvLyAzLiAgVGhlIG5hbWUgb2YgZWFjaCBwYXJhbWV0ZXIgaXMgY29uY2F0ZW5hdGVkIHRvIGl0cyBjb3JyZXNwb25kaW5nXG4gIC8vICAgICB2YWx1ZSB1c2luZyBhbiBcIj1cIiBjaGFyYWN0ZXIgKEFTQ0lJIGNvZGUgNjEpIGFzIGEgc2VwYXJhdG9yLCBldmVuXG4gIC8vICAgICBpZiB0aGUgdmFsdWUgaXMgZW1wdHkuXG4gIC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuam9pbignPScpIH0pXG4gICAvLyA0LiAgVGhlIHNvcnRlZCBuYW1lL3ZhbHVlIHBhaXJzIGFyZSBjb25jYXRlbmF0ZWQgdG9nZXRoZXIgaW50byBhXG4gICAvLyAgICAgc2luZ2xlIHN0cmluZyBieSB1c2luZyBhbiBcIiZcIiBjaGFyYWN0ZXIgKEFTQ0lJIGNvZGUgMzgpIGFzXG4gICAvLyAgICAgc2VwYXJhdG9yLlxuICAuam9pbignJicpXG5cbiAgdmFyIGJhc2UgPSBbXG4gICAgcmZjMzk4NihodHRwTWV0aG9kID8gaHR0cE1ldGhvZC50b1VwcGVyQ2FzZSgpIDogJ0dFVCcpLFxuICAgIHJmYzM5ODYoYmFzZV91cmkpLFxuICAgIHJmYzM5ODYobm9ybWFsaXplZClcbiAgXS5qb2luKCcmJylcblxuICByZXR1cm4gYmFzZVxufVxuXG5mdW5jdGlvbiBobWFjc2lnbiAoaHR0cE1ldGhvZCwgYmFzZV91cmksIHBhcmFtcywgY29uc3VtZXJfc2VjcmV0LCB0b2tlbl9zZWNyZXQpIHtcbiAgdmFyIGJhc2UgPSBnZW5lcmF0ZUJhc2UoaHR0cE1ldGhvZCwgYmFzZV91cmksIHBhcmFtcylcbiAgdmFyIGtleSA9IFtcbiAgICBjb25zdW1lcl9zZWNyZXQgfHwgJycsXG4gICAgdG9rZW5fc2VjcmV0IHx8ICcnXG4gIF0ubWFwKHJmYzM5ODYpLmpvaW4oJyYnKVxuXG4gIHJldHVybiBzaGExKGtleSwgYmFzZSlcbn1cblxuZnVuY3Rpb24gcnNhc2lnbiAoaHR0cE1ldGhvZCwgYmFzZV91cmksIHBhcmFtcywgcHJpdmF0ZV9rZXksIHRva2VuX3NlY3JldCkge1xuICB2YXIgYmFzZSA9IGdlbmVyYXRlQmFzZShodHRwTWV0aG9kLCBiYXNlX3VyaSwgcGFyYW1zKVxuICB2YXIga2V5ID0gcHJpdmF0ZV9rZXkgfHwgJydcblxuICByZXR1cm4gcnNhKGtleSwgYmFzZSlcbn1cblxuZnVuY3Rpb24gcGxhaW50ZXh0IChjb25zdW1lcl9zZWNyZXQsIHRva2VuX3NlY3JldCkge1xuICB2YXIga2V5ID0gW1xuICAgIGNvbnN1bWVyX3NlY3JldCB8fCAnJyxcbiAgICB0b2tlbl9zZWNyZXQgfHwgJydcbiAgXS5tYXAocmZjMzk4Nikuam9pbignJicpXG5cbiAgcmV0dXJuIGtleVxufVxuXG5mdW5jdGlvbiBzaWduIChzaWduTWV0aG9kLCBodHRwTWV0aG9kLCBiYXNlX3VyaSwgcGFyYW1zLCBjb25zdW1lcl9zZWNyZXQsIHRva2VuX3NlY3JldCkge1xuICB2YXIgbWV0aG9kXG4gIHZhciBza2lwQXJncyA9IDFcblxuICBzd2l0Y2ggKHNpZ25NZXRob2QpIHtcbiAgICBjYXNlICdSU0EtU0hBMSc6XG4gICAgICBtZXRob2QgPSByc2FzaWduXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0hNQUMtU0hBMSc6XG4gICAgICBtZXRob2QgPSBobWFjc2lnblxuICAgICAgYnJlYWtcbiAgICBjYXNlICdQTEFJTlRFWFQnOlxuICAgICAgbWV0aG9kID0gcGxhaW50ZXh0XG4gICAgICBza2lwQXJncyA9IDRcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmF0dXJlIG1ldGhvZCBub3Qgc3VwcG9ydGVkOiBcIiArIHNpZ25NZXRob2QpXG4gIH1cblxuICByZXR1cm4gbWV0aG9kLmFwcGx5KG51bGwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBza2lwQXJncykpXG59XG5cbmV4cG9ydHMuaG1hY3NpZ24gPSBobWFjc2lnblxuZXhwb3J0cy5yc2FzaWduID0gcnNhc2lnblxuZXhwb3J0cy5wbGFpbnRleHQgPSBwbGFpbnRleHRcbmV4cG9ydHMuc2lnbiA9IHNpZ25cbmV4cG9ydHMucmZjMzk4NiA9IHJmYzM5ODZcbmV4cG9ydHMuZ2VuZXJhdGVCYXNlID0gZ2VuZXJhdGVCYXNlXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9vYXV0aC1zaWduL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKVxuICAsIENvbWJpbmVkU3RyZWFtID0gcmVxdWlyZSgnY29tYmluZWQtc3RyZWFtJylcbiAgLCBpc3N0cmVhbSA9IHJlcXVpcmUoJ2lzc3RyZWFtJylcblxuXG5mdW5jdGlvbiBNdWx0aXBhcnQgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmJvdW5kYXJ5ID0gdXVpZCgpXG4gIHRoaXMuY2h1bmtlZCA9IGZhbHNlXG4gIHRoaXMuYm9keSA9IG51bGxcbn1cblxuTXVsdGlwYXJ0LnByb3RvdHlwZS5pc0NodW5rZWQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGNodW5rZWQgPSBmYWxzZVxuICAgICwgcGFydHMgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9uc1xuXG4gIGlmICghcGFydHMuZm9yRWFjaCkge1xuICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQXJndW1lbnQgZXJyb3IsIG9wdGlvbnMubXVsdGlwYXJ0LicpKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2h1bmtlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2h1bmtlZCA9IG9wdGlvbnMuY2h1bmtlZFxuICB9XG5cbiAgaWYgKHNlbGYucmVxdWVzdC5nZXRIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJykgPT09ICdjaHVua2VkJykge1xuICAgIGNodW5rZWQgPSB0cnVlXG4gIH1cblxuICBpZiAoIWNodW5rZWQpIHtcbiAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQuYm9keSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdCb2R5IGF0dHJpYnV0ZSBtaXNzaW5nIGluIG11bHRpcGFydC4nKSlcbiAgICAgIH1cbiAgICAgIGlmIChpc3N0cmVhbShwYXJ0LmJvZHkpKSB7XG4gICAgICAgIGNodW5rZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBjaHVua2VkXG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uIChjaHVua2VkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChjaHVua2VkICYmICFzZWxmLnJlcXVlc3QuaGFzSGVhZGVyKCd0cmFuc2Zlci1lbmNvZGluZycpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LnNldEhlYWRlcigndHJhbnNmZXItZW5jb2RpbmcnLCAnY2h1bmtlZCcpXG4gIH1cblxuICB2YXIgaGVhZGVyID0gc2VsZi5yZXF1ZXN0LmdldEhlYWRlcignY29udGVudC10eXBlJylcblxuICBpZiAoIWhlYWRlciB8fCBoZWFkZXIuaW5kZXhPZignbXVsdGlwYXJ0JykgPT09IC0xKSB7XG4gICAgc2VsZi5yZXF1ZXN0LnNldEhlYWRlcignY29udGVudC10eXBlJywgJ211bHRpcGFydC9yZWxhdGVkOyBib3VuZGFyeT0nICsgc2VsZi5ib3VuZGFyeSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoaGVhZGVyLmluZGV4T2YoJ2JvdW5kYXJ5JykgIT09IC0xKSB7XG4gICAgICBzZWxmLmJvdW5kYXJ5ID0gaGVhZGVyLnJlcGxhY2UoLy4qYm91bmRhcnk9KFteXFxzO10rKS4qLywgJyQxJylcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5yZXF1ZXN0LnNldEhlYWRlcignY29udGVudC10eXBlJywgaGVhZGVyICsgJzsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnkpXG4gICAgfVxuICB9XG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAocGFydHMsIGNodW5rZWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBib2R5ID0gY2h1bmtlZCA/IG5ldyBDb21iaW5lZFN0cmVhbSgpIDogW11cblxuICBmdW5jdGlvbiBhZGQgKHBhcnQpIHtcbiAgICByZXR1cm4gY2h1bmtlZCA/IGJvZHkuYXBwZW5kKHBhcnQpIDogYm9keS5wdXNoKG5ldyBCdWZmZXIocGFydCkpXG4gIH1cblxuICBpZiAoc2VsZi5yZXF1ZXN0LnByZWFtYmxlQ1JMRikge1xuICAgIGFkZCgnXFxyXFxuJylcbiAgfVxuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgcHJlYW1ibGUgPSAnLS0nICsgc2VsZi5ib3VuZGFyeSArICdcXHJcXG4nXG4gICAgT2JqZWN0LmtleXMocGFydCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnYm9keScpIHsgcmV0dXJuIH1cbiAgICAgIHByZWFtYmxlICs9IGtleSArICc6ICcgKyBwYXJ0W2tleV0gKyAnXFxyXFxuJ1xuICAgIH0pXG4gICAgcHJlYW1ibGUgKz0gJ1xcclxcbidcbiAgICBhZGQocHJlYW1ibGUpXG4gICAgYWRkKHBhcnQuYm9keSlcbiAgICBhZGQoJ1xcclxcbicpXG4gIH0pXG4gIGFkZCgnLS0nICsgc2VsZi5ib3VuZGFyeSArICctLScpXG5cbiAgaWYgKHNlbGYucmVxdWVzdC5wb3N0YW1ibGVDUkxGKSB7XG4gICAgYWRkKCdcXHJcXG4nKVxuICB9XG5cbiAgcmV0dXJuIGJvZHlcbn1cblxuTXVsdGlwYXJ0LnByb3RvdHlwZS5vblJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgY2h1bmtlZCA9IHNlbGYuaXNDaHVua2VkKG9wdGlvbnMpXG4gICAgLCBwYXJ0cyA9IG9wdGlvbnMuZGF0YSB8fCBvcHRpb25zXG5cbiAgc2VsZi5zZXRIZWFkZXJzKGNodW5rZWQpXG4gIHNlbGYuY2h1bmtlZCA9IGNodW5rZWRcbiAgc2VsZi5ib2R5ID0gc2VsZi5idWlsZChwYXJ0cywgY2h1bmtlZClcbn1cblxuZXhwb3J0cy5NdWx0aXBhcnQgPSBNdWx0aXBhcnRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZXF1ZXN0L2xpYi9tdWx0aXBhcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciBEZWxheWVkU3RyZWFtID0gcmVxdWlyZSgnZGVsYXllZC1zdHJlYW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21iaW5lZFN0cmVhbTtcbmZ1bmN0aW9uIENvbWJpbmVkU3RyZWFtKCkge1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuICB0aGlzLmRhdGFTaXplID0gMDtcbiAgdGhpcy5tYXhEYXRhU2l6ZSA9IDIgKiAxMDI0ICogMTAyNDtcbiAgdGhpcy5wYXVzZVN0cmVhbXMgPSB0cnVlO1xuXG4gIHRoaXMuX3JlbGVhc2VkID0gZmFsc2U7XG4gIHRoaXMuX3N0cmVhbXMgPSBbXTtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IG51bGw7XG59XG51dGlsLmluaGVyaXRzKENvbWJpbmVkU3RyZWFtLCBTdHJlYW0pO1xuXG5Db21iaW5lZFN0cmVhbS5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBjb21iaW5lZFN0cmVhbSA9IG5ldyB0aGlzKCk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgY29tYmluZWRTdHJlYW1bb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgfVxuXG4gIHJldHVybiBjb21iaW5lZFN0cmVhbTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICByZXR1cm4gKHR5cGVvZiBzdHJlYW0gIT09ICdmdW5jdGlvbicpXG4gICAgJiYgKHR5cGVvZiBzdHJlYW0gIT09ICdzdHJpbmcnKVxuICAgICYmICh0eXBlb2Ygc3RyZWFtICE9PSAnYm9vbGVhbicpXG4gICAgJiYgKHR5cGVvZiBzdHJlYW0gIT09ICdudW1iZXInKVxuICAgICYmICghQnVmZmVyLmlzQnVmZmVyKHN0cmVhbSkpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgaXNTdHJlYW1MaWtlID0gQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlKHN0cmVhbSk7XG5cbiAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgIGlmICghKHN0cmVhbSBpbnN0YW5jZW9mIERlbGF5ZWRTdHJlYW0pKSB7XG4gICAgICB2YXIgbmV3U3RyZWFtID0gRGVsYXllZFN0cmVhbS5jcmVhdGUoc3RyZWFtLCB7XG4gICAgICAgIG1heERhdGFTaXplOiBJbmZpbml0eSxcbiAgICAgICAgcGF1c2VTdHJlYW06IHRoaXMucGF1c2VTdHJlYW1zLFxuICAgICAgfSk7XG4gICAgICBzdHJlYW0ub24oJ2RhdGEnLCB0aGlzLl9jaGVja0RhdGFTaXplLmJpbmQodGhpcykpO1xuICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZUVycm9ycyhzdHJlYW0pO1xuXG4gICAgaWYgKHRoaXMucGF1c2VTdHJlYW1zKSB7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9zdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwodGhpcywgZGVzdCwgb3B0aW9ucyk7XG4gIHRoaXMucmVzdW1lKCk7XG4gIHJldHVybiBkZXN0O1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9nZXROZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBudWxsO1xuICB2YXIgc3RyZWFtID0gdGhpcy5fc3RyZWFtcy5zaGlmdCgpO1xuXG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmVuZCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fcGlwZU5leHQoc3RyZWFtKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2V0U3RyZWFtID0gc3RyZWFtO1xuICBnZXRTdHJlYW0oZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGlzU3RyZWFtTGlrZSA9IENvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZShzdHJlYW0pO1xuICAgIGlmIChpc1N0cmVhbUxpa2UpIHtcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIHRoaXMuX2NoZWNrRGF0YVNpemUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9oYW5kbGVFcnJvcnMoc3RyZWFtKTtcbiAgICB9XG5cbiAgICB0aGlzLl9waXBlTmV4dChzdHJlYW0pO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9waXBlTmV4dCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gc3RyZWFtO1xuXG4gIHZhciBpc1N0cmVhbUxpa2UgPSBDb21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2Uoc3RyZWFtKTtcbiAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgIHN0cmVhbS5vbignZW5kJywgdGhpcy5fZ2V0TmV4dC5iaW5kKHRoaXMpKTtcbiAgICBzdHJlYW0ucGlwZSh0aGlzLCB7ZW5kOiBmYWxzZX0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHN0cmVhbTtcbiAgdGhpcy53cml0ZSh2YWx1ZSk7XG4gIHRoaXMuX2dldE5leHQoKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5faGFuZGxlRXJyb3JzID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIHNlbGYuX2VtaXRFcnJvcihlcnIpO1xuICB9KTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnBhdXNlU3RyZWFtcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKHRoaXMucGF1c2VTdHJlYW1zICYmIHRoaXMuX2N1cnJlbnRTdHJlYW0gJiYgdHlwZW9mKHRoaXMuX2N1cnJlbnRTdHJlYW0ucGF1c2UpID09ICdmdW5jdGlvbicpIHRoaXMuX2N1cnJlbnRTdHJlYW0ucGF1c2UoKTtcbiAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbGVhc2VkKSB7XG4gICAgdGhpcy5fcmVsZWFzZWQgPSB0cnVlO1xuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2dldE5leHQoKTtcbiAgfVxuXG4gIGlmKHRoaXMucGF1c2VTdHJlYW1zICYmIHRoaXMuX2N1cnJlbnRTdHJlYW0gJiYgdHlwZW9mKHRoaXMuX2N1cnJlbnRTdHJlYW0ucmVzdW1lKSA9PSAnZnVuY3Rpb24nKSB0aGlzLl9jdXJyZW50U3RyZWFtLnJlc3VtZSgpO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLmVtaXQoJ2VuZCcpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHRoaXMuX3N0cmVhbXMgPSBbXTtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IG51bGw7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2NoZWNrRGF0YVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdXBkYXRlRGF0YVNpemUoKTtcbiAgaWYgKHRoaXMuZGF0YVNpemUgPD0gdGhpcy5tYXhEYXRhU2l6ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtZXNzYWdlID1cbiAgICAnRGVsYXllZFN0cmVhbSNtYXhEYXRhU2l6ZSBvZiAnICsgdGhpcy5tYXhEYXRhU2l6ZSArICcgYnl0ZXMgZXhjZWVkZWQuJztcbiAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3VwZGF0ZURhdGFTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIGlmICghc3RyZWFtLmRhdGFTaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5kYXRhU2l6ZSArPSBzdHJlYW0uZGF0YVNpemU7XG4gIH0pO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50U3RyZWFtICYmIHRoaXMuX2N1cnJlbnRTdHJlYW0uZGF0YVNpemUpIHtcbiAgICB0aGlzLmRhdGFTaXplICs9IHRoaXMuX2N1cnJlbnRTdHJlYW0uZGF0YVNpemU7XG4gIH1cbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fZW1pdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9jb21iaW5lZC1zdHJlYW0vbGliL2NvbWJpbmVkX3N0cmVhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlbGF5ZWRTdHJlYW07XG5mdW5jdGlvbiBEZWxheWVkU3RyZWFtKCkge1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuICB0aGlzLm1heERhdGFTaXplID0gMTAyNCAqIDEwMjQ7XG4gIHRoaXMucGF1c2VTdHJlYW0gPSB0cnVlO1xuXG4gIHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQgPSBmYWxzZTtcbiAgdGhpcy5fcmVsZWFzZWQgPSBmYWxzZTtcbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMgPSBbXTtcbn1cbnV0aWwuaW5oZXJpdHMoRGVsYXllZFN0cmVhbSwgU3RyZWFtKTtcblxuRGVsYXllZFN0cmVhbS5jcmVhdGUgPSBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgdmFyIGRlbGF5ZWRTdHJlYW0gPSBuZXcgdGhpcygpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGRlbGF5ZWRTdHJlYW1bb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgfVxuXG4gIGRlbGF5ZWRTdHJlYW0uc291cmNlID0gc291cmNlO1xuXG4gIHZhciByZWFsRW1pdCA9IHNvdXJjZS5lbWl0O1xuICBzb3VyY2UuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGF5ZWRTdHJlYW0uX2hhbmRsZUVtaXQoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVhbEVtaXQuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHNvdXJjZS5vbignZXJyb3InLCBmdW5jdGlvbigpIHt9KTtcbiAgaWYgKGRlbGF5ZWRTdHJlYW0ucGF1c2VTdHJlYW0pIHtcbiAgICBzb3VyY2UucGF1c2UoKTtcbiAgfVxuXG4gIHJldHVybiBkZWxheWVkU3RyZWFtO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLCAncmVhZGFibGUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UucmVhZGFibGU7XG4gIH1cbn0pO1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2Uuc2V0RW5jb2RpbmcuYXBwbHkodGhpcy5zb3VyY2UsIGFyZ3VtZW50cyk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZWxlYXNlZCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICB9XG5cbiAgdGhpcy5zb3VyY2UucmVzdW1lKCk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNvdXJjZS5wYXVzZSgpO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZWxlYXNlZCA9IHRydWU7XG5cbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7XG4gICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLl9idWZmZXJlZEV2ZW50cyA9IFtdO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgciA9IFN0cmVhbS5wcm90b3R5cGUucGlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLnJlc3VtZSgpO1xuICByZXR1cm4gcjtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVFbWl0ID0gZnVuY3Rpb24oYXJncykge1xuICBpZiAodGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFyZ3NbMF0gPT09ICdkYXRhJykge1xuICAgIHRoaXMuZGF0YVNpemUgKz0gYXJnc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fY2hlY2tJZk1heERhdGFTaXplRXhjZWVkZWQoKTtcbiAgfVxuXG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzLnB1c2goYXJncyk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5fY2hlY2tJZk1heERhdGFTaXplRXhjZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5kYXRhU2l6ZSA8PSB0aGlzLm1heERhdGFTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fbWF4RGF0YVNpemVFeGNlZWRlZCA9IHRydWU7XG4gIHZhciBtZXNzYWdlID1cbiAgICAnRGVsYXllZFN0cmVhbSNtYXhEYXRhU2l6ZSBvZiAnICsgdGhpcy5tYXhEYXRhU2l6ZSArICcgYnl0ZXMgZXhjZWVkZWQuJ1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vZGVsYXllZC1zdHJlYW0vbGliL2RlbGF5ZWRfc3RyZWFtLmpzXG4gKiogbW9kdWxlIGlkID0gMTU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcblxuXG5mdW5jdGlvbiBpc1N0cmVhbSAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBzdHJlYW0uU3RyZWFtXG59XG5cblxuZnVuY3Rpb24gaXNSZWFkYWJsZSAob2JqKSB7XG4gIHJldHVybiBpc1N0cmVhbShvYmopICYmIHR5cGVvZiBvYmouX3JlYWQgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLl9yZWFkYWJsZVN0YXRlID09ICdvYmplY3QnXG59XG5cblxuZnVuY3Rpb24gaXNXcml0YWJsZSAob2JqKSB7XG4gIHJldHVybiBpc1N0cmVhbShvYmopICYmIHR5cGVvZiBvYmouX3dyaXRlID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5fd3JpdGFibGVTdGF0ZSA9PSAnb2JqZWN0J1xufVxuXG5cbmZ1bmN0aW9uIGlzRHVwbGV4IChvYmopIHtcbiAgcmV0dXJuIGlzUmVhZGFibGUob2JqKSAmJiBpc1dyaXRhYmxlKG9iailcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyAgICAgICAgICAgID0gaXNTdHJlYW1cbm1vZHVsZS5leHBvcnRzLmlzUmVhZGFibGUgPSBpc1JlYWRhYmxlXG5tb2R1bGUuZXhwb3J0cy5pc1dyaXRhYmxlID0gaXNXcml0YWJsZVxubW9kdWxlLmV4cG9ydHMuaXNEdXBsZXggICA9IGlzRHVwbGV4XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vaXNzdHJlYW0vaXNzdHJlYW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciBpc1VybCA9IC9eaHR0cHM/Oi9cblxuZnVuY3Rpb24gUmVkaXJlY3QgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmZvbGxvd1JlZGlyZWN0ID0gdHJ1ZVxuICB0aGlzLmZvbGxvd1JlZGlyZWN0cyA9IHRydWVcbiAgdGhpcy5mb2xsb3dBbGxSZWRpcmVjdHMgPSBmYWxzZVxuICB0aGlzLmFsbG93UmVkaXJlY3QgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRydWV9XG4gIHRoaXMubWF4UmVkaXJlY3RzID0gMTBcbiAgdGhpcy5yZWRpcmVjdHMgPSBbXVxuICB0aGlzLnJlZGlyZWN0c0ZvbGxvd2VkID0gMFxuICB0aGlzLnJlbW92ZVJlZmVyZXJIZWFkZXIgPSBmYWxzZVxufVxuXG5SZWRpcmVjdC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLm1heFJlZGlyZWN0cyA9IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZvbGxvd1JlZGlyZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2VsZi5hbGxvd1JlZGlyZWN0ID0gb3B0aW9ucy5mb2xsb3dSZWRpcmVjdFxuICB9XG4gIGlmIChvcHRpb25zLmZvbGxvd1JlZGlyZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLmZvbGxvd1JlZGlyZWN0cyA9ICEhb3B0aW9ucy5mb2xsb3dSZWRpcmVjdFxuICB9XG4gIGlmIChvcHRpb25zLmZvbGxvd0FsbFJlZGlyZWN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMgPSBvcHRpb25zLmZvbGxvd0FsbFJlZGlyZWN0c1xuICB9XG4gIGlmIChzZWxmLmZvbGxvd1JlZGlyZWN0cyB8fCBzZWxmLmZvbGxvd0FsbFJlZGlyZWN0cykge1xuICAgIHNlbGYucmVkaXJlY3RzID0gc2VsZi5yZWRpcmVjdHMgfHwgW11cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVSZWZlcmVySGVhZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLnJlbW92ZVJlZmVyZXJIZWFkZXIgPSBvcHRpb25zLnJlbW92ZVJlZmVyZXJIZWFkZXJcbiAgfVxufVxuXG5SZWRpcmVjdC5wcm90b3R5cGUucmVkaXJlY3RUbyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICB2YXIgcmVkaXJlY3RUbyA9IG51bGxcbiAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdsb2NhdGlvbicpKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVzcG9uc2UuY2FzZWxlc3MuZ2V0KCdsb2NhdGlvbicpXG4gICAgcmVxdWVzdC5kZWJ1ZygncmVkaXJlY3QnLCBsb2NhdGlvbilcblxuICAgIGlmIChzZWxmLmZvbGxvd0FsbFJlZGlyZWN0cykge1xuICAgICAgcmVkaXJlY3RUbyA9IGxvY2F0aW9uXG4gICAgfSBlbHNlIGlmIChzZWxmLmZvbGxvd1JlZGlyZWN0cykge1xuICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICBjYXNlICdQQVRDSCc6XG4gICAgICAgIGNhc2UgJ1BVVCc6XG4gICAgICAgIGNhc2UgJ1BPU1QnOlxuICAgICAgICBjYXNlICdERUxFVEUnOlxuICAgICAgICAgIC8vIERvIG5vdCBmb2xsb3cgcmVkaXJlY3RzXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWRpcmVjdFRvID0gbG9jYXRpb25cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDEpIHtcbiAgICB2YXIgYXV0aEhlYWRlciA9IHJlcXVlc3QuX2F1dGgub25SZXNwb25zZShyZXNwb25zZSlcbiAgICBpZiAoYXV0aEhlYWRlcikge1xuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyKVxuICAgICAgcmVkaXJlY3RUbyA9IHJlcXVlc3QudXJpXG4gICAgfVxuICB9XG4gIHJldHVybiByZWRpcmVjdFRvXG59XG5cblJlZGlyZWN0LnByb3RvdHlwZS5vblJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgcmVxdWVzdCA9IHNlbGYucmVxdWVzdFxuXG4gIHZhciByZWRpcmVjdFRvID0gc2VsZi5yZWRpcmVjdFRvKHJlc3BvbnNlKVxuICBpZiAoIXJlZGlyZWN0VG8gfHwgIXNlbGYuYWxsb3dSZWRpcmVjdC5jYWxsKHJlcXVlc3QsIHJlc3BvbnNlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmVxdWVzdC5kZWJ1ZygncmVkaXJlY3QgdG8nLCByZWRpcmVjdFRvKVxuXG4gIC8vIGlnbm9yZSBhbnkgcG90ZW50aWFsIHJlc3BvbnNlIGJvZHkuICBpdCBjYW5ub3QgcG9zc2libHkgYmUgdXNlZnVsXG4gIC8vIHRvIHVzIGF0IHRoaXMgcG9pbnQuXG4gIC8vIHJlc3BvbnNlLnJlc3VtZSBzaG91bGQgYmUgZGVmaW5lZCwgYnV0IGNoZWNrIGFueXdheSBiZWZvcmUgY2FsbGluZy4gV29ya2Fyb3VuZCBmb3IgYnJvd3NlcmlmeS5cbiAgaWYgKHJlc3BvbnNlLnJlc3VtZSkge1xuICAgIHJlc3BvbnNlLnJlc3VtZSgpXG4gIH1cblxuICBpZiAoc2VsZi5yZWRpcmVjdHNGb2xsb3dlZCA+PSBzZWxmLm1heFJlZGlyZWN0cykge1xuICAgIHJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0V4Y2VlZGVkIG1heFJlZGlyZWN0cy4gUHJvYmFibHkgc3R1Y2sgaW4gYSByZWRpcmVjdCBsb29wICcgKyByZXF1ZXN0LnVyaS5ocmVmKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBzZWxmLnJlZGlyZWN0c0ZvbGxvd2VkICs9IDFcblxuICBpZiAoIWlzVXJsLnRlc3QocmVkaXJlY3RUbykpIHtcbiAgICByZWRpcmVjdFRvID0gdXJsLnJlc29sdmUocmVxdWVzdC51cmkuaHJlZiwgcmVkaXJlY3RUbylcbiAgfVxuXG4gIHZhciB1cmlQcmV2ID0gcmVxdWVzdC51cmlcbiAgcmVxdWVzdC51cmkgPSB1cmwucGFyc2UocmVkaXJlY3RUbylcblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgY2hhbmdlIHByb3RvY29sIGZyb20gaHR0cHMgdG8gaHR0cCBvciB2aWNlIHZlcnNhXG4gIGlmIChyZXF1ZXN0LnVyaS5wcm90b2NvbCAhPT0gdXJpUHJldi5wcm90b2NvbCkge1xuICAgIHJlcXVlc3QuX3VwZGF0ZVByb3RvY29sKClcbiAgfVxuXG4gIHNlbGYucmVkaXJlY3RzLnB1c2goXG4gICAgeyBzdGF0dXNDb2RlIDogcmVzcG9uc2Uuc3RhdHVzQ29kZVxuICAgICwgcmVkaXJlY3RVcmk6IHJlZGlyZWN0VG9cbiAgICB9XG4gIClcbiAgaWYgKHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDQwMSAmJiByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAzMDcpIHtcbiAgICByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnXG4gIH1cbiAgLy8gcmVxdWVzdC5tZXRob2QgPSAnR0VUJyAvLyBGb3JjZSBhbGwgcmVkaXJlY3RzIHRvIHVzZSBHRVQgfHwgY29tbWVudGVkIG91dCBmaXhlcyAjMjE1XG4gIGRlbGV0ZSByZXF1ZXN0LnNyY1xuICBkZWxldGUgcmVxdWVzdC5yZXFcbiAgZGVsZXRlIHJlcXVlc3QuYWdlbnRcbiAgZGVsZXRlIHJlcXVlc3QuX3N0YXJ0ZWRcbiAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDQwMSAmJiByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAzMDcpIHtcbiAgICAvLyBSZW1vdmUgcGFyYW1ldGVycyBmcm9tIHRoZSBwcmV2aW91cyByZXNwb25zZSwgdW5sZXNzIHRoaXMgaXMgdGhlIHNlY29uZCByZXF1ZXN0XG4gICAgLy8gZm9yIGEgc2VydmVyIHRoYXQgcmVxdWlyZXMgZGlnZXN0IGF1dGhlbnRpY2F0aW9uLlxuICAgIGRlbGV0ZSByZXF1ZXN0LmJvZHlcbiAgICBkZWxldGUgcmVxdWVzdC5fZm9ybVxuICAgIGlmIChyZXF1ZXN0LmhlYWRlcnMpIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlSGVhZGVyKCdob3N0JylcbiAgICAgIHJlcXVlc3QucmVtb3ZlSGVhZGVyKCdjb250ZW50LXR5cGUnKVxuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJylcbiAgICAgIGlmIChyZXF1ZXN0LnVyaS5ob3N0bmFtZSAhPT0gcmVxdWVzdC5vcmlnaW5hbEhvc3Quc3BsaXQoJzonKVswXSkge1xuICAgICAgICAvLyBSZW1vdmUgYXV0aG9yaXphdGlvbiBpZiBjaGFuZ2luZyBob3N0bmFtZXMgKGJ1dCBub3QgaWYganVzdFxuICAgICAgICAvLyBjaGFuZ2luZyBwb3J0cyBvciBwcm90b2NvbHMpLiAgVGhpcyBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiBjdXJsOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFnZGVyL2N1cmwvYmxvYi82YmViMGVlZS9saWIvaHR0cC5jI0w3MTBcbiAgICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2F1dGhvcml6YXRpb24nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2VsZi5yZW1vdmVSZWZlcmVySGVhZGVyKSB7XG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoJ3JlZmVyZXInLCByZXF1ZXN0LnVyaS5ocmVmKVxuICB9XG5cbiAgcmVxdWVzdC5lbWl0KCdyZWRpcmVjdCcpXG5cbiAgcmVxdWVzdC5pbml0KClcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLlJlZGlyZWN0ID0gUmVkaXJlY3RcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi9yZXF1ZXN0L2xpYi9yZWRpcmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuICAsIHR1bm5lbCA9IHJlcXVpcmUoJ3R1bm5lbC1hZ2VudCcpXG5cbnZhciBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBbXG4gICdhY2NlcHQnLFxuICAnYWNjZXB0LWNoYXJzZXQnLFxuICAnYWNjZXB0LWVuY29kaW5nJyxcbiAgJ2FjY2VwdC1sYW5ndWFnZScsXG4gICdhY2NlcHQtcmFuZ2VzJyxcbiAgJ2NhY2hlLWNvbnRyb2wnLFxuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbGVuZ3RoJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC1tZDUnLFxuICAnY29udGVudC1yYW5nZScsXG4gICdjb250ZW50LXR5cGUnLFxuICAnY29ubmVjdGlvbicsXG4gICdkYXRlJyxcbiAgJ2V4cGVjdCcsXG4gICdtYXgtZm9yd2FyZHMnLFxuICAncHJhZ21hJyxcbiAgJ3JlZmVyZXInLFxuICAndGUnLFxuICAndHJhbnNmZXItZW5jb2RpbmcnLFxuICAndXNlci1hZ2VudCcsXG4gICd2aWEnXG5dXG5cbnZhciBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW1xuICAncHJveHktYXV0aG9yaXphdGlvbidcbl1cblxuZnVuY3Rpb24gY29uc3RydWN0UHJveHlIb3N0KHVyaU9iamVjdCkge1xuICB2YXIgcG9ydCA9IHVyaU9iamVjdC5wb3J0QVxuICAgICwgcHJvdG9jb2wgPSB1cmlPYmplY3QucHJvdG9jb2xcbiAgICAsIHByb3h5SG9zdCA9IHVyaU9iamVjdC5ob3N0bmFtZSArICc6J1xuXG4gIGlmIChwb3J0KSB7XG4gICAgcHJveHlIb3N0ICs9IHBvcnRcbiAgfSBlbHNlIGlmIChwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwcm94eUhvc3QgKz0gJzQ0MydcbiAgfSBlbHNlIHtcbiAgICBwcm94eUhvc3QgKz0gJzgwJ1xuICB9XG5cbiAgcmV0dXJuIHByb3h5SG9zdFxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhlYWRlcldoaXRlTGlzdChoZWFkZXJzLCBwcm94eUhlYWRlcldoaXRlTGlzdCkge1xuICB2YXIgd2hpdGVMaXN0ID0gcHJveHlIZWFkZXJXaGl0ZUxpc3RcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGhlYWRlcikge1xuICAgICAgc2V0W2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHRydWVcbiAgICAgIHJldHVybiBzZXRcbiAgICB9LCB7fSlcblxuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIHJldHVybiB3aGl0ZUxpc3RbaGVhZGVyLnRvTG93ZXJDYXNlKCldXG4gICAgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGhlYWRlcikge1xuICAgICAgc2V0W2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl1cbiAgICAgIHJldHVybiBzZXRcbiAgICB9LCB7fSlcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsT3B0aW9ucyAocmVxdWVzdCwgcHJveHlIZWFkZXJzKSB7XG4gIHZhciBwcm94eSA9IHJlcXVlc3QucHJveHlcblxuICB2YXIgdHVubmVsT3B0aW9ucyA9IHtcbiAgICBwcm94eSA6IHtcbiAgICAgIGhvc3QgICAgICA6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgcG9ydCAgICAgIDogK3Byb3h5LnBvcnQsXG4gICAgICBwcm94eUF1dGggOiBwcm94eS5hdXRoLFxuICAgICAgaGVhZGVycyAgIDogcHJveHlIZWFkZXJzXG4gICAgfSxcbiAgICBoZWFkZXJzICAgICAgICAgICAgOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgY2EgICAgICAgICAgICAgICAgIDogcmVxdWVzdC5jYSxcbiAgICBjZXJ0ICAgICAgICAgICAgICAgOiByZXF1ZXN0LmNlcnQsXG4gICAga2V5ICAgICAgICAgICAgICAgIDogcmVxdWVzdC5rZXksXG4gICAgcGFzc3BocmFzZSAgICAgICAgIDogcmVxdWVzdC5wYXNzcGhyYXNlLFxuICAgIHBmeCAgICAgICAgICAgICAgICA6IHJlcXVlc3QucGZ4LFxuICAgIGNpcGhlcnMgICAgICAgICAgICA6IHJlcXVlc3QuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQgOiByZXF1ZXN0LnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBzZWN1cmVPcHRpb25zICAgICAgOiByZXF1ZXN0LnNlY3VyZU9wdGlvbnMsXG4gICAgc2VjdXJlUHJvdG9jb2wgICAgIDogcmVxdWVzdC5zZWN1cmVQcm90b2NvbFxuICB9XG5cbiAgcmV0dXJuIHR1bm5lbE9wdGlvbnNcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpIHtcbiAgdmFyIHVyaVByb3RvY29sID0gKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnaHR0cHMnIDogJ2h0dHAnKVxuICB2YXIgcHJveHlQcm90b2NvbCA9IChwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnSHR0cHMnIDogJ0h0dHAnKVxuICByZXR1cm4gW3VyaVByb3RvY29sLCBwcm94eVByb3RvY29sXS5qb2luKCdPdmVyJylcbn1cblxuZnVuY3Rpb24gZ2V0VHVubmVsRm4ocmVxdWVzdCkge1xuICB2YXIgdXJpID0gcmVxdWVzdC51cmlcbiAgdmFyIHByb3h5ID0gcmVxdWVzdC5wcm94eVxuICB2YXIgdHVubmVsRm5OYW1lID0gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpXG4gIHJldHVybiB0dW5uZWxbdHVubmVsRm5OYW1lXVxufVxuXG5cbmZ1bmN0aW9uIFR1bm5lbCAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMucHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3RcbiAgdGhpcy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBbXVxufVxuXG5UdW5uZWwucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0XG4gIC8vIFR1bm5lbCBIVFRQUyBieSBkZWZhdWx0LCBvciBpZiBhIHByZXZpb3VzIHJlcXVlc3QgaW4gdGhlIHJlZGlyZWN0IGNoYWluXG4gIC8vIHdhcyB0dW5uZWxlZC4gIEFsbG93IHRoZSB1c2VyIHRvIG92ZXJyaWRlIHRoaXMgc2V0dGluZy5cblxuICAvLyBJZiBzZWxmLnR1bm5lbCBpcyBhbHJlYWR5IHNldCAoYmVjYXVzZSB0aGlzIGlzIGEgcmVkaXJlY3QpLCB1c2UgdGhlXG4gIC8vIGV4aXN0aW5nIHZhbHVlLlxuICBpZiAodHlwZW9mIHJlcXVlc3QudHVubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiByZXF1ZXN0LnR1bm5lbFxuICB9XG5cbiAgLy8gSWYgb3B0aW9ucy50dW5uZWwgaXMgc2V0ICh0aGUgdXNlciBzcGVjaWZpZWQgYSB2YWx1ZSksIHVzZSBpdC5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLnR1bm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gb3B0aW9ucy50dW5uZWxcbiAgfVxuXG4gIC8vIElmIHRoZSBkZXN0aW5hdGlvbiBpcyBIVFRQUywgdHVubmVsLlxuICBpZiAocmVxdWVzdC51cmkucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbGVhdmUgdHVubmVsIHVuc2V0LCBiZWNhdXNlIGlmIGEgbGF0ZXIgcmVxdWVzdCBpbiB0aGUgcmVkaXJlY3RcbiAgLy8gY2hhaW4gaXMgSFRUUFMgdGhlbiB0aGF0IHJlcXVlc3QgKGFuZCBhbnkgc3Vic2VxdWVudCBvbmVzKSBzaG91bGQgYmVcbiAgLy8gdHVubmVsZWQuXG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuVHVubmVsLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgcmVxdWVzdCA9IHNlbGYucmVxdWVzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHR5cGVvZiByZXF1ZXN0LnByb3h5ID09PSAnc3RyaW5nJykge1xuICAgIHJlcXVlc3QucHJveHkgPSB1cmwucGFyc2UocmVxdWVzdC5wcm94eSlcbiAgfVxuXG4gIGlmICghcmVxdWVzdC5wcm94eSB8fCAhcmVxdWVzdC50dW5uZWwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFNldHVwIFByb3h5IEhlYWRlciBFeGNsdXNpdmUgTGlzdCBhbmQgV2hpdGUgTGlzdFxuICBpZiAob3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdCkge1xuICAgIHNlbGYucHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBvcHRpb25zLnByb3h5SGVhZGVyV2hpdGVMaXN0XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0KSB7XG4gICAgc2VsZi5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdFxuICB9XG5cbiAgdmFyIHByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9IHNlbGYucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmNvbmNhdChkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0KVxuICB2YXIgcHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBzZWxmLnByb3h5SGVhZGVyV2hpdGVMaXN0LmNvbmNhdChwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QpXG5cbiAgLy8gU2V0dXAgUHJveHkgSGVhZGVycyBhbmQgUHJveHkgSGVhZGVycyBIb3N0XG4gIC8vIE9ubHkgc2VuZCB0aGUgUHJveHkgV2hpdGUgTGlzdGVkIEhlYWRlciBuYW1lc1xuICB2YXIgcHJveHlIZWFkZXJzID0gY29uc3RydWN0UHJveHlIZWFkZXJXaGl0ZUxpc3QocmVxdWVzdC5oZWFkZXJzLCBwcm94eUhlYWRlcldoaXRlTGlzdClcbiAgcHJveHlIZWFkZXJzLmhvc3QgPSBjb25zdHJ1Y3RQcm94eUhvc3QocmVxdWVzdC51cmkpXG5cbiAgcHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmZvckVhY2gocmVxdWVzdC5yZW1vdmVIZWFkZXIsIHJlcXVlc3QpXG5cbiAgLy8gU2V0IEFnZW50IGZyb20gVHVubmVsIERhdGFcbiAgdmFyIHR1bm5lbEZuID0gZ2V0VHVubmVsRm4ocmVxdWVzdClcbiAgdmFyIHR1bm5lbE9wdGlvbnMgPSBjb25zdHJ1Y3RUdW5uZWxPcHRpb25zKHJlcXVlc3QsIHByb3h5SGVhZGVycylcbiAgcmVxdWVzdC5hZ2VudCA9IHR1bm5lbEZuKHR1bm5lbE9wdGlvbnMpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCA9IGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdFxuVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0XG5leHBvcnRzLlR1bm5lbCA9IFR1bm5lbFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3JlcXVlc3QvbGliL3R1bm5lbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKVxuICAsIHRscyA9IHJlcXVpcmUoJ3RscycpXG4gICwgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuICAsIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKVxuICAsIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG4gICwgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbiAgLCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG4gIDtcblxuZXhwb3J0cy5odHRwT3Zlckh0dHAgPSBodHRwT3Zlckh0dHBcbmV4cG9ydHMuaHR0cHNPdmVySHR0cCA9IGh0dHBzT3Zlckh0dHBcbmV4cG9ydHMuaHR0cE92ZXJIdHRwcyA9IGh0dHBPdmVySHR0cHNcbmV4cG9ydHMuaHR0cHNPdmVySHR0cHMgPSBodHRwc092ZXJIdHRwc1xuXG5cbmZ1bmN0aW9uIGh0dHBPdmVySHR0cChvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKVxuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0XG4gIHJldHVybiBhZ2VudFxufVxuXG5mdW5jdGlvbiBodHRwc092ZXJIdHRwKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpXG4gIGFnZW50LnJlcXVlc3QgPSBodHRwLnJlcXVlc3RcbiAgYWdlbnQuY3JlYXRlU29ja2V0ID0gY3JlYXRlU2VjdXJlU29ja2V0XG4gIGFnZW50LmRlZmF1bHRQb3J0ID0gNDQzXG4gIHJldHVybiBhZ2VudFxufVxuXG5mdW5jdGlvbiBodHRwT3Zlckh0dHBzKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpXG4gIGFnZW50LnJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0XG4gIHJldHVybiBhZ2VudFxufVxuXG5mdW5jdGlvbiBodHRwc092ZXJIdHRwcyhvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKVxuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdFxuICBhZ2VudC5jcmVhdGVTb2NrZXQgPSBjcmVhdGVTZWN1cmVTb2NrZXRcbiAgYWdlbnQuZGVmYXVsdFBvcnQgPSA0NDNcbiAgcmV0dXJuIGFnZW50XG59XG5cblxuZnVuY3Rpb24gVHVubmVsaW5nQWdlbnQob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBzZWxmLnByb3h5T3B0aW9ucyA9IHNlbGYub3B0aW9ucy5wcm94eSB8fCB7fVxuICBzZWxmLm1heFNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWF4U29ja2V0cyB8fCBodHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzXG4gIHNlbGYucmVxdWVzdHMgPSBbXVxuICBzZWxmLnNvY2tldHMgPSBbXVxuXG4gIHNlbGYub24oJ2ZyZWUnLCBmdW5jdGlvbiBvbkZyZWUoc29ja2V0LCBob3N0LCBwb3J0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYucmVxdWVzdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBwZW5kaW5nID0gc2VsZi5yZXF1ZXN0c1tpXVxuICAgICAgaWYgKHBlbmRpbmcuaG9zdCA9PT0gaG9zdCAmJiBwZW5kaW5nLnBvcnQgPT09IHBvcnQpIHtcbiAgICAgICAgLy8gRGV0ZWN0IHRoZSByZXF1ZXN0IHRvIGNvbm5lY3Qgc2FtZSBvcmlnaW4gc2VydmVyLFxuICAgICAgICAvLyByZXVzZSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgc2VsZi5yZXF1ZXN0cy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcGVuZGluZy5yZXF1ZXN0Lm9uU29ja2V0KHNvY2tldClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHNvY2tldC5kZXN0cm95KClcbiAgICBzZWxmLnJlbW92ZVNvY2tldChzb2NrZXQpXG4gIH0pXG59XG51dGlsLmluaGVyaXRzKFR1bm5lbGluZ0FnZW50LCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIGFkZFJlcXVlc3QocmVxLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gICAvLyBMZWdhY3kgQVBJOiBhZGRSZXF1ZXN0KHJlcSwgaG9zdCwgcG9ydCwgcGF0aClcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiBvcHRpb25zLFxuICAgICAgcG9ydDogYXJndW1lbnRzWzJdLFxuICAgICAgcGF0aDogYXJndW1lbnRzWzNdXG4gICAgfTtcbiAgfVxuXG4gIGlmIChzZWxmLnNvY2tldHMubGVuZ3RoID49IHRoaXMubWF4U29ja2V0cykge1xuICAgIC8vIFdlIGFyZSBvdmVyIGxpbWl0IHNvIHdlJ2xsIGFkZCBpdCB0byB0aGUgcXVldWUuXG4gICAgc2VsZi5yZXF1ZXN0cy5wdXNoKHtob3N0OiBvcHRpb25zLmhvc3QsIHBvcnQ6IG9wdGlvbnMucG9ydCwgcmVxdWVzdDogcmVxfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHdlIGFyZSB1bmRlciBtYXhTb2NrZXRzIGNyZWF0ZSBhIG5ldyBvbmUuXG4gIHNlbGYuY3JlYXRlQ29ubmVjdGlvbih7aG9zdDogb3B0aW9ucy5ob3N0LCBwb3J0OiBvcHRpb25zLnBvcnQsIHJlcXVlc3Q6IHJlcX0pXG59XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbihwZW5kaW5nKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuY3JlYXRlU29ja2V0KHBlbmRpbmcsIGZ1bmN0aW9uKHNvY2tldCkge1xuICAgIHNvY2tldC5vbignZnJlZScsIG9uRnJlZSlcbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZU9yUmVtb3ZlKVxuICAgIHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgcGVuZGluZy5yZXF1ZXN0Lm9uU29ja2V0KHNvY2tldClcblxuICAgIGZ1bmN0aW9uIG9uRnJlZSgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZnJlZScsIHNvY2tldCwgcGVuZGluZy5ob3N0LCBwZW5kaW5nLnBvcnQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZU9yUmVtb3ZlKGVycikge1xuICAgICAgc2VsZi5yZW1vdmVTb2NrZXQoc29ja2V0KVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2VPclJlbW92ZSlcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgfVxuICB9KVxufVxuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0ID0gZnVuY3Rpb24gY3JlYXRlU29ja2V0KG9wdGlvbnMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcGxhY2Vob2xkZXIgPSB7fVxuICBzZWxmLnNvY2tldHMucHVzaChwbGFjZWhvbGRlcilcblxuICB2YXIgY29ubmVjdE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoe30sIHNlbGYucHJveHlPcHRpb25zLCBcbiAgICB7IG1ldGhvZDogJ0NPTk5FQ1QnXG4gICAgLCBwYXRoOiBvcHRpb25zLmhvc3QgKyAnOicgKyBvcHRpb25zLnBvcnRcbiAgICAsIGFnZW50OiBmYWxzZVxuICAgIH1cbiAgKVxuICBpZiAoY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKSB7XG4gICAgY29ubmVjdE9wdGlvbnMuaGVhZGVycyA9IGNvbm5lY3RPcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICBjb25uZWN0T3B0aW9ucy5oZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArXG4gICAgICAgIG5ldyBCdWZmZXIoY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKS50b1N0cmluZygnYmFzZTY0JylcbiAgfVxuXG4gIGRlYnVnKCdtYWtpbmcgQ09OTkVDVCByZXF1ZXN0JylcbiAgdmFyIGNvbm5lY3RSZXEgPSBzZWxmLnJlcXVlc3QoY29ubmVjdE9wdGlvbnMpXG4gIGNvbm5lY3RSZXEudXNlQ2h1bmtlZEVuY29kaW5nQnlEZWZhdWx0ID0gZmFsc2UgLy8gZm9yIHYwLjZcbiAgY29ubmVjdFJlcS5vbmNlKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpIC8vIGZvciB2MC42XG4gIGNvbm5lY3RSZXEub25jZSgndXBncmFkZScsIG9uVXBncmFkZSkgICAvLyBmb3IgdjAuNlxuICBjb25uZWN0UmVxLm9uY2UoJ2Nvbm5lY3QnLCBvbkNvbm5lY3QpICAgLy8gZm9yIHYwLjcgb3IgbGF0ZXJcbiAgY29ubmVjdFJlcS5vbmNlKCdlcnJvcicsIG9uRXJyb3IpXG4gIGNvbm5lY3RSZXEuZW5kKClcblxuICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcykge1xuICAgIC8vIFZlcnkgaGFja3kuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGh0dHAtcGFyc2VyIGxlYWtzLlxuICAgIHJlcy51cGdyYWRlID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25VcGdyYWRlKHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgLy8gSGFja3kuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG9uQ29ubmVjdChyZXMsIHNvY2tldCwgaGVhZClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGFzc2VydC5lcXVhbChoZWFkLmxlbmd0aCwgMClcbiAgICAgIGRlYnVnKCd0dW5uZWxpbmcgY29ubmVjdGlvbiBoYXMgZXN0YWJsaXNoZWQnKVxuICAgICAgc2VsZi5zb2NrZXRzW3NlbGYuc29ja2V0cy5pbmRleE9mKHBsYWNlaG9sZGVyKV0gPSBzb2NrZXRcbiAgICAgIGNiKHNvY2tldClcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBzdGF0dXNDb2RlPSVkJywgcmVzLnN0YXR1c0NvZGUpXG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCAnICsgJ3N0YXR1c0NvZGU9JyArIHJlcy5zdGF0dXNDb2RlKVxuICAgICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJ1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICBzZWxmLnJlbW92ZVNvY2tldChwbGFjZWhvbGRlcilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGNhdXNlKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBjYXVzZT0lc1xcbicsIGNhdXNlLm1lc3NhZ2UsIGNhdXNlLnN0YWNrKVxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigndHVubmVsaW5nIHNvY2tldCBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsICcgKyAnY2F1c2U9JyArIGNhdXNlLm1lc3NhZ2UpXG4gICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJ1xuICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgIHNlbGYucmVtb3ZlU29ja2V0KHBsYWNlaG9sZGVyKVxuICB9XG59XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5yZW1vdmVTb2NrZXQgPSBmdW5jdGlvbiByZW1vdmVTb2NrZXQoc29ja2V0KSB7XG4gIHZhciBwb3MgPSB0aGlzLnNvY2tldHMuaW5kZXhPZihzb2NrZXQpXG4gIGlmIChwb3MgPT09IC0xKSByZXR1cm5cbiAgXG4gIHRoaXMuc29ja2V0cy5zcGxpY2UocG9zLCAxKVxuXG4gIHZhciBwZW5kaW5nID0gdGhpcy5yZXF1ZXN0cy5zaGlmdCgpXG4gIGlmIChwZW5kaW5nKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHJlcXVlc3RzIGFuZCBhIHNvY2tldCBnZXRzIGNsb3NlZCBhIG5ldyBvbmVcbiAgICAvLyBuZWVkcyB0byBiZSBjcmVhdGVkIHRvIHRha2Ugb3ZlciBpbiB0aGUgcG9vbCBmb3IgdGhlIG9uZSB0aGF0IGNsb3NlZC5cbiAgICB0aGlzLmNyZWF0ZUNvbm5lY3Rpb24ocGVuZGluZylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTZWN1cmVTb2NrZXQob3B0aW9ucywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIFR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5jcmVhdGVTb2NrZXQuY2FsbChzZWxmLCBvcHRpb25zLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICAvLyAwIGlzIGR1bW15IHBvcnQgZm9yIHYwLjZcbiAgICB2YXIgc2VjdXJlU29ja2V0ID0gdGxzLmNvbm5lY3QoMCwgbWVyZ2VPcHRpb25zKHt9LCBzZWxmLm9wdGlvbnMsIFxuICAgICAgeyBzZXJ2ZXJuYW1lOiBvcHRpb25zLmhvc3RcbiAgICAgICwgc29ja2V0OiBzb2NrZXRcbiAgICAgIH1cbiAgICApKVxuICAgIHNlbGYuc29ja2V0c1tzZWxmLnNvY2tldHMuaW5kZXhPZihzb2NrZXQpXSA9IHNlY3VyZVNvY2tldFxuICAgIGNiKHNlY3VyZVNvY2tldClcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgb3ZlcnJpZGVzID0gYXJndW1lbnRzW2ldXG4gICAgaWYgKHR5cGVvZiBvdmVycmlkZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcylcbiAgICAgIGZvciAodmFyIGogPSAwLCBrZXlMZW4gPSBrZXlzLmxlbmd0aDsgaiA8IGtleUxlbjsgKytqKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tqXVxuICAgICAgICBpZiAob3ZlcnJpZGVzW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRba10gPSBvdmVycmlkZXNba11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59XG5cblxudmFyIGRlYnVnXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxidHVubmVsXFxiLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKSB7XG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgYXJnc1swXSA9ICdUVU5ORUw6ICcgKyBhcmdzWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudW5zaGlmdCgnVFVOTkVMOicpXG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJncylcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHt9XG59XG5leHBvcnRzLmRlYnVnID0gZGVidWcgLy8gZm9yIHRlc3RcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90dW5uZWwtYWdlbnQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb25maWcgPSB7XG4gIGJhc2VVUkw6IFwiaHR0cHM6Ly9hcHAudGlja2V0bWFzdGVyLmNvbVwiXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9jb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBmaW5kID0gcmVxdWlyZSgnLi9maW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4ge1xuICAgIGZpbmQ6IGZpbmQoYXBpS2V5LCBhY2Nlc3NUb2tlbilcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjEvY2F0ZWdvcnkvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBQcm9taXNlICAgICAgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIHJlcXVlc3RBc3luYyA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvcmVxdWVzdF9oZWxwZXInKTtcbnZhciBjb25maWcgICAgICAgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiBmdW5jdGlvbihjYXRlZ29yeUlkKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyh7XG4gICAgICB1cmw6IGNvbmZpZy5iYXNlVVJMICsgJy9kaXNjb3ZlcnkvdjEvY2F0ZWdvcmllcy8nICsgY2F0ZWdvcnlJZCArICc/YXBpa2V5PScgKyBhcGlLZXksXG4gICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSlcbiAgICAuc3ByZWFkKGZ1bmN0aW9uIChyZXNwb25zZSwgYm9keSkge1xuICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwYXJzZWRCb2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9jYXRlZ29yeS9maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYWxsID0gcmVxdWlyZSgnLi9hbGwnKSxcbiAgICBmaW5kID0gcmVxdWlyZSgnLi9maW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4ge1xuICAgIGFsbDogYWxsKGFwaUtleSwgYWNjZXNzVG9rZW4pLFxuICAgIGZpbmQ6IGZpbmQoYXBpS2V5LCBhY2Nlc3NUb2tlbilcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuYWxsICA9IGFsbDtcbm1vZHVsZS5leHBvcnRzLmZpbmQgPSBmaW5kO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL2V2ZW50L2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHJvbWlzZSAgICAgID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciByZXF1ZXN0QXN5bmMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyJyk7XG52YXIgY29uZmlnICAgICAgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuYXBpa2V5ID0gYXBpS2V5O1xuXG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyh7XG4gICAgICB1cmw6IGNvbmZpZy5iYXNlVVJMICsgJy9kaXNjb3ZlcnkvdjEvZXZlbnRzLycsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcXM6IG9wdGlvbnNcbiAgICB9KVxuICAgIC5zcHJlYWQoZnVuY3Rpb24gKHJlc3BvbnNlLCBib2R5KSB7XG4gICAgICBpZihyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuX2VtYmVkZGVkLmV2ZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGFyc2VkQm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjEvZXZlbnQvYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHJvbWlzZSAgICAgID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciByZXF1ZXN0QXN5bmMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyJyk7XG52YXIgY29uZmlnICAgICAgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnRJZCkge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoe1xuICAgICAgdXJsOiBjb25maWcuYmFzZVVSTCArICcvZGlzY292ZXJ5L3YxL2V2ZW50cy8nICsgZXZlbnRJZCArICc/YXBpa2V5PScgKyBhcGlLZXksXG4gICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSlcbiAgICAuc3ByZWFkKGZ1bmN0aW9uIChyZXNwb25zZSwgYm9keSkge1xuICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwYXJzZWRCb2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92MS9ldmVudC9maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZmluZCA9IHJlcXVpcmUoJy4vZmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pIHtcbiAgcmV0dXJuIHtcbiAgICBmaW5kOiBmaW5kKGFwaUtleSwgYWNjZXNzVG9rZW4pXG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjEvdmVudWUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBQcm9taXNlICAgICAgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIHJlcXVlc3RBc3luYyA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvcmVxdWVzdF9oZWxwZXInKTtcbnZhciBjb25maWcgICAgICAgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiBmdW5jdGlvbih2ZW51ZUlkKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyh7XG4gICAgICB1cmw6IGNvbmZpZy5iYXNlVVJMICsgJy9kaXNjb3ZlcnkvdjEvdmVudWVzLycgKyB2ZW51ZUlkICsgJz9hcGlrZXk9JyArIGFwaUtleSxcbiAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICB9KVxuICAgIC5zcHJlYWQoZnVuY3Rpb24gKHJlc3BvbnNlLCBib2R5KSB7XG4gICAgICBpZihyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBhcnNlZEJvZHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YxL3ZlbnVlL2ZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhdHRyYWN0aW9uID0gcmVxdWlyZSgnLi9hdHRyYWN0aW9uJyksXG4gICAgZXZlbnQgICAgICA9IHJlcXVpcmUoJy4vZXZlbnQnKSxcbiAgICB2ZW51ZSAgICAgID0gcmVxdWlyZSgnLi92ZW51ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pIHtcbiAgcmV0dXJuIHtcbiAgICBhdHRyYWN0aW9uOiBhdHRyYWN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pLFxuICAgIGV2ZW50OiBldmVudChhcGlLZXksIGFjY2Vzc1Rva2VuKSxcbiAgICB2ZW51ZTogdmVudWUoYXBpS2V5LCBhY2Nlc3NUb2tlbilcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmF0dHJhY3Rpb24gPSBhdHRyYWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuZXZlbnQgPSBldmVudDtcbm1vZHVsZS5leHBvcnRzLnZlbnVlID0gdmVudWU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbGwgPSByZXF1aXJlKCcuL2FsbCcpLFxuICAgIGZpbmQgPSByZXF1aXJlKCcuL2ZpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiB7XG4gICAgYWxsOiBhbGwoYXBpS2V5LCBhY2Nlc3NUb2tlbiksXG4gICAgZmluZDogZmluZChhcGlLZXksIGFjY2Vzc1Rva2VuKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5hbGwgPSBhbGw7XG5tb2R1bGUuZXhwb3J0cy5maW5kID0gZmluZDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92Mi9hdHRyYWN0aW9uL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHJvbWlzZSAgICAgID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciByZXF1ZXN0QXN5bmMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyJyk7XG52YXIgY29uZmlnICAgICAgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuYXBpa2V5ID0gYXBpS2V5O1xuXG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyh7XG4gICAgICB1cmw6IGNvbmZpZy5iYXNlVVJMICsgJy9kaXNjb3ZlcnkvdjIvYXR0cmFjdGlvbnMvJyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pXG4gICAgLnNwcmVhZChmdW5jdGlvbiAocmVzcG9uc2UsIGJvZHkpIHtcbiAgICAgIGlmKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5fZW1iZWRkZWQuYXR0cmFjdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBhcnNlZEJvZHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YyL2F0dHJhY3Rpb24vYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHJvbWlzZSAgICAgID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciByZXF1ZXN0QXN5bmMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyJyk7XG52YXIgY29uZmlnICAgICAgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gZnVuY3Rpb24oYXR0cmFjdGlvbklkKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyh7XG4gICAgICB1cmw6IGNvbmZpZy5iYXNlVVJMICsgJy9kaXNjb3ZlcnkvdjIvYXR0cmFjdGlvbnMvJyArIGF0dHJhY3Rpb25JZCArICc/YXBpa2V5PScgKyBhcGlLZXksXG4gICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSlcbiAgICAuc3ByZWFkKGZ1bmN0aW9uIChyZXNwb25zZSwgYm9keSkge1xuICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwYXJzZWRCb2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92Mi9hdHRyYWN0aW9uL2ZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbGwgPSByZXF1aXJlKCcuL2FsbCcpLFxuICAgIGZpbmQgPSByZXF1aXJlKCcuL2ZpbmQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiB7XG4gICAgYWxsOiBhbGwoYXBpS2V5LCBhY2Nlc3NUb2tlbiksXG4gICAgZmluZDogZmluZChhcGlLZXksIGFjY2Vzc1Rva2VuKVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5hbGwgID0gYWxsO1xubW9kdWxlLmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvZXZlbnQvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBQcm9taXNlICAgICAgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIHJlcXVlc3RBc3luYyA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvcmVxdWVzdF9oZWxwZXInKTtcbnZhciBjb25maWcgICAgICAgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5hcGlrZXkgPSBhcGlLZXk7XG5cbiAgICByZXR1cm4gcmVxdWVzdEFzeW5jKHtcbiAgICAgIHVybDogY29uZmlnLmJhc2VVUkwgKyAnL2Rpc2NvdmVyeS92Mi9ldmVudHMvJyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBxczogb3B0aW9uc1xuICAgIH0pXG4gICAgLnNwcmVhZChmdW5jdGlvbiAocmVzcG9uc2UsIGJvZHkpIHtcbiAgICAgIGlmKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5fZW1iZWRkZWQgPyByZXN1bHQuX2VtYmVkZGVkLmV2ZW50czogUHJvbWlzZS5yZWplY3QocmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGFyc2VkQm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvZXZlbnQvYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTc1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHJvbWlzZSAgICAgID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciByZXF1ZXN0QXN5bmMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyJyk7XG52YXIgY29uZmlnICAgICAgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnRJZCkge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoe1xuICAgICAgdXJsOiBjb25maWcuYmFzZVVSTCArICcvZGlzY292ZXJ5L3YyL2V2ZW50cy8nICsgZXZlbnRJZCArICc/YXBpa2V5PScgKyBhcGlLZXksXG4gICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSlcbiAgICAuc3ByZWFkKGZ1bmN0aW9uIChyZXNwb25zZSwgYm9keSkge1xuICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwYXJzZWRCb2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2Rpc2NvdmVyeS92Mi9ldmVudC9maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZmluZCA9IHJlcXVpcmUoJy4vZmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFwaUtleSwgYWNjZXNzVG9rZW4pIHtcbiAgcmV0dXJuIHtcbiAgICBmaW5kOiBmaW5kKGFwaUtleSwgYWNjZXNzVG9rZW4pXG4gIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4uL34vdGlja2V0bWFzdGVyL2xpYi9kaXNjb3ZlcnkvdjIvdmVudWUvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBQcm9taXNlICAgICAgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xudmFyIHJlcXVlc3RBc3luYyA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvcmVxdWVzdF9oZWxwZXInKTtcbnZhciBjb25maWcgICAgICAgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiBmdW5jdGlvbih2ZW51ZUlkKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RBc3luYyh7XG4gICAgICB1cmw6IGNvbmZpZy5iYXNlVVJMICsgJy9kaXNjb3ZlcnkvdjIvdmVudWVzLycgKyB2ZW51ZUlkICsgJz9hcGlrZXk9JyArIGFwaUtleSxcbiAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICB9KVxuICAgIC5zcHJlYWQoZnVuY3Rpb24gKHJlc3BvbnNlLCBib2R5KSB7XG4gICAgICBpZihyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHBhcnNlZEJvZHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9saWIvZGlzY292ZXJ5L3YyL3ZlbnVlL2ZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB2MiA9IHJlcXVpcmUoJy4vdjInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGlLZXksIGFjY2Vzc1Rva2VuKSB7XG4gIHJldHVybiB7IHYyOiB2MihhcGlLZXksIGFjY2Vzc1Rva2VuKSB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMudjIgPSB2MjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2NvbW1lcmNlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgb2ZmZXIgPSByZXF1aXJlKCcuL29mZmVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4geyBvZmZlcjogb2ZmZXIoYXBpS2V5LCBhY2Nlc3NUb2tlbikgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLm9mZmVyID0gb2ZmZXI7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuLi9+L3RpY2tldG1hc3Rlci9saWIvY29tbWVyY2UvdjIvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBmaW5kID0gcmVxdWlyZSgnLi9maW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4geyBmaW5kOiBmaW5kKGFwaUtleSwgYWNjZXNzVG9rZW4pIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmZpbmQgPSBmaW5kO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2NvbW1lcmNlL3YyL29mZmVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUHJvbWlzZSAgICAgID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcbnZhciByZXF1ZXN0QXN5bmMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3JlcXVlc3RfaGVscGVyJyk7XG52YXIgY29uZmlnICAgICAgID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vY29uZmlnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBpS2V5LCBhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnRJZCkge1xuICAgIHJldHVybiByZXF1ZXN0QXN5bmMoe1xuICAgICAgdXJsOiBjb25maWcuYmFzZVVSTCArICcvY29tbWVyY2UvdjIvZXZlbnRzLycgKyBldmVudElkICsgJy9vZmZlcnM/YXBpa2V5PScgKyBhcGlLZXksXG4gICAgICBtZXRob2Q6ICdHRVQnXG4gICAgfSlcbiAgICAuc3ByZWFkKGZ1bmN0aW9uIChyZXNwb25zZSwgYm9keSkge1xuICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkQm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwYXJzZWRCb2R5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi4vfi90aWNrZXRtYXN0ZXIvbGliL2NvbW1lcmNlL3YyL29mZmVyL2ZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0Q0E7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hnS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzd6Q0E7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2poQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN2dEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzQkE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN4M0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3Y5QkE7QUFDQTtBQUNBOzs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3Q0E7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNubUJBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3g3QkE7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3B1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5cUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5OUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDajdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzU4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3AvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeklBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsREE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==